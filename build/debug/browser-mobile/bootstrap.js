webpackJsonp([1],{

/***/ 0:
/*!*******************************!*\
  !*** ./frontend/jsio/base.js ***!
  \*******************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.CACHE = exports.CONFIG = exports.NATIVE = exports.GLOBAL = exports.logger = exports.logging = exports.delay = exports.merge = exports.bind = exports.isArray = exports.log = undefined;\n\nvar _jsio = __webpack_require__(/*! jsio */ 38);\n\nvar _jsio2 = _interopRequireDefault(_jsio);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _exports = {};\n\n/**\n * base.js\n * This file contains all global functions provided by js.io.\n */\n_exports.log = _jsio2.default.__env.log;\n_exports.GLOBAL = _jsio2.default.__env.global;\n\n/**\n * Various polyfill methods to ensure js.io implementations provide\n * a baseline of JavaScript functionality. Feature compatibility (localStorage,\n * etc.) should be provided elsewhere.\n */\n// Array.isArray\n// Not available before ECMAScript 5.\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray\nif (!Array.isArray) {\n  Array.isArray = function (arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]';\n  };\n}\n\n// Function.prototype.bind\n// Not available before ECMAScript 5.\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function (oThis) {\n    if (typeof this !== 'function') {\n      // closest thing possible to the ECMAScript 5 internal IsCallable function\n      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n    }\n\n    var aArgs = Array.prototype.slice.call(arguments, 1),\n        fToBind = this,\n        fNOP = function fNOP() {},\n        fBound = function fBound() {\n      return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));\n    };\n\n    fNOP.prototype = this.prototype;\n    fBound.prototype = new fNOP();\n\n    return fBound;\n  };\n}\n\n/**\n * DEPRECATED. Old js.io polyfills.\n */\nvar SLICE = Array.prototype.slice;\n\n/* Use native isArray if available\n */\nif (typeof Array.isArray === 'function') {\n  _exports.isArray = Array.isArray;\n} else {\n  _exports.isArray = function (obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  };\n}\n\n_exports.bind = function (context, method)\n/*, VARGS*/\n{\n\n  if (typeof method === 'string') {\n    method = context[method];\n    if (!method) {\n      throw logger.error('No method:', method, 'for context', context);\n    }\n  }\n\n  if (arguments.length > 2) {\n    var _method;\n\n    var args = SLICE.call(arguments, 2);\n    return (_method = method).bind.apply(_method, [context].concat(args));\n  }\n\n  return method.bind(context);\n};\n\n/**\n * Class constructor.\n */\n_exports.Class = function (name, parent, proto) {\n  return _exports.__class__(function () {\n    return this.init && this.init.apply(this, arguments);\n  }, name, parent, proto);\n};\n\n_exports.__class__ = function (cls, name, parent, proto) {\n  var clsProto = function clsProto() {};\n  var logger;\n\n  if (typeof name != 'string') {\n    proto = parent;\n    parent = name;\n    name = null;\n  }\n\n  if (name) {\n    logger = _exports.logging.get(name);\n  }\n\n  if (!parent) {\n    throw new Error('parent or prototype not provided');\n  }\n  if (!proto) {\n    proto = parent;\n    parent = null;\n  }\n\n  if (parent) {\n    if (_exports.isArray(parent)) {\n      // multiple inheritance, use at your own risk =)\n      clsProto.prototype = {};\n      for (var i = 0, p; p = parent[i]; ++i) {\n        if (p == Error && ErrorParentClass) {\n          p = ErrorParentClass;\n        }\n        for (var item in p.prototype) {\n          if (!(item in clsProto.prototype)) {\n            clsProto.prototype[item] = p.prototype[item];\n          }\n        }\n      }\n      parent = parent[0];\n    } else {\n      if (parent == Error && ErrorParentClass) {\n        parent = ErrorParentClass;\n      }\n      clsProto.prototype = parent.prototype;\n    }\n  }\n\n  var supr = parent ? function (context, method, args) {\n    var f = parent.prototype[method];\n    if (!f) {\n      throw new Error('method ' + method + ' does not exist');\n    }\n    return f.apply(context, args || []);\n  } : null;\n\n  var p = cls.prototype = new clsProto();\n  p.constructor = cls;\n  p.__parentClass__ = parent;\n  if (name) {\n    p.__class__ = name;\n  }\n  proto.call(p, logger || supr, logger && supr);\n  return cls;\n};\n\nvar ErrorParentClass = _exports.__class__(function ErrorCls() {\n  var err = Error.prototype.constructor.apply(this, arguments);\n  for (var prop in err) {\n    if (err.hasOwnProperty(prop)) {\n      this[prop] = err[prop];\n    }\n  }\n}, function () {});\n\n/**\n * Merge two objects together.\n */\n_exports.merge = function (base, extra) {\n  base = base || {};\n\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var copyFrom = arguments[i];\n    for (var key in copyFrom) {\n      if (copyFrom.hasOwnProperty(key) && !base.hasOwnProperty(key)) {\n        base[key] = copyFrom[key];\n      }\n    }\n  }\n\n  return base;\n};\n_exports.Class.defaults = _exports.merge;\n\n/**\n * Create a timer delay.\n */\n_exports.delay = function (orig, timeout) {\n  var _timer = null;\n  var ctx, args;\n  var f = function f() {\n    orig.apply(ctx, args);\n  };\n  return function () {\n    ctx = this;\n    args = arguments;\n    if (_timer) {\n      clearTimeout(_timer);\n    }\n    _timer = setTimeout(f, timeout || 0);\n  };\n};\n\n/**\n * Log constructor and default \"logger\".\n */\n_exports.logging = function () {\n  // logging namespace, this is what is exported\n  var logging = {\n    DEBUG: 1,\n    LOG: 2,\n    INFO: 3,\n    WARN: 4,\n    ERROR: 5,\n    NONE: 10\n  };\n\n  var _loggers = {};\n  // all loggers\n  var _production = false;\n  var _prefix = '';\n\n  logging.setPrefix = function (prefix) {\n    _prefix = prefix + ' ';\n  };\n\n  logging.setProduction = function (prod) {\n    _production = !!prod;\n    for (var key in _loggers) {\n      _loggers[key].setProduction(_production);\n    }\n  };\n\n  logging.get = function (name) {\n    var logger = name in _loggers ? _loggers[name] : _loggers[name] = new Logger(name);\n    logger.setProduction(_production);\n    return logger;\n  };\n\n  logging.set = function (name, logger) {\n    _loggers[name] = logger;\n  };\n\n  logging.getAll = function () {\n    return _loggers;\n  };\n\n  logging.__create = function (pkg, ctx) {\n    ctx.logger = logging.get(pkg);\n  };\n\n  var Logger = _exports.__class__(function Logger(name, level) {\n    this._name = name;\n    this._isProduction = _production;\n\n    this.setLevel(level || logging.LOG);\n  }, function () {\n    this.setProduction = function (isProduction) {\n      this._isProduction = isProduction;\n      isProduction && this.setLevel(logging.NONE);\n    };\n\n    this.setLevel = function (level) {\n      this._level = level;\n\n      if (this._isProduction) {\n        level = logging.NONE;\n      }\n\n      this.DEBUG = level <= logging.DEBUG;\n      this.LOG = level <= logging.LOG;\n      this.INFO = level <= logging.INFO;\n      this.WARN = level <= logging.WARN;\n      this.ERROR = level <= logging.ERROR;\n    };\n\n    function makeLogger(type) {\n      var level = logging[type];\n      return function () {\n        if (!this._isProduction && level >= this._level) {\n          var prefix = type + ' ' + _prefix + this._name;\n          var listener = this._listener || _exports.log;\n\n          return listener && listener.apply(this._listener, [prefix].concat(SLICE.call(arguments)));\n        }\n        return arguments[0];\n      };\n    }\n\n    this.setListener = function (listener) {\n      this._listener = listener;\n    };\n\n    this.debug = makeLogger('DEBUG');\n    this.log = makeLogger('LOG');\n    this.info = makeLogger('INFO');\n    this.warn = makeLogger('WARN');\n    this.error = makeLogger('ERROR');\n  });\n\n  return logging;\n}();\n\nvar logger = _exports.logging.get('jsiocore');\n_exports.logger = logger;\n\n// TODO: make this not a hack\nvar _exportLog = _exports.log;\nvar _exportIsArray = _exports.isArray;\nvar _exportBind = _exports.bind;\nvar _exportMerge = _exports.merge;\nvar _exportDelay = _exports.delay;\nvar _exportLogging = _exports.logging;\nvar _exportLogger = _exports.logger;\nvar _exportCONFIG = typeof CONFIG !== 'undefined' ? CONFIG : {};\nvar _exportNATIVE = typeof NATIVE !== 'undefined' ? NATIVE : {};\nvar _exportCACHE = typeof CACHE !== 'undefined' ? CACHE : {};\n\nvar _exportGLOBAL;\nif (typeof GLOBAL !== 'undefined') {\n  exports.GLOBAL = _exportGLOBAL = GLOBAL;\n} else {\n  exports.GLOBAL = _exportGLOBAL = window;\n  window.CACHE = _exportCACHE;\n  window.CONFIG = _exportCONFIG;\n  window.NATIVE = _exportNATIVE;\n}\n\nexports.log = _exportLog;\nexports.isArray = _exportIsArray;\nexports.bind = _exportBind;\nexports.merge = _exportMerge;\nexports.delay = _exportDelay;\nexports.logging = _exportLogging;\nexports.logger = _exportLogger;\nexports.GLOBAL = _exportGLOBAL;\nexports.NATIVE = _exportNATIVE;\nexports.CONFIG = _exportCONFIG;\nexports.CACHE = _exportCACHE;\nexports.default = _exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9mcm9udGVuZC9qc2lvL2Jhc2UuanM/NmY5ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQkFBZ0I7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQ0FDSEUgPSBleHBvcnRzLkNPTkZJRyA9IGV4cG9ydHMuTkFUSVZFID0gZXhwb3J0cy5HTE9CQUwgPSBleHBvcnRzLmxvZ2dlciA9IGV4cG9ydHMubG9nZ2luZyA9IGV4cG9ydHMuZGVsYXkgPSBleHBvcnRzLm1lcmdlID0gZXhwb3J0cy5iaW5kID0gZXhwb3J0cy5pc0FycmF5ID0gZXhwb3J0cy5sb2cgPSB1bmRlZmluZWQ7XG5cbnZhciBfanNpbyA9IHJlcXVpcmUoJ2pzaW8nKTtcblxudmFyIF9qc2lvMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2pzaW8pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgX2V4cG9ydHMgPSB7fTtcblxuLyoqXG4gKiBiYXNlLmpzXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgYWxsIGdsb2JhbCBmdW5jdGlvbnMgcHJvdmlkZWQgYnkganMuaW8uXG4gKi9cbl9leHBvcnRzLmxvZyA9IF9qc2lvMi5kZWZhdWx0Ll9fZW52LmxvZztcbl9leHBvcnRzLkdMT0JBTCA9IF9qc2lvMi5kZWZhdWx0Ll9fZW52Lmdsb2JhbDtcblxuLyoqXG4gKiBWYXJpb3VzIHBvbHlmaWxsIG1ldGhvZHMgdG8gZW5zdXJlIGpzLmlvIGltcGxlbWVudGF0aW9ucyBwcm92aWRlXG4gKiBhIGJhc2VsaW5lIG9mIEphdmFTY3JpcHQgZnVuY3Rpb25hbGl0eS4gRmVhdHVyZSBjb21wYXRpYmlsaXR5IChsb2NhbFN0b3JhZ2UsXG4gKiBldGMuKSBzaG91bGQgYmUgcHJvdmlkZWQgZWxzZXdoZXJlLlxuICovXG4vLyBBcnJheS5pc0FycmF5XG4vLyBOb3QgYXZhaWxhYmxlIGJlZm9yZSBFQ01BU2NyaXB0IDUuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5XG5pZiAoIUFycmF5LmlzQXJyYXkpIHtcbiAgQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG59XG5cbi8vIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4vLyBOb3QgYXZhaWxhYmxlIGJlZm9yZSBFQ01BU2NyaXB0IDUuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kXG5pZiAoIUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSB7XG4gIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKG9UaGlzKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBjbG9zZXN0IHRoaW5nIHBvc3NpYmxlIHRvIHRoZSBFQ01BU2NyaXB0IDUgaW50ZXJuYWwgSXNDYWxsYWJsZSBmdW5jdGlvblxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGUnKTtcbiAgICB9XG5cbiAgICB2YXIgYUFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICBmVG9CaW5kID0gdGhpcyxcbiAgICAgICAgZk5PUCA9IGZ1bmN0aW9uIGZOT1AoKSB7fSxcbiAgICAgICAgZkJvdW5kID0gZnVuY3Rpb24gZkJvdW5kKCkge1xuICAgICAgcmV0dXJuIGZUb0JpbmQuYXBwbHkodGhpcyBpbnN0YW5jZW9mIGZOT1AgPyB0aGlzIDogb1RoaXMsIGFBcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgfTtcblxuICAgIGZOT1AucHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XG4gICAgZkJvdW5kLnByb3RvdHlwZSA9IG5ldyBmTk9QKCk7XG5cbiAgICByZXR1cm4gZkJvdW5kO1xuICB9O1xufVxuXG4vKipcbiAqIERFUFJFQ0FURUQuIE9sZCBqcy5pbyBwb2x5ZmlsbHMuXG4gKi9cbnZhciBTTElDRSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuLyogVXNlIG5hdGl2ZSBpc0FycmF5IGlmIGF2YWlsYWJsZVxuICovXG5pZiAodHlwZW9mIEFycmF5LmlzQXJyYXkgPT09ICdmdW5jdGlvbicpIHtcbiAgX2V4cG9ydHMuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG59IGVsc2Uge1xuICBfZXhwb3J0cy5pc0FycmF5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcbn1cblxuX2V4cG9ydHMuYmluZCA9IGZ1bmN0aW9uIChjb250ZXh0LCBtZXRob2QpXG4vKiwgVkFSR1MqL1xue1xuXG4gIGlmICh0eXBlb2YgbWV0aG9kID09PSAnc3RyaW5nJykge1xuICAgIG1ldGhvZCA9IGNvbnRleHRbbWV0aG9kXTtcbiAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgdGhyb3cgbG9nZ2VyLmVycm9yKCdObyBtZXRob2Q6JywgbWV0aG9kLCAnZm9yIGNvbnRleHQnLCBjb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICB2YXIgX21ldGhvZDtcblxuICAgIHZhciBhcmdzID0gU0xJQ0UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiAoX21ldGhvZCA9IG1ldGhvZCkuYmluZC5hcHBseShfbWV0aG9kLCBbY29udGV4dF0uY29uY2F0KGFyZ3MpKTtcbiAgfVxuXG4gIHJldHVybiBtZXRob2QuYmluZChjb250ZXh0KTtcbn07XG5cbi8qKlxuICogQ2xhc3MgY29uc3RydWN0b3IuXG4gKi9cbl9leHBvcnRzLkNsYXNzID0gZnVuY3Rpb24gKG5hbWUsIHBhcmVudCwgcHJvdG8pIHtcbiAgcmV0dXJuIF9leHBvcnRzLl9fY2xhc3NfXyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdCAmJiB0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSwgbmFtZSwgcGFyZW50LCBwcm90byk7XG59O1xuXG5fZXhwb3J0cy5fX2NsYXNzX18gPSBmdW5jdGlvbiAoY2xzLCBuYW1lLCBwYXJlbnQsIHByb3RvKSB7XG4gIHZhciBjbHNQcm90byA9IGZ1bmN0aW9uIGNsc1Byb3RvKCkge307XG4gIHZhciBsb2dnZXI7XG5cbiAgaWYgKHR5cGVvZiBuYW1lICE9ICdzdHJpbmcnKSB7XG4gICAgcHJvdG8gPSBwYXJlbnQ7XG4gICAgcGFyZW50ID0gbmFtZTtcbiAgICBuYW1lID0gbnVsbDtcbiAgfVxuXG4gIGlmIChuYW1lKSB7XG4gICAgbG9nZ2VyID0gX2V4cG9ydHMubG9nZ2luZy5nZXQobmFtZSk7XG4gIH1cblxuICBpZiAoIXBhcmVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncGFyZW50IG9yIHByb3RvdHlwZSBub3QgcHJvdmlkZWQnKTtcbiAgfVxuICBpZiAoIXByb3RvKSB7XG4gICAgcHJvdG8gPSBwYXJlbnQ7XG4gICAgcGFyZW50ID0gbnVsbDtcbiAgfVxuXG4gIGlmIChwYXJlbnQpIHtcbiAgICBpZiAoX2V4cG9ydHMuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICAvLyBtdWx0aXBsZSBpbmhlcml0YW5jZSwgdXNlIGF0IHlvdXIgb3duIHJpc2sgPSlcbiAgICAgIGNsc1Byb3RvLnByb3RvdHlwZSA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDAsIHA7IHAgPSBwYXJlbnRbaV07ICsraSkge1xuICAgICAgICBpZiAocCA9PSBFcnJvciAmJiBFcnJvclBhcmVudENsYXNzKSB7XG4gICAgICAgICAgcCA9IEVycm9yUGFyZW50Q2xhc3M7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaXRlbSBpbiBwLnByb3RvdHlwZSkge1xuICAgICAgICAgIGlmICghKGl0ZW0gaW4gY2xzUHJvdG8ucHJvdG90eXBlKSkge1xuICAgICAgICAgICAgY2xzUHJvdG8ucHJvdG90eXBlW2l0ZW1dID0gcC5wcm90b3R5cGVbaXRlbV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwYXJlbnQgPT0gRXJyb3IgJiYgRXJyb3JQYXJlbnRDbGFzcykge1xuICAgICAgICBwYXJlbnQgPSBFcnJvclBhcmVudENsYXNzO1xuICAgICAgfVxuICAgICAgY2xzUHJvdG8ucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3VwciA9IHBhcmVudCA/IGZ1bmN0aW9uIChjb250ZXh0LCBtZXRob2QsIGFyZ3MpIHtcbiAgICB2YXIgZiA9IHBhcmVudC5wcm90b3R5cGVbbWV0aG9kXTtcbiAgICBpZiAoIWYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kICcgKyBtZXRob2QgKyAnIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgfVxuICAgIHJldHVybiBmLmFwcGx5KGNvbnRleHQsIGFyZ3MgfHwgW10pO1xuICB9IDogbnVsbDtcblxuICB2YXIgcCA9IGNscy5wcm90b3R5cGUgPSBuZXcgY2xzUHJvdG8oKTtcbiAgcC5jb25zdHJ1Y3RvciA9IGNscztcbiAgcC5fX3BhcmVudENsYXNzX18gPSBwYXJlbnQ7XG4gIGlmIChuYW1lKSB7XG4gICAgcC5fX2NsYXNzX18gPSBuYW1lO1xuICB9XG4gIHByb3RvLmNhbGwocCwgbG9nZ2VyIHx8IHN1cHIsIGxvZ2dlciAmJiBzdXByKTtcbiAgcmV0dXJuIGNscztcbn07XG5cbnZhciBFcnJvclBhcmVudENsYXNzID0gX2V4cG9ydHMuX19jbGFzc19fKGZ1bmN0aW9uIEVycm9yQ2xzKCkge1xuICB2YXIgZXJyID0gRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGZvciAodmFyIHByb3AgaW4gZXJyKSB7XG4gICAgaWYgKGVyci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgdGhpc1twcm9wXSA9IGVycltwcm9wXTtcbiAgICB9XG4gIH1cbn0sIGZ1bmN0aW9uICgpIHt9KTtcblxuLyoqXG4gKiBNZXJnZSB0d28gb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuX2V4cG9ydHMubWVyZ2UgPSBmdW5jdGlvbiAoYmFzZSwgZXh0cmEpIHtcbiAgYmFzZSA9IGJhc2UgfHwge307XG5cbiAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciBjb3B5RnJvbSA9IGFyZ3VtZW50c1tpXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gY29weUZyb20pIHtcbiAgICAgIGlmIChjb3B5RnJvbS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICFiYXNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgYmFzZVtrZXldID0gY29weUZyb21ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gYmFzZTtcbn07XG5fZXhwb3J0cy5DbGFzcy5kZWZhdWx0cyA9IF9leHBvcnRzLm1lcmdlO1xuXG4vKipcbiAqIENyZWF0ZSBhIHRpbWVyIGRlbGF5LlxuICovXG5fZXhwb3J0cy5kZWxheSA9IGZ1bmN0aW9uIChvcmlnLCB0aW1lb3V0KSB7XG4gIHZhciBfdGltZXIgPSBudWxsO1xuICB2YXIgY3R4LCBhcmdzO1xuICB2YXIgZiA9IGZ1bmN0aW9uIGYoKSB7XG4gICAgb3JpZy5hcHBseShjdHgsIGFyZ3MpO1xuICB9O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGN0eCA9IHRoaXM7XG4gICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICBpZiAoX3RpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQoX3RpbWVyKTtcbiAgICB9XG4gICAgX3RpbWVyID0gc2V0VGltZW91dChmLCB0aW1lb3V0IHx8IDApO1xuICB9O1xufTtcblxuLyoqXG4gKiBMb2cgY29uc3RydWN0b3IgYW5kIGRlZmF1bHQgXCJsb2dnZXJcIi5cbiAqL1xuX2V4cG9ydHMubG9nZ2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gbG9nZ2luZyBuYW1lc3BhY2UsIHRoaXMgaXMgd2hhdCBpcyBleHBvcnRlZFxuICB2YXIgbG9nZ2luZyA9IHtcbiAgICBERUJVRzogMSxcbiAgICBMT0c6IDIsXG4gICAgSU5GTzogMyxcbiAgICBXQVJOOiA0LFxuICAgIEVSUk9SOiA1LFxuICAgIE5PTkU6IDEwXG4gIH07XG5cbiAgdmFyIF9sb2dnZXJzID0ge307XG4gIC8vIGFsbCBsb2dnZXJzXG4gIHZhciBfcHJvZHVjdGlvbiA9IGZhbHNlO1xuICB2YXIgX3ByZWZpeCA9ICcnO1xuXG4gIGxvZ2dpbmcuc2V0UHJlZml4ID0gZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIF9wcmVmaXggPSBwcmVmaXggKyAnICc7XG4gIH07XG5cbiAgbG9nZ2luZy5zZXRQcm9kdWN0aW9uID0gZnVuY3Rpb24gKHByb2QpIHtcbiAgICBfcHJvZHVjdGlvbiA9ICEhcHJvZDtcbiAgICBmb3IgKHZhciBrZXkgaW4gX2xvZ2dlcnMpIHtcbiAgICAgIF9sb2dnZXJzW2tleV0uc2V0UHJvZHVjdGlvbihfcHJvZHVjdGlvbik7XG4gICAgfVxuICB9O1xuXG4gIGxvZ2dpbmcuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgbG9nZ2VyID0gbmFtZSBpbiBfbG9nZ2VycyA/IF9sb2dnZXJzW25hbWVdIDogX2xvZ2dlcnNbbmFtZV0gPSBuZXcgTG9nZ2VyKG5hbWUpO1xuICAgIGxvZ2dlci5zZXRQcm9kdWN0aW9uKF9wcm9kdWN0aW9uKTtcbiAgICByZXR1cm4gbG9nZ2VyO1xuICB9O1xuXG4gIGxvZ2dpbmcuc2V0ID0gZnVuY3Rpb24gKG5hbWUsIGxvZ2dlcikge1xuICAgIF9sb2dnZXJzW25hbWVdID0gbG9nZ2VyO1xuICB9O1xuXG4gIGxvZ2dpbmcuZ2V0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfbG9nZ2VycztcbiAgfTtcblxuICBsb2dnaW5nLl9fY3JlYXRlID0gZnVuY3Rpb24gKHBrZywgY3R4KSB7XG4gICAgY3R4LmxvZ2dlciA9IGxvZ2dpbmcuZ2V0KHBrZyk7XG4gIH07XG5cbiAgdmFyIExvZ2dlciA9IF9leHBvcnRzLl9fY2xhc3NfXyhmdW5jdGlvbiBMb2dnZXIobmFtZSwgbGV2ZWwpIHtcbiAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICB0aGlzLl9pc1Byb2R1Y3Rpb24gPSBfcHJvZHVjdGlvbjtcblxuICAgIHRoaXMuc2V0TGV2ZWwobGV2ZWwgfHwgbG9nZ2luZy5MT0cpO1xuICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZXRQcm9kdWN0aW9uID0gZnVuY3Rpb24gKGlzUHJvZHVjdGlvbikge1xuICAgICAgdGhpcy5faXNQcm9kdWN0aW9uID0gaXNQcm9kdWN0aW9uO1xuICAgICAgaXNQcm9kdWN0aW9uICYmIHRoaXMuc2V0TGV2ZWwobG9nZ2luZy5OT05FKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zZXRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgdGhpcy5fbGV2ZWwgPSBsZXZlbDtcblxuICAgICAgaWYgKHRoaXMuX2lzUHJvZHVjdGlvbikge1xuICAgICAgICBsZXZlbCA9IGxvZ2dpbmcuTk9ORTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ERUJVRyA9IGxldmVsIDw9IGxvZ2dpbmcuREVCVUc7XG4gICAgICB0aGlzLkxPRyA9IGxldmVsIDw9IGxvZ2dpbmcuTE9HO1xuICAgICAgdGhpcy5JTkZPID0gbGV2ZWwgPD0gbG9nZ2luZy5JTkZPO1xuICAgICAgdGhpcy5XQVJOID0gbGV2ZWwgPD0gbG9nZ2luZy5XQVJOO1xuICAgICAgdGhpcy5FUlJPUiA9IGxldmVsIDw9IGxvZ2dpbmcuRVJST1I7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1ha2VMb2dnZXIodHlwZSkge1xuICAgICAgdmFyIGxldmVsID0gbG9nZ2luZ1t0eXBlXTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNQcm9kdWN0aW9uICYmIGxldmVsID49IHRoaXMuX2xldmVsKSB7XG4gICAgICAgICAgdmFyIHByZWZpeCA9IHR5cGUgKyAnICcgKyBfcHJlZml4ICsgdGhpcy5fbmFtZTtcbiAgICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLl9saXN0ZW5lciB8fCBfZXhwb3J0cy5sb2c7XG5cbiAgICAgICAgICByZXR1cm4gbGlzdGVuZXIgJiYgbGlzdGVuZXIuYXBwbHkodGhpcy5fbGlzdGVuZXIsIFtwcmVmaXhdLmNvbmNhdChTTElDRS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLnNldExpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgIH07XG5cbiAgICB0aGlzLmRlYnVnID0gbWFrZUxvZ2dlcignREVCVUcnKTtcbiAgICB0aGlzLmxvZyA9IG1ha2VMb2dnZXIoJ0xPRycpO1xuICAgIHRoaXMuaW5mbyA9IG1ha2VMb2dnZXIoJ0lORk8nKTtcbiAgICB0aGlzLndhcm4gPSBtYWtlTG9nZ2VyKCdXQVJOJyk7XG4gICAgdGhpcy5lcnJvciA9IG1ha2VMb2dnZXIoJ0VSUk9SJyk7XG4gIH0pO1xuXG4gIHJldHVybiBsb2dnaW5nO1xufSgpO1xuXG52YXIgbG9nZ2VyID0gX2V4cG9ydHMubG9nZ2luZy5nZXQoJ2pzaW9jb3JlJyk7XG5fZXhwb3J0cy5sb2dnZXIgPSBsb2dnZXI7XG5cbi8vIFRPRE86IG1ha2UgdGhpcyBub3QgYSBoYWNrXG52YXIgX2V4cG9ydExvZyA9IF9leHBvcnRzLmxvZztcbnZhciBfZXhwb3J0SXNBcnJheSA9IF9leHBvcnRzLmlzQXJyYXk7XG52YXIgX2V4cG9ydEJpbmQgPSBfZXhwb3J0cy5iaW5kO1xudmFyIF9leHBvcnRNZXJnZSA9IF9leHBvcnRzLm1lcmdlO1xudmFyIF9leHBvcnREZWxheSA9IF9leHBvcnRzLmRlbGF5O1xudmFyIF9leHBvcnRMb2dnaW5nID0gX2V4cG9ydHMubG9nZ2luZztcbnZhciBfZXhwb3J0TG9nZ2VyID0gX2V4cG9ydHMubG9nZ2VyO1xudmFyIF9leHBvcnRDT05GSUcgPSB0eXBlb2YgQ09ORklHICE9PSAndW5kZWZpbmVkJyA/IENPTkZJRyA6IHt9O1xudmFyIF9leHBvcnROQVRJVkUgPSB0eXBlb2YgTkFUSVZFICE9PSAndW5kZWZpbmVkJyA/IE5BVElWRSA6IHt9O1xudmFyIF9leHBvcnRDQUNIRSA9IHR5cGVvZiBDQUNIRSAhPT0gJ3VuZGVmaW5lZCcgPyBDQUNIRSA6IHt9O1xuXG52YXIgX2V4cG9ydEdMT0JBTDtcbmlmICh0eXBlb2YgR0xPQkFMICE9PSAndW5kZWZpbmVkJykge1xuICBleHBvcnRzLkdMT0JBTCA9IF9leHBvcnRHTE9CQUwgPSBHTE9CQUw7XG59IGVsc2Uge1xuICBleHBvcnRzLkdMT0JBTCA9IF9leHBvcnRHTE9CQUwgPSB3aW5kb3c7XG4gIHdpbmRvdy5DQUNIRSA9IF9leHBvcnRDQUNIRTtcbiAgd2luZG93LkNPTkZJRyA9IF9leHBvcnRDT05GSUc7XG4gIHdpbmRvdy5OQVRJVkUgPSBfZXhwb3J0TkFUSVZFO1xufVxuXG5leHBvcnRzLmxvZyA9IF9leHBvcnRMb2c7XG5leHBvcnRzLmlzQXJyYXkgPSBfZXhwb3J0SXNBcnJheTtcbmV4cG9ydHMuYmluZCA9IF9leHBvcnRCaW5kO1xuZXhwb3J0cy5tZXJnZSA9IF9leHBvcnRNZXJnZTtcbmV4cG9ydHMuZGVsYXkgPSBfZXhwb3J0RGVsYXk7XG5leHBvcnRzLmxvZ2dpbmcgPSBfZXhwb3J0TG9nZ2luZztcbmV4cG9ydHMubG9nZ2VyID0gX2V4cG9ydExvZ2dlcjtcbmV4cG9ydHMuR0xPQkFMID0gX2V4cG9ydEdMT0JBTDtcbmV4cG9ydHMuTkFUSVZFID0gX2V4cG9ydE5BVElWRTtcbmV4cG9ydHMuQ09ORklHID0gX2V4cG9ydENPTkZJRztcbmV4cG9ydHMuQ0FDSEUgPSBfZXhwb3J0Q0FDSEU7XG5leHBvcnRzLmRlZmF1bHQgPSBfZXhwb3J0cztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Zyb250ZW5kL2pzaW8vYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n");

/***/ }),

/***/ 1:
/*!***************************************************************!*\
  !*** ./frontend/node_modules/bluebird/js/browser/bluebird.js ***!
  \***************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/* @preserve\n * The MIT License (MIT)\n * \n * Copyright (c) 2013-2017 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n/**\n * bluebird build version 3.5.0\n * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, using, timers, filter, any, each\n*/\n!function (e) {\n    if (\"object\" == ( false ? \"undefined\" : _typeof(exports)) && \"undefined\" != typeof module) module.exports = e();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (e),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {\n        var f;\"undefined\" != typeof window ? f = window : \"undefined\" != typeof global ? f = global : \"undefined\" != typeof self && (f = self), f.Promise = e();\n    }\n}(function () {\n    var define, module, exports;return function e(t, n, r) {\n        function s(o, u) {\n            if (!n[o]) {\n                if (!t[o]) {\n                    var a = typeof _dereq_ == \"function\" && _dereq_;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error(\"Cannot find module '\" + o + \"'\");throw f.code = \"MODULE_NOT_FOUND\", f;\n                }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {\n                    var n = t[o][1][e];return s(n ? n : e);\n                }, l, l.exports, e, t, n, r);\n            }return n[o].exports;\n        }var i = typeof _dereq_ == \"function\" && _dereq_;for (var o = 0; o < r.length; o++) {\n            s(r[o]);\n        }return s;\n    }({ 1: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise) {\n                var SomePromiseArray = Promise._SomePromiseArray;\n                function any(promises) {\n                    var ret = new SomePromiseArray(promises);\n                    var promise = ret.promise();\n                    ret.setHowMany(1);\n                    ret.setUnwrap();\n                    ret.init();\n                    return promise;\n                }\n\n                Promise.any = function (promises) {\n                    return any(promises);\n                };\n\n                Promise.prototype.any = function () {\n                    return any(this);\n                };\n            };\n        }, {}], 2: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            var firstLineError;\n            try {\n                throw new Error();\n            } catch (e) {\n                firstLineError = e;\n            }\n            var schedule = _dereq_(\"./schedule\");\n            var Queue = _dereq_(\"./queue\");\n            var util = _dereq_(\"./util\");\n\n            function Async() {\n                this._customScheduler = false;\n                this._isTickUsed = false;\n                this._lateQueue = new Queue(16);\n                this._normalQueue = new Queue(16);\n                this._haveDrainedQueues = false;\n                this._trampolineEnabled = true;\n                var self = this;\n                this.drainQueues = function () {\n                    self._drainQueues();\n                };\n                this._schedule = schedule;\n            }\n\n            Async.prototype.setScheduler = function (fn) {\n                var prev = this._schedule;\n                this._schedule = fn;\n                this._customScheduler = true;\n                return prev;\n            };\n\n            Async.prototype.hasCustomScheduler = function () {\n                return this._customScheduler;\n            };\n\n            Async.prototype.enableTrampoline = function () {\n                this._trampolineEnabled = true;\n            };\n\n            Async.prototype.disableTrampolineIfNecessary = function () {\n                if (util.hasDevTools) {\n                    this._trampolineEnabled = false;\n                }\n            };\n\n            Async.prototype.haveItemsQueued = function () {\n                return this._isTickUsed || this._haveDrainedQueues;\n            };\n\n            Async.prototype.fatalError = function (e, isNode) {\n                if (isNode) {\n                    process.stderr.write(\"Fatal \" + (e instanceof Error ? e.stack : e) + \"\\n\");\n                    process.exit(2);\n                } else {\n                    this.throwLater(e);\n                }\n            };\n\n            Async.prototype.throwLater = function (fn, arg) {\n                if (arguments.length === 1) {\n                    arg = fn;\n                    fn = function fn() {\n                        throw arg;\n                    };\n                }\n                if (typeof setTimeout !== \"undefined\") {\n                    setTimeout(function () {\n                        fn(arg);\n                    }, 0);\n                } else try {\n                    this._schedule(function () {\n                        fn(arg);\n                    });\n                } catch (e) {\n                    throw new Error(\"No async scheduler available\\n\\n    See http://goo.gl/MqrFmX\\n\");\n                }\n            };\n\n            function AsyncInvokeLater(fn, receiver, arg) {\n                this._lateQueue.push(fn, receiver, arg);\n                this._queueTick();\n            }\n\n            function AsyncInvoke(fn, receiver, arg) {\n                this._normalQueue.push(fn, receiver, arg);\n                this._queueTick();\n            }\n\n            function AsyncSettlePromises(promise) {\n                this._normalQueue._pushOne(promise);\n                this._queueTick();\n            }\n\n            if (!util.hasDevTools) {\n                Async.prototype.invokeLater = AsyncInvokeLater;\n                Async.prototype.invoke = AsyncInvoke;\n                Async.prototype.settlePromises = AsyncSettlePromises;\n            } else {\n                Async.prototype.invokeLater = function (fn, receiver, arg) {\n                    if (this._trampolineEnabled) {\n                        AsyncInvokeLater.call(this, fn, receiver, arg);\n                    } else {\n                        this._schedule(function () {\n                            setTimeout(function () {\n                                fn.call(receiver, arg);\n                            }, 100);\n                        });\n                    }\n                };\n\n                Async.prototype.invoke = function (fn, receiver, arg) {\n                    if (this._trampolineEnabled) {\n                        AsyncInvoke.call(this, fn, receiver, arg);\n                    } else {\n                        this._schedule(function () {\n                            fn.call(receiver, arg);\n                        });\n                    }\n                };\n\n                Async.prototype.settlePromises = function (promise) {\n                    if (this._trampolineEnabled) {\n                        AsyncSettlePromises.call(this, promise);\n                    } else {\n                        this._schedule(function () {\n                            promise._settlePromises();\n                        });\n                    }\n                };\n            }\n\n            Async.prototype._drainQueue = function (queue) {\n                while (queue.length() > 0) {\n                    var fn = queue.shift();\n                    if (typeof fn !== \"function\") {\n                        fn._settlePromises();\n                        continue;\n                    }\n                    var receiver = queue.shift();\n                    var arg = queue.shift();\n                    fn.call(receiver, arg);\n                }\n            };\n\n            Async.prototype._drainQueues = function () {\n                this._drainQueue(this._normalQueue);\n                this._reset();\n                this._haveDrainedQueues = true;\n                this._drainQueue(this._lateQueue);\n            };\n\n            Async.prototype._queueTick = function () {\n                if (!this._isTickUsed) {\n                    this._isTickUsed = true;\n                    this._schedule(this.drainQueues);\n                }\n            };\n\n            Async.prototype._reset = function () {\n                this._isTickUsed = false;\n            };\n\n            module.exports = Async;\n            module.exports.firstLineError = firstLineError;\n        }, { \"./queue\": 26, \"./schedule\": 29, \"./util\": 36 }], 3: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, INTERNAL, tryConvertToPromise, debug) {\n                var calledBind = false;\n                var rejectThis = function rejectThis(_, e) {\n                    this._reject(e);\n                };\n\n                var targetRejected = function targetRejected(e, context) {\n                    context.promiseRejectionQueued = true;\n                    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);\n                };\n\n                var bindingResolved = function bindingResolved(thisArg, context) {\n                    if ((this._bitField & 50397184) === 0) {\n                        this._resolveCallback(context.target);\n                    }\n                };\n\n                var bindingRejected = function bindingRejected(e, context) {\n                    if (!context.promiseRejectionQueued) this._reject(e);\n                };\n\n                Promise.prototype.bind = function (thisArg) {\n                    if (!calledBind) {\n                        calledBind = true;\n                        Promise.prototype._propagateFrom = debug.propagateFromFunction();\n                        Promise.prototype._boundValue = debug.boundValueFunction();\n                    }\n                    var maybePromise = tryConvertToPromise(thisArg);\n                    var ret = new Promise(INTERNAL);\n                    ret._propagateFrom(this, 1);\n                    var target = this._target();\n                    ret._setBoundTo(maybePromise);\n                    if (maybePromise instanceof Promise) {\n                        var context = {\n                            promiseRejectionQueued: false,\n                            promise: ret,\n                            target: target,\n                            bindingPromise: maybePromise\n                        };\n                        target._then(INTERNAL, targetRejected, undefined, ret, context);\n                        maybePromise._then(bindingResolved, bindingRejected, undefined, ret, context);\n                        ret._setOnCancel(maybePromise);\n                    } else {\n                        ret._resolveCallback(target);\n                    }\n                    return ret;\n                };\n\n                Promise.prototype._setBoundTo = function (obj) {\n                    if (obj !== undefined) {\n                        this._bitField = this._bitField | 2097152;\n                        this._boundTo = obj;\n                    } else {\n                        this._bitField = this._bitField & ~2097152;\n                    }\n                };\n\n                Promise.prototype._isBound = function () {\n                    return (this._bitField & 2097152) === 2097152;\n                };\n\n                Promise.bind = function (thisArg, value) {\n                    return Promise.resolve(value).bind(thisArg);\n                };\n            };\n        }, {}], 4: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            var old;\n            if (typeof Promise !== \"undefined\") old = Promise;\n            function noConflict() {\n                try {\n                    if (Promise === bluebird) Promise = old;\n                } catch (e) {}\n                return bluebird;\n            }\n            var bluebird = _dereq_(\"./promise\")();\n            bluebird.noConflict = noConflict;\n            module.exports = bluebird;\n        }, { \"./promise\": 22 }], 5: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            var cr = Object.create;\n            if (cr) {\n                var callerCache = cr(null);\n                var getterCache = cr(null);\n                callerCache[\" size\"] = getterCache[\" size\"] = 0;\n            }\n\n            module.exports = function (Promise) {\n                var util = _dereq_(\"./util\");\n                var canEvaluate = util.canEvaluate;\n                var isIdentifier = util.isIdentifier;\n\n                var getMethodCaller;\n                var getGetter;\n                if (false) {\n                    var makeMethodCaller = function makeMethodCaller(methodName) {\n                        return new Function(\"ensureMethod\", \"                                    \\n\\\n        return function(obj) {                                               \\n\\\n            'use strict'                                                     \\n\\\n            var len = this.length;                                           \\n\\\n            ensureMethod(obj, 'methodName');                                 \\n\\\n            switch(len) {                                                    \\n\\\n                case 1: return obj.methodName(this[0]);                      \\n\\\n                case 2: return obj.methodName(this[0], this[1]);             \\n\\\n                case 3: return obj.methodName(this[0], this[1], this[2]);    \\n\\\n                case 0: return obj.methodName();                             \\n\\\n                default:                                                     \\n\\\n                    return obj.methodName.apply(obj, this);                  \\n\\\n            }                                                                \\n\\\n        };                                                                   \\n\\\n        \".replace(/methodName/g, methodName))(ensureMethod);\n                    };\n\n                    var makeGetter = function makeGetter(propertyName) {\n                        return new Function(\"obj\", \"                                             \\n\\\n        'use strict';                                                        \\n\\\n        return obj.propertyName;                                             \\n\\\n        \".replace(\"propertyName\", propertyName));\n                    };\n\n                    var getCompiled = function getCompiled(name, compiler, cache) {\n                        var ret = cache[name];\n                        if (typeof ret !== \"function\") {\n                            if (!isIdentifier(name)) {\n                                return null;\n                            }\n                            ret = compiler(name);\n                            cache[name] = ret;\n                            cache[\" size\"]++;\n                            if (cache[\" size\"] > 512) {\n                                var keys = Object.keys(cache);\n                                for (var i = 0; i < 256; ++i) {\n                                    delete cache[keys[i]];\n                                }cache[\" size\"] = keys.length - 256;\n                            }\n                        }\n                        return ret;\n                    };\n\n                    getMethodCaller = function getMethodCaller(name) {\n                        return getCompiled(name, makeMethodCaller, callerCache);\n                    };\n\n                    getGetter = function getGetter(name) {\n                        return getCompiled(name, makeGetter, getterCache);\n                    };\n                }\n\n                function ensureMethod(obj, methodName) {\n                    var fn;\n                    if (obj != null) fn = obj[methodName];\n                    if (typeof fn !== \"function\") {\n                        var message = \"Object \" + util.classString(obj) + \" has no method '\" + util.toString(methodName) + \"'\";\n                        throw new Promise.TypeError(message);\n                    }\n                    return fn;\n                }\n\n                function caller(obj) {\n                    var methodName = this.pop();\n                    var fn = ensureMethod(obj, methodName);\n                    return fn.apply(obj, this);\n                }\n                Promise.prototype.call = function (methodName) {\n                    var args = [].slice.call(arguments, 1);;\n                    if (false) {\n                        if (canEvaluate) {\n                            var maybeCaller = getMethodCaller(methodName);\n                            if (maybeCaller !== null) {\n                                return this._then(maybeCaller, undefined, undefined, args, undefined);\n                            }\n                        }\n                    }\n                    args.push(methodName);\n                    return this._then(caller, undefined, undefined, args, undefined);\n                };\n\n                function namedGetter(obj) {\n                    return obj[this];\n                }\n                function indexedGetter(obj) {\n                    var index = +this;\n                    if (index < 0) index = Math.max(0, index + obj.length);\n                    return obj[index];\n                }\n                Promise.prototype.get = function (propertyName) {\n                    var isIndex = typeof propertyName === \"number\";\n                    var getter;\n                    if (!isIndex) {\n                        if (canEvaluate) {\n                            var maybeGetter = getGetter(propertyName);\n                            getter = maybeGetter !== null ? maybeGetter : namedGetter;\n                        } else {\n                            getter = namedGetter;\n                        }\n                    } else {\n                        getter = indexedGetter;\n                    }\n                    return this._then(getter, undefined, undefined, propertyName, undefined);\n                };\n            };\n        }, { \"./util\": 36 }], 6: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, PromiseArray, apiRejection, debug) {\n                var util = _dereq_(\"./util\");\n                var tryCatch = util.tryCatch;\n                var errorObj = util.errorObj;\n                var async = Promise._async;\n\n                Promise.prototype[\"break\"] = Promise.prototype.cancel = function () {\n                    if (!debug.cancellation()) return this._warn(\"cancellation is disabled\");\n\n                    var promise = this;\n                    var child = promise;\n                    while (promise._isCancellable()) {\n                        if (!promise._cancelBy(child)) {\n                            if (child._isFollowing()) {\n                                child._followee().cancel();\n                            } else {\n                                child._cancelBranched();\n                            }\n                            break;\n                        }\n\n                        var parent = promise._cancellationParent;\n                        if (parent == null || !parent._isCancellable()) {\n                            if (promise._isFollowing()) {\n                                promise._followee().cancel();\n                            } else {\n                                promise._cancelBranched();\n                            }\n                            break;\n                        } else {\n                            if (promise._isFollowing()) promise._followee().cancel();\n                            promise._setWillBeCancelled();\n                            child = promise;\n                            promise = parent;\n                        }\n                    }\n                };\n\n                Promise.prototype._branchHasCancelled = function () {\n                    this._branchesRemainingToCancel--;\n                };\n\n                Promise.prototype._enoughBranchesHaveCancelled = function () {\n                    return this._branchesRemainingToCancel === undefined || this._branchesRemainingToCancel <= 0;\n                };\n\n                Promise.prototype._cancelBy = function (canceller) {\n                    if (canceller === this) {\n                        this._branchesRemainingToCancel = 0;\n                        this._invokeOnCancel();\n                        return true;\n                    } else {\n                        this._branchHasCancelled();\n                        if (this._enoughBranchesHaveCancelled()) {\n                            this._invokeOnCancel();\n                            return true;\n                        }\n                    }\n                    return false;\n                };\n\n                Promise.prototype._cancelBranched = function () {\n                    if (this._enoughBranchesHaveCancelled()) {\n                        this._cancel();\n                    }\n                };\n\n                Promise.prototype._cancel = function () {\n                    if (!this._isCancellable()) return;\n                    this._setCancelled();\n                    async.invoke(this._cancelPromises, this, undefined);\n                };\n\n                Promise.prototype._cancelPromises = function () {\n                    if (this._length() > 0) this._settlePromises();\n                };\n\n                Promise.prototype._unsetOnCancel = function () {\n                    this._onCancelField = undefined;\n                };\n\n                Promise.prototype._isCancellable = function () {\n                    return this.isPending() && !this._isCancelled();\n                };\n\n                Promise.prototype.isCancellable = function () {\n                    return this.isPending() && !this.isCancelled();\n                };\n\n                Promise.prototype._doInvokeOnCancel = function (onCancelCallback, internalOnly) {\n                    if (util.isArray(onCancelCallback)) {\n                        for (var i = 0; i < onCancelCallback.length; ++i) {\n                            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);\n                        }\n                    } else if (onCancelCallback !== undefined) {\n                        if (typeof onCancelCallback === \"function\") {\n                            if (!internalOnly) {\n                                var e = tryCatch(onCancelCallback).call(this._boundValue());\n                                if (e === errorObj) {\n                                    this._attachExtraTrace(e.e);\n                                    async.throwLater(e.e);\n                                }\n                            }\n                        } else {\n                            onCancelCallback._resultCancelled(this);\n                        }\n                    }\n                };\n\n                Promise.prototype._invokeOnCancel = function () {\n                    var onCancelCallback = this._onCancel();\n                    this._unsetOnCancel();\n                    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);\n                };\n\n                Promise.prototype._invokeInternalOnCancel = function () {\n                    if (this._isCancellable()) {\n                        this._doInvokeOnCancel(this._onCancel(), true);\n                        this._unsetOnCancel();\n                    }\n                };\n\n                Promise.prototype._resultCancelled = function () {\n                    this.cancel();\n                };\n            };\n        }, { \"./util\": 36 }], 7: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (NEXT_FILTER) {\n                var util = _dereq_(\"./util\");\n                var getKeys = _dereq_(\"./es5\").keys;\n                var tryCatch = util.tryCatch;\n                var errorObj = util.errorObj;\n\n                function catchFilter(instances, cb, promise) {\n                    return function (e) {\n                        var boundTo = promise._boundValue();\n                        predicateLoop: for (var i = 0; i < instances.length; ++i) {\n                            var item = instances[i];\n\n                            if (item === Error || item != null && item.prototype instanceof Error) {\n                                if (e instanceof item) {\n                                    return tryCatch(cb).call(boundTo, e);\n                                }\n                            } else if (typeof item === \"function\") {\n                                var matchesPredicate = tryCatch(item).call(boundTo, e);\n                                if (matchesPredicate === errorObj) {\n                                    return matchesPredicate;\n                                } else if (matchesPredicate) {\n                                    return tryCatch(cb).call(boundTo, e);\n                                }\n                            } else if (util.isObject(e)) {\n                                var keys = getKeys(item);\n                                for (var j = 0; j < keys.length; ++j) {\n                                    var key = keys[j];\n                                    if (item[key] != e[key]) {\n                                        continue predicateLoop;\n                                    }\n                                }\n                                return tryCatch(cb).call(boundTo, e);\n                            }\n                        }\n                        return NEXT_FILTER;\n                    };\n                }\n\n                return catchFilter;\n            };\n        }, { \"./es5\": 13, \"./util\": 36 }], 8: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise) {\n                var longStackTraces = false;\n                var contextStack = [];\n\n                Promise.prototype._promiseCreated = function () {};\n                Promise.prototype._pushContext = function () {};\n                Promise.prototype._popContext = function () {\n                    return null;\n                };\n                Promise._peekContext = Promise.prototype._peekContext = function () {};\n\n                function Context() {\n                    this._trace = new Context.CapturedTrace(peekContext());\n                }\n                Context.prototype._pushContext = function () {\n                    if (this._trace !== undefined) {\n                        this._trace._promiseCreated = null;\n                        contextStack.push(this._trace);\n                    }\n                };\n\n                Context.prototype._popContext = function () {\n                    if (this._trace !== undefined) {\n                        var trace = contextStack.pop();\n                        var ret = trace._promiseCreated;\n                        trace._promiseCreated = null;\n                        return ret;\n                    }\n                    return null;\n                };\n\n                function createContext() {\n                    if (longStackTraces) return new Context();\n                }\n\n                function peekContext() {\n                    var lastIndex = contextStack.length - 1;\n                    if (lastIndex >= 0) {\n                        return contextStack[lastIndex];\n                    }\n                    return undefined;\n                }\n                Context.CapturedTrace = null;\n                Context.create = createContext;\n                Context.deactivateLongStackTraces = function () {};\n                Context.activateLongStackTraces = function () {\n                    var Promise_pushContext = Promise.prototype._pushContext;\n                    var Promise_popContext = Promise.prototype._popContext;\n                    var Promise_PeekContext = Promise._peekContext;\n                    var Promise_peekContext = Promise.prototype._peekContext;\n                    var Promise_promiseCreated = Promise.prototype._promiseCreated;\n                    Context.deactivateLongStackTraces = function () {\n                        Promise.prototype._pushContext = Promise_pushContext;\n                        Promise.prototype._popContext = Promise_popContext;\n                        Promise._peekContext = Promise_PeekContext;\n                        Promise.prototype._peekContext = Promise_peekContext;\n                        Promise.prototype._promiseCreated = Promise_promiseCreated;\n                        longStackTraces = false;\n                    };\n                    longStackTraces = true;\n                    Promise.prototype._pushContext = Context.prototype._pushContext;\n                    Promise.prototype._popContext = Context.prototype._popContext;\n                    Promise._peekContext = Promise.prototype._peekContext = peekContext;\n                    Promise.prototype._promiseCreated = function () {\n                        var ctx = this._peekContext();\n                        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;\n                    };\n                };\n                return Context;\n            };\n        }, {}], 9: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, Context) {\n                var getDomain = Promise._getDomain;\n                var async = Promise._async;\n                var Warning = _dereq_(\"./errors\").Warning;\n                var util = _dereq_(\"./util\");\n                var canAttachTrace = util.canAttachTrace;\n                var unhandledRejectionHandled;\n                var possiblyUnhandledRejection;\n                var bluebirdFramePattern = /[\\\\\\/]bluebird[\\\\\\/]js[\\\\\\/](release|debug|instrumented)/;\n                var nodeFramePattern = /\\((?:timers\\.js):\\d+:\\d+\\)/;\n                var parseLinePattern = /[\\/<\\(](.+?):(\\d+):(\\d+)\\)?\\s*$/;\n                var stackFramePattern = null;\n                var formatStack = null;\n                var indentStackFrames = false;\n                var printWarning;\n                var debugging = !!(util.env(\"BLUEBIRD_DEBUG\") != 0 && (true || util.env(\"BLUEBIRD_DEBUG\") || util.env(\"NODE_ENV\") === \"development\"));\n\n                var warnings = !!(util.env(\"BLUEBIRD_WARNINGS\") != 0 && (debugging || util.env(\"BLUEBIRD_WARNINGS\")));\n\n                var longStackTraces = !!(util.env(\"BLUEBIRD_LONG_STACK_TRACES\") != 0 && (debugging || util.env(\"BLUEBIRD_LONG_STACK_TRACES\")));\n\n                var wForgottenReturn = util.env(\"BLUEBIRD_W_FORGOTTEN_RETURN\") != 0 && (warnings || !!util.env(\"BLUEBIRD_W_FORGOTTEN_RETURN\"));\n\n                Promise.prototype.suppressUnhandledRejections = function () {\n                    var target = this._target();\n                    target._bitField = target._bitField & ~1048576 | 524288;\n                };\n\n                Promise.prototype._ensurePossibleRejectionHandled = function () {\n                    if ((this._bitField & 524288) !== 0) return;\n                    this._setRejectionIsUnhandled();\n                    async.invokeLater(this._notifyUnhandledRejection, this, undefined);\n                };\n\n                Promise.prototype._notifyUnhandledRejectionIsHandled = function () {\n                    fireRejectionEvent(\"rejectionHandled\", unhandledRejectionHandled, undefined, this);\n                };\n\n                Promise.prototype._setReturnedNonUndefined = function () {\n                    this._bitField = this._bitField | 268435456;\n                };\n\n                Promise.prototype._returnedNonUndefined = function () {\n                    return (this._bitField & 268435456) !== 0;\n                };\n\n                Promise.prototype._notifyUnhandledRejection = function () {\n                    if (this._isRejectionUnhandled()) {\n                        var reason = this._settledValue();\n                        this._setUnhandledRejectionIsNotified();\n                        fireRejectionEvent(\"unhandledRejection\", possiblyUnhandledRejection, reason, this);\n                    }\n                };\n\n                Promise.prototype._setUnhandledRejectionIsNotified = function () {\n                    this._bitField = this._bitField | 262144;\n                };\n\n                Promise.prototype._unsetUnhandledRejectionIsNotified = function () {\n                    this._bitField = this._bitField & ~262144;\n                };\n\n                Promise.prototype._isUnhandledRejectionNotified = function () {\n                    return (this._bitField & 262144) > 0;\n                };\n\n                Promise.prototype._setRejectionIsUnhandled = function () {\n                    this._bitField = this._bitField | 1048576;\n                };\n\n                Promise.prototype._unsetRejectionIsUnhandled = function () {\n                    this._bitField = this._bitField & ~1048576;\n                    if (this._isUnhandledRejectionNotified()) {\n                        this._unsetUnhandledRejectionIsNotified();\n                        this._notifyUnhandledRejectionIsHandled();\n                    }\n                };\n\n                Promise.prototype._isRejectionUnhandled = function () {\n                    return (this._bitField & 1048576) > 0;\n                };\n\n                Promise.prototype._warn = function (message, shouldUseOwnTrace, promise) {\n                    return warn(message, shouldUseOwnTrace, promise || this);\n                };\n\n                Promise.onPossiblyUnhandledRejection = function (fn) {\n                    var domain = getDomain();\n                    possiblyUnhandledRejection = typeof fn === \"function\" ? domain === null ? fn : util.domainBind(domain, fn) : undefined;\n                };\n\n                Promise.onUnhandledRejectionHandled = function (fn) {\n                    var domain = getDomain();\n                    unhandledRejectionHandled = typeof fn === \"function\" ? domain === null ? fn : util.domainBind(domain, fn) : undefined;\n                };\n\n                var disableLongStackTraces = function disableLongStackTraces() {};\n                Promise.longStackTraces = function () {\n                    if (async.haveItemsQueued() && !config.longStackTraces) {\n                        throw new Error(\"cannot enable long stack traces after promises have been created\\n\\n    See http://goo.gl/MqrFmX\\n\");\n                    }\n                    if (!config.longStackTraces && longStackTracesIsSupported()) {\n                        var Promise_captureStackTrace = Promise.prototype._captureStackTrace;\n                        var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;\n                        config.longStackTraces = true;\n                        disableLongStackTraces = function disableLongStackTraces() {\n                            if (async.haveItemsQueued() && !config.longStackTraces) {\n                                throw new Error(\"cannot enable long stack traces after promises have been created\\n\\n    See http://goo.gl/MqrFmX\\n\");\n                            }\n                            Promise.prototype._captureStackTrace = Promise_captureStackTrace;\n                            Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;\n                            Context.deactivateLongStackTraces();\n                            async.enableTrampoline();\n                            config.longStackTraces = false;\n                        };\n                        Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;\n                        Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;\n                        Context.activateLongStackTraces();\n                        async.disableTrampolineIfNecessary();\n                    }\n                };\n\n                Promise.hasLongStackTraces = function () {\n                    return config.longStackTraces && longStackTracesIsSupported();\n                };\n\n                var fireDomEvent = function () {\n                    try {\n                        if (typeof CustomEvent === \"function\") {\n                            var event = new CustomEvent(\"CustomEvent\");\n                            util.global.dispatchEvent(event);\n                            return function (name, event) {\n                                var domEvent = new CustomEvent(name.toLowerCase(), {\n                                    detail: event,\n                                    cancelable: true\n                                });\n                                return !util.global.dispatchEvent(domEvent);\n                            };\n                        } else if (typeof Event === \"function\") {\n                            var event = new Event(\"CustomEvent\");\n                            util.global.dispatchEvent(event);\n                            return function (name, event) {\n                                var domEvent = new Event(name.toLowerCase(), {\n                                    cancelable: true\n                                });\n                                domEvent.detail = event;\n                                return !util.global.dispatchEvent(domEvent);\n                            };\n                        } else {\n                            var event = document.createEvent(\"CustomEvent\");\n                            event.initCustomEvent(\"testingtheevent\", false, true, {});\n                            util.global.dispatchEvent(event);\n                            return function (name, event) {\n                                var domEvent = document.createEvent(\"CustomEvent\");\n                                domEvent.initCustomEvent(name.toLowerCase(), false, true, event);\n                                return !util.global.dispatchEvent(domEvent);\n                            };\n                        }\n                    } catch (e) {}\n                    return function () {\n                        return false;\n                    };\n                }();\n\n                var fireGlobalEvent = function () {\n                    if (util.isNode) {\n                        return function () {\n                            return process.emit.apply(process, arguments);\n                        };\n                    } else {\n                        if (!util.global) {\n                            return function () {\n                                return false;\n                            };\n                        }\n                        return function (name) {\n                            var methodName = \"on\" + name.toLowerCase();\n                            var method = util.global[methodName];\n                            if (!method) return false;\n                            method.apply(util.global, [].slice.call(arguments, 1));\n                            return true;\n                        };\n                    }\n                }();\n\n                function generatePromiseLifecycleEventObject(name, promise) {\n                    return { promise: promise };\n                }\n\n                var eventToObjectGenerator = {\n                    promiseCreated: generatePromiseLifecycleEventObject,\n                    promiseFulfilled: generatePromiseLifecycleEventObject,\n                    promiseRejected: generatePromiseLifecycleEventObject,\n                    promiseResolved: generatePromiseLifecycleEventObject,\n                    promiseCancelled: generatePromiseLifecycleEventObject,\n                    promiseChained: function promiseChained(name, promise, child) {\n                        return { promise: promise, child: child };\n                    },\n                    warning: function warning(name, _warning) {\n                        return { warning: _warning };\n                    },\n                    unhandledRejection: function unhandledRejection(name, reason, promise) {\n                        return { reason: reason, promise: promise };\n                    },\n                    rejectionHandled: generatePromiseLifecycleEventObject\n                };\n\n                var activeFireEvent = function activeFireEvent(name) {\n                    var globalEventFired = false;\n                    try {\n                        globalEventFired = fireGlobalEvent.apply(null, arguments);\n                    } catch (e) {\n                        async.throwLater(e);\n                        globalEventFired = true;\n                    }\n\n                    var domEventFired = false;\n                    try {\n                        domEventFired = fireDomEvent(name, eventToObjectGenerator[name].apply(null, arguments));\n                    } catch (e) {\n                        async.throwLater(e);\n                        domEventFired = true;\n                    }\n\n                    return domEventFired || globalEventFired;\n                };\n\n                Promise.config = function (opts) {\n                    opts = Object(opts);\n                    if (\"longStackTraces\" in opts) {\n                        if (opts.longStackTraces) {\n                            Promise.longStackTraces();\n                        } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {\n                            disableLongStackTraces();\n                        }\n                    }\n                    if (\"warnings\" in opts) {\n                        var warningsOption = opts.warnings;\n                        config.warnings = !!warningsOption;\n                        wForgottenReturn = config.warnings;\n\n                        if (util.isObject(warningsOption)) {\n                            if (\"wForgottenReturn\" in warningsOption) {\n                                wForgottenReturn = !!warningsOption.wForgottenReturn;\n                            }\n                        }\n                    }\n                    if (\"cancellation\" in opts && opts.cancellation && !config.cancellation) {\n                        if (async.haveItemsQueued()) {\n                            throw new Error(\"cannot enable cancellation after promises are in use\");\n                        }\n                        Promise.prototype._clearCancellationData = cancellationClearCancellationData;\n                        Promise.prototype._propagateFrom = cancellationPropagateFrom;\n                        Promise.prototype._onCancel = cancellationOnCancel;\n                        Promise.prototype._setOnCancel = cancellationSetOnCancel;\n                        Promise.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;\n                        Promise.prototype._execute = cancellationExecute;\n                        _propagateFromFunction = cancellationPropagateFrom;\n                        config.cancellation = true;\n                    }\n                    if (\"monitoring\" in opts) {\n                        if (opts.monitoring && !config.monitoring) {\n                            config.monitoring = true;\n                            Promise.prototype._fireEvent = activeFireEvent;\n                        } else if (!opts.monitoring && config.monitoring) {\n                            config.monitoring = false;\n                            Promise.prototype._fireEvent = defaultFireEvent;\n                        }\n                    }\n                    return Promise;\n                };\n\n                function defaultFireEvent() {\n                    return false;\n                }\n\n                Promise.prototype._fireEvent = defaultFireEvent;\n                Promise.prototype._execute = function (executor, resolve, reject) {\n                    try {\n                        executor(resolve, reject);\n                    } catch (e) {\n                        return e;\n                    }\n                };\n                Promise.prototype._onCancel = function () {};\n                Promise.prototype._setOnCancel = function (handler) {\n                    ;\n                };\n                Promise.prototype._attachCancellationCallback = function (onCancel) {\n                    ;\n                };\n                Promise.prototype._captureStackTrace = function () {};\n                Promise.prototype._attachExtraTrace = function () {};\n                Promise.prototype._clearCancellationData = function () {};\n                Promise.prototype._propagateFrom = function (parent, flags) {\n                    ;\n                    ;\n                };\n\n                function cancellationExecute(executor, resolve, reject) {\n                    var promise = this;\n                    try {\n                        executor(resolve, reject, function (onCancel) {\n                            if (typeof onCancel !== \"function\") {\n                                throw new TypeError(\"onCancel must be a function, got: \" + util.toString(onCancel));\n                            }\n                            promise._attachCancellationCallback(onCancel);\n                        });\n                    } catch (e) {\n                        return e;\n                    }\n                }\n\n                function cancellationAttachCancellationCallback(onCancel) {\n                    if (!this._isCancellable()) return this;\n\n                    var previousOnCancel = this._onCancel();\n                    if (previousOnCancel !== undefined) {\n                        if (util.isArray(previousOnCancel)) {\n                            previousOnCancel.push(onCancel);\n                        } else {\n                            this._setOnCancel([previousOnCancel, onCancel]);\n                        }\n                    } else {\n                        this._setOnCancel(onCancel);\n                    }\n                }\n\n                function cancellationOnCancel() {\n                    return this._onCancelField;\n                }\n\n                function cancellationSetOnCancel(onCancel) {\n                    this._onCancelField = onCancel;\n                }\n\n                function cancellationClearCancellationData() {\n                    this._cancellationParent = undefined;\n                    this._onCancelField = undefined;\n                }\n\n                function cancellationPropagateFrom(parent, flags) {\n                    if ((flags & 1) !== 0) {\n                        this._cancellationParent = parent;\n                        var branchesRemainingToCancel = parent._branchesRemainingToCancel;\n                        if (branchesRemainingToCancel === undefined) {\n                            branchesRemainingToCancel = 0;\n                        }\n                        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;\n                    }\n                    if ((flags & 2) !== 0 && parent._isBound()) {\n                        this._setBoundTo(parent._boundTo);\n                    }\n                }\n\n                function bindingPropagateFrom(parent, flags) {\n                    if ((flags & 2) !== 0 && parent._isBound()) {\n                        this._setBoundTo(parent._boundTo);\n                    }\n                }\n                var _propagateFromFunction = bindingPropagateFrom;\n\n                function _boundValueFunction() {\n                    var ret = this._boundTo;\n                    if (ret !== undefined) {\n                        if (ret instanceof Promise) {\n                            if (ret.isFulfilled()) {\n                                return ret.value();\n                            } else {\n                                return undefined;\n                            }\n                        }\n                    }\n                    return ret;\n                }\n\n                function longStackTracesCaptureStackTrace() {\n                    this._trace = new CapturedTrace(this._peekContext());\n                }\n\n                function longStackTracesAttachExtraTrace(error, ignoreSelf) {\n                    if (canAttachTrace(error)) {\n                        var trace = this._trace;\n                        if (trace !== undefined) {\n                            if (ignoreSelf) trace = trace._parent;\n                        }\n                        if (trace !== undefined) {\n                            trace.attachExtraTrace(error);\n                        } else if (!error.__stackCleaned__) {\n                            var parsed = parseStackAndMessage(error);\n                            util.notEnumerableProp(error, \"stack\", parsed.message + \"\\n\" + parsed.stack.join(\"\\n\"));\n                            util.notEnumerableProp(error, \"__stackCleaned__\", true);\n                        }\n                    }\n                }\n\n                function checkForgottenReturns(returnValue, promiseCreated, name, promise, parent) {\n                    if (returnValue === undefined && promiseCreated !== null && wForgottenReturn) {\n                        if (parent !== undefined && parent._returnedNonUndefined()) return;\n                        if ((promise._bitField & 65535) === 0) return;\n\n                        if (name) name = name + \" \";\n                        var handlerLine = \"\";\n                        var creatorLine = \"\";\n                        if (promiseCreated._trace) {\n                            var traceLines = promiseCreated._trace.stack.split(\"\\n\");\n                            var stack = cleanStack(traceLines);\n                            for (var i = stack.length - 1; i >= 0; --i) {\n                                var line = stack[i];\n                                if (!nodeFramePattern.test(line)) {\n                                    var lineMatches = line.match(parseLinePattern);\n                                    if (lineMatches) {\n                                        handlerLine = \"at \" + lineMatches[1] + \":\" + lineMatches[2] + \":\" + lineMatches[3] + \" \";\n                                    }\n                                    break;\n                                }\n                            }\n\n                            if (stack.length > 0) {\n                                var firstUserLine = stack[0];\n                                for (var i = 0; i < traceLines.length; ++i) {\n\n                                    if (traceLines[i] === firstUserLine) {\n                                        if (i > 0) {\n                                            creatorLine = \"\\n\" + traceLines[i - 1];\n                                        }\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                        var msg = \"a promise was created in a \" + name + \"handler \" + handlerLine + \"but was not returned from it, \" + \"see http://goo.gl/rRqMUw\" + creatorLine;\n                        promise._warn(msg, true, promiseCreated);\n                    }\n                }\n\n                function deprecated(name, replacement) {\n                    var message = name + \" is deprecated and will be removed in a future version.\";\n                    if (replacement) message += \" Use \" + replacement + \" instead.\";\n                    return warn(message);\n                }\n\n                function warn(message, shouldUseOwnTrace, promise) {\n                    if (!config.warnings) return;\n                    var warning = new Warning(message);\n                    var ctx;\n                    if (shouldUseOwnTrace) {\n                        promise._attachExtraTrace(warning);\n                    } else if (config.longStackTraces && (ctx = Promise._peekContext())) {\n                        ctx.attachExtraTrace(warning);\n                    } else {\n                        var parsed = parseStackAndMessage(warning);\n                        warning.stack = parsed.message + \"\\n\" + parsed.stack.join(\"\\n\");\n                    }\n\n                    if (!activeFireEvent(\"warning\", warning)) {\n                        formatAndLogError(warning, \"\", true);\n                    }\n                }\n\n                function reconstructStack(message, stacks) {\n                    for (var i = 0; i < stacks.length - 1; ++i) {\n                        stacks[i].push(\"From previous event:\");\n                        stacks[i] = stacks[i].join(\"\\n\");\n                    }\n                    if (i < stacks.length) {\n                        stacks[i] = stacks[i].join(\"\\n\");\n                    }\n                    return message + \"\\n\" + stacks.join(\"\\n\");\n                }\n\n                function removeDuplicateOrEmptyJumps(stacks) {\n                    for (var i = 0; i < stacks.length; ++i) {\n                        if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {\n                            stacks.splice(i, 1);\n                            i--;\n                        }\n                    }\n                }\n\n                function removeCommonRoots(stacks) {\n                    var current = stacks[0];\n                    for (var i = 1; i < stacks.length; ++i) {\n                        var prev = stacks[i];\n                        var currentLastIndex = current.length - 1;\n                        var currentLastLine = current[currentLastIndex];\n                        var commonRootMeetPoint = -1;\n\n                        for (var j = prev.length - 1; j >= 0; --j) {\n                            if (prev[j] === currentLastLine) {\n                                commonRootMeetPoint = j;\n                                break;\n                            }\n                        }\n\n                        for (var j = commonRootMeetPoint; j >= 0; --j) {\n                            var line = prev[j];\n                            if (current[currentLastIndex] === line) {\n                                current.pop();\n                                currentLastIndex--;\n                            } else {\n                                break;\n                            }\n                        }\n                        current = prev;\n                    }\n                }\n\n                function cleanStack(stack) {\n                    var ret = [];\n                    for (var i = 0; i < stack.length; ++i) {\n                        var line = stack[i];\n                        var isTraceLine = \"    (No stack trace)\" === line || stackFramePattern.test(line);\n                        var isInternalFrame = isTraceLine && shouldIgnore(line);\n                        if (isTraceLine && !isInternalFrame) {\n                            if (indentStackFrames && line.charAt(0) !== \" \") {\n                                line = \"    \" + line;\n                            }\n                            ret.push(line);\n                        }\n                    }\n                    return ret;\n                }\n\n                function stackFramesAsArray(error) {\n                    var stack = error.stack.replace(/\\s+$/g, \"\").split(\"\\n\");\n                    for (var i = 0; i < stack.length; ++i) {\n                        var line = stack[i];\n                        if (\"    (No stack trace)\" === line || stackFramePattern.test(line)) {\n                            break;\n                        }\n                    }\n                    if (i > 0 && error.name != \"SyntaxError\") {\n                        stack = stack.slice(i);\n                    }\n                    return stack;\n                }\n\n                function parseStackAndMessage(error) {\n                    var stack = error.stack;\n                    var message = error.toString();\n                    stack = typeof stack === \"string\" && stack.length > 0 ? stackFramesAsArray(error) : [\"    (No stack trace)\"];\n                    return {\n                        message: message,\n                        stack: error.name == \"SyntaxError\" ? stack : cleanStack(stack)\n                    };\n                }\n\n                function formatAndLogError(error, title, isSoft) {\n                    if (typeof console !== \"undefined\") {\n                        var message;\n                        if (util.isObject(error)) {\n                            var stack = error.stack;\n                            message = title + formatStack(stack, error);\n                        } else {\n                            message = title + String(error);\n                        }\n                        if (typeof printWarning === \"function\") {\n                            printWarning(message, isSoft);\n                        } else if (typeof console.log === \"function\" || _typeof(console.log) === \"object\") {\n                            console.log(message);\n                        }\n                    }\n                }\n\n                function fireRejectionEvent(name, localHandler, reason, promise) {\n                    var localEventFired = false;\n                    try {\n                        if (typeof localHandler === \"function\") {\n                            localEventFired = true;\n                            if (name === \"rejectionHandled\") {\n                                localHandler(promise);\n                            } else {\n                                localHandler(reason, promise);\n                            }\n                        }\n                    } catch (e) {\n                        async.throwLater(e);\n                    }\n\n                    if (name === \"unhandledRejection\") {\n                        if (!activeFireEvent(name, reason, promise) && !localEventFired) {\n                            formatAndLogError(reason, \"Unhandled rejection \");\n                        }\n                    } else {\n                        activeFireEvent(name, promise);\n                    }\n                }\n\n                function formatNonError(obj) {\n                    var str;\n                    if (typeof obj === \"function\") {\n                        str = \"[function \" + (obj.name || \"anonymous\") + \"]\";\n                    } else {\n                        str = obj && typeof obj.toString === \"function\" ? obj.toString() : util.toString(obj);\n                        var ruselessToString = /\\[object [a-zA-Z0-9$_]+\\]/;\n                        if (ruselessToString.test(str)) {\n                            try {\n                                var newStr = JSON.stringify(obj);\n                                str = newStr;\n                            } catch (e) {}\n                        }\n                        if (str.length === 0) {\n                            str = \"(empty array)\";\n                        }\n                    }\n                    return \"(<\" + snip(str) + \">, no stack trace)\";\n                }\n\n                function snip(str) {\n                    var maxChars = 41;\n                    if (str.length < maxChars) {\n                        return str;\n                    }\n                    return str.substr(0, maxChars - 3) + \"...\";\n                }\n\n                function longStackTracesIsSupported() {\n                    return typeof captureStackTrace === \"function\";\n                }\n\n                var shouldIgnore = function shouldIgnore() {\n                    return false;\n                };\n                var parseLineInfoRegex = /[\\/<\\(]([^:\\/]+):(\\d+):(?:\\d+)\\)?\\s*$/;\n                function parseLineInfo(line) {\n                    var matches = line.match(parseLineInfoRegex);\n                    if (matches) {\n                        return {\n                            fileName: matches[1],\n                            line: parseInt(matches[2], 10)\n                        };\n                    }\n                }\n\n                function setBounds(firstLineError, lastLineError) {\n                    if (!longStackTracesIsSupported()) return;\n                    var firstStackLines = firstLineError.stack.split(\"\\n\");\n                    var lastStackLines = lastLineError.stack.split(\"\\n\");\n                    var firstIndex = -1;\n                    var lastIndex = -1;\n                    var firstFileName;\n                    var lastFileName;\n                    for (var i = 0; i < firstStackLines.length; ++i) {\n                        var result = parseLineInfo(firstStackLines[i]);\n                        if (result) {\n                            firstFileName = result.fileName;\n                            firstIndex = result.line;\n                            break;\n                        }\n                    }\n                    for (var i = 0; i < lastStackLines.length; ++i) {\n                        var result = parseLineInfo(lastStackLines[i]);\n                        if (result) {\n                            lastFileName = result.fileName;\n                            lastIndex = result.line;\n                            break;\n                        }\n                    }\n                    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {\n                        return;\n                    }\n\n                    shouldIgnore = function shouldIgnore(line) {\n                        if (bluebirdFramePattern.test(line)) return true;\n                        var info = parseLineInfo(line);\n                        if (info) {\n                            if (info.fileName === firstFileName && firstIndex <= info.line && info.line <= lastIndex) {\n                                return true;\n                            }\n                        }\n                        return false;\n                    };\n                }\n\n                function CapturedTrace(parent) {\n                    this._parent = parent;\n                    this._promisesCreated = 0;\n                    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);\n                    captureStackTrace(this, CapturedTrace);\n                    if (length > 32) this.uncycle();\n                }\n                util.inherits(CapturedTrace, Error);\n                Context.CapturedTrace = CapturedTrace;\n\n                CapturedTrace.prototype.uncycle = function () {\n                    var length = this._length;\n                    if (length < 2) return;\n                    var nodes = [];\n                    var stackToIndex = {};\n\n                    for (var i = 0, node = this; node !== undefined; ++i) {\n                        nodes.push(node);\n                        node = node._parent;\n                    }\n                    length = this._length = i;\n                    for (var i = length - 1; i >= 0; --i) {\n                        var stack = nodes[i].stack;\n                        if (stackToIndex[stack] === undefined) {\n                            stackToIndex[stack] = i;\n                        }\n                    }\n                    for (var i = 0; i < length; ++i) {\n                        var currentStack = nodes[i].stack;\n                        var index = stackToIndex[currentStack];\n                        if (index !== undefined && index !== i) {\n                            if (index > 0) {\n                                nodes[index - 1]._parent = undefined;\n                                nodes[index - 1]._length = 1;\n                            }\n                            nodes[i]._parent = undefined;\n                            nodes[i]._length = 1;\n                            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;\n\n                            if (index < length - 1) {\n                                cycleEdgeNode._parent = nodes[index + 1];\n                                cycleEdgeNode._parent.uncycle();\n                                cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;\n                            } else {\n                                cycleEdgeNode._parent = undefined;\n                                cycleEdgeNode._length = 1;\n                            }\n                            var currentChildLength = cycleEdgeNode._length + 1;\n                            for (var j = i - 2; j >= 0; --j) {\n                                nodes[j]._length = currentChildLength;\n                                currentChildLength++;\n                            }\n                            return;\n                        }\n                    }\n                };\n\n                CapturedTrace.prototype.attachExtraTrace = function (error) {\n                    if (error.__stackCleaned__) return;\n                    this.uncycle();\n                    var parsed = parseStackAndMessage(error);\n                    var message = parsed.message;\n                    var stacks = [parsed.stack];\n\n                    var trace = this;\n                    while (trace !== undefined) {\n                        stacks.push(cleanStack(trace.stack.split(\"\\n\")));\n                        trace = trace._parent;\n                    }\n                    removeCommonRoots(stacks);\n                    removeDuplicateOrEmptyJumps(stacks);\n                    util.notEnumerableProp(error, \"stack\", reconstructStack(message, stacks));\n                    util.notEnumerableProp(error, \"__stackCleaned__\", true);\n                };\n\n                var captureStackTrace = function stackDetection() {\n                    var v8stackFramePattern = /^\\s*at\\s*/;\n                    var v8stackFormatter = function v8stackFormatter(stack, error) {\n                        if (typeof stack === \"string\") return stack;\n\n                        if (error.name !== undefined && error.message !== undefined) {\n                            return error.toString();\n                        }\n                        return formatNonError(error);\n                    };\n\n                    if (typeof Error.stackTraceLimit === \"number\" && typeof Error.captureStackTrace === \"function\") {\n                        Error.stackTraceLimit += 6;\n                        stackFramePattern = v8stackFramePattern;\n                        formatStack = v8stackFormatter;\n                        var captureStackTrace = Error.captureStackTrace;\n\n                        shouldIgnore = function shouldIgnore(line) {\n                            return bluebirdFramePattern.test(line);\n                        };\n                        return function (receiver, ignoreUntil) {\n                            Error.stackTraceLimit += 6;\n                            captureStackTrace(receiver, ignoreUntil);\n                            Error.stackTraceLimit -= 6;\n                        };\n                    }\n                    var err = new Error();\n\n                    if (typeof err.stack === \"string\" && err.stack.split(\"\\n\")[0].indexOf(\"stackDetection@\") >= 0) {\n                        stackFramePattern = /@/;\n                        formatStack = v8stackFormatter;\n                        indentStackFrames = true;\n                        return function captureStackTrace(o) {\n                            o.stack = new Error().stack;\n                        };\n                    }\n\n                    var hasStackAfterThrow;\n                    try {\n                        throw new Error();\n                    } catch (e) {\n                        hasStackAfterThrow = \"stack\" in e;\n                    }\n                    if (!(\"stack\" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === \"number\") {\n                        stackFramePattern = v8stackFramePattern;\n                        formatStack = v8stackFormatter;\n                        return function captureStackTrace(o) {\n                            Error.stackTraceLimit += 6;\n                            try {\n                                throw new Error();\n                            } catch (e) {\n                                o.stack = e.stack;\n                            }\n                            Error.stackTraceLimit -= 6;\n                        };\n                    }\n\n                    formatStack = function formatStack(stack, error) {\n                        if (typeof stack === \"string\") return stack;\n\n                        if (((typeof error === \"undefined\" ? \"undefined\" : _typeof(error)) === \"object\" || typeof error === \"function\") && error.name !== undefined && error.message !== undefined) {\n                            return error.toString();\n                        }\n                        return formatNonError(error);\n                    };\n\n                    return null;\n                }([]);\n\n                if (typeof console !== \"undefined\" && typeof console.warn !== \"undefined\") {\n                    printWarning = function printWarning(message) {\n                        console.warn(message);\n                    };\n                    if (util.isNode && process.stderr.isTTY) {\n                        printWarning = function printWarning(message, isSoft) {\n                            var color = isSoft ? \"\\x1B[33m\" : \"\\x1B[31m\";\n                            console.warn(color + message + \"\\x1B[0m\\n\");\n                        };\n                    } else if (!util.isNode && typeof new Error().stack === \"string\") {\n                        printWarning = function printWarning(message, isSoft) {\n                            console.warn(\"%c\" + message, isSoft ? \"color: darkorange\" : \"color: red\");\n                        };\n                    }\n                }\n\n                var config = {\n                    warnings: warnings,\n                    longStackTraces: false,\n                    cancellation: false,\n                    monitoring: false\n                };\n\n                if (longStackTraces) Promise.longStackTraces();\n\n                return {\n                    longStackTraces: function longStackTraces() {\n                        return config.longStackTraces;\n                    },\n                    warnings: function warnings() {\n                        return config.warnings;\n                    },\n                    cancellation: function cancellation() {\n                        return config.cancellation;\n                    },\n                    monitoring: function monitoring() {\n                        return config.monitoring;\n                    },\n                    propagateFromFunction: function propagateFromFunction() {\n                        return _propagateFromFunction;\n                    },\n                    boundValueFunction: function boundValueFunction() {\n                        return _boundValueFunction;\n                    },\n                    checkForgottenReturns: checkForgottenReturns,\n                    setBounds: setBounds,\n                    warn: warn,\n                    deprecated: deprecated,\n                    CapturedTrace: CapturedTrace,\n                    fireDomEvent: fireDomEvent,\n                    fireGlobalEvent: fireGlobalEvent\n                };\n            };\n        }, { \"./errors\": 12, \"./util\": 36 }], 10: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise) {\n                function returner() {\n                    return this.value;\n                }\n                function thrower() {\n                    throw this.reason;\n                }\n\n                Promise.prototype[\"return\"] = Promise.prototype.thenReturn = function (value) {\n                    if (value instanceof Promise) value.suppressUnhandledRejections();\n                    return this._then(returner, undefined, undefined, { value: value }, undefined);\n                };\n\n                Promise.prototype[\"throw\"] = Promise.prototype.thenThrow = function (reason) {\n                    return this._then(thrower, undefined, undefined, { reason: reason }, undefined);\n                };\n\n                Promise.prototype.catchThrow = function (reason) {\n                    if (arguments.length <= 1) {\n                        return this._then(undefined, thrower, undefined, { reason: reason }, undefined);\n                    } else {\n                        var _reason = arguments[1];\n                        var handler = function handler() {\n                            throw _reason;\n                        };\n                        return this.caught(reason, handler);\n                    }\n                };\n\n                Promise.prototype.catchReturn = function (value) {\n                    if (arguments.length <= 1) {\n                        if (value instanceof Promise) value.suppressUnhandledRejections();\n                        return this._then(undefined, returner, undefined, { value: value }, undefined);\n                    } else {\n                        var _value = arguments[1];\n                        if (_value instanceof Promise) _value.suppressUnhandledRejections();\n                        var handler = function handler() {\n                            return _value;\n                        };\n                        return this.caught(value, handler);\n                    }\n                };\n            };\n        }, {}], 11: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, INTERNAL) {\n                var PromiseReduce = Promise.reduce;\n                var PromiseAll = Promise.all;\n\n                function promiseAllThis() {\n                    return PromiseAll(this);\n                }\n\n                function PromiseMapSeries(promises, fn) {\n                    return PromiseReduce(promises, fn, INTERNAL, INTERNAL);\n                }\n\n                Promise.prototype.each = function (fn) {\n                    return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, undefined, undefined, this, undefined);\n                };\n\n                Promise.prototype.mapSeries = function (fn) {\n                    return PromiseReduce(this, fn, INTERNAL, INTERNAL);\n                };\n\n                Promise.each = function (promises, fn) {\n                    return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, undefined, undefined, promises, undefined);\n                };\n\n                Promise.mapSeries = PromiseMapSeries;\n            };\n        }, {}], 12: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            var es5 = _dereq_(\"./es5\");\n            var Objectfreeze = es5.freeze;\n            var util = _dereq_(\"./util\");\n            var inherits = util.inherits;\n            var notEnumerableProp = util.notEnumerableProp;\n\n            function subError(nameProperty, defaultMessage) {\n                function SubError(message) {\n                    if (!(this instanceof SubError)) return new SubError(message);\n                    notEnumerableProp(this, \"message\", typeof message === \"string\" ? message : defaultMessage);\n                    notEnumerableProp(this, \"name\", nameProperty);\n                    if (Error.captureStackTrace) {\n                        Error.captureStackTrace(this, this.constructor);\n                    } else {\n                        Error.call(this);\n                    }\n                }\n                inherits(SubError, Error);\n                return SubError;\n            }\n\n            var _TypeError, _RangeError;\n            var Warning = subError(\"Warning\", \"warning\");\n            var CancellationError = subError(\"CancellationError\", \"cancellation error\");\n            var TimeoutError = subError(\"TimeoutError\", \"timeout error\");\n            var AggregateError = subError(\"AggregateError\", \"aggregate error\");\n            try {\n                _TypeError = TypeError;\n                _RangeError = RangeError;\n            } catch (e) {\n                _TypeError = subError(\"TypeError\", \"type error\");\n                _RangeError = subError(\"RangeError\", \"range error\");\n            }\n\n            var methods = (\"join pop push shift unshift slice filter forEach some \" + \"every map indexOf lastIndexOf reduce reduceRight sort reverse\").split(\" \");\n\n            for (var i = 0; i < methods.length; ++i) {\n                if (typeof Array.prototype[methods[i]] === \"function\") {\n                    AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];\n                }\n            }\n\n            es5.defineProperty(AggregateError.prototype, \"length\", {\n                value: 0,\n                configurable: false,\n                writable: true,\n                enumerable: true\n            });\n            AggregateError.prototype[\"isOperational\"] = true;\n            var level = 0;\n            AggregateError.prototype.toString = function () {\n                var indent = Array(level * 4 + 1).join(\" \");\n                var ret = \"\\n\" + indent + \"AggregateError of:\" + \"\\n\";\n                level++;\n                indent = Array(level * 4 + 1).join(\" \");\n                for (var i = 0; i < this.length; ++i) {\n                    var str = this[i] === this ? \"[Circular AggregateError]\" : this[i] + \"\";\n                    var lines = str.split(\"\\n\");\n                    for (var j = 0; j < lines.length; ++j) {\n                        lines[j] = indent + lines[j];\n                    }\n                    str = lines.join(\"\\n\");\n                    ret += str + \"\\n\";\n                }\n                level--;\n                return ret;\n            };\n\n            function OperationalError(message) {\n                if (!(this instanceof OperationalError)) return new OperationalError(message);\n                notEnumerableProp(this, \"name\", \"OperationalError\");\n                notEnumerableProp(this, \"message\", message);\n                this.cause = message;\n                this[\"isOperational\"] = true;\n\n                if (message instanceof Error) {\n                    notEnumerableProp(this, \"message\", message.message);\n                    notEnumerableProp(this, \"stack\", message.stack);\n                } else if (Error.captureStackTrace) {\n                    Error.captureStackTrace(this, this.constructor);\n                }\n            }\n            inherits(OperationalError, Error);\n\n            var errorTypes = Error[\"__BluebirdErrorTypes__\"];\n            if (!errorTypes) {\n                errorTypes = Objectfreeze({\n                    CancellationError: CancellationError,\n                    TimeoutError: TimeoutError,\n                    OperationalError: OperationalError,\n                    RejectionError: OperationalError,\n                    AggregateError: AggregateError\n                });\n                es5.defineProperty(Error, \"__BluebirdErrorTypes__\", {\n                    value: errorTypes,\n                    writable: false,\n                    enumerable: false,\n                    configurable: false\n                });\n            }\n\n            module.exports = {\n                Error: Error,\n                TypeError: _TypeError,\n                RangeError: _RangeError,\n                CancellationError: errorTypes.CancellationError,\n                OperationalError: errorTypes.OperationalError,\n                TimeoutError: errorTypes.TimeoutError,\n                AggregateError: errorTypes.AggregateError,\n                Warning: Warning\n            };\n        }, { \"./es5\": 13, \"./util\": 36 }], 13: [function (_dereq_, module, exports) {\n            var isES5 = function () {\n                \"use strict\";\n\n                return this === undefined;\n            }();\n\n            if (isES5) {\n                module.exports = {\n                    freeze: Object.freeze,\n                    defineProperty: Object.defineProperty,\n                    getDescriptor: Object.getOwnPropertyDescriptor,\n                    keys: Object.keys,\n                    names: Object.getOwnPropertyNames,\n                    getPrototypeOf: Object.getPrototypeOf,\n                    isArray: Array.isArray,\n                    isES5: isES5,\n                    propertyIsWritable: function propertyIsWritable(obj, prop) {\n                        var descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n                        return !!(!descriptor || descriptor.writable || descriptor.set);\n                    }\n                };\n            } else {\n                var has = {}.hasOwnProperty;\n                var str = {}.toString;\n                var proto = {}.constructor.prototype;\n\n                var ObjectKeys = function ObjectKeys(o) {\n                    var ret = [];\n                    for (var key in o) {\n                        if (has.call(o, key)) {\n                            ret.push(key);\n                        }\n                    }\n                    return ret;\n                };\n\n                var ObjectGetDescriptor = function ObjectGetDescriptor(o, key) {\n                    return { value: o[key] };\n                };\n\n                var ObjectDefineProperty = function ObjectDefineProperty(o, key, desc) {\n                    o[key] = desc.value;\n                    return o;\n                };\n\n                var ObjectFreeze = function ObjectFreeze(obj) {\n                    return obj;\n                };\n\n                var ObjectGetPrototypeOf = function ObjectGetPrototypeOf(obj) {\n                    try {\n                        return Object(obj).constructor.prototype;\n                    } catch (e) {\n                        return proto;\n                    }\n                };\n\n                var ArrayIsArray = function ArrayIsArray(obj) {\n                    try {\n                        return str.call(obj) === \"[object Array]\";\n                    } catch (e) {\n                        return false;\n                    }\n                };\n\n                module.exports = {\n                    isArray: ArrayIsArray,\n                    keys: ObjectKeys,\n                    names: ObjectKeys,\n                    defineProperty: ObjectDefineProperty,\n                    getDescriptor: ObjectGetDescriptor,\n                    freeze: ObjectFreeze,\n                    getPrototypeOf: ObjectGetPrototypeOf,\n                    isES5: isES5,\n                    propertyIsWritable: function propertyIsWritable() {\n                        return true;\n                    }\n                };\n            }\n        }, {}], 14: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, INTERNAL) {\n                var PromiseMap = Promise.map;\n\n                Promise.prototype.filter = function (fn, options) {\n                    return PromiseMap(this, fn, options, INTERNAL);\n                };\n\n                Promise.filter = function (promises, fn, options) {\n                    return PromiseMap(promises, fn, options, INTERNAL);\n                };\n            };\n        }, {}], 15: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, tryConvertToPromise, NEXT_FILTER) {\n                var util = _dereq_(\"./util\");\n                var CancellationError = Promise.CancellationError;\n                var errorObj = util.errorObj;\n                var catchFilter = _dereq_(\"./catch_filter\")(NEXT_FILTER);\n\n                function PassThroughHandlerContext(promise, type, handler) {\n                    this.promise = promise;\n                    this.type = type;\n                    this.handler = handler;\n                    this.called = false;\n                    this.cancelPromise = null;\n                }\n\n                PassThroughHandlerContext.prototype.isFinallyHandler = function () {\n                    return this.type === 0;\n                };\n\n                function FinallyHandlerCancelReaction(finallyHandler) {\n                    this.finallyHandler = finallyHandler;\n                }\n\n                FinallyHandlerCancelReaction.prototype._resultCancelled = function () {\n                    checkCancel(this.finallyHandler);\n                };\n\n                function checkCancel(ctx, reason) {\n                    if (ctx.cancelPromise != null) {\n                        if (arguments.length > 1) {\n                            ctx.cancelPromise._reject(reason);\n                        } else {\n                            ctx.cancelPromise._cancel();\n                        }\n                        ctx.cancelPromise = null;\n                        return true;\n                    }\n                    return false;\n                }\n\n                function succeed() {\n                    return finallyHandler.call(this, this.promise._target()._settledValue());\n                }\n                function fail(reason) {\n                    if (checkCancel(this, reason)) return;\n                    errorObj.e = reason;\n                    return errorObj;\n                }\n                function finallyHandler(reasonOrValue) {\n                    var promise = this.promise;\n                    var handler = this.handler;\n\n                    if (!this.called) {\n                        this.called = true;\n                        var ret = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);\n                        if (ret === NEXT_FILTER) {\n                            return ret;\n                        } else if (ret !== undefined) {\n                            promise._setReturnedNonUndefined();\n                            var maybePromise = tryConvertToPromise(ret, promise);\n                            if (maybePromise instanceof Promise) {\n                                if (this.cancelPromise != null) {\n                                    if (maybePromise._isCancelled()) {\n                                        var reason = new CancellationError(\"late cancellation observer\");\n                                        promise._attachExtraTrace(reason);\n                                        errorObj.e = reason;\n                                        return errorObj;\n                                    } else if (maybePromise.isPending()) {\n                                        maybePromise._attachCancellationCallback(new FinallyHandlerCancelReaction(this));\n                                    }\n                                }\n                                return maybePromise._then(succeed, fail, undefined, this, undefined);\n                            }\n                        }\n                    }\n\n                    if (promise.isRejected()) {\n                        checkCancel(this);\n                        errorObj.e = reasonOrValue;\n                        return errorObj;\n                    } else {\n                        checkCancel(this);\n                        return reasonOrValue;\n                    }\n                }\n\n                Promise.prototype._passThrough = function (handler, type, success, fail) {\n                    if (typeof handler !== \"function\") return this.then();\n                    return this._then(success, fail, undefined, new PassThroughHandlerContext(this, type, handler), undefined);\n                };\n\n                Promise.prototype.lastly = Promise.prototype[\"finally\"] = function (handler) {\n                    return this._passThrough(handler, 0, finallyHandler, finallyHandler);\n                };\n\n                Promise.prototype.tap = function (handler) {\n                    return this._passThrough(handler, 1, finallyHandler);\n                };\n\n                Promise.prototype.tapCatch = function (handlerOrPredicate) {\n                    var len = arguments.length;\n                    if (len === 1) {\n                        return this._passThrough(handlerOrPredicate, 1, undefined, finallyHandler);\n                    } else {\n                        var catchInstances = new Array(len - 1),\n                            j = 0,\n                            i;\n                        for (i = 0; i < len - 1; ++i) {\n                            var item = arguments[i];\n                            if (util.isObject(item)) {\n                                catchInstances[j++] = item;\n                            } else {\n                                return Promise.reject(new TypeError(\"tapCatch statement predicate: \" + \"expecting an object but got \" + util.classString(item)));\n                            }\n                        }\n                        catchInstances.length = j;\n                        var handler = arguments[i];\n                        return this._passThrough(catchFilter(catchInstances, handler, this), 1, undefined, finallyHandler);\n                    }\n                };\n\n                return PassThroughHandlerContext;\n            };\n        }, { \"./catch_filter\": 7, \"./util\": 36 }], 16: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {\n                var errors = _dereq_(\"./errors\");\n                var TypeError = errors.TypeError;\n                var util = _dereq_(\"./util\");\n                var errorObj = util.errorObj;\n                var tryCatch = util.tryCatch;\n                var yieldHandlers = [];\n\n                function promiseFromYieldHandler(value, yieldHandlers, traceParent) {\n                    for (var i = 0; i < yieldHandlers.length; ++i) {\n                        traceParent._pushContext();\n                        var result = tryCatch(yieldHandlers[i])(value);\n                        traceParent._popContext();\n                        if (result === errorObj) {\n                            traceParent._pushContext();\n                            var ret = Promise.reject(errorObj.e);\n                            traceParent._popContext();\n                            return ret;\n                        }\n                        var maybePromise = tryConvertToPromise(result, traceParent);\n                        if (maybePromise instanceof Promise) return maybePromise;\n                    }\n                    return null;\n                }\n\n                function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {\n                    if (debug.cancellation()) {\n                        var internal = new Promise(INTERNAL);\n                        var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);\n                        this._promise = internal.lastly(function () {\n                            return _finallyPromise;\n                        });\n                        internal._captureStackTrace();\n                        internal._setOnCancel(this);\n                    } else {\n                        var promise = this._promise = new Promise(INTERNAL);\n                        promise._captureStackTrace();\n                    }\n                    this._stack = stack;\n                    this._generatorFunction = generatorFunction;\n                    this._receiver = receiver;\n                    this._generator = undefined;\n                    this._yieldHandlers = typeof yieldHandler === \"function\" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;\n                    this._yieldedPromise = null;\n                    this._cancellationPhase = false;\n                }\n                util.inherits(PromiseSpawn, Proxyable);\n\n                PromiseSpawn.prototype._isResolved = function () {\n                    return this._promise === null;\n                };\n\n                PromiseSpawn.prototype._cleanup = function () {\n                    this._promise = this._generator = null;\n                    if (debug.cancellation() && this._finallyPromise !== null) {\n                        this._finallyPromise._fulfill();\n                        this._finallyPromise = null;\n                    }\n                };\n\n                PromiseSpawn.prototype._promiseCancelled = function () {\n                    if (this._isResolved()) return;\n                    var implementsReturn = typeof this._generator[\"return\"] !== \"undefined\";\n\n                    var result;\n                    if (!implementsReturn) {\n                        var reason = new Promise.CancellationError(\"generator .return() sentinel\");\n                        Promise.coroutine.returnSentinel = reason;\n                        this._promise._attachExtraTrace(reason);\n                        this._promise._pushContext();\n                        result = tryCatch(this._generator[\"throw\"]).call(this._generator, reason);\n                        this._promise._popContext();\n                    } else {\n                        this._promise._pushContext();\n                        result = tryCatch(this._generator[\"return\"]).call(this._generator, undefined);\n                        this._promise._popContext();\n                    }\n                    this._cancellationPhase = true;\n                    this._yieldedPromise = null;\n                    this._continue(result);\n                };\n\n                PromiseSpawn.prototype._promiseFulfilled = function (value) {\n                    this._yieldedPromise = null;\n                    this._promise._pushContext();\n                    var result = tryCatch(this._generator.next).call(this._generator, value);\n                    this._promise._popContext();\n                    this._continue(result);\n                };\n\n                PromiseSpawn.prototype._promiseRejected = function (reason) {\n                    this._yieldedPromise = null;\n                    this._promise._attachExtraTrace(reason);\n                    this._promise._pushContext();\n                    var result = tryCatch(this._generator[\"throw\"]).call(this._generator, reason);\n                    this._promise._popContext();\n                    this._continue(result);\n                };\n\n                PromiseSpawn.prototype._resultCancelled = function () {\n                    if (this._yieldedPromise instanceof Promise) {\n                        var promise = this._yieldedPromise;\n                        this._yieldedPromise = null;\n                        promise.cancel();\n                    }\n                };\n\n                PromiseSpawn.prototype.promise = function () {\n                    return this._promise;\n                };\n\n                PromiseSpawn.prototype._run = function () {\n                    this._generator = this._generatorFunction.call(this._receiver);\n                    this._receiver = this._generatorFunction = undefined;\n                    this._promiseFulfilled(undefined);\n                };\n\n                PromiseSpawn.prototype._continue = function (result) {\n                    var promise = this._promise;\n                    if (result === errorObj) {\n                        this._cleanup();\n                        if (this._cancellationPhase) {\n                            return promise.cancel();\n                        } else {\n                            return promise._rejectCallback(result.e, false);\n                        }\n                    }\n\n                    var value = result.value;\n                    if (result.done === true) {\n                        this._cleanup();\n                        if (this._cancellationPhase) {\n                            return promise.cancel();\n                        } else {\n                            return promise._resolveCallback(value);\n                        }\n                    } else {\n                        var maybePromise = tryConvertToPromise(value, this._promise);\n                        if (!(maybePromise instanceof Promise)) {\n                            maybePromise = promiseFromYieldHandler(maybePromise, this._yieldHandlers, this._promise);\n                            if (maybePromise === null) {\n                                this._promiseRejected(new TypeError(\"A value %s was yielded that could not be treated as a promise\\n\\n    See http://goo.gl/MqrFmX\\n\\n\".replace(\"%s\", String(value)) + \"From coroutine:\\n\" + this._stack.split(\"\\n\").slice(1, -7).join(\"\\n\")));\n                                return;\n                            }\n                        }\n                        maybePromise = maybePromise._target();\n                        var bitField = maybePromise._bitField;\n                        ;\n                        if ((bitField & 50397184) === 0) {\n                            this._yieldedPromise = maybePromise;\n                            maybePromise._proxy(this, null);\n                        } else if ((bitField & 33554432) !== 0) {\n                            Promise._async.invoke(this._promiseFulfilled, this, maybePromise._value());\n                        } else if ((bitField & 16777216) !== 0) {\n                            Promise._async.invoke(this._promiseRejected, this, maybePromise._reason());\n                        } else {\n                            this._promiseCancelled();\n                        }\n                    }\n                };\n\n                Promise.coroutine = function (generatorFunction, options) {\n                    if (typeof generatorFunction !== \"function\") {\n                        throw new TypeError(\"generatorFunction must be a function\\n\\n    See http://goo.gl/MqrFmX\\n\");\n                    }\n                    var yieldHandler = Object(options).yieldHandler;\n                    var PromiseSpawn$ = PromiseSpawn;\n                    var stack = new Error().stack;\n                    return function () {\n                        var generator = generatorFunction.apply(this, arguments);\n                        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler, stack);\n                        var ret = spawn.promise();\n                        spawn._generator = generator;\n                        spawn._promiseFulfilled(undefined);\n                        return ret;\n                    };\n                };\n\n                Promise.coroutine.addYieldHandler = function (fn) {\n                    if (typeof fn !== \"function\") {\n                        throw new TypeError(\"expecting a function but got \" + util.classString(fn));\n                    }\n                    yieldHandlers.push(fn);\n                };\n\n                Promise.spawn = function (generatorFunction) {\n                    debug.deprecated(\"Promise.spawn()\", \"Promise.coroutine()\");\n                    if (typeof generatorFunction !== \"function\") {\n                        return apiRejection(\"generatorFunction must be a function\\n\\n    See http://goo.gl/MqrFmX\\n\");\n                    }\n                    var spawn = new PromiseSpawn(generatorFunction, this);\n                    var ret = spawn.promise();\n                    spawn._run(Promise.spawn);\n                    return ret;\n                };\n            };\n        }, { \"./errors\": 12, \"./util\": 36 }], 17: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain) {\n                var util = _dereq_(\"./util\");\n                var canEvaluate = util.canEvaluate;\n                var tryCatch = util.tryCatch;\n                var errorObj = util.errorObj;\n                var reject;\n\n                if (false) {\n                    if (canEvaluate) {\n                        var thenCallback = function thenCallback(i) {\n                            return new Function(\"value\", \"holder\", \"                             \\n\\\n            'use strict';                                                    \\n\\\n            holder.pIndex = value;                                           \\n\\\n            holder.checkFulfillment(this);                                   \\n\\\n            \".replace(/Index/g, i));\n                        };\n\n                        var promiseSetter = function promiseSetter(i) {\n                            return new Function(\"promise\", \"holder\", \"                           \\n\\\n            'use strict';                                                    \\n\\\n            holder.pIndex = promise;                                         \\n\\\n            \".replace(/Index/g, i));\n                        };\n\n                        var generateHolderClass = function generateHolderClass(total) {\n                            var props = new Array(total);\n                            for (var i = 0; i < props.length; ++i) {\n                                props[i] = \"this.p\" + (i + 1);\n                            }\n                            var assignment = props.join(\" = \") + \" = null;\";\n                            var cancellationCode = \"var promise;\\n\" + props.map(function (prop) {\n                                return \"                                                         \\n\\\n                promise = \" + prop + \";                                      \\n\\\n                if (promise instanceof Promise) {                            \\n\\\n                    promise.cancel();                                        \\n\\\n                }                                                            \\n\\\n            \";\n                            }).join(\"\\n\");\n                            var passedArguments = props.join(\", \");\n                            var name = \"Holder$\" + total;\n\n                            var code = \"return function(tryCatch, errorObj, Promise, async) {    \\n\\\n            'use strict';                                                    \\n\\\n            function [TheName](fn) {                                         \\n\\\n                [TheProperties]                                              \\n\\\n                this.fn = fn;                                                \\n\\\n                this.asyncNeeded = true;                                     \\n\\\n                this.now = 0;                                                \\n\\\n            }                                                                \\n\\\n                                                                             \\n\\\n            [TheName].prototype._callFunction = function(promise) {          \\n\\\n                promise._pushContext();                                      \\n\\\n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \\n\\\n                promise._popContext();                                       \\n\\\n                if (ret === errorObj) {                                      \\n\\\n                    promise._rejectCallback(ret.e, false);                   \\n\\\n                } else {                                                     \\n\\\n                    promise._resolveCallback(ret);                           \\n\\\n                }                                                            \\n\\\n            };                                                               \\n\\\n                                                                             \\n\\\n            [TheName].prototype.checkFulfillment = function(promise) {       \\n\\\n                var now = ++this.now;                                        \\n\\\n                if (now === [TheTotal]) {                                    \\n\\\n                    if (this.asyncNeeded) {                                  \\n\\\n                        async.invoke(this._callFunction, this, promise);     \\n\\\n                    } else {                                                 \\n\\\n                        this._callFunction(promise);                         \\n\\\n                    }                                                        \\n\\\n                                                                             \\n\\\n                }                                                            \\n\\\n            };                                                               \\n\\\n                                                                             \\n\\\n            [TheName].prototype._resultCancelled = function() {              \\n\\\n                [CancellationCode]                                           \\n\\\n            };                                                               \\n\\\n                                                                             \\n\\\n            return [TheName];                                                \\n\\\n        }(tryCatch, errorObj, Promise, async);                               \\n\\\n        \";\n\n                            code = code.replace(/\\[TheName\\]/g, name).replace(/\\[TheTotal\\]/g, total).replace(/\\[ThePassedArguments\\]/g, passedArguments).replace(/\\[TheProperties\\]/g, assignment).replace(/\\[CancellationCode\\]/g, cancellationCode);\n\n                            return new Function(\"tryCatch\", \"errorObj\", \"Promise\", \"async\", code)(tryCatch, errorObj, Promise, async);\n                        };\n\n                        var holderClasses = [];\n                        var thenCallbacks = [];\n                        var promiseSetters = [];\n\n                        for (var i = 0; i < 8; ++i) {\n                            holderClasses.push(generateHolderClass(i + 1));\n                            thenCallbacks.push(thenCallback(i + 1));\n                            promiseSetters.push(promiseSetter(i + 1));\n                        }\n\n                        reject = function reject(reason) {\n                            this._reject(reason);\n                        };\n                    }\n                }\n\n                Promise.join = function () {\n                    var last = arguments.length - 1;\n                    var fn;\n                    if (last > 0 && typeof arguments[last] === \"function\") {\n                        fn = arguments[last];\n                        if (false) {\n                            if (last <= 8 && canEvaluate) {\n                                var ret = new Promise(INTERNAL);\n                                ret._captureStackTrace();\n                                var HolderClass = holderClasses[last - 1];\n                                var holder = new HolderClass(fn);\n                                var callbacks = thenCallbacks;\n\n                                for (var i = 0; i < last; ++i) {\n                                    var maybePromise = tryConvertToPromise(arguments[i], ret);\n                                    if (maybePromise instanceof Promise) {\n                                        maybePromise = maybePromise._target();\n                                        var bitField = maybePromise._bitField;\n                                        ;\n                                        if ((bitField & 50397184) === 0) {\n                                            maybePromise._then(callbacks[i], reject, undefined, ret, holder);\n                                            promiseSetters[i](maybePromise, holder);\n                                            holder.asyncNeeded = false;\n                                        } else if ((bitField & 33554432) !== 0) {\n                                            callbacks[i].call(ret, maybePromise._value(), holder);\n                                        } else if ((bitField & 16777216) !== 0) {\n                                            ret._reject(maybePromise._reason());\n                                        } else {\n                                            ret._cancel();\n                                        }\n                                    } else {\n                                        callbacks[i].call(ret, maybePromise, holder);\n                                    }\n                                }\n\n                                if (!ret._isFateSealed()) {\n                                    if (holder.asyncNeeded) {\n                                        var domain = getDomain();\n                                        if (domain !== null) {\n                                            holder.fn = util.domainBind(domain, holder.fn);\n                                        }\n                                    }\n                                    ret._setAsyncGuaranteed();\n                                    ret._setOnCancel(holder);\n                                }\n                                return ret;\n                            }\n                        }\n                    }\n                    var args = [].slice.call(arguments);;\n                    if (fn) args.pop();\n                    var ret = new PromiseArray(args).promise();\n                    return fn !== undefined ? ret.spread(fn) : ret;\n                };\n            };\n        }, { \"./util\": 36 }], 18: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {\n                var getDomain = Promise._getDomain;\n                var util = _dereq_(\"./util\");\n                var tryCatch = util.tryCatch;\n                var errorObj = util.errorObj;\n                var async = Promise._async;\n\n                function MappingPromiseArray(promises, fn, limit, _filter) {\n                    this.constructor$(promises);\n                    this._promise._captureStackTrace();\n                    var domain = getDomain();\n                    this._callback = domain === null ? fn : util.domainBind(domain, fn);\n                    this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;\n                    this._limit = limit;\n                    this._inFlight = 0;\n                    this._queue = [];\n                    async.invoke(this._asyncInit, this, undefined);\n                }\n                util.inherits(MappingPromiseArray, PromiseArray);\n\n                MappingPromiseArray.prototype._asyncInit = function () {\n                    this._init$(undefined, -2);\n                };\n\n                MappingPromiseArray.prototype._init = function () {};\n\n                MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {\n                    var values = this._values;\n                    var length = this.length();\n                    var preservedValues = this._preservedValues;\n                    var limit = this._limit;\n\n                    if (index < 0) {\n                        index = index * -1 - 1;\n                        values[index] = value;\n                        if (limit >= 1) {\n                            this._inFlight--;\n                            this._drainQueue();\n                            if (this._isResolved()) return true;\n                        }\n                    } else {\n                        if (limit >= 1 && this._inFlight >= limit) {\n                            values[index] = value;\n                            this._queue.push(index);\n                            return false;\n                        }\n                        if (preservedValues !== null) preservedValues[index] = value;\n\n                        var promise = this._promise;\n                        var callback = this._callback;\n                        var receiver = promise._boundValue();\n                        promise._pushContext();\n                        var ret = tryCatch(callback).call(receiver, value, index, length);\n                        var promiseCreated = promise._popContext();\n                        debug.checkForgottenReturns(ret, promiseCreated, preservedValues !== null ? \"Promise.filter\" : \"Promise.map\", promise);\n                        if (ret === errorObj) {\n                            this._reject(ret.e);\n                            return true;\n                        }\n\n                        var maybePromise = tryConvertToPromise(ret, this._promise);\n                        if (maybePromise instanceof Promise) {\n                            maybePromise = maybePromise._target();\n                            var bitField = maybePromise._bitField;\n                            ;\n                            if ((bitField & 50397184) === 0) {\n                                if (limit >= 1) this._inFlight++;\n                                values[index] = maybePromise;\n                                maybePromise._proxy(this, (index + 1) * -1);\n                                return false;\n                            } else if ((bitField & 33554432) !== 0) {\n                                ret = maybePromise._value();\n                            } else if ((bitField & 16777216) !== 0) {\n                                this._reject(maybePromise._reason());\n                                return true;\n                            } else {\n                                this._cancel();\n                                return true;\n                            }\n                        }\n                        values[index] = ret;\n                    }\n                    var totalResolved = ++this._totalResolved;\n                    if (totalResolved >= length) {\n                        if (preservedValues !== null) {\n                            this._filter(values, preservedValues);\n                        } else {\n                            this._resolve(values);\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n\n                MappingPromiseArray.prototype._drainQueue = function () {\n                    var queue = this._queue;\n                    var limit = this._limit;\n                    var values = this._values;\n                    while (queue.length > 0 && this._inFlight < limit) {\n                        if (this._isResolved()) return;\n                        var index = queue.pop();\n                        this._promiseFulfilled(values[index], index);\n                    }\n                };\n\n                MappingPromiseArray.prototype._filter = function (booleans, values) {\n                    var len = values.length;\n                    var ret = new Array(len);\n                    var j = 0;\n                    for (var i = 0; i < len; ++i) {\n                        if (booleans[i]) ret[j++] = values[i];\n                    }\n                    ret.length = j;\n                    this._resolve(ret);\n                };\n\n                MappingPromiseArray.prototype.preservedValues = function () {\n                    return this._preservedValues;\n                };\n\n                function map(promises, fn, options, _filter) {\n                    if (typeof fn !== \"function\") {\n                        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n                    }\n\n                    var limit = 0;\n                    if (options !== undefined) {\n                        if ((typeof options === \"undefined\" ? \"undefined\" : _typeof(options)) === \"object\" && options !== null) {\n                            if (typeof options.concurrency !== \"number\") {\n                                return Promise.reject(new TypeError(\"'concurrency' must be a number but it is \" + util.classString(options.concurrency)));\n                            }\n                            limit = options.concurrency;\n                        } else {\n                            return Promise.reject(new TypeError(\"options argument must be an object but it is \" + util.classString(options)));\n                        }\n                    }\n                    limit = typeof limit === \"number\" && isFinite(limit) && limit >= 1 ? limit : 0;\n                    return new MappingPromiseArray(promises, fn, limit, _filter).promise();\n                }\n\n                Promise.prototype.map = function (fn, options) {\n                    return map(this, fn, options, null);\n                };\n\n                Promise.map = function (promises, fn, options, _filter) {\n                    return map(promises, fn, options, _filter);\n                };\n            };\n        }, { \"./util\": 36 }], 19: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {\n                var util = _dereq_(\"./util\");\n                var tryCatch = util.tryCatch;\n\n                Promise.method = function (fn) {\n                    if (typeof fn !== \"function\") {\n                        throw new Promise.TypeError(\"expecting a function but got \" + util.classString(fn));\n                    }\n                    return function () {\n                        var ret = new Promise(INTERNAL);\n                        ret._captureStackTrace();\n                        ret._pushContext();\n                        var value = tryCatch(fn).apply(this, arguments);\n                        var promiseCreated = ret._popContext();\n                        debug.checkForgottenReturns(value, promiseCreated, \"Promise.method\", ret);\n                        ret._resolveFromSyncValue(value);\n                        return ret;\n                    };\n                };\n\n                Promise.attempt = Promise[\"try\"] = function (fn) {\n                    if (typeof fn !== \"function\") {\n                        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n                    }\n                    var ret = new Promise(INTERNAL);\n                    ret._captureStackTrace();\n                    ret._pushContext();\n                    var value;\n                    if (arguments.length > 1) {\n                        debug.deprecated(\"calling Promise.try with more than 1 argument\");\n                        var arg = arguments[1];\n                        var ctx = arguments[2];\n                        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg) : tryCatch(fn).call(ctx, arg);\n                    } else {\n                        value = tryCatch(fn)();\n                    }\n                    var promiseCreated = ret._popContext();\n                    debug.checkForgottenReturns(value, promiseCreated, \"Promise.try\", ret);\n                    ret._resolveFromSyncValue(value);\n                    return ret;\n                };\n\n                Promise.prototype._resolveFromSyncValue = function (value) {\n                    if (value === util.errorObj) {\n                        this._rejectCallback(value.e, false);\n                    } else {\n                        this._resolveCallback(value, true);\n                    }\n                };\n            };\n        }, { \"./util\": 36 }], 20: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            var util = _dereq_(\"./util\");\n            var maybeWrapAsError = util.maybeWrapAsError;\n            var errors = _dereq_(\"./errors\");\n            var OperationalError = errors.OperationalError;\n            var es5 = _dereq_(\"./es5\");\n\n            function isUntypedError(obj) {\n                return obj instanceof Error && es5.getPrototypeOf(obj) === Error.prototype;\n            }\n\n            var rErrorKey = /^(?:name|message|stack|cause)$/;\n            function wrapAsOperationalError(obj) {\n                var ret;\n                if (isUntypedError(obj)) {\n                    ret = new OperationalError(obj);\n                    ret.name = obj.name;\n                    ret.message = obj.message;\n                    ret.stack = obj.stack;\n                    var keys = es5.keys(obj);\n                    for (var i = 0; i < keys.length; ++i) {\n                        var key = keys[i];\n                        if (!rErrorKey.test(key)) {\n                            ret[key] = obj[key];\n                        }\n                    }\n                    return ret;\n                }\n                util.markAsOriginatingFromRejection(obj);\n                return obj;\n            }\n\n            function nodebackForPromise(promise, multiArgs) {\n                return function (err, value) {\n                    if (promise === null) return;\n                    if (err) {\n                        var wrapped = wrapAsOperationalError(maybeWrapAsError(err));\n                        promise._attachExtraTrace(wrapped);\n                        promise._reject(wrapped);\n                    } else if (!multiArgs) {\n                        promise._fulfill(value);\n                    } else {\n                        var args = [].slice.call(arguments, 1);;\n                        promise._fulfill(args);\n                    }\n                    promise = null;\n                };\n            }\n\n            module.exports = nodebackForPromise;\n        }, { \"./errors\": 12, \"./es5\": 13, \"./util\": 36 }], 21: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise) {\n                var util = _dereq_(\"./util\");\n                var async = Promise._async;\n                var tryCatch = util.tryCatch;\n                var errorObj = util.errorObj;\n\n                function spreadAdapter(val, nodeback) {\n                    var promise = this;\n                    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);\n                    var ret = tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));\n                    if (ret === errorObj) {\n                        async.throwLater(ret.e);\n                    }\n                }\n\n                function successAdapter(val, nodeback) {\n                    var promise = this;\n                    var receiver = promise._boundValue();\n                    var ret = val === undefined ? tryCatch(nodeback).call(receiver, null) : tryCatch(nodeback).call(receiver, null, val);\n                    if (ret === errorObj) {\n                        async.throwLater(ret.e);\n                    }\n                }\n                function errorAdapter(reason, nodeback) {\n                    var promise = this;\n                    if (!reason) {\n                        var newReason = new Error(reason + \"\");\n                        newReason.cause = reason;\n                        reason = newReason;\n                    }\n                    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);\n                    if (ret === errorObj) {\n                        async.throwLater(ret.e);\n                    }\n                }\n\n                Promise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback, options) {\n                    if (typeof nodeback == \"function\") {\n                        var adapter = successAdapter;\n                        if (options !== undefined && Object(options).spread) {\n                            adapter = spreadAdapter;\n                        }\n                        this._then(adapter, errorAdapter, undefined, this, nodeback);\n                    }\n                    return this;\n                };\n            };\n        }, { \"./util\": 36 }], 22: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function () {\n                var makeSelfResolutionError = function makeSelfResolutionError() {\n                    return new TypeError(\"circular promise resolution chain\\n\\n    See http://goo.gl/MqrFmX\\n\");\n                };\n                var reflectHandler = function reflectHandler() {\n                    return new Promise.PromiseInspection(this._target());\n                };\n                var apiRejection = function apiRejection(msg) {\n                    return Promise.reject(new TypeError(msg));\n                };\n                function Proxyable() {}\n                var UNDEFINED_BINDING = {};\n                var util = _dereq_(\"./util\");\n\n                var getDomain;\n                if (util.isNode) {\n                    getDomain = function getDomain() {\n                        var ret = process.domain;\n                        if (ret === undefined) ret = null;\n                        return ret;\n                    };\n                } else {\n                    getDomain = function getDomain() {\n                        return null;\n                    };\n                }\n                util.notEnumerableProp(Promise, \"_getDomain\", getDomain);\n\n                var es5 = _dereq_(\"./es5\");\n                var Async = _dereq_(\"./async\");\n                var async = new Async();\n                es5.defineProperty(Promise, \"_async\", { value: async });\n                var errors = _dereq_(\"./errors\");\n                var TypeError = Promise.TypeError = errors.TypeError;\n                Promise.RangeError = errors.RangeError;\n                var CancellationError = Promise.CancellationError = errors.CancellationError;\n                Promise.TimeoutError = errors.TimeoutError;\n                Promise.OperationalError = errors.OperationalError;\n                Promise.RejectionError = errors.OperationalError;\n                Promise.AggregateError = errors.AggregateError;\n                var INTERNAL = function INTERNAL() {};\n                var APPLY = {};\n                var NEXT_FILTER = {};\n                var tryConvertToPromise = _dereq_(\"./thenables\")(Promise, INTERNAL);\n                var PromiseArray = _dereq_(\"./promise_array\")(Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable);\n                var Context = _dereq_(\"./context\")(Promise);\n                /*jshint unused:false*/\n                var createContext = Context.create;\n                var debug = _dereq_(\"./debuggability\")(Promise, Context);\n                var CapturedTrace = debug.CapturedTrace;\n                var PassThroughHandlerContext = _dereq_(\"./finally\")(Promise, tryConvertToPromise, NEXT_FILTER);\n                var catchFilter = _dereq_(\"./catch_filter\")(NEXT_FILTER);\n                var nodebackForPromise = _dereq_(\"./nodeback\");\n                var errorObj = util.errorObj;\n                var tryCatch = util.tryCatch;\n                function check(self, executor) {\n                    if (self == null || self.constructor !== Promise) {\n                        throw new TypeError(\"the promise constructor cannot be invoked directly\\n\\n    See http://goo.gl/MqrFmX\\n\");\n                    }\n                    if (typeof executor !== \"function\") {\n                        throw new TypeError(\"expecting a function but got \" + util.classString(executor));\n                    }\n                }\n\n                function Promise(executor) {\n                    if (executor !== INTERNAL) {\n                        check(this, executor);\n                    }\n                    this._bitField = 0;\n                    this._fulfillmentHandler0 = undefined;\n                    this._rejectionHandler0 = undefined;\n                    this._promise0 = undefined;\n                    this._receiver0 = undefined;\n                    this._resolveFromExecutor(executor);\n                    this._promiseCreated();\n                    this._fireEvent(\"promiseCreated\", this);\n                }\n\n                Promise.prototype.toString = function () {\n                    return \"[object Promise]\";\n                };\n\n                Promise.prototype.caught = Promise.prototype[\"catch\"] = function (fn) {\n                    var len = arguments.length;\n                    if (len > 1) {\n                        var catchInstances = new Array(len - 1),\n                            j = 0,\n                            i;\n                        for (i = 0; i < len - 1; ++i) {\n                            var item = arguments[i];\n                            if (util.isObject(item)) {\n                                catchInstances[j++] = item;\n                            } else {\n                                return apiRejection(\"Catch statement predicate: \" + \"expecting an object but got \" + util.classString(item));\n                            }\n                        }\n                        catchInstances.length = j;\n                        fn = arguments[i];\n                        return this.then(undefined, catchFilter(catchInstances, fn, this));\n                    }\n                    return this.then(undefined, fn);\n                };\n\n                Promise.prototype.reflect = function () {\n                    return this._then(reflectHandler, reflectHandler, undefined, this, undefined);\n                };\n\n                Promise.prototype.then = function (didFulfill, didReject) {\n                    if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== \"function\" && typeof didReject !== \"function\") {\n                        var msg = \".then() only accepts functions but was passed: \" + util.classString(didFulfill);\n                        if (arguments.length > 1) {\n                            msg += \", \" + util.classString(didReject);\n                        }\n                        this._warn(msg);\n                    }\n                    return this._then(didFulfill, didReject, undefined, undefined, undefined);\n                };\n\n                Promise.prototype.done = function (didFulfill, didReject) {\n                    var promise = this._then(didFulfill, didReject, undefined, undefined, undefined);\n                    promise._setIsFinal();\n                };\n\n                Promise.prototype.spread = function (fn) {\n                    if (typeof fn !== \"function\") {\n                        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n                    }\n                    return this.all()._then(fn, undefined, undefined, APPLY, undefined);\n                };\n\n                Promise.prototype.toJSON = function () {\n                    var ret = {\n                        isFulfilled: false,\n                        isRejected: false,\n                        fulfillmentValue: undefined,\n                        rejectionReason: undefined\n                    };\n                    if (this.isFulfilled()) {\n                        ret.fulfillmentValue = this.value();\n                        ret.isFulfilled = true;\n                    } else if (this.isRejected()) {\n                        ret.rejectionReason = this.reason();\n                        ret.isRejected = true;\n                    }\n                    return ret;\n                };\n\n                Promise.prototype.all = function () {\n                    if (arguments.length > 0) {\n                        this._warn(\".all() was passed arguments but it does not take any\");\n                    }\n                    return new PromiseArray(this).promise();\n                };\n\n                Promise.prototype.error = function (fn) {\n                    return this.caught(util.originatesFromRejection, fn);\n                };\n\n                Promise.getNewLibraryCopy = module.exports;\n\n                Promise.is = function (val) {\n                    return val instanceof Promise;\n                };\n\n                Promise.fromNode = Promise.fromCallback = function (fn) {\n                    var ret = new Promise(INTERNAL);\n                    ret._captureStackTrace();\n                    var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;\n                    var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));\n                    if (result === errorObj) {\n                        ret._rejectCallback(result.e, true);\n                    }\n                    if (!ret._isFateSealed()) ret._setAsyncGuaranteed();\n                    return ret;\n                };\n\n                Promise.all = function (promises) {\n                    return new PromiseArray(promises).promise();\n                };\n\n                Promise.cast = function (obj) {\n                    var ret = tryConvertToPromise(obj);\n                    if (!(ret instanceof Promise)) {\n                        ret = new Promise(INTERNAL);\n                        ret._captureStackTrace();\n                        ret._setFulfilled();\n                        ret._rejectionHandler0 = obj;\n                    }\n                    return ret;\n                };\n\n                Promise.resolve = Promise.fulfilled = Promise.cast;\n\n                Promise.reject = Promise.rejected = function (reason) {\n                    var ret = new Promise(INTERNAL);\n                    ret._captureStackTrace();\n                    ret._rejectCallback(reason, true);\n                    return ret;\n                };\n\n                Promise.setScheduler = function (fn) {\n                    if (typeof fn !== \"function\") {\n                        throw new TypeError(\"expecting a function but got \" + util.classString(fn));\n                    }\n                    return async.setScheduler(fn);\n                };\n\n                Promise.prototype._then = function (didFulfill, didReject, _, receiver, internalData) {\n                    var haveInternalData = internalData !== undefined;\n                    var promise = haveInternalData ? internalData : new Promise(INTERNAL);\n                    var target = this._target();\n                    var bitField = target._bitField;\n\n                    if (!haveInternalData) {\n                        promise._propagateFrom(this, 3);\n                        promise._captureStackTrace();\n                        if (receiver === undefined && (this._bitField & 2097152) !== 0) {\n                            if (!((bitField & 50397184) === 0)) {\n                                receiver = this._boundValue();\n                            } else {\n                                receiver = target === this ? undefined : this._boundTo;\n                            }\n                        }\n                        this._fireEvent(\"promiseChained\", this, promise);\n                    }\n\n                    var domain = getDomain();\n                    if (!((bitField & 50397184) === 0)) {\n                        var handler,\n                            value,\n                            settler = target._settlePromiseCtx;\n                        if ((bitField & 33554432) !== 0) {\n                            value = target._rejectionHandler0;\n                            handler = didFulfill;\n                        } else if ((bitField & 16777216) !== 0) {\n                            value = target._fulfillmentHandler0;\n                            handler = didReject;\n                            target._unsetRejectionIsUnhandled();\n                        } else {\n                            settler = target._settlePromiseLateCancellationObserver;\n                            value = new CancellationError(\"late cancellation observer\");\n                            target._attachExtraTrace(value);\n                            handler = didReject;\n                        }\n\n                        async.invoke(settler, target, {\n                            handler: domain === null ? handler : typeof handler === \"function\" && util.domainBind(domain, handler),\n                            promise: promise,\n                            receiver: receiver,\n                            value: value\n                        });\n                    } else {\n                        target._addCallbacks(didFulfill, didReject, promise, receiver, domain);\n                    }\n\n                    return promise;\n                };\n\n                Promise.prototype._length = function () {\n                    return this._bitField & 65535;\n                };\n\n                Promise.prototype._isFateSealed = function () {\n                    return (this._bitField & 117506048) !== 0;\n                };\n\n                Promise.prototype._isFollowing = function () {\n                    return (this._bitField & 67108864) === 67108864;\n                };\n\n                Promise.prototype._setLength = function (len) {\n                    this._bitField = this._bitField & -65536 | len & 65535;\n                };\n\n                Promise.prototype._setFulfilled = function () {\n                    this._bitField = this._bitField | 33554432;\n                    this._fireEvent(\"promiseFulfilled\", this);\n                };\n\n                Promise.prototype._setRejected = function () {\n                    this._bitField = this._bitField | 16777216;\n                    this._fireEvent(\"promiseRejected\", this);\n                };\n\n                Promise.prototype._setFollowing = function () {\n                    this._bitField = this._bitField | 67108864;\n                    this._fireEvent(\"promiseResolved\", this);\n                };\n\n                Promise.prototype._setIsFinal = function () {\n                    this._bitField = this._bitField | 4194304;\n                };\n\n                Promise.prototype._isFinal = function () {\n                    return (this._bitField & 4194304) > 0;\n                };\n\n                Promise.prototype._unsetCancelled = function () {\n                    this._bitField = this._bitField & ~65536;\n                };\n\n                Promise.prototype._setCancelled = function () {\n                    this._bitField = this._bitField | 65536;\n                    this._fireEvent(\"promiseCancelled\", this);\n                };\n\n                Promise.prototype._setWillBeCancelled = function () {\n                    this._bitField = this._bitField | 8388608;\n                };\n\n                Promise.prototype._setAsyncGuaranteed = function () {\n                    if (async.hasCustomScheduler()) return;\n                    this._bitField = this._bitField | 134217728;\n                };\n\n                Promise.prototype._receiverAt = function (index) {\n                    var ret = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];\n                    if (ret === UNDEFINED_BINDING) {\n                        return undefined;\n                    } else if (ret === undefined && this._isBound()) {\n                        return this._boundValue();\n                    }\n                    return ret;\n                };\n\n                Promise.prototype._promiseAt = function (index) {\n                    return this[index * 4 - 4 + 2];\n                };\n\n                Promise.prototype._fulfillmentHandlerAt = function (index) {\n                    return this[index * 4 - 4 + 0];\n                };\n\n                Promise.prototype._rejectionHandlerAt = function (index) {\n                    return this[index * 4 - 4 + 1];\n                };\n\n                Promise.prototype._boundValue = function () {};\n\n                Promise.prototype._migrateCallback0 = function (follower) {\n                    var bitField = follower._bitField;\n                    var fulfill = follower._fulfillmentHandler0;\n                    var reject = follower._rejectionHandler0;\n                    var promise = follower._promise0;\n                    var receiver = follower._receiverAt(0);\n                    if (receiver === undefined) receiver = UNDEFINED_BINDING;\n                    this._addCallbacks(fulfill, reject, promise, receiver, null);\n                };\n\n                Promise.prototype._migrateCallbackAt = function (follower, index) {\n                    var fulfill = follower._fulfillmentHandlerAt(index);\n                    var reject = follower._rejectionHandlerAt(index);\n                    var promise = follower._promiseAt(index);\n                    var receiver = follower._receiverAt(index);\n                    if (receiver === undefined) receiver = UNDEFINED_BINDING;\n                    this._addCallbacks(fulfill, reject, promise, receiver, null);\n                };\n\n                Promise.prototype._addCallbacks = function (fulfill, reject, promise, receiver, domain) {\n                    var index = this._length();\n\n                    if (index >= 65535 - 4) {\n                        index = 0;\n                        this._setLength(0);\n                    }\n\n                    if (index === 0) {\n                        this._promise0 = promise;\n                        this._receiver0 = receiver;\n                        if (typeof fulfill === \"function\") {\n                            this._fulfillmentHandler0 = domain === null ? fulfill : util.domainBind(domain, fulfill);\n                        }\n                        if (typeof reject === \"function\") {\n                            this._rejectionHandler0 = domain === null ? reject : util.domainBind(domain, reject);\n                        }\n                    } else {\n                        var base = index * 4 - 4;\n                        this[base + 2] = promise;\n                        this[base + 3] = receiver;\n                        if (typeof fulfill === \"function\") {\n                            this[base + 0] = domain === null ? fulfill : util.domainBind(domain, fulfill);\n                        }\n                        if (typeof reject === \"function\") {\n                            this[base + 1] = domain === null ? reject : util.domainBind(domain, reject);\n                        }\n                    }\n                    this._setLength(index + 1);\n                    return index;\n                };\n\n                Promise.prototype._proxy = function (proxyable, arg) {\n                    this._addCallbacks(undefined, undefined, arg, proxyable, null);\n                };\n\n                Promise.prototype._resolveCallback = function (value, shouldBind) {\n                    if ((this._bitField & 117506048) !== 0) return;\n                    if (value === this) return this._rejectCallback(makeSelfResolutionError(), false);\n                    var maybePromise = tryConvertToPromise(value, this);\n                    if (!(maybePromise instanceof Promise)) return this._fulfill(value);\n\n                    if (shouldBind) this._propagateFrom(maybePromise, 2);\n\n                    var promise = maybePromise._target();\n\n                    if (promise === this) {\n                        this._reject(makeSelfResolutionError());\n                        return;\n                    }\n\n                    var bitField = promise._bitField;\n                    if ((bitField & 50397184) === 0) {\n                        var len = this._length();\n                        if (len > 0) promise._migrateCallback0(this);\n                        for (var i = 1; i < len; ++i) {\n                            promise._migrateCallbackAt(this, i);\n                        }\n                        this._setFollowing();\n                        this._setLength(0);\n                        this._setFollowee(promise);\n                    } else if ((bitField & 33554432) !== 0) {\n                        this._fulfill(promise._value());\n                    } else if ((bitField & 16777216) !== 0) {\n                        this._reject(promise._reason());\n                    } else {\n                        var reason = new CancellationError(\"late cancellation observer\");\n                        promise._attachExtraTrace(reason);\n                        this._reject(reason);\n                    }\n                };\n\n                Promise.prototype._rejectCallback = function (reason, synchronous, ignoreNonErrorWarnings) {\n                    var trace = util.ensureErrorObject(reason);\n                    var hasStack = trace === reason;\n                    if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {\n                        var message = \"a promise was rejected with a non-error: \" + util.classString(reason);\n                        this._warn(message, true);\n                    }\n                    this._attachExtraTrace(trace, synchronous ? hasStack : false);\n                    this._reject(reason);\n                };\n\n                Promise.prototype._resolveFromExecutor = function (executor) {\n                    if (executor === INTERNAL) return;\n                    var promise = this;\n                    this._captureStackTrace();\n                    this._pushContext();\n                    var synchronous = true;\n                    var r = this._execute(executor, function (value) {\n                        promise._resolveCallback(value);\n                    }, function (reason) {\n                        promise._rejectCallback(reason, synchronous);\n                    });\n                    synchronous = false;\n                    this._popContext();\n\n                    if (r !== undefined) {\n                        promise._rejectCallback(r, true);\n                    }\n                };\n\n                Promise.prototype._settlePromiseFromHandler = function (handler, receiver, value, promise) {\n                    var bitField = promise._bitField;\n                    if ((bitField & 65536) !== 0) return;\n                    promise._pushContext();\n                    var x;\n                    if (receiver === APPLY) {\n                        if (!value || typeof value.length !== \"number\") {\n                            x = errorObj;\n                            x.e = new TypeError(\"cannot .spread() a non-array: \" + util.classString(value));\n                        } else {\n                            x = tryCatch(handler).apply(this._boundValue(), value);\n                        }\n                    } else {\n                        x = tryCatch(handler).call(receiver, value);\n                    }\n                    var promiseCreated = promise._popContext();\n                    bitField = promise._bitField;\n                    if ((bitField & 65536) !== 0) return;\n\n                    if (x === NEXT_FILTER) {\n                        promise._reject(value);\n                    } else if (x === errorObj) {\n                        promise._rejectCallback(x.e, false);\n                    } else {\n                        debug.checkForgottenReturns(x, promiseCreated, \"\", promise, this);\n                        promise._resolveCallback(x);\n                    }\n                };\n\n                Promise.prototype._target = function () {\n                    var ret = this;\n                    while (ret._isFollowing()) {\n                        ret = ret._followee();\n                    }return ret;\n                };\n\n                Promise.prototype._followee = function () {\n                    return this._rejectionHandler0;\n                };\n\n                Promise.prototype._setFollowee = function (promise) {\n                    this._rejectionHandler0 = promise;\n                };\n\n                Promise.prototype._settlePromise = function (promise, handler, receiver, value) {\n                    var isPromise = promise instanceof Promise;\n                    var bitField = this._bitField;\n                    var asyncGuaranteed = (bitField & 134217728) !== 0;\n                    if ((bitField & 65536) !== 0) {\n                        if (isPromise) promise._invokeInternalOnCancel();\n\n                        if (receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler()) {\n                            receiver.cancelPromise = promise;\n                            if (tryCatch(handler).call(receiver, value) === errorObj) {\n                                promise._reject(errorObj.e);\n                            }\n                        } else if (handler === reflectHandler) {\n                            promise._fulfill(reflectHandler.call(receiver));\n                        } else if (receiver instanceof Proxyable) {\n                            receiver._promiseCancelled(promise);\n                        } else if (isPromise || promise instanceof PromiseArray) {\n                            promise._cancel();\n                        } else {\n                            receiver.cancel();\n                        }\n                    } else if (typeof handler === \"function\") {\n                        if (!isPromise) {\n                            handler.call(receiver, value, promise);\n                        } else {\n                            if (asyncGuaranteed) promise._setAsyncGuaranteed();\n                            this._settlePromiseFromHandler(handler, receiver, value, promise);\n                        }\n                    } else if (receiver instanceof Proxyable) {\n                        if (!receiver._isResolved()) {\n                            if ((bitField & 33554432) !== 0) {\n                                receiver._promiseFulfilled(value, promise);\n                            } else {\n                                receiver._promiseRejected(value, promise);\n                            }\n                        }\n                    } else if (isPromise) {\n                        if (asyncGuaranteed) promise._setAsyncGuaranteed();\n                        if ((bitField & 33554432) !== 0) {\n                            promise._fulfill(value);\n                        } else {\n                            promise._reject(value);\n                        }\n                    }\n                };\n\n                Promise.prototype._settlePromiseLateCancellationObserver = function (ctx) {\n                    var handler = ctx.handler;\n                    var promise = ctx.promise;\n                    var receiver = ctx.receiver;\n                    var value = ctx.value;\n                    if (typeof handler === \"function\") {\n                        if (!(promise instanceof Promise)) {\n                            handler.call(receiver, value, promise);\n                        } else {\n                            this._settlePromiseFromHandler(handler, receiver, value, promise);\n                        }\n                    } else if (promise instanceof Promise) {\n                        promise._reject(value);\n                    }\n                };\n\n                Promise.prototype._settlePromiseCtx = function (ctx) {\n                    this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);\n                };\n\n                Promise.prototype._settlePromise0 = function (handler, value, bitField) {\n                    var promise = this._promise0;\n                    var receiver = this._receiverAt(0);\n                    this._promise0 = undefined;\n                    this._receiver0 = undefined;\n                    this._settlePromise(promise, handler, receiver, value);\n                };\n\n                Promise.prototype._clearCallbackDataAtIndex = function (index) {\n                    var base = index * 4 - 4;\n                    this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = undefined;\n                };\n\n                Promise.prototype._fulfill = function (value) {\n                    var bitField = this._bitField;\n                    if ((bitField & 117506048) >>> 16) return;\n                    if (value === this) {\n                        var err = makeSelfResolutionError();\n                        this._attachExtraTrace(err);\n                        return this._reject(err);\n                    }\n                    this._setFulfilled();\n                    this._rejectionHandler0 = value;\n\n                    if ((bitField & 65535) > 0) {\n                        if ((bitField & 134217728) !== 0) {\n                            this._settlePromises();\n                        } else {\n                            async.settlePromises(this);\n                        }\n                    }\n                };\n\n                Promise.prototype._reject = function (reason) {\n                    var bitField = this._bitField;\n                    if ((bitField & 117506048) >>> 16) return;\n                    this._setRejected();\n                    this._fulfillmentHandler0 = reason;\n\n                    if (this._isFinal()) {\n                        return async.fatalError(reason, util.isNode);\n                    }\n\n                    if ((bitField & 65535) > 0) {\n                        async.settlePromises(this);\n                    } else {\n                        this._ensurePossibleRejectionHandled();\n                    }\n                };\n\n                Promise.prototype._fulfillPromises = function (len, value) {\n                    for (var i = 1; i < len; i++) {\n                        var handler = this._fulfillmentHandlerAt(i);\n                        var promise = this._promiseAt(i);\n                        var receiver = this._receiverAt(i);\n                        this._clearCallbackDataAtIndex(i);\n                        this._settlePromise(promise, handler, receiver, value);\n                    }\n                };\n\n                Promise.prototype._rejectPromises = function (len, reason) {\n                    for (var i = 1; i < len; i++) {\n                        var handler = this._rejectionHandlerAt(i);\n                        var promise = this._promiseAt(i);\n                        var receiver = this._receiverAt(i);\n                        this._clearCallbackDataAtIndex(i);\n                        this._settlePromise(promise, handler, receiver, reason);\n                    }\n                };\n\n                Promise.prototype._settlePromises = function () {\n                    var bitField = this._bitField;\n                    var len = bitField & 65535;\n\n                    if (len > 0) {\n                        if ((bitField & 16842752) !== 0) {\n                            var reason = this._fulfillmentHandler0;\n                            this._settlePromise0(this._rejectionHandler0, reason, bitField);\n                            this._rejectPromises(len, reason);\n                        } else {\n                            var value = this._rejectionHandler0;\n                            this._settlePromise0(this._fulfillmentHandler0, value, bitField);\n                            this._fulfillPromises(len, value);\n                        }\n                        this._setLength(0);\n                    }\n                    this._clearCancellationData();\n                };\n\n                Promise.prototype._settledValue = function () {\n                    var bitField = this._bitField;\n                    if ((bitField & 33554432) !== 0) {\n                        return this._rejectionHandler0;\n                    } else if ((bitField & 16777216) !== 0) {\n                        return this._fulfillmentHandler0;\n                    }\n                };\n\n                function deferResolve(v) {\n                    this.promise._resolveCallback(v);\n                }\n                function deferReject(v) {\n                    this.promise._rejectCallback(v, false);\n                }\n\n                Promise.defer = Promise.pending = function () {\n                    debug.deprecated(\"Promise.defer\", \"new Promise\");\n                    var promise = new Promise(INTERNAL);\n                    return {\n                        promise: promise,\n                        resolve: deferResolve,\n                        reject: deferReject\n                    };\n                };\n\n                util.notEnumerableProp(Promise, \"_makeSelfResolutionError\", makeSelfResolutionError);\n\n                _dereq_(\"./method\")(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug);\n                _dereq_(\"./bind\")(Promise, INTERNAL, tryConvertToPromise, debug);\n                _dereq_(\"./cancel\")(Promise, PromiseArray, apiRejection, debug);\n                _dereq_(\"./direct_resolve\")(Promise);\n                _dereq_(\"./synchronous_inspection\")(Promise);\n                _dereq_(\"./join\")(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);\n                Promise.Promise = Promise;\n                Promise.version = \"3.5.0\";\n                _dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);\n                _dereq_('./call_get.js')(Promise);\n                _dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);\n                _dereq_('./timers.js')(Promise, INTERNAL, debug);\n                _dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);\n                _dereq_('./nodeify.js')(Promise);\n                _dereq_('./promisify.js')(Promise, INTERNAL);\n                _dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);\n                _dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);\n                _dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);\n                _dereq_('./settle.js')(Promise, PromiseArray, debug);\n                _dereq_('./some.js')(Promise, PromiseArray, apiRejection);\n                _dereq_('./filter.js')(Promise, INTERNAL);\n                _dereq_('./each.js')(Promise, INTERNAL);\n                _dereq_('./any.js')(Promise);\n\n                util.toFastProperties(Promise);\n                util.toFastProperties(Promise.prototype);\n                function fillTypes(value) {\n                    var p = new Promise(INTERNAL);\n                    p._fulfillmentHandler0 = value;\n                    p._rejectionHandler0 = value;\n                    p._promise0 = value;\n                    p._receiver0 = value;\n                }\n                // Complete slack tracking, opt out of field-type tracking and           \n                // stabilize map                                                         \n                fillTypes({ a: 1 });\n                fillTypes({ b: 2 });\n                fillTypes({ c: 3 });\n                fillTypes(1);\n                fillTypes(function () {});\n                fillTypes(undefined);\n                fillTypes(false);\n                fillTypes(new Promise(INTERNAL));\n                debug.setBounds(Async.firstLineError, util.lastLineError);\n                return Promise;\n            };\n        }, { \"./any.js\": 1, \"./async\": 2, \"./bind\": 3, \"./call_get.js\": 5, \"./cancel\": 6, \"./catch_filter\": 7, \"./context\": 8, \"./debuggability\": 9, \"./direct_resolve\": 10, \"./each.js\": 11, \"./errors\": 12, \"./es5\": 13, \"./filter.js\": 14, \"./finally\": 15, \"./generators.js\": 16, \"./join\": 17, \"./map.js\": 18, \"./method\": 19, \"./nodeback\": 20, \"./nodeify.js\": 21, \"./promise_array\": 23, \"./promisify.js\": 24, \"./props.js\": 25, \"./race.js\": 27, \"./reduce.js\": 28, \"./settle.js\": 30, \"./some.js\": 31, \"./synchronous_inspection\": 32, \"./thenables\": 33, \"./timers.js\": 34, \"./using.js\": 35, \"./util\": 36 }], 23: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {\n                var util = _dereq_(\"./util\");\n                var isArray = util.isArray;\n\n                function toResolutionValue(val) {\n                    switch (val) {\n                        case -2:\n                            return [];\n                        case -3:\n                            return {};\n                        case -6:\n                            return new Map();\n                    }\n                }\n\n                function PromiseArray(values) {\n                    var promise = this._promise = new Promise(INTERNAL);\n                    if (values instanceof Promise) {\n                        promise._propagateFrom(values, 3);\n                    }\n                    promise._setOnCancel(this);\n                    this._values = values;\n                    this._length = 0;\n                    this._totalResolved = 0;\n                    this._init(undefined, -2);\n                }\n                util.inherits(PromiseArray, Proxyable);\n\n                PromiseArray.prototype.length = function () {\n                    return this._length;\n                };\n\n                PromiseArray.prototype.promise = function () {\n                    return this._promise;\n                };\n\n                PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {\n                    var values = tryConvertToPromise(this._values, this._promise);\n                    if (values instanceof Promise) {\n                        values = values._target();\n                        var bitField = values._bitField;\n                        ;\n                        this._values = values;\n\n                        if ((bitField & 50397184) === 0) {\n                            this._promise._setAsyncGuaranteed();\n                            return values._then(init, this._reject, undefined, this, resolveValueIfEmpty);\n                        } else if ((bitField & 33554432) !== 0) {\n                            values = values._value();\n                        } else if ((bitField & 16777216) !== 0) {\n                            return this._reject(values._reason());\n                        } else {\n                            return this._cancel();\n                        }\n                    }\n                    values = util.asArray(values);\n                    if (values === null) {\n                        var err = apiRejection(\"expecting an array or an iterable object but got \" + util.classString(values)).reason();\n                        this._promise._rejectCallback(err, false);\n                        return;\n                    }\n\n                    if (values.length === 0) {\n                        if (resolveValueIfEmpty === -5) {\n                            this._resolveEmptyArray();\n                        } else {\n                            this._resolve(toResolutionValue(resolveValueIfEmpty));\n                        }\n                        return;\n                    }\n                    this._iterate(values);\n                };\n\n                PromiseArray.prototype._iterate = function (values) {\n                    var len = this.getActualLength(values.length);\n                    this._length = len;\n                    this._values = this.shouldCopyValues() ? new Array(len) : this._values;\n                    var result = this._promise;\n                    var isResolved = false;\n                    var bitField = null;\n                    for (var i = 0; i < len; ++i) {\n                        var maybePromise = tryConvertToPromise(values[i], result);\n\n                        if (maybePromise instanceof Promise) {\n                            maybePromise = maybePromise._target();\n                            bitField = maybePromise._bitField;\n                        } else {\n                            bitField = null;\n                        }\n\n                        if (isResolved) {\n                            if (bitField !== null) {\n                                maybePromise.suppressUnhandledRejections();\n                            }\n                        } else if (bitField !== null) {\n                            if ((bitField & 50397184) === 0) {\n                                maybePromise._proxy(this, i);\n                                this._values[i] = maybePromise;\n                            } else if ((bitField & 33554432) !== 0) {\n                                isResolved = this._promiseFulfilled(maybePromise._value(), i);\n                            } else if ((bitField & 16777216) !== 0) {\n                                isResolved = this._promiseRejected(maybePromise._reason(), i);\n                            } else {\n                                isResolved = this._promiseCancelled(i);\n                            }\n                        } else {\n                            isResolved = this._promiseFulfilled(maybePromise, i);\n                        }\n                    }\n                    if (!isResolved) result._setAsyncGuaranteed();\n                };\n\n                PromiseArray.prototype._isResolved = function () {\n                    return this._values === null;\n                };\n\n                PromiseArray.prototype._resolve = function (value) {\n                    this._values = null;\n                    this._promise._fulfill(value);\n                };\n\n                PromiseArray.prototype._cancel = function () {\n                    if (this._isResolved() || !this._promise._isCancellable()) return;\n                    this._values = null;\n                    this._promise._cancel();\n                };\n\n                PromiseArray.prototype._reject = function (reason) {\n                    this._values = null;\n                    this._promise._rejectCallback(reason, false);\n                };\n\n                PromiseArray.prototype._promiseFulfilled = function (value, index) {\n                    this._values[index] = value;\n                    var totalResolved = ++this._totalResolved;\n                    if (totalResolved >= this._length) {\n                        this._resolve(this._values);\n                        return true;\n                    }\n                    return false;\n                };\n\n                PromiseArray.prototype._promiseCancelled = function () {\n                    this._cancel();\n                    return true;\n                };\n\n                PromiseArray.prototype._promiseRejected = function (reason) {\n                    this._totalResolved++;\n                    this._reject(reason);\n                    return true;\n                };\n\n                PromiseArray.prototype._resultCancelled = function () {\n                    if (this._isResolved()) return;\n                    var values = this._values;\n                    this._cancel();\n                    if (values instanceof Promise) {\n                        values.cancel();\n                    } else {\n                        for (var i = 0; i < values.length; ++i) {\n                            if (values[i] instanceof Promise) {\n                                values[i].cancel();\n                            }\n                        }\n                    }\n                };\n\n                PromiseArray.prototype.shouldCopyValues = function () {\n                    return true;\n                };\n\n                PromiseArray.prototype.getActualLength = function (len) {\n                    return len;\n                };\n\n                return PromiseArray;\n            };\n        }, { \"./util\": 36 }], 24: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, INTERNAL) {\n                var THIS = {};\n                var util = _dereq_(\"./util\");\n                var nodebackForPromise = _dereq_(\"./nodeback\");\n                var withAppended = util.withAppended;\n                var maybeWrapAsError = util.maybeWrapAsError;\n                var canEvaluate = util.canEvaluate;\n                var TypeError = _dereq_(\"./errors\").TypeError;\n                var defaultSuffix = \"Async\";\n                var defaultPromisified = { __isPromisified__: true };\n                var noCopyProps = [\"arity\", \"length\", \"name\", \"arguments\", \"caller\", \"callee\", \"prototype\", \"__isPromisified__\"];\n                var noCopyPropsPattern = new RegExp(\"^(?:\" + noCopyProps.join(\"|\") + \")$\");\n\n                var defaultFilter = function defaultFilter(name) {\n                    return util.isIdentifier(name) && name.charAt(0) !== \"_\" && name !== \"constructor\";\n                };\n\n                function propsFilter(key) {\n                    return !noCopyPropsPattern.test(key);\n                }\n\n                function isPromisified(fn) {\n                    try {\n                        return fn.__isPromisified__ === true;\n                    } catch (e) {\n                        return false;\n                    }\n                }\n\n                function hasPromisified(obj, key, suffix) {\n                    var val = util.getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);\n                    return val ? isPromisified(val) : false;\n                }\n                function checkValid(ret, suffix, suffixRegexp) {\n                    for (var i = 0; i < ret.length; i += 2) {\n                        var key = ret[i];\n                        if (suffixRegexp.test(key)) {\n                            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, \"\");\n                            for (var j = 0; j < ret.length; j += 2) {\n                                if (ret[j] === keyWithoutAsyncSuffix) {\n                                    throw new TypeError(\"Cannot promisify an API that has normal methods with '%s'-suffix\\n\\n    See http://goo.gl/MqrFmX\\n\".replace(\"%s\", suffix));\n                                }\n                            }\n                        }\n                    }\n                }\n\n                function promisifiableMethods(obj, suffix, suffixRegexp, filter) {\n                    var keys = util.inheritedDataKeys(obj);\n                    var ret = [];\n                    for (var i = 0; i < keys.length; ++i) {\n                        var key = keys[i];\n                        var value = obj[key];\n                        var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj);\n                        if (typeof value === \"function\" && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter(key, value, obj, passesDefaultFilter)) {\n                            ret.push(key, value);\n                        }\n                    }\n                    checkValid(ret, suffix, suffixRegexp);\n                    return ret;\n                }\n\n                var escapeIdentRegex = function escapeIdentRegex(str) {\n                    return str.replace(/([$])/, \"\\\\$\");\n                };\n\n                var makeNodePromisifiedEval;\n                if (false) {\n                    var switchCaseArgumentOrder = function switchCaseArgumentOrder(likelyArgumentCount) {\n                        var ret = [likelyArgumentCount];\n                        var min = Math.max(0, likelyArgumentCount - 1 - 3);\n                        for (var i = likelyArgumentCount - 1; i >= min; --i) {\n                            ret.push(i);\n                        }\n                        for (var i = likelyArgumentCount + 1; i <= 3; ++i) {\n                            ret.push(i);\n                        }\n                        return ret;\n                    };\n\n                    var argumentSequence = function argumentSequence(argumentCount) {\n                        return util.filledRange(argumentCount, \"_arg\", \"\");\n                    };\n\n                    var parameterDeclaration = function parameterDeclaration(parameterCount) {\n                        return util.filledRange(Math.max(parameterCount, 3), \"_arg\", \"\");\n                    };\n\n                    var parameterCount = function parameterCount(fn) {\n                        if (typeof fn.length === \"number\") {\n                            return Math.max(Math.min(fn.length, 1023 + 1), 0);\n                        }\n                        return 0;\n                    };\n\n                    makeNodePromisifiedEval = function makeNodePromisifiedEval(callback, receiver, originalName, fn, _, multiArgs) {\n                        var newParameterCount = Math.max(0, parameterCount(fn) - 1);\n                        var argumentOrder = switchCaseArgumentOrder(newParameterCount);\n                        var shouldProxyThis = typeof callback === \"string\" || receiver === THIS;\n\n                        function generateCallForArgumentCount(count) {\n                            var args = argumentSequence(count).join(\", \");\n                            var comma = count > 0 ? \", \" : \"\";\n                            var ret;\n                            if (shouldProxyThis) {\n                                ret = \"ret = callback.call(this, {{args}}, nodeback); break;\\n\";\n                            } else {\n                                ret = receiver === undefined ? \"ret = callback({{args}}, nodeback); break;\\n\" : \"ret = callback.call(receiver, {{args}}, nodeback); break;\\n\";\n                            }\n                            return ret.replace(\"{{args}}\", args).replace(\", \", comma);\n                        }\n\n                        function generateArgumentSwitchCase() {\n                            var ret = \"\";\n                            for (var i = 0; i < argumentOrder.length; ++i) {\n                                ret += \"case \" + argumentOrder[i] + \":\" + generateCallForArgumentCount(argumentOrder[i]);\n                            }\n\n                            ret += \"                                                             \\n\\\n        default:                                                             \\n\\\n            var args = new Array(len + 1);                                   \\n\\\n            var i = 0;                                                       \\n\\\n            for (var i = 0; i < len; ++i) {                                  \\n\\\n               args[i] = arguments[i];                                       \\n\\\n            }                                                                \\n\\\n            args[i] = nodeback;                                              \\n\\\n            [CodeForCall]                                                    \\n\\\n            break;                                                           \\n\\\n        \".replace(\"[CodeForCall]\", shouldProxyThis ? \"ret = callback.apply(this, args);\\n\" : \"ret = callback.apply(receiver, args);\\n\");\n                            return ret;\n                        }\n\n                        var getFunctionCode = typeof callback === \"string\" ? \"this != null ? this['\" + callback + \"'] : fn\" : \"fn\";\n                        var body = \"'use strict';                                                \\n\\\n        var ret = function (Parameters) {                                    \\n\\\n            'use strict';                                                    \\n\\\n            var len = arguments.length;                                      \\n\\\n            var promise = new Promise(INTERNAL);                             \\n\\\n            promise._captureStackTrace();                                    \\n\\\n            var nodeback = nodebackForPromise(promise, \" + multiArgs + \");   \\n\\\n            var ret;                                                         \\n\\\n            var callback = tryCatch([GetFunctionCode]);                      \\n\\\n            switch(len) {                                                    \\n\\\n                [CodeForSwitchCase]                                          \\n\\\n            }                                                                \\n\\\n            if (ret === errorObj) {                                          \\n\\\n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\\n\\\n            }                                                                \\n\\\n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \\n\\\n            return promise;                                                  \\n\\\n        };                                                                   \\n\\\n        notEnumerableProp(ret, '__isPromisified__', true);                   \\n\\\n        return ret;                                                          \\n\\\n    \".replace(\"[CodeForSwitchCase]\", generateArgumentSwitchCase()).replace(\"[GetFunctionCode]\", getFunctionCode);\n                        body = body.replace(\"Parameters\", parameterDeclaration(newParameterCount));\n                        return new Function(\"Promise\", \"fn\", \"receiver\", \"withAppended\", \"maybeWrapAsError\", \"nodebackForPromise\", \"tryCatch\", \"errorObj\", \"notEnumerableProp\", \"INTERNAL\", body)(Promise, fn, receiver, withAppended, maybeWrapAsError, nodebackForPromise, util.tryCatch, util.errorObj, util.notEnumerableProp, INTERNAL);\n                    };\n                }\n\n                function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {\n                    var defaultThis = function () {\n                        return this;\n                    }();\n                    var method = callback;\n                    if (typeof method === \"string\") {\n                        callback = fn;\n                    }\n                    function promisified() {\n                        var _receiver = receiver;\n                        if (receiver === THIS) _receiver = this;\n                        var promise = new Promise(INTERNAL);\n                        promise._captureStackTrace();\n                        var cb = typeof method === \"string\" && this !== defaultThis ? this[method] : callback;\n                        var fn = nodebackForPromise(promise, multiArgs);\n                        try {\n                            cb.apply(_receiver, withAppended(arguments, fn));\n                        } catch (e) {\n                            promise._rejectCallback(maybeWrapAsError(e), true, true);\n                        }\n                        if (!promise._isFateSealed()) promise._setAsyncGuaranteed();\n                        return promise;\n                    }\n                    util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n                    return promisified;\n                }\n\n                var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;\n\n                function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {\n                    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + \"$\");\n                    var methods = promisifiableMethods(obj, suffix, suffixRegexp, filter);\n\n                    for (var i = 0, len = methods.length; i < len; i += 2) {\n                        var key = methods[i];\n                        var fn = methods[i + 1];\n                        var promisifiedKey = key + suffix;\n                        if (promisifier === makeNodePromisified) {\n                            obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);\n                        } else {\n                            var promisified = promisifier(fn, function () {\n                                return makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);\n                            });\n                            util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n                            obj[promisifiedKey] = promisified;\n                        }\n                    }\n                    util.toFastProperties(obj);\n                    return obj;\n                }\n\n                function promisify(callback, receiver, multiArgs) {\n                    return makeNodePromisified(callback, receiver, undefined, callback, null, multiArgs);\n                }\n\n                Promise.promisify = function (fn, options) {\n                    if (typeof fn !== \"function\") {\n                        throw new TypeError(\"expecting a function but got \" + util.classString(fn));\n                    }\n                    if (isPromisified(fn)) {\n                        return fn;\n                    }\n                    options = Object(options);\n                    var receiver = options.context === undefined ? THIS : options.context;\n                    var multiArgs = !!options.multiArgs;\n                    var ret = promisify(fn, receiver, multiArgs);\n                    util.copyDescriptors(fn, ret, propsFilter);\n                    return ret;\n                };\n\n                Promise.promisifyAll = function (target, options) {\n                    if (typeof target !== \"function\" && (typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) !== \"object\") {\n                        throw new TypeError(\"the target of promisifyAll must be an object or a function\\n\\n    See http://goo.gl/MqrFmX\\n\");\n                    }\n                    options = Object(options);\n                    var multiArgs = !!options.multiArgs;\n                    var suffix = options.suffix;\n                    if (typeof suffix !== \"string\") suffix = defaultSuffix;\n                    var filter = options.filter;\n                    if (typeof filter !== \"function\") filter = defaultFilter;\n                    var promisifier = options.promisifier;\n                    if (typeof promisifier !== \"function\") promisifier = makeNodePromisified;\n\n                    if (!util.isIdentifier(suffix)) {\n                        throw new RangeError(\"suffix must be a valid identifier\\n\\n    See http://goo.gl/MqrFmX\\n\");\n                    }\n\n                    var keys = util.inheritedDataKeys(target);\n                    for (var i = 0; i < keys.length; ++i) {\n                        var value = target[keys[i]];\n                        if (keys[i] !== \"constructor\" && util.isClass(value)) {\n                            promisifyAll(value.prototype, suffix, filter, promisifier, multiArgs);\n                            promisifyAll(value, suffix, filter, promisifier, multiArgs);\n                        }\n                    }\n\n                    return promisifyAll(target, suffix, filter, promisifier, multiArgs);\n                };\n            };\n        }, { \"./errors\": 12, \"./nodeback\": 20, \"./util\": 36 }], 25: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, PromiseArray, tryConvertToPromise, apiRejection) {\n                var util = _dereq_(\"./util\");\n                var isObject = util.isObject;\n                var es5 = _dereq_(\"./es5\");\n                var Es6Map;\n                if (typeof Map === \"function\") Es6Map = Map;\n\n                var mapToEntries = function () {\n                    var index = 0;\n                    var size = 0;\n\n                    function extractEntry(value, key) {\n                        this[index] = value;\n                        this[index + size] = key;\n                        index++;\n                    }\n\n                    return function mapToEntries(map) {\n                        size = map.size;\n                        index = 0;\n                        var ret = new Array(map.size * 2);\n                        map.forEach(extractEntry, ret);\n                        return ret;\n                    };\n                }();\n\n                var entriesToMap = function entriesToMap(entries) {\n                    var ret = new Es6Map();\n                    var length = entries.length / 2 | 0;\n                    for (var i = 0; i < length; ++i) {\n                        var key = entries[length + i];\n                        var value = entries[i];\n                        ret.set(key, value);\n                    }\n                    return ret;\n                };\n\n                function PropertiesPromiseArray(obj) {\n                    var isMap = false;\n                    var entries;\n                    if (Es6Map !== undefined && obj instanceof Es6Map) {\n                        entries = mapToEntries(obj);\n                        isMap = true;\n                    } else {\n                        var keys = es5.keys(obj);\n                        var len = keys.length;\n                        entries = new Array(len * 2);\n                        for (var i = 0; i < len; ++i) {\n                            var key = keys[i];\n                            entries[i] = obj[key];\n                            entries[i + len] = key;\n                        }\n                    }\n                    this.constructor$(entries);\n                    this._isMap = isMap;\n                    this._init$(undefined, isMap ? -6 : -3);\n                }\n                util.inherits(PropertiesPromiseArray, PromiseArray);\n\n                PropertiesPromiseArray.prototype._init = function () {};\n\n                PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {\n                    this._values[index] = value;\n                    var totalResolved = ++this._totalResolved;\n                    if (totalResolved >= this._length) {\n                        var val;\n                        if (this._isMap) {\n                            val = entriesToMap(this._values);\n                        } else {\n                            val = {};\n                            var keyOffset = this.length();\n                            for (var i = 0, len = this.length(); i < len; ++i) {\n                                val[this._values[i + keyOffset]] = this._values[i];\n                            }\n                        }\n                        this._resolve(val);\n                        return true;\n                    }\n                    return false;\n                };\n\n                PropertiesPromiseArray.prototype.shouldCopyValues = function () {\n                    return false;\n                };\n\n                PropertiesPromiseArray.prototype.getActualLength = function (len) {\n                    return len >> 1;\n                };\n\n                function props(promises) {\n                    var ret;\n                    var castValue = tryConvertToPromise(promises);\n\n                    if (!isObject(castValue)) {\n                        return apiRejection(\"cannot await properties of a non-object\\n\\n    See http://goo.gl/MqrFmX\\n\");\n                    } else if (castValue instanceof Promise) {\n                        ret = castValue._then(Promise.props, undefined, undefined, undefined, undefined);\n                    } else {\n                        ret = new PropertiesPromiseArray(castValue).promise();\n                    }\n\n                    if (castValue instanceof Promise) {\n                        ret._propagateFrom(castValue, 2);\n                    }\n                    return ret;\n                }\n\n                Promise.prototype.props = function () {\n                    return props(this);\n                };\n\n                Promise.props = function (promises) {\n                    return props(promises);\n                };\n            };\n        }, { \"./es5\": 13, \"./util\": 36 }], 26: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            function arrayMove(src, srcIndex, dst, dstIndex, len) {\n                for (var j = 0; j < len; ++j) {\n                    dst[j + dstIndex] = src[j + srcIndex];\n                    src[j + srcIndex] = void 0;\n                }\n            }\n\n            function Queue(capacity) {\n                this._capacity = capacity;\n                this._length = 0;\n                this._front = 0;\n            }\n\n            Queue.prototype._willBeOverCapacity = function (size) {\n                return this._capacity < size;\n            };\n\n            Queue.prototype._pushOne = function (arg) {\n                var length = this.length();\n                this._checkCapacity(length + 1);\n                var i = this._front + length & this._capacity - 1;\n                this[i] = arg;\n                this._length = length + 1;\n            };\n\n            Queue.prototype.push = function (fn, receiver, arg) {\n                var length = this.length() + 3;\n                if (this._willBeOverCapacity(length)) {\n                    this._pushOne(fn);\n                    this._pushOne(receiver);\n                    this._pushOne(arg);\n                    return;\n                }\n                var j = this._front + length - 3;\n                this._checkCapacity(length);\n                var wrapMask = this._capacity - 1;\n                this[j + 0 & wrapMask] = fn;\n                this[j + 1 & wrapMask] = receiver;\n                this[j + 2 & wrapMask] = arg;\n                this._length = length;\n            };\n\n            Queue.prototype.shift = function () {\n                var front = this._front,\n                    ret = this[front];\n\n                this[front] = undefined;\n                this._front = front + 1 & this._capacity - 1;\n                this._length--;\n                return ret;\n            };\n\n            Queue.prototype.length = function () {\n                return this._length;\n            };\n\n            Queue.prototype._checkCapacity = function (size) {\n                if (this._capacity < size) {\n                    this._resizeTo(this._capacity << 1);\n                }\n            };\n\n            Queue.prototype._resizeTo = function (capacity) {\n                var oldCapacity = this._capacity;\n                this._capacity = capacity;\n                var front = this._front;\n                var length = this._length;\n                var moveItemsCount = front + length & oldCapacity - 1;\n                arrayMove(this, 0, this, oldCapacity, moveItemsCount);\n            };\n\n            module.exports = Queue;\n        }, {}], 27: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection) {\n                var util = _dereq_(\"./util\");\n\n                var raceLater = function raceLater(promise) {\n                    return promise.then(function (array) {\n                        return race(array, promise);\n                    });\n                };\n\n                function race(promises, parent) {\n                    var maybePromise = tryConvertToPromise(promises);\n\n                    if (maybePromise instanceof Promise) {\n                        return raceLater(maybePromise);\n                    } else {\n                        promises = util.asArray(promises);\n                        if (promises === null) return apiRejection(\"expecting an array or an iterable object but got \" + util.classString(promises));\n                    }\n\n                    var ret = new Promise(INTERNAL);\n                    if (parent !== undefined) {\n                        ret._propagateFrom(parent, 3);\n                    }\n                    var fulfill = ret._fulfill;\n                    var reject = ret._reject;\n                    for (var i = 0, len = promises.length; i < len; ++i) {\n                        var val = promises[i];\n\n                        if (val === undefined && !(i in promises)) {\n                            continue;\n                        }\n\n                        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);\n                    }\n                    return ret;\n                }\n\n                Promise.race = function (promises) {\n                    return race(promises, undefined);\n                };\n\n                Promise.prototype.race = function () {\n                    return race(this, undefined);\n                };\n            };\n        }, { \"./util\": 36 }], 28: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {\n                var getDomain = Promise._getDomain;\n                var util = _dereq_(\"./util\");\n                var tryCatch = util.tryCatch;\n\n                function ReductionPromiseArray(promises, fn, initialValue, _each) {\n                    this.constructor$(promises);\n                    var domain = getDomain();\n                    this._fn = domain === null ? fn : util.domainBind(domain, fn);\n                    if (initialValue !== undefined) {\n                        initialValue = Promise.resolve(initialValue);\n                        initialValue._attachCancellationCallback(this);\n                    }\n                    this._initialValue = initialValue;\n                    this._currentCancellable = null;\n                    if (_each === INTERNAL) {\n                        this._eachValues = Array(this._length);\n                    } else if (_each === 0) {\n                        this._eachValues = null;\n                    } else {\n                        this._eachValues = undefined;\n                    }\n                    this._promise._captureStackTrace();\n                    this._init$(undefined, -5);\n                }\n                util.inherits(ReductionPromiseArray, PromiseArray);\n\n                ReductionPromiseArray.prototype._gotAccum = function (accum) {\n                    if (this._eachValues !== undefined && this._eachValues !== null && accum !== INTERNAL) {\n                        this._eachValues.push(accum);\n                    }\n                };\n\n                ReductionPromiseArray.prototype._eachComplete = function (value) {\n                    if (this._eachValues !== null) {\n                        this._eachValues.push(value);\n                    }\n                    return this._eachValues;\n                };\n\n                ReductionPromiseArray.prototype._init = function () {};\n\n                ReductionPromiseArray.prototype._resolveEmptyArray = function () {\n                    this._resolve(this._eachValues !== undefined ? this._eachValues : this._initialValue);\n                };\n\n                ReductionPromiseArray.prototype.shouldCopyValues = function () {\n                    return false;\n                };\n\n                ReductionPromiseArray.prototype._resolve = function (value) {\n                    this._promise._resolveCallback(value);\n                    this._values = null;\n                };\n\n                ReductionPromiseArray.prototype._resultCancelled = function (sender) {\n                    if (sender === this._initialValue) return this._cancel();\n                    if (this._isResolved()) return;\n                    this._resultCancelled$();\n                    if (this._currentCancellable instanceof Promise) {\n                        this._currentCancellable.cancel();\n                    }\n                    if (this._initialValue instanceof Promise) {\n                        this._initialValue.cancel();\n                    }\n                };\n\n                ReductionPromiseArray.prototype._iterate = function (values) {\n                    this._values = values;\n                    var value;\n                    var i;\n                    var length = values.length;\n                    if (this._initialValue !== undefined) {\n                        value = this._initialValue;\n                        i = 0;\n                    } else {\n                        value = Promise.resolve(values[0]);\n                        i = 1;\n                    }\n\n                    this._currentCancellable = value;\n\n                    if (!value.isRejected()) {\n                        for (; i < length; ++i) {\n                            var ctx = {\n                                accum: null,\n                                value: values[i],\n                                index: i,\n                                length: length,\n                                array: this\n                            };\n                            value = value._then(gotAccum, undefined, undefined, ctx, undefined);\n                        }\n                    }\n\n                    if (this._eachValues !== undefined) {\n                        value = value._then(this._eachComplete, undefined, undefined, this, undefined);\n                    }\n                    value._then(completed, completed, undefined, value, this);\n                };\n\n                Promise.prototype.reduce = function (fn, initialValue) {\n                    return reduce(this, fn, initialValue, null);\n                };\n\n                Promise.reduce = function (promises, fn, initialValue, _each) {\n                    return reduce(promises, fn, initialValue, _each);\n                };\n\n                function completed(valueOrReason, array) {\n                    if (this.isFulfilled()) {\n                        array._resolve(valueOrReason);\n                    } else {\n                        array._reject(valueOrReason);\n                    }\n                }\n\n                function reduce(promises, fn, initialValue, _each) {\n                    if (typeof fn !== \"function\") {\n                        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n                    }\n                    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);\n                    return array.promise();\n                }\n\n                function gotAccum(accum) {\n                    this.accum = accum;\n                    this.array._gotAccum(accum);\n                    var value = tryConvertToPromise(this.value, this.array._promise);\n                    if (value instanceof Promise) {\n                        this.array._currentCancellable = value;\n                        return value._then(gotValue, undefined, undefined, this, undefined);\n                    } else {\n                        return gotValue.call(this, value);\n                    }\n                }\n\n                function gotValue(value) {\n                    var array = this.array;\n                    var promise = array._promise;\n                    var fn = tryCatch(array._fn);\n                    promise._pushContext();\n                    var ret;\n                    if (array._eachValues !== undefined) {\n                        ret = fn.call(promise._boundValue(), value, this.index, this.length);\n                    } else {\n                        ret = fn.call(promise._boundValue(), this.accum, value, this.index, this.length);\n                    }\n                    if (ret instanceof Promise) {\n                        array._currentCancellable = ret;\n                    }\n                    var promiseCreated = promise._popContext();\n                    debug.checkForgottenReturns(ret, promiseCreated, array._eachValues !== undefined ? \"Promise.each\" : \"Promise.reduce\", promise);\n                    return ret;\n                }\n            };\n        }, { \"./util\": 36 }], 29: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            var util = _dereq_(\"./util\");\n            var schedule;\n            var noAsyncScheduler = function noAsyncScheduler() {\n                throw new Error(\"No async scheduler available\\n\\n    See http://goo.gl/MqrFmX\\n\");\n            };\n            var NativePromise = util.getNativePromise();\n            if (util.isNode && typeof MutationObserver === \"undefined\") {\n                var GlobalSetImmediate = global.setImmediate;\n                var ProcessNextTick = process.nextTick;\n                schedule = util.isRecentNode ? function (fn) {\n                    GlobalSetImmediate.call(global, fn);\n                } : function (fn) {\n                    ProcessNextTick.call(process, fn);\n                };\n            } else if (typeof NativePromise === \"function\" && typeof NativePromise.resolve === \"function\") {\n                var nativePromise = NativePromise.resolve();\n                schedule = function schedule(fn) {\n                    nativePromise.then(fn);\n                };\n            } else if (typeof MutationObserver !== \"undefined\" && !(typeof window !== \"undefined\" && window.navigator && (window.navigator.standalone || window.cordova))) {\n                schedule = function () {\n                    var div = document.createElement(\"div\");\n                    var opts = { attributes: true };\n                    var toggleScheduled = false;\n                    var div2 = document.createElement(\"div\");\n                    var o2 = new MutationObserver(function () {\n                        div.classList.toggle(\"foo\");\n                        toggleScheduled = false;\n                    });\n                    o2.observe(div2, opts);\n\n                    var scheduleToggle = function scheduleToggle() {\n                        if (toggleScheduled) return;\n                        toggleScheduled = true;\n                        div2.classList.toggle(\"foo\");\n                    };\n\n                    return function schedule(fn) {\n                        var o = new MutationObserver(function () {\n                            o.disconnect();\n                            fn();\n                        });\n                        o.observe(div, opts);\n                        scheduleToggle();\n                    };\n                }();\n            } else if (typeof setImmediate !== \"undefined\") {\n                schedule = function schedule(fn) {\n                    setImmediate(fn);\n                };\n            } else if (typeof setTimeout !== \"undefined\") {\n                schedule = function schedule(fn) {\n                    setTimeout(fn, 0);\n                };\n            } else {\n                schedule = noAsyncScheduler;\n            }\n            module.exports = schedule;\n        }, { \"./util\": 36 }], 30: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, PromiseArray, debug) {\n                var PromiseInspection = Promise.PromiseInspection;\n                var util = _dereq_(\"./util\");\n\n                function SettledPromiseArray(values) {\n                    this.constructor$(values);\n                }\n                util.inherits(SettledPromiseArray, PromiseArray);\n\n                SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {\n                    this._values[index] = inspection;\n                    var totalResolved = ++this._totalResolved;\n                    if (totalResolved >= this._length) {\n                        this._resolve(this._values);\n                        return true;\n                    }\n                    return false;\n                };\n\n                SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {\n                    var ret = new PromiseInspection();\n                    ret._bitField = 33554432;\n                    ret._settledValueField = value;\n                    return this._promiseResolved(index, ret);\n                };\n                SettledPromiseArray.prototype._promiseRejected = function (reason, index) {\n                    var ret = new PromiseInspection();\n                    ret._bitField = 16777216;\n                    ret._settledValueField = reason;\n                    return this._promiseResolved(index, ret);\n                };\n\n                Promise.settle = function (promises) {\n                    debug.deprecated(\".settle()\", \".reflect()\");\n                    return new SettledPromiseArray(promises).promise();\n                };\n\n                Promise.prototype.settle = function () {\n                    return Promise.settle(this);\n                };\n            };\n        }, { \"./util\": 36 }], 31: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, PromiseArray, apiRejection) {\n                var util = _dereq_(\"./util\");\n                var RangeError = _dereq_(\"./errors\").RangeError;\n                var AggregateError = _dereq_(\"./errors\").AggregateError;\n                var isArray = util.isArray;\n                var CANCELLATION = {};\n\n                function SomePromiseArray(values) {\n                    this.constructor$(values);\n                    this._howMany = 0;\n                    this._unwrap = false;\n                    this._initialized = false;\n                }\n                util.inherits(SomePromiseArray, PromiseArray);\n\n                SomePromiseArray.prototype._init = function () {\n                    if (!this._initialized) {\n                        return;\n                    }\n                    if (this._howMany === 0) {\n                        this._resolve([]);\n                        return;\n                    }\n                    this._init$(undefined, -5);\n                    var isArrayResolved = isArray(this._values);\n                    if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {\n                        this._reject(this._getRangeError(this.length()));\n                    }\n                };\n\n                SomePromiseArray.prototype.init = function () {\n                    this._initialized = true;\n                    this._init();\n                };\n\n                SomePromiseArray.prototype.setUnwrap = function () {\n                    this._unwrap = true;\n                };\n\n                SomePromiseArray.prototype.howMany = function () {\n                    return this._howMany;\n                };\n\n                SomePromiseArray.prototype.setHowMany = function (count) {\n                    this._howMany = count;\n                };\n\n                SomePromiseArray.prototype._promiseFulfilled = function (value) {\n                    this._addFulfilled(value);\n                    if (this._fulfilled() === this.howMany()) {\n                        this._values.length = this.howMany();\n                        if (this.howMany() === 1 && this._unwrap) {\n                            this._resolve(this._values[0]);\n                        } else {\n                            this._resolve(this._values);\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n                SomePromiseArray.prototype._promiseRejected = function (reason) {\n                    this._addRejected(reason);\n                    return this._checkOutcome();\n                };\n\n                SomePromiseArray.prototype._promiseCancelled = function () {\n                    if (this._values instanceof Promise || this._values == null) {\n                        return this._cancel();\n                    }\n                    this._addRejected(CANCELLATION);\n                    return this._checkOutcome();\n                };\n\n                SomePromiseArray.prototype._checkOutcome = function () {\n                    if (this.howMany() > this._canPossiblyFulfill()) {\n                        var e = new AggregateError();\n                        for (var i = this.length(); i < this._values.length; ++i) {\n                            if (this._values[i] !== CANCELLATION) {\n                                e.push(this._values[i]);\n                            }\n                        }\n                        if (e.length > 0) {\n                            this._reject(e);\n                        } else {\n                            this._cancel();\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n\n                SomePromiseArray.prototype._fulfilled = function () {\n                    return this._totalResolved;\n                };\n\n                SomePromiseArray.prototype._rejected = function () {\n                    return this._values.length - this.length();\n                };\n\n                SomePromiseArray.prototype._addRejected = function (reason) {\n                    this._values.push(reason);\n                };\n\n                SomePromiseArray.prototype._addFulfilled = function (value) {\n                    this._values[this._totalResolved++] = value;\n                };\n\n                SomePromiseArray.prototype._canPossiblyFulfill = function () {\n                    return this.length() - this._rejected();\n                };\n\n                SomePromiseArray.prototype._getRangeError = function (count) {\n                    var message = \"Input array must contain at least \" + this._howMany + \" items but contains only \" + count + \" items\";\n                    return new RangeError(message);\n                };\n\n                SomePromiseArray.prototype._resolveEmptyArray = function () {\n                    this._reject(this._getRangeError(0));\n                };\n\n                function some(promises, howMany) {\n                    if ((howMany | 0) !== howMany || howMany < 0) {\n                        return apiRejection(\"expecting a positive integer\\n\\n    See http://goo.gl/MqrFmX\\n\");\n                    }\n                    var ret = new SomePromiseArray(promises);\n                    var promise = ret.promise();\n                    ret.setHowMany(howMany);\n                    ret.init();\n                    return promise;\n                }\n\n                Promise.some = function (promises, howMany) {\n                    return some(promises, howMany);\n                };\n\n                Promise.prototype.some = function (howMany) {\n                    return some(this, howMany);\n                };\n\n                Promise._SomePromiseArray = SomePromiseArray;\n            };\n        }, { \"./errors\": 12, \"./util\": 36 }], 32: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise) {\n                function PromiseInspection(promise) {\n                    if (promise !== undefined) {\n                        promise = promise._target();\n                        this._bitField = promise._bitField;\n                        this._settledValueField = promise._isFateSealed() ? promise._settledValue() : undefined;\n                    } else {\n                        this._bitField = 0;\n                        this._settledValueField = undefined;\n                    }\n                }\n\n                PromiseInspection.prototype._settledValue = function () {\n                    return this._settledValueField;\n                };\n\n                var value = PromiseInspection.prototype.value = function () {\n                    if (!this.isFulfilled()) {\n                        throw new TypeError(\"cannot get fulfillment value of a non-fulfilled promise\\n\\n    See http://goo.gl/MqrFmX\\n\");\n                    }\n                    return this._settledValue();\n                };\n\n                var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function () {\n                    if (!this.isRejected()) {\n                        throw new TypeError(\"cannot get rejection reason of a non-rejected promise\\n\\n    See http://goo.gl/MqrFmX\\n\");\n                    }\n                    return this._settledValue();\n                };\n\n                var isFulfilled = PromiseInspection.prototype.isFulfilled = function () {\n                    return (this._bitField & 33554432) !== 0;\n                };\n\n                var isRejected = PromiseInspection.prototype.isRejected = function () {\n                    return (this._bitField & 16777216) !== 0;\n                };\n\n                var isPending = PromiseInspection.prototype.isPending = function () {\n                    return (this._bitField & 50397184) === 0;\n                };\n\n                var isResolved = PromiseInspection.prototype.isResolved = function () {\n                    return (this._bitField & 50331648) !== 0;\n                };\n\n                PromiseInspection.prototype.isCancelled = function () {\n                    return (this._bitField & 8454144) !== 0;\n                };\n\n                Promise.prototype.__isCancelled = function () {\n                    return (this._bitField & 65536) === 65536;\n                };\n\n                Promise.prototype._isCancelled = function () {\n                    return this._target().__isCancelled();\n                };\n\n                Promise.prototype.isCancelled = function () {\n                    return (this._target()._bitField & 8454144) !== 0;\n                };\n\n                Promise.prototype.isPending = function () {\n                    return isPending.call(this._target());\n                };\n\n                Promise.prototype.isRejected = function () {\n                    return isRejected.call(this._target());\n                };\n\n                Promise.prototype.isFulfilled = function () {\n                    return isFulfilled.call(this._target());\n                };\n\n                Promise.prototype.isResolved = function () {\n                    return isResolved.call(this._target());\n                };\n\n                Promise.prototype.value = function () {\n                    return value.call(this._target());\n                };\n\n                Promise.prototype.reason = function () {\n                    var target = this._target();\n                    target._unsetRejectionIsUnhandled();\n                    return reason.call(target);\n                };\n\n                Promise.prototype._value = function () {\n                    return this._settledValue();\n                };\n\n                Promise.prototype._reason = function () {\n                    this._unsetRejectionIsUnhandled();\n                    return this._settledValue();\n                };\n\n                Promise.PromiseInspection = PromiseInspection;\n            };\n        }, {}], 33: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, INTERNAL) {\n                var util = _dereq_(\"./util\");\n                var errorObj = util.errorObj;\n                var isObject = util.isObject;\n\n                function tryConvertToPromise(obj, context) {\n                    if (isObject(obj)) {\n                        if (obj instanceof Promise) return obj;\n                        var then = getThen(obj);\n                        if (then === errorObj) {\n                            if (context) context._pushContext();\n                            var ret = Promise.reject(then.e);\n                            if (context) context._popContext();\n                            return ret;\n                        } else if (typeof then === \"function\") {\n                            if (isAnyBluebirdPromise(obj)) {\n                                var ret = new Promise(INTERNAL);\n                                obj._then(ret._fulfill, ret._reject, undefined, ret, null);\n                                return ret;\n                            }\n                            return doThenable(obj, then, context);\n                        }\n                    }\n                    return obj;\n                }\n\n                function doGetThen(obj) {\n                    return obj.then;\n                }\n\n                function getThen(obj) {\n                    try {\n                        return doGetThen(obj);\n                    } catch (e) {\n                        errorObj.e = e;\n                        return errorObj;\n                    }\n                }\n\n                var hasProp = {}.hasOwnProperty;\n                function isAnyBluebirdPromise(obj) {\n                    try {\n                        return hasProp.call(obj, \"_promise0\");\n                    } catch (e) {\n                        return false;\n                    }\n                }\n\n                function doThenable(x, then, context) {\n                    var promise = new Promise(INTERNAL);\n                    var ret = promise;\n                    if (context) context._pushContext();\n                    promise._captureStackTrace();\n                    if (context) context._popContext();\n                    var synchronous = true;\n                    var result = util.tryCatch(then).call(x, resolve, reject);\n                    synchronous = false;\n\n                    if (promise && result === errorObj) {\n                        promise._rejectCallback(result.e, true, true);\n                        promise = null;\n                    }\n\n                    function resolve(value) {\n                        if (!promise) return;\n                        promise._resolveCallback(value);\n                        promise = null;\n                    }\n\n                    function reject(reason) {\n                        if (!promise) return;\n                        promise._rejectCallback(reason, synchronous, true);\n                        promise = null;\n                    }\n                    return ret;\n                }\n\n                return tryConvertToPromise;\n            };\n        }, { \"./util\": 36 }], 34: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, INTERNAL, debug) {\n                var util = _dereq_(\"./util\");\n                var TimeoutError = Promise.TimeoutError;\n\n                function HandleWrapper(handle) {\n                    this.handle = handle;\n                }\n\n                HandleWrapper.prototype._resultCancelled = function () {\n                    clearTimeout(this.handle);\n                };\n\n                var afterValue = function afterValue(value) {\n                    return delay(+this).thenReturn(value);\n                };\n                var delay = Promise.delay = function (ms, value) {\n                    var ret;\n                    var handle;\n                    if (value !== undefined) {\n                        ret = Promise.resolve(value)._then(afterValue, null, null, ms, undefined);\n                        if (debug.cancellation() && value instanceof Promise) {\n                            ret._setOnCancel(value);\n                        }\n                    } else {\n                        ret = new Promise(INTERNAL);\n                        handle = setTimeout(function () {\n                            ret._fulfill();\n                        }, +ms);\n                        if (debug.cancellation()) {\n                            ret._setOnCancel(new HandleWrapper(handle));\n                        }\n                        ret._captureStackTrace();\n                    }\n                    ret._setAsyncGuaranteed();\n                    return ret;\n                };\n\n                Promise.prototype.delay = function (ms) {\n                    return delay(ms, this);\n                };\n\n                var afterTimeout = function afterTimeout(promise, message, parent) {\n                    var err;\n                    if (typeof message !== \"string\") {\n                        if (message instanceof Error) {\n                            err = message;\n                        } else {\n                            err = new TimeoutError(\"operation timed out\");\n                        }\n                    } else {\n                        err = new TimeoutError(message);\n                    }\n                    util.markAsOriginatingFromRejection(err);\n                    promise._attachExtraTrace(err);\n                    promise._reject(err);\n\n                    if (parent != null) {\n                        parent.cancel();\n                    }\n                };\n\n                function successClear(value) {\n                    clearTimeout(this.handle);\n                    return value;\n                }\n\n                function failureClear(reason) {\n                    clearTimeout(this.handle);\n                    throw reason;\n                }\n\n                Promise.prototype.timeout = function (ms, message) {\n                    ms = +ms;\n                    var ret, parent;\n\n                    var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {\n                        if (ret.isPending()) {\n                            afterTimeout(ret, message, parent);\n                        }\n                    }, ms));\n\n                    if (debug.cancellation()) {\n                        parent = this.then();\n                        ret = parent._then(successClear, failureClear, undefined, handleWrapper, undefined);\n                        ret._setOnCancel(handleWrapper);\n                    } else {\n                        ret = this._then(successClear, failureClear, undefined, handleWrapper, undefined);\n                    }\n\n                    return ret;\n                };\n            };\n        }, { \"./util\": 36 }], 35: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {\n                var util = _dereq_(\"./util\");\n                var TypeError = _dereq_(\"./errors\").TypeError;\n                var inherits = _dereq_(\"./util\").inherits;\n                var errorObj = util.errorObj;\n                var tryCatch = util.tryCatch;\n                var NULL = {};\n\n                function thrower(e) {\n                    setTimeout(function () {\n                        throw e;\n                    }, 0);\n                }\n\n                function castPreservingDisposable(thenable) {\n                    var maybePromise = tryConvertToPromise(thenable);\n                    if (maybePromise !== thenable && typeof thenable._isDisposable === \"function\" && typeof thenable._getDisposer === \"function\" && thenable._isDisposable()) {\n                        maybePromise._setDisposable(thenable._getDisposer());\n                    }\n                    return maybePromise;\n                }\n                function dispose(resources, inspection) {\n                    var i = 0;\n                    var len = resources.length;\n                    var ret = new Promise(INTERNAL);\n                    function iterator() {\n                        if (i >= len) return ret._fulfill();\n                        var maybePromise = castPreservingDisposable(resources[i++]);\n                        if (maybePromise instanceof Promise && maybePromise._isDisposable()) {\n                            try {\n                                maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);\n                            } catch (e) {\n                                return thrower(e);\n                            }\n                            if (maybePromise instanceof Promise) {\n                                return maybePromise._then(iterator, thrower, null, null, null);\n                            }\n                        }\n                        iterator();\n                    }\n                    iterator();\n                    return ret;\n                }\n\n                function Disposer(data, promise, context) {\n                    this._data = data;\n                    this._promise = promise;\n                    this._context = context;\n                }\n\n                Disposer.prototype.data = function () {\n                    return this._data;\n                };\n\n                Disposer.prototype.promise = function () {\n                    return this._promise;\n                };\n\n                Disposer.prototype.resource = function () {\n                    if (this.promise().isFulfilled()) {\n                        return this.promise().value();\n                    }\n                    return NULL;\n                };\n\n                Disposer.prototype.tryDispose = function (inspection) {\n                    var resource = this.resource();\n                    var context = this._context;\n                    if (context !== undefined) context._pushContext();\n                    var ret = resource !== NULL ? this.doDispose(resource, inspection) : null;\n                    if (context !== undefined) context._popContext();\n                    this._promise._unsetDisposable();\n                    this._data = null;\n                    return ret;\n                };\n\n                Disposer.isDisposer = function (d) {\n                    return d != null && typeof d.resource === \"function\" && typeof d.tryDispose === \"function\";\n                };\n\n                function FunctionDisposer(fn, promise, context) {\n                    this.constructor$(fn, promise, context);\n                }\n                inherits(FunctionDisposer, Disposer);\n\n                FunctionDisposer.prototype.doDispose = function (resource, inspection) {\n                    var fn = this.data();\n                    return fn.call(resource, resource, inspection);\n                };\n\n                function maybeUnwrapDisposer(value) {\n                    if (Disposer.isDisposer(value)) {\n                        this.resources[this.index]._setDisposable(value);\n                        return value.promise();\n                    }\n                    return value;\n                }\n\n                function ResourceList(length) {\n                    this.length = length;\n                    this.promise = null;\n                    this[length - 1] = null;\n                }\n\n                ResourceList.prototype._resultCancelled = function () {\n                    var len = this.length;\n                    for (var i = 0; i < len; ++i) {\n                        var item = this[i];\n                        if (item instanceof Promise) {\n                            item.cancel();\n                        }\n                    }\n                };\n\n                Promise.using = function () {\n                    var len = arguments.length;\n                    if (len < 2) return apiRejection(\"you must pass at least 2 arguments to Promise.using\");\n                    var fn = arguments[len - 1];\n                    if (typeof fn !== \"function\") {\n                        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n                    }\n                    var input;\n                    var spreadArgs = true;\n                    if (len === 2 && Array.isArray(arguments[0])) {\n                        input = arguments[0];\n                        len = input.length;\n                        spreadArgs = false;\n                    } else {\n                        input = arguments;\n                        len--;\n                    }\n                    var resources = new ResourceList(len);\n                    for (var i = 0; i < len; ++i) {\n                        var resource = input[i];\n                        if (Disposer.isDisposer(resource)) {\n                            var disposer = resource;\n                            resource = resource.promise();\n                            resource._setDisposable(disposer);\n                        } else {\n                            var maybePromise = tryConvertToPromise(resource);\n                            if (maybePromise instanceof Promise) {\n                                resource = maybePromise._then(maybeUnwrapDisposer, null, null, {\n                                    resources: resources,\n                                    index: i\n                                }, undefined);\n                            }\n                        }\n                        resources[i] = resource;\n                    }\n\n                    var reflectedResources = new Array(resources.length);\n                    for (var i = 0; i < reflectedResources.length; ++i) {\n                        reflectedResources[i] = Promise.resolve(resources[i]).reflect();\n                    }\n\n                    var resultPromise = Promise.all(reflectedResources).then(function (inspections) {\n                        for (var i = 0; i < inspections.length; ++i) {\n                            var inspection = inspections[i];\n                            if (inspection.isRejected()) {\n                                errorObj.e = inspection.error();\n                                return errorObj;\n                            } else if (!inspection.isFulfilled()) {\n                                resultPromise.cancel();\n                                return;\n                            }\n                            inspections[i] = inspection.value();\n                        }\n                        promise._pushContext();\n\n                        fn = tryCatch(fn);\n                        var ret = spreadArgs ? fn.apply(undefined, inspections) : fn(inspections);\n                        var promiseCreated = promise._popContext();\n                        debug.checkForgottenReturns(ret, promiseCreated, \"Promise.using\", promise);\n                        return ret;\n                    });\n\n                    var promise = resultPromise.lastly(function () {\n                        var inspection = new Promise.PromiseInspection(resultPromise);\n                        return dispose(resources, inspection);\n                    });\n                    resources.promise = promise;\n                    promise._setOnCancel(resources);\n                    return promise;\n                };\n\n                Promise.prototype._setDisposable = function (disposer) {\n                    this._bitField = this._bitField | 131072;\n                    this._disposer = disposer;\n                };\n\n                Promise.prototype._isDisposable = function () {\n                    return (this._bitField & 131072) > 0;\n                };\n\n                Promise.prototype._getDisposer = function () {\n                    return this._disposer;\n                };\n\n                Promise.prototype._unsetDisposable = function () {\n                    this._bitField = this._bitField & ~131072;\n                    this._disposer = undefined;\n                };\n\n                Promise.prototype.disposer = function (fn) {\n                    if (typeof fn === \"function\") {\n                        return new FunctionDisposer(fn, this, createContext());\n                    }\n                    throw new TypeError();\n                };\n            };\n        }, { \"./errors\": 12, \"./util\": 36 }], 36: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            var es5 = _dereq_(\"./es5\");\n            var canEvaluate = typeof navigator == \"undefined\";\n\n            var errorObj = { e: {} };\n            var tryCatchTarget;\n            var globalObject = typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : this !== undefined ? this : null;\n\n            function tryCatcher() {\n                try {\n                    var target = tryCatchTarget;\n                    tryCatchTarget = null;\n                    return target.apply(this, arguments);\n                } catch (e) {\n                    errorObj.e = e;\n                    return errorObj;\n                }\n            }\n            function tryCatch(fn) {\n                tryCatchTarget = fn;\n                return tryCatcher;\n            }\n\n            var inherits = function inherits(Child, Parent) {\n                var hasProp = {}.hasOwnProperty;\n\n                function T() {\n                    this.constructor = Child;\n                    this.constructor$ = Parent;\n                    for (var propertyName in Parent.prototype) {\n                        if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== \"$\") {\n                            this[propertyName + \"$\"] = Parent.prototype[propertyName];\n                        }\n                    }\n                }\n                T.prototype = Parent.prototype;\n                Child.prototype = new T();\n                return Child.prototype;\n            };\n\n            function isPrimitive(val) {\n                return val == null || val === true || val === false || typeof val === \"string\" || typeof val === \"number\";\n            }\n\n            function isObject(value) {\n                return typeof value === \"function\" || (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\" && value !== null;\n            }\n\n            function maybeWrapAsError(maybeError) {\n                if (!isPrimitive(maybeError)) return maybeError;\n\n                return new Error(safeToString(maybeError));\n            }\n\n            function withAppended(target, appendee) {\n                var len = target.length;\n                var ret = new Array(len + 1);\n                var i;\n                for (i = 0; i < len; ++i) {\n                    ret[i] = target[i];\n                }\n                ret[i] = appendee;\n                return ret;\n            }\n\n            function getDataPropertyOrDefault(obj, key, defaultValue) {\n                if (es5.isES5) {\n                    var desc = Object.getOwnPropertyDescriptor(obj, key);\n\n                    if (desc != null) {\n                        return desc.get == null && desc.set == null ? desc.value : defaultValue;\n                    }\n                } else {\n                    return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;\n                }\n            }\n\n            function notEnumerableProp(obj, name, value) {\n                if (isPrimitive(obj)) return obj;\n                var descriptor = {\n                    value: value,\n                    configurable: true,\n                    enumerable: false,\n                    writable: true\n                };\n                es5.defineProperty(obj, name, descriptor);\n                return obj;\n            }\n\n            function thrower(r) {\n                throw r;\n            }\n\n            var inheritedDataKeys = function () {\n                var excludedPrototypes = [Array.prototype, Object.prototype, Function.prototype];\n\n                var isExcludedProto = function isExcludedProto(val) {\n                    for (var i = 0; i < excludedPrototypes.length; ++i) {\n                        if (excludedPrototypes[i] === val) {\n                            return true;\n                        }\n                    }\n                    return false;\n                };\n\n                if (es5.isES5) {\n                    var getKeys = Object.getOwnPropertyNames;\n                    return function (obj) {\n                        var ret = [];\n                        var visitedKeys = Object.create(null);\n                        while (obj != null && !isExcludedProto(obj)) {\n                            var keys;\n                            try {\n                                keys = getKeys(obj);\n                            } catch (e) {\n                                return ret;\n                            }\n                            for (var i = 0; i < keys.length; ++i) {\n                                var key = keys[i];\n                                if (visitedKeys[key]) continue;\n                                visitedKeys[key] = true;\n                                var desc = Object.getOwnPropertyDescriptor(obj, key);\n                                if (desc != null && desc.get == null && desc.set == null) {\n                                    ret.push(key);\n                                }\n                            }\n                            obj = es5.getPrototypeOf(obj);\n                        }\n                        return ret;\n                    };\n                } else {\n                    var hasProp = {}.hasOwnProperty;\n                    return function (obj) {\n                        if (isExcludedProto(obj)) return [];\n                        var ret = [];\n\n                        /*jshint forin:false */\n                        enumeration: for (var key in obj) {\n                            if (hasProp.call(obj, key)) {\n                                ret.push(key);\n                            } else {\n                                for (var i = 0; i < excludedPrototypes.length; ++i) {\n                                    if (hasProp.call(excludedPrototypes[i], key)) {\n                                        continue enumeration;\n                                    }\n                                }\n                                ret.push(key);\n                            }\n                        }\n                        return ret;\n                    };\n                }\n            }();\n\n            var thisAssignmentPattern = /this\\s*\\.\\s*\\S+\\s*=/;\n            function isClass(fn) {\n                try {\n                    if (typeof fn === \"function\") {\n                        var keys = es5.names(fn.prototype);\n\n                        var hasMethods = es5.isES5 && keys.length > 1;\n                        var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === \"constructor\");\n                        var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + \"\") && es5.names(fn).length > 0;\n\n                        if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {\n                            return true;\n                        }\n                    }\n                    return false;\n                } catch (e) {\n                    return false;\n                }\n            }\n\n            function toFastProperties(obj) {\n                /*jshint -W027,-W055,-W031*/\n                function FakeConstructor() {}\n                FakeConstructor.prototype = obj;\n                var l = 8;\n                while (l--) {\n                    new FakeConstructor();\n                }return obj;\n                eval(obj);\n            }\n\n            var rident = /^[a-z$_][a-z$_0-9]*$/i;\n            function isIdentifier(str) {\n                return rident.test(str);\n            }\n\n            function filledRange(count, prefix, suffix) {\n                var ret = new Array(count);\n                for (var i = 0; i < count; ++i) {\n                    ret[i] = prefix + i + suffix;\n                }\n                return ret;\n            }\n\n            function safeToString(obj) {\n                try {\n                    return obj + \"\";\n                } catch (e) {\n                    return \"[no string representation]\";\n                }\n            }\n\n            function isError(obj) {\n                return obj !== null && (typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) === \"object\" && typeof obj.message === \"string\" && typeof obj.name === \"string\";\n            }\n\n            function markAsOriginatingFromRejection(e) {\n                try {\n                    notEnumerableProp(e, \"isOperational\", true);\n                } catch (ignore) {}\n            }\n\n            function originatesFromRejection(e) {\n                if (e == null) return false;\n                return e instanceof Error[\"__BluebirdErrorTypes__\"].OperationalError || e[\"isOperational\"] === true;\n            }\n\n            function canAttachTrace(obj) {\n                return isError(obj) && es5.propertyIsWritable(obj, \"stack\");\n            }\n\n            var ensureErrorObject = function () {\n                if (!(\"stack\" in new Error())) {\n                    return function (value) {\n                        if (canAttachTrace(value)) return value;\n                        try {\n                            throw new Error(safeToString(value));\n                        } catch (err) {\n                            return err;\n                        }\n                    };\n                } else {\n                    return function (value) {\n                        if (canAttachTrace(value)) return value;\n                        return new Error(safeToString(value));\n                    };\n                }\n            }();\n\n            function classString(obj) {\n                return {}.toString.call(obj);\n            }\n\n            function copyDescriptors(from, to, filter) {\n                var keys = es5.names(from);\n                for (var i = 0; i < keys.length; ++i) {\n                    var key = keys[i];\n                    if (filter(key)) {\n                        try {\n                            es5.defineProperty(to, key, es5.getDescriptor(from, key));\n                        } catch (ignore) {}\n                    }\n                }\n            }\n\n            var asArray = function asArray(v) {\n                if (es5.isArray(v)) {\n                    return v;\n                }\n                return null;\n            };\n\n            if (typeof Symbol !== \"undefined\" && Symbol.iterator) {\n                var ArrayFrom = typeof Array.from === \"function\" ? function (v) {\n                    return Array.from(v);\n                } : function (v) {\n                    var ret = [];\n                    var it = v[Symbol.iterator]();\n                    var itResult;\n                    while (!(itResult = it.next()).done) {\n                        ret.push(itResult.value);\n                    }\n                    return ret;\n                };\n\n                asArray = function asArray(v) {\n                    if (es5.isArray(v)) {\n                        return v;\n                    } else if (v != null && typeof v[Symbol.iterator] === \"function\") {\n                        return ArrayFrom(v);\n                    }\n                    return null;\n                };\n            }\n\n            var isNode = typeof process !== \"undefined\" && classString(process).toLowerCase() === \"[object process]\";\n\n            var hasEnvVariables = typeof process !== \"undefined\" && \"object\" !== \"undefined\";\n\n            function env(key) {\n                return hasEnvVariables ? Object({\"NODE_ENV\":\"development\",\"SIMULATED\":\"true\",\"FLATLINE_APP_ID\":\"tsumtsum-dev\",\"FLATLINE_HOST\":\"https://deferred-actions-a4365e9-dot-wintermute-151001.appspot.com\",\"FLATLINE_USE_V2_SESSION\":\"true\",\"FLATLINE_ADMIN_TOKEN\":\"tsumtsum_5601879890534\",\"FREESIDE_HOST\":\"https://onions.science\",\"FREESIDE_CONTEXT_STORAGE_HOST\":\"https://context-storage-dot-freeside-152323.appspot.com\",\"SOCIAL_MESSAGING_HOST\":\"https://sms-dot-wintermute-151001.appspot.com\",\"FB_INSTANT_USE_MOCK_DATA\":\"true\",\"FB_INSTANT_MOCK_SIGNATURE\":\"b67607cb5ecba55fbcc3c72771ebf9df\",\"COMMITHASH\":\"94ac762\",\"GIT_BRANCH\":\"sim_garrett\",\"BUILD_NUMBER\":\"-1\",\"IS_TEST\":undefined,\"IS_AUTOMATED\":undefined})[key] : undefined;\n            }\n\n            function getNativePromise() {\n                if (typeof Promise === \"function\") {\n                    try {\n                        var promise = new Promise(function () {});\n                        if ({}.toString.call(promise) === \"[object Promise]\") {\n                            return Promise;\n                        }\n                    } catch (e) {}\n                }\n            }\n\n            function domainBind(self, cb) {\n                return self.bind(cb);\n            }\n\n            var ret = {\n                isClass: isClass,\n                isIdentifier: isIdentifier,\n                inheritedDataKeys: inheritedDataKeys,\n                getDataPropertyOrDefault: getDataPropertyOrDefault,\n                thrower: thrower,\n                isArray: es5.isArray,\n                asArray: asArray,\n                notEnumerableProp: notEnumerableProp,\n                isPrimitive: isPrimitive,\n                isObject: isObject,\n                isError: isError,\n                canEvaluate: canEvaluate,\n                errorObj: errorObj,\n                tryCatch: tryCatch,\n                inherits: inherits,\n                withAppended: withAppended,\n                maybeWrapAsError: maybeWrapAsError,\n                toFastProperties: toFastProperties,\n                filledRange: filledRange,\n                toString: safeToString,\n                canAttachTrace: canAttachTrace,\n                ensureErrorObject: ensureErrorObject,\n                originatesFromRejection: originatesFromRejection,\n                markAsOriginatingFromRejection: markAsOriginatingFromRejection,\n                classString: classString,\n                copyDescriptors: copyDescriptors,\n                hasDevTools: typeof chrome !== \"undefined\" && chrome && typeof chrome.loadTimes === \"function\",\n                isNode: isNode,\n                hasEnvVariables: hasEnvVariables,\n                env: env,\n                global: globalObject,\n                getNativePromise: getNativePromise,\n                domainBind: domainBind\n            };\n            ret.isRecentNode = ret.isNode && function () {\n                var version = process.versions.node.split(\".\").map(Number);\n                return version[0] === 0 && version[1] > 10 || version[0] > 0;\n            }();\n\n            if (ret.isNode) ret.toFastProperties(process);\n\n            try {\n                throw new Error();\n            } catch (e) {\n                ret.lastLineError = e;\n            }\n            module.exports = ret;\n        }, { \"./es5\": 13 }] }, {}, [4])(4);\n});;if (typeof window !== 'undefined' && window !== null) {\n    window.P = window.Promise;\n} else if (typeof self !== 'undefined' && self !== null) {\n    self.P = self.Promise;\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/process/browser.js */ 6), __webpack_require__(/*! ./../../../webpack/buildin/global.js */ 9)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvYnJvd3Nlci9ibHVlYmlyZC5qcz9hMzFlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJ1SkFBQTs7QUFFQSxvR0FBb0csbUJBQW1CLEVBQUUsbUJBQW1CLDhIQUE4SDs7QUFFMVE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9IQUE0STtBQUFBO0FBQUE7QUFBQSxxR0FBa0U7QUFDOU0sY0FBYztBQUNkO0FBQ0EsQ0FBQztBQUNELGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsNkJBQTZCLHVCQUF1QixvREFBb0Q7QUFDNUssaUJBQWlCLGdCQUFnQixZQUFZLEdBQUc7QUFDaEQsdUNBQXVDO0FBQ3ZDLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUyxnREFBZ0QsZUFBZSxjQUFjO0FBQ3RGO0FBQ0EsU0FBUztBQUNULEtBQUssRUFBRTtBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLEdBQUcsZ0RBQWdEO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUcsa0JBQWtCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0Esa0NBQWtDO0FBQ2xDLDRDQUE0QztBQUM1Qyx5QkFBeUI7QUFDekIsdURBQXVEO0FBQ3ZELGdFQUFnRTtBQUNoRSx5RUFBeUU7QUFDekUsZ0RBQWdEO0FBQ2hEO0FBQ0EsMkRBQTJEO0FBQzNELGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGdDQUFnQztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHLGVBQWU7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLDZCQUE2QjtBQUNwRTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUcsZUFBZTtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxzQkFBc0I7QUFDNUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSwrQ0FBK0MsaUJBQWlCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsR0FBRyw0QkFBNEI7QUFDeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxxQkFBcUI7QUFDckI7QUFDQSxnQ0FBZ0M7QUFDaEMscUJBQXFCO0FBQ3JCO0FBQ0EsZ0NBQWdDO0FBQ2hDLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsUUFBUTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyx1QkFBdUI7O0FBRXRFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyx1QkFBdUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxtQkFBbUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsbUJBQW1CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseURBQXlELFFBQVE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsa0JBQWtCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLGtCQUFrQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNEJBQTRCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDJCQUEyQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRCxvQkFBb0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFlBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHLCtCQUErQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUVBQXVFLGVBQWU7QUFDdEY7O0FBRUE7QUFDQSxzRUFBc0UsaUJBQWlCO0FBQ3ZGOztBQUVBO0FBQ0E7QUFDQSwwRUFBMEUsaUJBQWlCO0FBQzNGLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsZUFBZTtBQUMxRixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBLG1DQUFtQyxrQkFBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRyw0QkFBNEI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsYUFBYTtBQUNoRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxHQUFHLG9DQUFvQztBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQywwQkFBMEI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHLCtCQUErQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsa0NBQWtDO0FBQ2xDLDBDQUEwQztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQyxrQkFBa0I7QUFDN0Q7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRSxnRUFBZ0U7QUFDaEU7QUFDQSx1Q0FBdUM7QUFDdkMsaURBQWlEO0FBQ2pELHFDQUFxQztBQUNyQyxpQkFBaUI7QUFDakI7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQSw2RkFBNkY7QUFDN0YseUJBQXlCO0FBQ3pCLG9DQUFvQztBQUNwQztBQUNBLDZCQUE2QjtBQUM3Qix3Q0FBd0M7QUFDeEMsNkJBQTZCO0FBQzdCLGFBQWE7QUFDYjtBQUNBLG1FQUFtRTtBQUNuRSx1Q0FBdUM7QUFDdkMsa0VBQWtFO0FBQ2xFLHNDQUFzQztBQUN0Qyx1Q0FBdUM7QUFDdkMsMERBQTBEO0FBQzFELGlCQUFpQixPQUFPO0FBQ3hCLGtEQUFrRDtBQUNsRCxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0Esc0VBQXNFO0FBQ3RFLHFDQUFxQztBQUNyQyx5Q0FBeUM7QUFDekMsMkNBQTJDO0FBQzNDLHdFQUF3RTtBQUN4RSxxQkFBcUIsT0FBTztBQUM1QixvREFBb0Q7QUFDcEQscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBLCtEQUErRDtBQUMvRDtBQUNBLGNBQWM7QUFDZDtBQUNBLDZCQUE2QjtBQUM3QixTQUFTLHFDQUFxQztBQUM5Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0MsVUFBVTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRyxlQUFlO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUcsZUFBZTtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRyxlQUFlO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxHQUFHLDRDQUE0QztBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHLGVBQWU7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsZUFBZTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDLDJCQUEyQixPQUFPO0FBQ2xDLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRywya0JBQTJrQjtBQUN2bEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLHVDQUF1QyxtQkFBbUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsR0FBRyxlQUFlO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0JBQWdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsVUFBVTtBQUN2RTtBQUNBO0FBQ0EsNkRBQTZELFFBQVE7QUFDckU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxNQUFNLFlBQVksT0FBTztBQUM1Riw2QkFBNkI7QUFDN0IsaUZBQWlGLE1BQU0sWUFBWSxPQUFPLHVDQUF1QyxNQUFNLFlBQVksT0FBTztBQUMxSztBQUNBLGtEQUFrRCxNQUFNO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsMEJBQTBCO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxzQkFBc0I7QUFDdEIsMkJBQTJCLFNBQVMsT0FBTztBQUMzQyxzQ0FBc0M7QUFDdEMsYUFBYTtBQUNiLCtCQUErQjtBQUMvQjtBQUNBLGtCQUFrQjtBQUNsQix1RkFBdUYsNENBQTRDO0FBQ25JO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7QUFDakQseUNBQXlDO0FBQ3pDLHlCQUF5QjtBQUN6Qix1Q0FBdUM7QUFDdkMsZ0RBQWdEO0FBQ2hELHlDQUF5QztBQUN6QywwRUFBMEU7QUFDMUUsb0JBQW9CO0FBQ3BCLHVEQUF1RDtBQUN2RCx5QkFBeUI7QUFDekI7QUFDQSxhQUFhO0FBQ2IsbUNBQW1DO0FBQ25DLDZFQUE2RTtBQUM3RSxhQUFhO0FBQ2Isd0VBQXdFO0FBQ3hFLDJCQUEyQjtBQUMzQixVQUFVO0FBQ1YsMERBQTBEO0FBQzFELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5REFBeUQsU0FBUztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRyxpREFBaUQ7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxnRUFBZ0UsU0FBUztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRyw0QkFBNEI7QUFDeEM7O0FBRUE7QUFDQSwrQkFBK0IsU0FBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsU0FBUztBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHLGVBQWU7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw4QkFBOEIsWUFBWTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRyxlQUFlO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHLGVBQWU7QUFDM0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUcsZUFBZTtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHlCQUF5QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsR0FBRywrQkFBK0I7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsR0FBRyxlQUFlO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUcsZUFBZTtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQywrQkFBK0I7QUFDbEU7QUFDQTs7QUFFQTtBQUNBLHVDQUF1Qyx3QkFBd0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHLCtCQUErQjtBQUMzQzs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLCtCQUErQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSwyQ0FBMkMsaUJBQWlCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLCtDQUErQywrQkFBK0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixXQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEUsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUcsY0FBYyxHQUFHLElBQUk7QUFDakMsQ0FBQyxHQUFHO0FBQ0o7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4vKiBAcHJlc2VydmVcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNyBQZXRrYSBBbnRvbm92XG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKiBcbiAqL1xuLyoqXG4gKiBibHVlYmlyZCBidWlsZCB2ZXJzaW9uIDMuNS4wXG4gKiBGZWF0dXJlcyBlbmFibGVkOiBjb3JlLCByYWNlLCBjYWxsX2dldCwgZ2VuZXJhdG9ycywgbWFwLCBub2RlaWZ5LCBwcm9taXNpZnksIHByb3BzLCByZWR1Y2UsIHNldHRsZSwgc29tZSwgdXNpbmcsIHRpbWVycywgZmlsdGVyLCBhbnksIGVhY2hcbiovXG4hZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoXCJvYmplY3RcIiA9PSAodHlwZW9mIGV4cG9ydHMgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihleHBvcnRzKSkgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgbW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IGUoKTtlbHNlIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kKSBkZWZpbmUoW10sIGUpO2Vsc2Uge1xuICAgICAgICB2YXIgZjtcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB3aW5kb3cgPyBmID0gd2luZG93IDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZ2xvYmFsID8gZiA9IGdsb2JhbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHNlbGYgJiYgKGYgPSBzZWxmKSwgZi5Qcm9taXNlID0gZSgpO1xuICAgIH1cbn0oZnVuY3Rpb24gKCkge1xuICAgIHZhciBkZWZpbmUsIG1vZHVsZSwgZXhwb3J0cztyZXR1cm4gZnVuY3Rpb24gZSh0LCBuLCByKSB7XG4gICAgICAgIGZ1bmN0aW9uIHMobywgdSkge1xuICAgICAgICAgICAgaWYgKCFuW29dKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0W29dKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gdHlwZW9mIF9kZXJlcV8gPT0gXCJmdW5jdGlvblwiICYmIF9kZXJlcV87aWYgKCF1ICYmIGEpIHJldHVybiBhKG8sICEwKTtpZiAoaSkgcmV0dXJuIGkobywgITApO3ZhciBmID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIG8gKyBcIidcIik7dGhyb3cgZi5jb2RlID0gXCJNT0RVTEVfTk9UX0ZPVU5EXCIsIGY7XG4gICAgICAgICAgICAgICAgfXZhciBsID0gbltvXSA9IHsgZXhwb3J0czoge30gfTt0W29dWzBdLmNhbGwobC5leHBvcnRzLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHRbb11bMV1bZV07cmV0dXJuIHMobiA/IG4gOiBlKTtcbiAgICAgICAgICAgICAgICB9LCBsLCBsLmV4cG9ydHMsIGUsIHQsIG4sIHIpO1xuICAgICAgICAgICAgfXJldHVybiBuW29dLmV4cG9ydHM7XG4gICAgICAgIH12YXIgaSA9IHR5cGVvZiBfZGVyZXFfID09IFwiZnVuY3Rpb25cIiAmJiBfZGVyZXFfO2ZvciAodmFyIG8gPSAwOyBvIDwgci5sZW5ndGg7IG8rKykge1xuICAgICAgICAgICAgcyhyW29dKTtcbiAgICAgICAgfXJldHVybiBzO1xuICAgIH0oeyAxOiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgU29tZVByb21pc2VBcnJheSA9IFByb21pc2UuX1NvbWVQcm9taXNlQXJyYXk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYW55KHByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBuZXcgU29tZVByb21pc2VBcnJheShwcm9taXNlcyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gcmV0LnByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnNldEhvd01hbnkoMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldC5zZXRVbndyYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0LmluaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5hbnkgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFueShwcm9taXNlcyk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLmFueSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFueSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwge31dLCAyOiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICAgIHZhciBmaXJzdExpbmVFcnJvcjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RMaW5lRXJyb3IgPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNjaGVkdWxlID0gX2RlcmVxXyhcIi4vc2NoZWR1bGVcIik7XG4gICAgICAgICAgICB2YXIgUXVldWUgPSBfZGVyZXFfKFwiLi9xdWV1ZVwiKTtcbiAgICAgICAgICAgIHZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gQXN5bmMoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VzdG9tU2NoZWR1bGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNUaWNrVXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhdGVRdWV1ZSA9IG5ldyBRdWV1ZSgxNik7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9ybWFsUXVldWUgPSBuZXcgUXVldWUoMTYpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhdmVEcmFpbmVkUXVldWVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbXBvbGluZUVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWluUXVldWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9kcmFpblF1ZXVlcygpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGUgPSBzY2hlZHVsZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQXN5bmMucHJvdG90eXBlLnNldFNjaGVkdWxlciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2ID0gdGhpcy5fc2NoZWR1bGU7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGUgPSBmbjtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXN0b21TY2hlZHVsZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgQXN5bmMucHJvdG90eXBlLmhhc0N1c3RvbVNjaGVkdWxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY3VzdG9tU2NoZWR1bGVyO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgQXN5bmMucHJvdG90eXBlLmVuYWJsZVRyYW1wb2xpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbXBvbGluZUVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgQXN5bmMucHJvdG90eXBlLmRpc2FibGVUcmFtcG9saW5lSWZOZWNlc3NhcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWwuaGFzRGV2VG9vbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhbXBvbGluZUVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBBc3luYy5wcm90b3R5cGUuaGF2ZUl0ZW1zUXVldWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1RpY2tVc2VkIHx8IHRoaXMuX2hhdmVEcmFpbmVkUXVldWVzO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgQXN5bmMucHJvdG90eXBlLmZhdGFsRXJyb3IgPSBmdW5jdGlvbiAoZSwgaXNOb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLnN0ZGVyci53cml0ZShcIkZhdGFsIFwiICsgKGUgaW5zdGFuY2VvZiBFcnJvciA/IGUuc3RhY2sgOiBlKSArIFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLmV4aXQoMik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd0xhdGVyKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIEFzeW5jLnByb3RvdHlwZS50aHJvd0xhdGVyID0gZnVuY3Rpb24gKGZuLCBhcmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBhcmcgPSBmbjtcbiAgICAgICAgICAgICAgICAgICAgZm4gPSBmdW5jdGlvbiBmbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm4oYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuKGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXN5bmMgc2NoZWR1bGVyIGF2YWlsYWJsZVxcblxcbiAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXG5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gQXN5bmNJbnZva2VMYXRlcihmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhdGVRdWV1ZS5wdXNoKGZuLCByZWNlaXZlciwgYXJnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZVRpY2soKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gQXN5bmNJbnZva2UoZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ub3JtYWxRdWV1ZS5wdXNoKGZuLCByZWNlaXZlciwgYXJnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZVRpY2soKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gQXN5bmNTZXR0bGVQcm9taXNlcyhwcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9ybWFsUXVldWUuX3B1c2hPbmUocHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVUaWNrKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdXRpbC5oYXNEZXZUb29scykge1xuICAgICAgICAgICAgICAgIEFzeW5jLnByb3RvdHlwZS5pbnZva2VMYXRlciA9IEFzeW5jSW52b2tlTGF0ZXI7XG4gICAgICAgICAgICAgICAgQXN5bmMucHJvdG90eXBlLmludm9rZSA9IEFzeW5jSW52b2tlO1xuICAgICAgICAgICAgICAgIEFzeW5jLnByb3RvdHlwZS5zZXR0bGVQcm9taXNlcyA9IEFzeW5jU2V0dGxlUHJvbWlzZXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIEFzeW5jLnByb3RvdHlwZS5pbnZva2VMYXRlciA9IGZ1bmN0aW9uIChmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHJhbXBvbGluZUVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFzeW5jSW52b2tlTGF0ZXIuY2FsbCh0aGlzLCBmbiwgcmVjZWl2ZXIsIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY2hlZHVsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuLmNhbGwocmVjZWl2ZXIsIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIEFzeW5jLnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbiAoZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RyYW1wb2xpbmVFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBc3luY0ludm9rZS5jYWxsKHRoaXMsIGZuLCByZWNlaXZlciwgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbi5jYWxsKHJlY2VpdmVyLCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgQXN5bmMucHJvdG90eXBlLnNldHRsZVByb21pc2VzID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RyYW1wb2xpbmVFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBc3luY1NldHRsZVByb21pc2VzLmNhbGwodGhpcywgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY2hlZHVsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5fc2V0dGxlUHJvbWlzZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQXN5bmMucHJvdG90eXBlLl9kcmFpblF1ZXVlID0gZnVuY3Rpb24gKHF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCgpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuLl9zZXR0bGVQcm9taXNlcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY2VpdmVyID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuLmNhbGwocmVjZWl2ZXIsIGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgQXN5bmMucHJvdG90eXBlLl9kcmFpblF1ZXVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFpblF1ZXVlKHRoaXMuX25vcm1hbFF1ZXVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhdmVEcmFpbmVkUXVldWVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFpblF1ZXVlKHRoaXMuX2xhdGVRdWV1ZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBBc3luYy5wcm90b3R5cGUuX3F1ZXVlVGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzVGlja1VzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNUaWNrVXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlKHRoaXMuZHJhaW5RdWV1ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIEFzeW5jLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNUaWNrVXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBBc3luYztcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzLmZpcnN0TGluZUVycm9yID0gZmlyc3RMaW5lRXJyb3I7XG4gICAgICAgIH0sIHsgXCIuL3F1ZXVlXCI6IDI2LCBcIi4vc2NoZWR1bGVcIjogMjksIFwiLi91dGlsXCI6IDM2IH1dLCAzOiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBkZWJ1Zykge1xuICAgICAgICAgICAgICAgIHZhciBjYWxsZWRCaW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIHJlamVjdFRoaXMgPSBmdW5jdGlvbiByZWplY3RUaGlzKF8sIGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0UmVqZWN0ZWQgPSBmdW5jdGlvbiB0YXJnZXRSZWplY3RlZChlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucHJvbWlzZVJlamVjdGlvblF1ZXVlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYmluZGluZ1Byb21pc2UuX3RoZW4ocmVqZWN0VGhpcywgcmVqZWN0VGhpcywgbnVsbCwgdGhpcywgZSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBiaW5kaW5nUmVzb2x2ZWQgPSBmdW5jdGlvbiBiaW5kaW5nUmVzb2x2ZWQodGhpc0FyZywgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMuX2JpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlQ2FsbGJhY2soY29udGV4dC50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBiaW5kaW5nUmVqZWN0ZWQgPSBmdW5jdGlvbiBiaW5kaW5nUmVqZWN0ZWQoZSwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQucHJvbWlzZVJlamVjdGlvblF1ZXVlZCkgdGhpcy5fcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKHRoaXNBcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWxsZWRCaW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsZWRCaW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9wcm9wYWdhdGVGcm9tID0gZGVidWcucHJvcGFnYXRlRnJvbUZ1bmN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fYm91bmRWYWx1ZSA9IGRlYnVnLmJvdW5kVmFsdWVGdW5jdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHRoaXNBcmcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICAgICAgICAgICAgICByZXQuX3Byb3BhZ2F0ZUZyb20odGhpcywgMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0Ll9zZXRCb3VuZFRvKG1heWJlUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVqZWN0aW9uUXVldWVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlOiByZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluZGluZ1Byb21pc2U6IG1heWJlUHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5fdGhlbihJTlRFUk5BTCwgdGFyZ2V0UmVqZWN0ZWQsIHVuZGVmaW5lZCwgcmV0LCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fdGhlbihiaW5kaW5nUmVzb2x2ZWQsIGJpbmRpbmdSZWplY3RlZCwgdW5kZWZpbmVkLCByZXQsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0Ll9zZXRPbkNhbmNlbChtYXliZVByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0Ll9yZXNvbHZlQ2FsbGJhY2sodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fc2V0Qm91bmRUbyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMjA5NzE1MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2JvdW5kVG8gPSBvYmo7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkICYgfjIwOTcxNTI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2lzQm91bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAyMDk3MTUyKSA9PT0gMjA5NzE1MjtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5iaW5kID0gZnVuY3Rpb24gKHRoaXNBcmcsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLmJpbmQodGhpc0FyZyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHt9XSwgNDogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgICB2YXIgb2xkO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiKSBvbGQgPSBQcm9taXNlO1xuICAgICAgICAgICAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoUHJvbWlzZSA9PT0gYmx1ZWJpcmQpIFByb21pc2UgPSBvbGQ7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgICByZXR1cm4gYmx1ZWJpcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYmx1ZWJpcmQgPSBfZGVyZXFfKFwiLi9wcm9taXNlXCIpKCk7XG4gICAgICAgICAgICBibHVlYmlyZC5ub0NvbmZsaWN0ID0gbm9Db25mbGljdDtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gYmx1ZWJpcmQ7XG4gICAgICAgIH0sIHsgXCIuL3Byb21pc2VcIjogMjIgfV0sIDU6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgICAgdmFyIGNyID0gT2JqZWN0LmNyZWF0ZTtcbiAgICAgICAgICAgIGlmIChjcikge1xuICAgICAgICAgICAgICAgIHZhciBjYWxsZXJDYWNoZSA9IGNyKG51bGwpO1xuICAgICAgICAgICAgICAgIHZhciBnZXR0ZXJDYWNoZSA9IGNyKG51bGwpO1xuICAgICAgICAgICAgICAgIGNhbGxlckNhY2hlW1wiIHNpemVcIl0gPSBnZXR0ZXJDYWNoZVtcIiBzaXplXCJdID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgY2FuRXZhbHVhdGUgPSB1dGlsLmNhbkV2YWx1YXRlO1xuICAgICAgICAgICAgICAgIHZhciBpc0lkZW50aWZpZXIgPSB1dGlsLmlzSWRlbnRpZmllcjtcblxuICAgICAgICAgICAgICAgIHZhciBnZXRNZXRob2RDYWxsZXI7XG4gICAgICAgICAgICAgICAgdmFyIGdldEdldHRlcjtcbiAgICAgICAgICAgICAgICBpZiAoIXRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ha2VNZXRob2RDYWxsZXIgPSBmdW5jdGlvbiBtYWtlTWV0aG9kQ2FsbGVyKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJlbnN1cmVNZXRob2RcIiwgXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgZW5zdXJlTWV0aG9kKG9iaiwgJ21ldGhvZE5hbWUnKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgc3dpdGNoKGxlbikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG9iai5tZXRob2ROYW1lKHRoaXNbMF0pOyAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG9iai5tZXRob2ROYW1lKHRoaXNbMF0sIHRoaXNbMV0pOyAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIG9iai5tZXRob2ROYW1lKHRoaXNbMF0sIHRoaXNbMV0sIHRoaXNbMl0pOyAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG9iai5tZXRob2ROYW1lKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqLm1ldGhvZE5hbWUuYXBwbHkob2JqLCB0aGlzKTsgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBcIi5yZXBsYWNlKC9tZXRob2ROYW1lL2csIG1ldGhvZE5hbWUpKShlbnN1cmVNZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYWtlR2V0dGVyID0gZnVuY3Rpb24gbWFrZUdldHRlcihwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJvYmpcIiwgXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAndXNlIHN0cmljdCc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICByZXR1cm4gb2JqLnByb3BlcnR5TmFtZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBcIi5yZXBsYWNlKFwicHJvcGVydHlOYW1lXCIsIHByb3BlcnR5TmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXRDb21waWxlZCA9IGZ1bmN0aW9uIGdldENvbXBpbGVkKG5hbWUsIGNvbXBpbGVyLCBjYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IGNhY2hlW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNJZGVudGlmaWVyKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBjb21waWxlcihuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZVtuYW1lXSA9IHJldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZVtcIiBzaXplXCJdKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlW1wiIHNpemVcIl0gPiA1MTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfWNhY2hlW1wiIHNpemVcIl0gPSBrZXlzLmxlbmd0aCAtIDI1NjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGdldE1ldGhvZENhbGxlciA9IGZ1bmN0aW9uIGdldE1ldGhvZENhbGxlcihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcGlsZWQobmFtZSwgbWFrZU1ldGhvZENhbGxlciwgY2FsbGVyQ2FjaGUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGdldEdldHRlciA9IGZ1bmN0aW9uIGdldEdldHRlcihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcGlsZWQobmFtZSwgbWFrZUdldHRlciwgZ2V0dGVyQ2FjaGUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGVuc3VyZU1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqICE9IG51bGwpIGZuID0gb2JqW21ldGhvZE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gXCJPYmplY3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKG9iaikgKyBcIiBoYXMgbm8gbWV0aG9kICdcIiArIHV0aWwudG9TdHJpbmcobWV0aG9kTmFtZSkgKyBcIidcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQcm9taXNlLlR5cGVFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY2FsbGVyKG9iaikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IHRoaXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IGVuc3VyZU1ldGhvZChvYmosIG1ldGhvZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkob2JqLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FuRXZhbHVhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF5YmVDYWxsZXIgPSBnZXRNZXRob2RDYWxsZXIobWV0aG9kTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlQ2FsbGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90aGVuKG1heWJlQ2FsbGVyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJncywgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKG1ldGhvZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhlbihjYWxsZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcmdzLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBuYW1lZEdldHRlcihvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ialt0aGlzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaW5kZXhlZEdldHRlcihvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gK3RoaXM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIGluZGV4ID0gTWF0aC5tYXgoMCwgaW5kZXggKyBvYmoubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ialtpbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzSW5kZXggPSB0eXBlb2YgcHJvcGVydHlOYW1lID09PSBcIm51bWJlclwiO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0dGVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5FdmFsdWF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXliZUdldHRlciA9IGdldEdldHRlcihwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldHRlciA9IG1heWJlR2V0dGVyICE9PSBudWxsID8gbWF5YmVHZXR0ZXIgOiBuYW1lZEdldHRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0dGVyID0gbmFtZWRHZXR0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXR0ZXIgPSBpbmRleGVkR2V0dGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90aGVuKGdldHRlciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHByb3BlcnR5TmFtZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgeyBcIi4vdXRpbFwiOiAzNiB9XSwgNjogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChQcm9taXNlLCBQcm9taXNlQXJyYXksIGFwaVJlamVjdGlvbiwgZGVidWcpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG4gICAgICAgICAgICAgICAgdmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xuICAgICAgICAgICAgICAgIHZhciBhc3luYyA9IFByb21pc2UuX2FzeW5jO1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGVbXCJicmVha1wiXSA9IFByb21pc2UucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWJ1Zy5jYW5jZWxsYXRpb24oKSkgcmV0dXJuIHRoaXMuX3dhcm4oXCJjYW5jZWxsYXRpb24gaXMgZGlzYWJsZWRcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBwcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocHJvbWlzZS5faXNDYW5jZWxsYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByb21pc2UuX2NhbmNlbEJ5KGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5faXNGb2xsb3dpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5fZm9sbG93ZWUoKS5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5fY2FuY2VsQnJhbmNoZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBwcm9taXNlLl9jYW5jZWxsYXRpb25QYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ID09IG51bGwgfHwgIXBhcmVudC5faXNDYW5jZWxsYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb21pc2UuX2lzRm9sbG93aW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5fZm9sbG93ZWUoKS5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9jYW5jZWxCcmFuY2hlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb21pc2UuX2lzRm9sbG93aW5nKCkpIHByb21pc2UuX2ZvbGxvd2VlKCkuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5fc2V0V2lsbEJlQ2FuY2VsbGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBwcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2JyYW5jaEhhc0NhbmNlbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbC0tO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fZW5vdWdoQnJhbmNoZXNIYXZlQ2FuY2VsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX2JyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgPD0gMDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2NhbmNlbEJ5ID0gZnVuY3Rpb24gKGNhbmNlbGxlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuY2VsbGVyID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ludm9rZU9uQ2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2JyYW5jaEhhc0NhbmNlbGxlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Vub3VnaEJyYW5jaGVzSGF2ZUNhbmNlbGxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW52b2tlT25DYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9jYW5jZWxCcmFuY2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Vub3VnaEJyYW5jaGVzSGF2ZUNhbmNlbGxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzQ2FuY2VsbGFibGUoKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMuaW52b2tlKHRoaXMuX2NhbmNlbFByb21pc2VzLCB0aGlzLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fY2FuY2VsUHJvbWlzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sZW5ndGgoKSA+IDApIHRoaXMuX3NldHRsZVByb21pc2VzKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl91bnNldE9uQ2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkNhbmNlbEZpZWxkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5faXNDYW5jZWxsYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNQZW5kaW5nKCkgJiYgIXRoaXMuX2lzQ2FuY2VsbGVkKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLmlzQ2FuY2VsbGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzUGVuZGluZygpICYmICF0aGlzLmlzQ2FuY2VsbGVkKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9kb0ludm9rZU9uQ2FuY2VsID0gZnVuY3Rpb24gKG9uQ2FuY2VsQ2FsbGJhY2ssIGludGVybmFsT25seSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXRpbC5pc0FycmF5KG9uQ2FuY2VsQ2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9uQ2FuY2VsQ2FsbGJhY2subGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb0ludm9rZU9uQ2FuY2VsKG9uQ2FuY2VsQ2FsbGJhY2tbaV0sIGludGVybmFsT25seSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob25DYW5jZWxDYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9uQ2FuY2VsQ2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW50ZXJuYWxPbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gdHJ5Q2F0Y2gob25DYW5jZWxDYWxsYmFjaykuY2FsbCh0aGlzLl9ib3VuZFZhbHVlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F0dGFjaEV4dHJhVHJhY2UoZS5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jLnRocm93TGF0ZXIoZS5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DYW5jZWxDYWxsYmFjay5fcmVzdWx0Q2FuY2VsbGVkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9pbnZva2VPbkNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9uQ2FuY2VsQ2FsbGJhY2sgPSB0aGlzLl9vbkNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91bnNldE9uQ2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jLmludm9rZSh0aGlzLl9kb0ludm9rZU9uQ2FuY2VsLCB0aGlzLCBvbkNhbmNlbENhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2ludm9rZUludGVybmFsT25DYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0NhbmNlbGxhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvSW52b2tlT25DYW5jZWwodGhpcy5fb25DYW5jZWwoKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91bnNldE9uQ2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgeyBcIi4vdXRpbFwiOiAzNiB9XSwgNzogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChORVhUX0ZJTFRFUikge1xuICAgICAgICAgICAgICAgIHZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgZ2V0S2V5cyA9IF9kZXJlcV8oXCIuL2VzNVwiKS5rZXlzO1xuICAgICAgICAgICAgICAgIHZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNhdGNoRmlsdGVyKGluc3RhbmNlcywgY2IsIHByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm91bmRUbyA9IHByb21pc2UuX2JvdW5kVmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWRpY2F0ZUxvb3A6IGZvciAodmFyIGkgPSAwOyBpIDwgaW5zdGFuY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBpbnN0YW5jZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSA9PT0gRXJyb3IgfHwgaXRlbSAhPSBudWxsICYmIGl0ZW0ucHJvdG90eXBlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ5Q2F0Y2goY2IpLmNhbGwoYm91bmRUbywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoZXNQcmVkaWNhdGUgPSB0cnlDYXRjaChpdGVtKS5jYWxsKGJvdW5kVG8sIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlc1ByZWRpY2F0ZSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzUHJlZGljYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZXNQcmVkaWNhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnlDYXRjaChjYikuY2FsbChib3VuZFRvLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodXRpbC5pc09iamVjdChlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IGdldEtleXMoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbVtrZXldICE9IGVba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHByZWRpY2F0ZUxvb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyeUNhdGNoKGNiKS5jYWxsKGJvdW5kVG8sIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBORVhUX0ZJTFRFUjtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0Y2hGaWx0ZXI7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7IFwiLi9lczVcIjogMTMsIFwiLi91dGlsXCI6IDM2IH1dLCA4OiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgbG9uZ1N0YWNrVHJhY2VzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHRTdGFjayA9IFtdO1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VDcmVhdGVkID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3B1c2hDb250ZXh0ID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3BvcENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUHJvbWlzZS5fcGVla0NvbnRleHQgPSBQcm9taXNlLnByb3RvdHlwZS5fcGVla0NvbnRleHQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIENvbnRleHQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYWNlID0gbmV3IENvbnRleHQuQ2FwdHVyZWRUcmFjZShwZWVrQ29udGV4dCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgQ29udGV4dC5wcm90b3R5cGUuX3B1c2hDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHJhY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhY2UuX3Byb21pc2VDcmVhdGVkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRTdGFjay5wdXNoKHRoaXMuX3RyYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBDb250ZXh0LnByb3RvdHlwZS5fcG9wQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFjZSA9IGNvbnRleHRTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSB0cmFjZS5fcHJvbWlzZUNyZWF0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZS5fcHJvbWlzZUNyZWF0ZWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlQ29udGV4dCgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvbmdTdGFja1RyYWNlcykgcmV0dXJuIG5ldyBDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcGVla0NvbnRleHQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0SW5kZXggPSBjb250ZXh0U3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dFN0YWNrW2xhc3RJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgQ29udGV4dC5DYXB0dXJlZFRyYWNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBDb250ZXh0LmNyZWF0ZSA9IGNyZWF0ZUNvbnRleHQ7XG4gICAgICAgICAgICAgICAgQ29udGV4dC5kZWFjdGl2YXRlTG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgQ29udGV4dC5hY3RpdmF0ZUxvbmdTdGFja1RyYWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFByb21pc2VfcHVzaENvbnRleHQgPSBQcm9taXNlLnByb3RvdHlwZS5fcHVzaENvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBQcm9taXNlX3BvcENvbnRleHQgPSBQcm9taXNlLnByb3RvdHlwZS5fcG9wQ29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFByb21pc2VfUGVla0NvbnRleHQgPSBQcm9taXNlLl9wZWVrQ29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFByb21pc2VfcGVla0NvbnRleHQgPSBQcm9taXNlLnByb3RvdHlwZS5fcGVla0NvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBQcm9taXNlX3Byb21pc2VDcmVhdGVkID0gUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VDcmVhdGVkO1xuICAgICAgICAgICAgICAgICAgICBDb250ZXh0LmRlYWN0aXZhdGVMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fcHVzaENvbnRleHQgPSBQcm9taXNlX3B1c2hDb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3BvcENvbnRleHQgPSBQcm9taXNlX3BvcENvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLl9wZWVrQ29udGV4dCA9IFByb21pc2VfUGVla0NvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fcGVla0NvbnRleHQgPSBQcm9taXNlX3BlZWtDb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VDcmVhdGVkID0gUHJvbWlzZV9wcm9taXNlQ3JlYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvbmdTdGFja1RyYWNlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBsb25nU3RhY2tUcmFjZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fcHVzaENvbnRleHQgPSBDb250ZXh0LnByb3RvdHlwZS5fcHVzaENvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9wb3BDb250ZXh0ID0gQ29udGV4dC5wcm90b3R5cGUuX3BvcENvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuX3BlZWtDb250ZXh0ID0gUHJvbWlzZS5wcm90b3R5cGUuX3BlZWtDb250ZXh0ID0gcGVla0NvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9wcm9taXNlQ3JlYXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9wZWVrQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0eCAmJiBjdHguX3Byb21pc2VDcmVhdGVkID09IG51bGwpIGN0eC5fcHJvbWlzZUNyZWF0ZWQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbnRleHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7fV0sIDk6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUHJvbWlzZSwgQ29udGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBnZXREb21haW4gPSBQcm9taXNlLl9nZXREb21haW47XG4gICAgICAgICAgICAgICAgdmFyIGFzeW5jID0gUHJvbWlzZS5fYXN5bmM7XG4gICAgICAgICAgICAgICAgdmFyIFdhcm5pbmcgPSBfZGVyZXFfKFwiLi9lcnJvcnNcIikuV2FybmluZztcbiAgICAgICAgICAgICAgICB2YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG4gICAgICAgICAgICAgICAgdmFyIGNhbkF0dGFjaFRyYWNlID0gdXRpbC5jYW5BdHRhY2hUcmFjZTtcbiAgICAgICAgICAgICAgICB2YXIgdW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlZDtcbiAgICAgICAgICAgICAgICB2YXIgcG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb247XG4gICAgICAgICAgICAgICAgdmFyIGJsdWViaXJkRnJhbWVQYXR0ZXJuID0gL1tcXFxcXFwvXWJsdWViaXJkW1xcXFxcXC9danNbXFxcXFxcL10ocmVsZWFzZXxkZWJ1Z3xpbnN0cnVtZW50ZWQpLztcbiAgICAgICAgICAgICAgICB2YXIgbm9kZUZyYW1lUGF0dGVybiA9IC9cXCgoPzp0aW1lcnNcXC5qcyk6XFxkKzpcXGQrXFwpLztcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VMaW5lUGF0dGVybiA9IC9bXFwvPFxcKF0oLis/KTooXFxkKyk6KFxcZCspXFwpP1xccyokLztcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tGcmFtZVBhdHRlcm4gPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBmb3JtYXRTdGFjayA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGluZGVudFN0YWNrRnJhbWVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIHByaW50V2FybmluZztcbiAgICAgICAgICAgICAgICB2YXIgZGVidWdnaW5nID0gISEodXRpbC5lbnYoXCJCTFVFQklSRF9ERUJVR1wiKSAhPSAwICYmICh0cnVlIHx8IHV0aWwuZW52KFwiQkxVRUJJUkRfREVCVUdcIikgfHwgdXRpbC5lbnYoXCJOT0RFX0VOVlwiKSA9PT0gXCJkZXZlbG9wbWVudFwiKSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgd2FybmluZ3MgPSAhISh1dGlsLmVudihcIkJMVUVCSVJEX1dBUk5JTkdTXCIpICE9IDAgJiYgKGRlYnVnZ2luZyB8fCB1dGlsLmVudihcIkJMVUVCSVJEX1dBUk5JTkdTXCIpKSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbG9uZ1N0YWNrVHJhY2VzID0gISEodXRpbC5lbnYoXCJCTFVFQklSRF9MT05HX1NUQUNLX1RSQUNFU1wiKSAhPSAwICYmIChkZWJ1Z2dpbmcgfHwgdXRpbC5lbnYoXCJCTFVFQklSRF9MT05HX1NUQUNLX1RSQUNFU1wiKSkpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHdGb3Jnb3R0ZW5SZXR1cm4gPSB1dGlsLmVudihcIkJMVUVCSVJEX1dfRk9SR09UVEVOX1JFVFVSTlwiKSAhPSAwICYmICh3YXJuaW5ncyB8fCAhIXV0aWwuZW52KFwiQkxVRUJJUkRfV19GT1JHT1RURU5fUkVUVVJOXCIpKTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX3RhcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuX2JpdEZpZWxkID0gdGFyZ2V0Ll9iaXRGaWVsZCAmIH4xMDQ4NTc2IHwgNTI0Mjg4O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fZW5zdXJlUG9zc2libGVSZWplY3Rpb25IYW5kbGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMuX2JpdEZpZWxkICYgNTI0Mjg4KSAhPT0gMCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCgpO1xuICAgICAgICAgICAgICAgICAgICBhc3luYy5pbnZva2VMYXRlcih0aGlzLl9ub3RpZnlVbmhhbmRsZWRSZWplY3Rpb24sIHRoaXMsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9ub3RpZnlVbmhhbmRsZWRSZWplY3Rpb25Jc0hhbmRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcmVSZWplY3Rpb25FdmVudChcInJlamVjdGlvbkhhbmRsZWRcIiwgdW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlZCwgdW5kZWZpbmVkLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3NldFJldHVybmVkTm9uVW5kZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMjY4NDM1NDU2O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fcmV0dXJuZWROb25VbmRlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAyNjg0MzU0NTYpICE9PSAwO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNSZWplY3Rpb25VbmhhbmRsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlYXNvbiA9IHRoaXMuX3NldHRsZWRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0VW5oYW5kbGVkUmVqZWN0aW9uSXNOb3RpZmllZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyZVJlamVjdGlvbkV2ZW50KFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsIHBvc3NpYmx5VW5oYW5kbGVkUmVqZWN0aW9uLCByZWFzb24sIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9zZXRVbmhhbmRsZWRSZWplY3Rpb25Jc05vdGlmaWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMjYyMTQ0O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fdW5zZXRVbmhhbmRsZWRSZWplY3Rpb25Jc05vdGlmaWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkICYgfjI2MjE0NDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2lzVW5oYW5kbGVkUmVqZWN0aW9uTm90aWZpZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAyNjIxNDQpID4gMDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3NldFJlamVjdGlvbklzVW5oYW5kbGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMTA0ODU3NjtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgJiB+MTA0ODU3NjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzVW5oYW5kbGVkUmVqZWN0aW9uTm90aWZpZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdW5zZXRVbmhhbmRsZWRSZWplY3Rpb25Jc05vdGlmaWVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ub3RpZnlVbmhhbmRsZWRSZWplY3Rpb25Jc0hhbmRsZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5faXNSZWplY3Rpb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAxMDQ4NTc2KSA+IDA7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl93YXJuID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNob3VsZFVzZU93blRyYWNlLCBwcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3YXJuKG1lc3NhZ2UsIHNob3VsZFVzZU93blRyYWNlLCBwcm9taXNlIHx8IHRoaXMpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLm9uUG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb24gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbiA9IGdldERvbWFpbigpO1xuICAgICAgICAgICAgICAgICAgICBwb3NzaWJseVVuaGFuZGxlZFJlamVjdGlvbiA9IHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiID8gZG9tYWluID09PSBudWxsID8gZm4gOiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBmbikgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2Uub25VbmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSBnZXREb21haW4oKTtcbiAgICAgICAgICAgICAgICAgICAgdW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlZCA9IHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiID8gZG9tYWluID09PSBudWxsID8gZm4gOiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBmbikgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBkaXNhYmxlTG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24gZGlzYWJsZUxvbmdTdGFja1RyYWNlcygpIHt9O1xuICAgICAgICAgICAgICAgIFByb21pc2UubG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXN5bmMuaGF2ZUl0ZW1zUXVldWVkKCkgJiYgIWNvbmZpZy5sb25nU3RhY2tUcmFjZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBlbmFibGUgbG9uZyBzdGFjayB0cmFjZXMgYWZ0ZXIgcHJvbWlzZXMgaGF2ZSBiZWVuIGNyZWF0ZWRcXG5cXG4gICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29uZmlnLmxvbmdTdGFja1RyYWNlcyAmJiBsb25nU3RhY2tUcmFjZXNJc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgUHJvbWlzZV9jYXB0dXJlU3RhY2tUcmFjZSA9IFByb21pc2UucHJvdG90eXBlLl9jYXB0dXJlU3RhY2tUcmFjZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBQcm9taXNlX2F0dGFjaEV4dHJhVHJhY2UgPSBQcm9taXNlLnByb3RvdHlwZS5fYXR0YWNoRXh0cmFUcmFjZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5sb25nU3RhY2tUcmFjZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZUxvbmdTdGFja1RyYWNlcyA9IGZ1bmN0aW9uIGRpc2FibGVMb25nU3RhY2tUcmFjZXMoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFzeW5jLmhhdmVJdGVtc1F1ZXVlZCgpICYmICFjb25maWcubG9uZ1N0YWNrVHJhY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBlbmFibGUgbG9uZyBzdGFjayB0cmFjZXMgYWZ0ZXIgcHJvbWlzZXMgaGF2ZSBiZWVuIGNyZWF0ZWRcXG5cXG4gICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fY2FwdHVyZVN0YWNrVHJhY2UgPSBQcm9taXNlX2NhcHR1cmVTdGFja1RyYWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9hdHRhY2hFeHRyYVRyYWNlID0gUHJvbWlzZV9hdHRhY2hFeHRyYVRyYWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnRleHQuZGVhY3RpdmF0ZUxvbmdTdGFja1RyYWNlcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jLmVuYWJsZVRyYW1wb2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcubG9uZ1N0YWNrVHJhY2VzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2NhcHR1cmVTdGFja1RyYWNlID0gbG9uZ1N0YWNrVHJhY2VzQ2FwdHVyZVN0YWNrVHJhY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fYXR0YWNoRXh0cmFUcmFjZSA9IGxvbmdTdGFja1RyYWNlc0F0dGFjaEV4dHJhVHJhY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBDb250ZXh0LmFjdGl2YXRlTG9uZ1N0YWNrVHJhY2VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3luYy5kaXNhYmxlVHJhbXBvbGluZUlmTmVjZXNzYXJ5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5oYXNMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25maWcubG9uZ1N0YWNrVHJhY2VzICYmIGxvbmdTdGFja1RyYWNlc0lzU3VwcG9ydGVkKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBmaXJlRG9tRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEN1c3RvbUV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmdsb2JhbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5hbWUsIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb21FdmVudCA9IG5ldyBDdXN0b21FdmVudChuYW1lLnRvTG93ZXJDYXNlKCksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbDogZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXV0aWwuZ2xvYmFsLmRpc3BhdGNoRXZlbnQoZG9tRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBFdmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5nbG9iYWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lLCBldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9tRXZlbnQgPSBuZXcgRXZlbnQobmFtZS50b0xvd2VyQ2FzZSgpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21FdmVudC5kZXRhaWwgPSBldmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICF1dGlsLmdsb2JhbC5kaXNwYXRjaEV2ZW50KGRvbUV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmluaXRDdXN0b21FdmVudChcInRlc3Rpbmd0aGVldmVudFwiLCBmYWxzZSwgdHJ1ZSwge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuZ2xvYmFsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobmFtZSwgZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvbUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tRXZlbnQuaW5pdEN1c3RvbUV2ZW50KG5hbWUudG9Mb3dlckNhc2UoKSwgZmFsc2UsIHRydWUsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICF1dGlsLmdsb2JhbC5kaXNwYXRjaEV2ZW50KGRvbUV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgICAgIHZhciBmaXJlR2xvYmFsRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbWl0LmFwcGx5KHByb2Nlc3MsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1dGlsLmdsb2JhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBcIm9uXCIgKyBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IHV0aWwuZ2xvYmFsW21ldGhvZE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWV0aG9kKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kLmFwcGx5KHV0aWwuZ2xvYmFsLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0KG5hbWUsIHByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcHJvbWlzZTogcHJvbWlzZSB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBldmVudFRvT2JqZWN0R2VuZXJhdG9yID0ge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlQ3JlYXRlZDogZ2VuZXJhdGVQcm9taXNlTGlmZWN5Y2xlRXZlbnRPYmplY3QsXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VGdWxmaWxsZWQ6IGdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVqZWN0ZWQ6IGdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVzb2x2ZWQ6IGdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlQ2FuY2VsbGVkOiBnZW5lcmF0ZVByb21pc2VMaWZlY3ljbGVFdmVudE9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZUNoYWluZWQ6IGZ1bmN0aW9uIHByb21pc2VDaGFpbmVkKG5hbWUsIHByb21pc2UsIGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBwcm9taXNlOiBwcm9taXNlLCBjaGlsZDogY2hpbGQgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZzogZnVuY3Rpb24gd2FybmluZyhuYW1lLCBfd2FybmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgd2FybmluZzogX3dhcm5pbmcgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdW5oYW5kbGVkUmVqZWN0aW9uOiBmdW5jdGlvbiB1bmhhbmRsZWRSZWplY3Rpb24obmFtZSwgcmVhc29uLCBwcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByZWFzb246IHJlYXNvbiwgcHJvbWlzZTogcHJvbWlzZSB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZWplY3Rpb25IYW5kbGVkOiBnZW5lcmF0ZVByb21pc2VMaWZlY3ljbGVFdmVudE9iamVjdFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgYWN0aXZlRmlyZUV2ZW50ID0gZnVuY3Rpb24gYWN0aXZlRmlyZUV2ZW50KG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdsb2JhbEV2ZW50RmlyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50RmlyZWQgPSBmaXJlR2xvYmFsRXZlbnQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmMudGhyb3dMYXRlcihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50RmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvbUV2ZW50RmlyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbUV2ZW50RmlyZWQgPSBmaXJlRG9tRXZlbnQobmFtZSwgZXZlbnRUb09iamVjdEdlbmVyYXRvcltuYW1lXS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmMudGhyb3dMYXRlcihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbUV2ZW50RmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvbUV2ZW50RmlyZWQgfHwgZ2xvYmFsRXZlbnRGaXJlZDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5jb25maWcgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICAgICAgICAgICAgICBvcHRzID0gT2JqZWN0KG9wdHMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJsb25nU3RhY2tUcmFjZXNcIiBpbiBvcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5sb25nU3RhY2tUcmFjZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmxvbmdTdGFja1RyYWNlcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghb3B0cy5sb25nU3RhY2tUcmFjZXMgJiYgUHJvbWlzZS5oYXNMb25nU3RhY2tUcmFjZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVMb25nU3RhY2tUcmFjZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoXCJ3YXJuaW5nc1wiIGluIG9wdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3YXJuaW5nc09wdGlvbiA9IG9wdHMud2FybmluZ3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcud2FybmluZ3MgPSAhIXdhcm5pbmdzT3B0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgd0ZvcmdvdHRlblJldHVybiA9IGNvbmZpZy53YXJuaW5ncztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHV0aWwuaXNPYmplY3Qod2FybmluZ3NPcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwid0ZvcmdvdHRlblJldHVyblwiIGluIHdhcm5pbmdzT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdGb3Jnb3R0ZW5SZXR1cm4gPSAhIXdhcm5pbmdzT3B0aW9uLndGb3Jnb3R0ZW5SZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImNhbmNlbGxhdGlvblwiIGluIG9wdHMgJiYgb3B0cy5jYW5jZWxsYXRpb24gJiYgIWNvbmZpZy5jYW5jZWxsYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhc3luYy5oYXZlSXRlbXNRdWV1ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBlbmFibGUgY2FuY2VsbGF0aW9uIGFmdGVyIHByb21pc2VzIGFyZSBpbiB1c2VcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fY2xlYXJDYW5jZWxsYXRpb25EYXRhID0gY2FuY2VsbGF0aW9uQ2xlYXJDYW5jZWxsYXRpb25EYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3Byb3BhZ2F0ZUZyb20gPSBjYW5jZWxsYXRpb25Qcm9wYWdhdGVGcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX29uQ2FuY2VsID0gY2FuY2VsbGF0aW9uT25DYW5jZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fc2V0T25DYW5jZWwgPSBjYW5jZWxsYXRpb25TZXRPbkNhbmNlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9hdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayA9IGNhbmNlbGxhdGlvbkF0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2V4ZWN1dGUgPSBjYW5jZWxsYXRpb25FeGVjdXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3Byb3BhZ2F0ZUZyb21GdW5jdGlvbiA9IGNhbmNlbGxhdGlvblByb3BhZ2F0ZUZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuY2FuY2VsbGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoXCJtb25pdG9yaW5nXCIgaW4gb3B0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMubW9uaXRvcmluZyAmJiAhY29uZmlnLm1vbml0b3JpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcubW9uaXRvcmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2ZpcmVFdmVudCA9IGFjdGl2ZUZpcmVFdmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIW9wdHMubW9uaXRvcmluZyAmJiBjb25maWcubW9uaXRvcmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5tb25pdG9yaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2ZpcmVFdmVudCA9IGRlZmF1bHRGaXJlRXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2U7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRlZmF1bHRGaXJlRXZlbnQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fZmlyZUV2ZW50ID0gZGVmYXVsdEZpcmVFdmVudDtcbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fZXhlY3V0ZSA9IGZ1bmN0aW9uIChleGVjdXRvciwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX29uQ2FuY2VsID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3NldE9uQ2FuY2VsID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24gKG9uQ2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9jYXB0dXJlU3RhY2tUcmFjZSA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9hdHRhY2hFeHRyYVRyYWNlID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2NsZWFyQ2FuY2VsbGF0aW9uRGF0YSA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9wcm9wYWdhdGVGcm9tID0gZnVuY3Rpb24gKHBhcmVudCwgZmxhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNhbmNlbGxhdGlvbkV4ZWN1dGUoZXhlY3V0b3IsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRvcihyZXNvbHZlLCByZWplY3QsIGZ1bmN0aW9uIChvbkNhbmNlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb25DYW5jZWwgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwib25DYW5jZWwgbXVzdCBiZSBhIGZ1bmN0aW9uLCBnb3Q6IFwiICsgdXRpbC50b1N0cmluZyhvbkNhbmNlbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9hdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayhvbkNhbmNlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjYW5jZWxsYXRpb25BdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayhvbkNhbmNlbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzQ2FuY2VsbGFibGUoKSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzT25DYW5jZWwgPSB0aGlzLl9vbkNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNPbkNhbmNlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXRpbC5pc0FycmF5KHByZXZpb3VzT25DYW5jZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNPbkNhbmNlbC5wdXNoKG9uQ2FuY2VsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0T25DYW5jZWwoW3ByZXZpb3VzT25DYW5jZWwsIG9uQ2FuY2VsXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRPbkNhbmNlbChvbkNhbmNlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjYW5jZWxsYXRpb25PbkNhbmNlbCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29uQ2FuY2VsRmllbGQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY2FuY2VsbGF0aW9uU2V0T25DYW5jZWwob25DYW5jZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25DYW5jZWxGaWVsZCA9IG9uQ2FuY2VsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNhbmNlbGxhdGlvbkNsZWFyQ2FuY2VsbGF0aW9uRGF0YSgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsbGF0aW9uUGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkNhbmNlbEZpZWxkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNhbmNlbGxhdGlvblByb3BhZ2F0ZUZyb20ocGFyZW50LCBmbGFncykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGZsYWdzICYgMSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbGxhdGlvblBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBicmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsID0gcGFyZW50Ll9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Ll9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsID0gYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKChmbGFncyAmIDIpICE9PSAwICYmIHBhcmVudC5faXNCb3VuZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRCb3VuZFRvKHBhcmVudC5fYm91bmRUbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBiaW5kaW5nUHJvcGFnYXRlRnJvbShwYXJlbnQsIGZsYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoZmxhZ3MgJiAyKSAhPT0gMCAmJiBwYXJlbnQuX2lzQm91bmQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0Qm91bmRUbyhwYXJlbnQuX2JvdW5kVG8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBfcHJvcGFnYXRlRnJvbUZ1bmN0aW9uID0gYmluZGluZ1Byb3BhZ2F0ZUZyb207XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBfYm91bmRWYWx1ZUZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gdGhpcy5fYm91bmRUbztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0LnZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBsb25nU3RhY2tUcmFjZXNDYXB0dXJlU3RhY2tUcmFjZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhY2UgPSBuZXcgQ2FwdHVyZWRUcmFjZSh0aGlzLl9wZWVrQ29udGV4dCgpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBsb25nU3RhY2tUcmFjZXNBdHRhY2hFeHRyYVRyYWNlKGVycm9yLCBpZ25vcmVTZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW5BdHRhY2hUcmFjZShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFjZSA9IHRoaXMuX3RyYWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlU2VsZikgdHJhY2UgPSB0cmFjZS5fcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjZS5hdHRhY2hFeHRyYVRyYWNlKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWVycm9yLl9fc3RhY2tDbGVhbmVkX18pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VTdGFja0FuZE1lc3NhZ2UoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AoZXJyb3IsIFwic3RhY2tcIiwgcGFyc2VkLm1lc3NhZ2UgKyBcIlxcblwiICsgcGFyc2VkLnN0YWNrLmpvaW4oXCJcXG5cIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AoZXJyb3IsIFwiX19zdGFja0NsZWFuZWRfX1wiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrRm9yZ290dGVuUmV0dXJucyhyZXR1cm5WYWx1ZSwgcHJvbWlzZUNyZWF0ZWQsIG5hbWUsIHByb21pc2UsIHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBwcm9taXNlQ3JlYXRlZCAhPT0gbnVsbCAmJiB3Rm9yZ290dGVuUmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ICE9PSB1bmRlZmluZWQgJiYgcGFyZW50Ll9yZXR1cm5lZE5vblVuZGVmaW5lZCgpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByb21pc2UuX2JpdEZpZWxkICYgNjU1MzUpID09PSAwKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lKSBuYW1lID0gbmFtZSArIFwiIFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZXJMaW5lID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjcmVhdG9yTGluZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvbWlzZUNyZWF0ZWQuX3RyYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNlTGluZXMgPSBwcm9taXNlQ3JlYXRlZC5fdHJhY2Uuc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWNrID0gY2xlYW5TdGFjayh0cmFjZUxpbmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBzdGFja1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlRnJhbWVQYXR0ZXJuLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaW5lTWF0Y2hlcyA9IGxpbmUubWF0Y2gocGFyc2VMaW5lUGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZU1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyTGluZSA9IFwiYXQgXCIgKyBsaW5lTWF0Y2hlc1sxXSArIFwiOlwiICsgbGluZU1hdGNoZXNbMl0gKyBcIjpcIiArIGxpbmVNYXRjaGVzWzNdICsgXCIgXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdFVzZXJMaW5lID0gc3RhY2tbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2VMaW5lcy5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2VMaW5lc1tpXSA9PT0gZmlyc3RVc2VyTGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdG9yTGluZSA9IFwiXFxuXCIgKyB0cmFjZUxpbmVzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gXCJhIHByb21pc2Ugd2FzIGNyZWF0ZWQgaW4gYSBcIiArIG5hbWUgKyBcImhhbmRsZXIgXCIgKyBoYW5kbGVyTGluZSArIFwiYnV0IHdhcyBub3QgcmV0dXJuZWQgZnJvbSBpdCwgXCIgKyBcInNlZSBodHRwOi8vZ29vLmdsL3JScU1Vd1wiICsgY3JlYXRvckxpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl93YXJuKG1zZywgdHJ1ZSwgcHJvbWlzZUNyZWF0ZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZGVwcmVjYXRlZChuYW1lLCByZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5hbWUgKyBcIiBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50KSBtZXNzYWdlICs9IFwiIFVzZSBcIiArIHJlcGxhY2VtZW50ICsgXCIgaW5zdGVhZC5cIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhcm4obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gd2FybihtZXNzYWdlLCBzaG91bGRVc2VPd25UcmFjZSwgcHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbmZpZy53YXJuaW5ncykgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2FybmluZyA9IG5ldyBXYXJuaW5nKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3R4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkVXNlT3duVHJhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2Uod2FybmluZyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLmxvbmdTdGFja1RyYWNlcyAmJiAoY3R4ID0gUHJvbWlzZS5fcGVla0NvbnRleHQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hdHRhY2hFeHRyYVRyYWNlKHdhcm5pbmcpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlU3RhY2tBbmRNZXNzYWdlKHdhcm5pbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZy5zdGFjayA9IHBhcnNlZC5tZXNzYWdlICsgXCJcXG5cIiArIHBhcnNlZC5zdGFjay5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhY3RpdmVGaXJlRXZlbnQoXCJ3YXJuaW5nXCIsIHdhcm5pbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXRBbmRMb2dFcnJvcih3YXJuaW5nLCBcIlwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlY29uc3RydWN0U3RhY2sobWVzc2FnZSwgc3RhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2tzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tzW2ldLnB1c2goXCJGcm9tIHByZXZpb3VzIGV2ZW50OlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrc1tpXSA9IHN0YWNrc1tpXS5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgc3RhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tzW2ldID0gc3RhY2tzW2ldLmpvaW4oXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2UgKyBcIlxcblwiICsgc3RhY2tzLmpvaW4oXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlT3JFbXB0eUp1bXBzKHN0YWNrcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrc1tpXS5sZW5ndGggPT09IDAgfHwgaSArIDEgPCBzdGFja3MubGVuZ3RoICYmIHN0YWNrc1tpXVswXSA9PT0gc3RhY2tzW2kgKyAxXVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlQ29tbW9uUm9vdHMoc3RhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gc3RhY2tzWzBdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHN0YWNrcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXYgPSBzdGFja3NbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudExhc3RJbmRleCA9IGN1cnJlbnQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50TGFzdExpbmUgPSBjdXJyZW50W2N1cnJlbnRMYXN0SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1vblJvb3RNZWV0UG9pbnQgPSAtMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHByZXYubGVuZ3RoIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldltqXSA9PT0gY3VycmVudExhc3RMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1vblJvb3RNZWV0UG9pbnQgPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBjb21tb25Sb290TWVldFBvaW50OyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaW5lID0gcHJldltqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFtjdXJyZW50TGFzdEluZGV4XSA9PT0gbGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGFzdEluZGV4LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHByZXY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjbGVhblN0YWNrKHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBzdGFja1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc1RyYWNlTGluZSA9IFwiICAgIChObyBzdGFjayB0cmFjZSlcIiA9PT0gbGluZSB8fCBzdGFja0ZyYW1lUGF0dGVybi50ZXN0KGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzSW50ZXJuYWxGcmFtZSA9IGlzVHJhY2VMaW5lICYmIHNob3VsZElnbm9yZShsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1RyYWNlTGluZSAmJiAhaXNJbnRlcm5hbEZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGVudFN0YWNrRnJhbWVzICYmIGxpbmUuY2hhckF0KDApICE9PSBcIiBcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gXCIgICAgXCIgKyBsaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHN0YWNrRnJhbWVzQXNBcnJheShlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBlcnJvci5zdGFjay5yZXBsYWNlKC9cXHMrJC9nLCBcIlwiKS5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBzdGFja1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIiAgICAoTm8gc3RhY2sgdHJhY2UpXCIgPT09IGxpbmUgfHwgc3RhY2tGcmFtZVBhdHRlcm4udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gMCAmJiBlcnJvci5uYW1lICE9IFwiU3ludGF4RXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sgPSBzdGFjay5zbGljZShpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2s7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VTdGFja0FuZE1lc3NhZ2UoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWNrID0gZXJyb3Iuc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gZXJyb3IudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sgPSB0eXBlb2Ygc3RhY2sgPT09IFwic3RyaW5nXCIgJiYgc3RhY2subGVuZ3RoID4gMCA/IHN0YWNrRnJhbWVzQXNBcnJheShlcnJvcikgOiBbXCIgICAgKE5vIHN0YWNrIHRyYWNlKVwiXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogZXJyb3IubmFtZSA9PSBcIlN5bnRheEVycm9yXCIgPyBzdGFjayA6IGNsZWFuU3RhY2soc3RhY2spXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZm9ybWF0QW5kTG9nRXJyb3IoZXJyb3IsIHRpdGxlLCBpc1NvZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzT2JqZWN0KGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFjayA9IGVycm9yLnN0YWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSB0aXRsZSArIGZvcm1hdFN0YWNrKHN0YWNrLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSB0aXRsZSArIFN0cmluZyhlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByaW50V2FybmluZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnRXYXJuaW5nKG1lc3NhZ2UsIGlzU29mdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gXCJmdW5jdGlvblwiIHx8IF90eXBlb2YoY29uc29sZS5sb2cpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBmaXJlUmVqZWN0aW9uRXZlbnQobmFtZSwgbG9jYWxIYW5kbGVyLCByZWFzb24sIHByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2FsRXZlbnRGaXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsb2NhbEhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsRXZlbnRGaXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwicmVqZWN0aW9uSGFuZGxlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsSGFuZGxlcihwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEhhbmRsZXIocmVhc29uLCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jLnRocm93TGF0ZXIoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJ1bmhhbmRsZWRSZWplY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhY3RpdmVGaXJlRXZlbnQobmFtZSwgcmVhc29uLCBwcm9taXNlKSAmJiAhbG9jYWxFdmVudEZpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0QW5kTG9nRXJyb3IocmVhc29uLCBcIlVuaGFuZGxlZCByZWplY3Rpb24gXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlRmlyZUV2ZW50KG5hbWUsIHByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZm9ybWF0Tm9uRXJyb3Iob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IFwiW2Z1bmN0aW9uIFwiICsgKG9iai5uYW1lIHx8IFwiYW5vbnltb3VzXCIpICsgXCJdXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBvYmogJiYgdHlwZW9mIG9iai50b1N0cmluZyA9PT0gXCJmdW5jdGlvblwiID8gb2JqLnRvU3RyaW5nKCkgOiB1dGlsLnRvU3RyaW5nKG9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnVzZWxlc3NUb1N0cmluZyA9IC9cXFtvYmplY3QgW2EtekEtWjAtOSRfXStcXF0vO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1c2VsZXNzVG9TdHJpbmcudGVzdChzdHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1N0ciA9IEpTT04uc3RyaW5naWZ5KG9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IG5ld1N0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBcIihlbXB0eSBhcnJheSlcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIoPFwiICsgc25pcChzdHIpICsgXCI+LCBubyBzdGFjayB0cmFjZSlcIjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzbmlwKHN0cikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4Q2hhcnMgPSA0MTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPCBtYXhDaGFycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnN1YnN0cigwLCBtYXhDaGFycyAtIDMpICsgXCIuLi5cIjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBsb25nU3RhY2tUcmFjZXNJc1N1cHBvcnRlZCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBjYXB0dXJlU3RhY2tUcmFjZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBzaG91bGRJZ25vcmUgPSBmdW5jdGlvbiBzaG91bGRJZ25vcmUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZUxpbmVJbmZvUmVnZXggPSAvW1xcLzxcXChdKFteOlxcL10rKTooXFxkKyk6KD86XFxkKylcXCk/XFxzKiQvO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlTGluZUluZm8obGluZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IGxpbmUubWF0Y2gocGFyc2VMaW5lSW5mb1JlZ2V4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IG1hdGNoZXNbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogcGFyc2VJbnQobWF0Y2hlc1syXSwgMTApXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0Qm91bmRzKGZpcnN0TGluZUVycm9yLCBsYXN0TGluZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbG9uZ1N0YWNrVHJhY2VzSXNTdXBwb3J0ZWQoKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RTdGFja0xpbmVzID0gZmlyc3RMaW5lRXJyb3Iuc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0U3RhY2tMaW5lcyA9IGxhc3RMaW5lRXJyb3Iuc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdEluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0SW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0RmlsZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0RmlsZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlyc3RTdGFja0xpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VMaW5lSW5mbyhmaXJzdFN0YWNrTGluZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0RmlsZU5hbWUgPSByZXN1bHQuZmlsZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RJbmRleCA9IHJlc3VsdC5saW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdFN0YWNrTGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBwYXJzZUxpbmVJbmZvKGxhc3RTdGFja0xpbmVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0RmlsZU5hbWUgPSByZXN1bHQuZmlsZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gcmVzdWx0LmxpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0SW5kZXggPCAwIHx8IGxhc3RJbmRleCA8IDAgfHwgIWZpcnN0RmlsZU5hbWUgfHwgIWxhc3RGaWxlTmFtZSB8fCBmaXJzdEZpbGVOYW1lICE9PSBsYXN0RmlsZU5hbWUgfHwgZmlyc3RJbmRleCA+PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZElnbm9yZSA9IGZ1bmN0aW9uIHNob3VsZElnbm9yZShsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmx1ZWJpcmRGcmFtZVBhdHRlcm4udGVzdChsaW5lKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IHBhcnNlTGluZUluZm8obGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvLmZpbGVOYW1lID09PSBmaXJzdEZpbGVOYW1lICYmIGZpcnN0SW5kZXggPD0gaW5mby5saW5lICYmIGluZm8ubGluZSA8PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIENhcHR1cmVkVHJhY2UocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZXNDcmVhdGVkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuX2xlbmd0aCA9IDEgKyAocGFyZW50ID09PSB1bmRlZmluZWQgPyAwIDogcGFyZW50Ll9sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBjYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDYXB0dXJlZFRyYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA+IDMyKSB0aGlzLnVuY3ljbGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXRpbC5pbmhlcml0cyhDYXB0dXJlZFRyYWNlLCBFcnJvcik7XG4gICAgICAgICAgICAgICAgQ29udGV4dC5DYXB0dXJlZFRyYWNlID0gQ2FwdHVyZWRUcmFjZTtcblxuICAgICAgICAgICAgICAgIENhcHR1cmVkVHJhY2UucHJvdG90eXBlLnVuY3ljbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSB0aGlzLl9sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPCAyKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2tUb0luZGV4ID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG5vZGUgPSB0aGlzOyBub2RlICE9PSB1bmRlZmluZWQ7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLl9wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5fbGVuZ3RoID0gaTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBub2Rlc1tpXS5zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFja1RvSW5kZXhbc3RhY2tdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFja1RvSW5kZXhbc3RhY2tdID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFN0YWNrID0gbm9kZXNbaV0uc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBzdGFja1RvSW5kZXhbY3VycmVudFN0YWNrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1tpbmRleCAtIDFdLl9wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzW2luZGV4IC0gMV0uX2xlbmd0aCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldLl9wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNbaV0uX2xlbmd0aCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN5Y2xlRWRnZU5vZGUgPSBpID4gMCA/IG5vZGVzW2kgLSAxXSA6IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX3BhcmVudCA9IG5vZGVzW2luZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX3BhcmVudC51bmN5Y2xlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX2xlbmd0aCA9IGN5Y2xlRWRnZU5vZGUuX3BhcmVudC5fbGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX2xlbmd0aCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Q2hpbGRMZW5ndGggPSBjeWNsZUVkZ2VOb2RlLl9sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBpIC0gMjsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNbal0uX2xlbmd0aCA9IGN1cnJlbnRDaGlsZExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENoaWxkTGVuZ3RoKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBDYXB0dXJlZFRyYWNlLnByb3RvdHlwZS5hdHRhY2hFeHRyYVRyYWNlID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5fX3N0YWNrQ2xlYW5lZF9fKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5jeWNsZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VTdGFja0FuZE1lc3NhZ2UoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHBhcnNlZC5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2tzID0gW3BhcnNlZC5zdGFja107XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNlID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrcy5wdXNoKGNsZWFuU3RhY2sodHJhY2Uuc3RhY2suc3BsaXQoXCJcXG5cIikpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlID0gdHJhY2UuX3BhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZW1vdmVDb21tb25Sb290cyhzdGFja3MpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVEdXBsaWNhdGVPckVtcHR5SnVtcHMoc3RhY2tzKTtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChlcnJvciwgXCJzdGFja1wiLCByZWNvbnN0cnVjdFN0YWNrKG1lc3NhZ2UsIHN0YWNrcykpO1xuICAgICAgICAgICAgICAgICAgICB1dGlsLm5vdEVudW1lcmFibGVQcm9wKGVycm9yLCBcIl9fc3RhY2tDbGVhbmVkX19cIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBjYXB0dXJlU3RhY2tUcmFjZSA9IGZ1bmN0aW9uIHN0YWNrRGV0ZWN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdjhzdGFja0ZyYW1lUGF0dGVybiA9IC9eXFxzKmF0XFxzKi87XG4gICAgICAgICAgICAgICAgICAgIHZhciB2OHN0YWNrRm9ybWF0dGVyID0gZnVuY3Rpb24gdjhzdGFja0Zvcm1hdHRlcihzdGFjaywgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhY2sgPT09IFwic3RyaW5nXCIpIHJldHVybiBzdGFjaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgIT09IHVuZGVmaW5lZCAmJiBlcnJvci5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXROb25FcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBFcnJvci5zdGFja1RyYWNlTGltaXQgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCArPSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tGcmFtZVBhdHRlcm4gPSB2OHN0YWNrRnJhbWVQYXR0ZXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0U3RhY2sgPSB2OHN0YWNrRm9ybWF0dGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhcHR1cmVTdGFja1RyYWNlID0gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZElnbm9yZSA9IGZ1bmN0aW9uIHNob3VsZElnbm9yZShsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsdWViaXJkRnJhbWVQYXR0ZXJuLnRlc3QobGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZWNlaXZlciwgaWdub3JlVW50aWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgKz0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXB0dXJlU3RhY2tUcmFjZShyZWNlaXZlciwgaWdub3JlVW50aWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCAtPSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnIuc3RhY2sgPT09IFwic3RyaW5nXCIgJiYgZXJyLnN0YWNrLnNwbGl0KFwiXFxuXCIpWzBdLmluZGV4T2YoXCJzdGFja0RldGVjdGlvbkBcIikgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tGcmFtZVBhdHRlcm4gPSAvQC87XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXRTdGFjayA9IHY4c3RhY2tGb3JtYXR0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnRTdGFja0ZyYW1lcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY2FwdHVyZVN0YWNrVHJhY2Uobykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8uc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzU3RhY2tBZnRlclRocm93O1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1N0YWNrQWZ0ZXJUaHJvdyA9IFwic3RhY2tcIiBpbiBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghKFwic3RhY2tcIiBpbiBlcnIpICYmIGhhc1N0YWNrQWZ0ZXJUaHJvdyAmJiB0eXBlb2YgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFja0ZyYW1lUGF0dGVybiA9IHY4c3RhY2tGcmFtZVBhdHRlcm47XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXRTdGFjayA9IHY4c3RhY2tGb3JtYXR0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY2FwdHVyZVN0YWNrVHJhY2Uobykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCArPSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgby5zdGFjayA9IGUuc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCAtPSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFN0YWNrID0gZnVuY3Rpb24gZm9ybWF0U3RhY2soc3RhY2ssIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0YWNrID09PSBcInN0cmluZ1wiKSByZXR1cm4gc3RhY2s7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKHR5cGVvZiBlcnJvciA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGVycm9yKSkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGVycm9yID09PSBcImZ1bmN0aW9uXCIpICYmIGVycm9yLm5hbWUgIT09IHVuZGVmaW5lZCAmJiBlcnJvci5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXROb25FcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfShbXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNvbnNvbGUud2FybiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAodXRpbC5pc05vZGUgJiYgcHJvY2Vzcy5zdGRlcnIuaXNUVFkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIHByaW50V2FybmluZyhtZXNzYWdlLCBpc1NvZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBpc1NvZnQgPyBcIlxceDFCWzMzbVwiIDogXCJcXHgxQlszMW1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oY29sb3IgKyBtZXNzYWdlICsgXCJcXHgxQlswbVxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXV0aWwuaXNOb2RlICYmIHR5cGVvZiBuZXcgRXJyb3IoKS5zdGFjayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKG1lc3NhZ2UsIGlzU29mdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIiVjXCIgKyBtZXNzYWdlLCBpc1NvZnQgPyBcImNvbG9yOiBkYXJrb3JhbmdlXCIgOiBcImNvbG9yOiByZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZ3M6IHdhcm5pbmdzLFxuICAgICAgICAgICAgICAgICAgICBsb25nU3RhY2tUcmFjZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtb25pdG9yaW5nOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAobG9uZ1N0YWNrVHJhY2VzKSBQcm9taXNlLmxvbmdTdGFja1RyYWNlcygpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbG9uZ1N0YWNrVHJhY2VzOiBmdW5jdGlvbiBsb25nU3RhY2tUcmFjZXMoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnLmxvbmdTdGFja1RyYWNlcztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZ3M6IGZ1bmN0aW9uIHdhcm5pbmdzKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy53YXJuaW5ncztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uOiBmdW5jdGlvbiBjYW5jZWxsYXRpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnLmNhbmNlbGxhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbW9uaXRvcmluZzogZnVuY3Rpb24gbW9uaXRvcmluZygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25maWcubW9uaXRvcmluZztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGFnYXRlRnJvbUZ1bmN0aW9uOiBmdW5jdGlvbiBwcm9wYWdhdGVGcm9tRnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3Byb3BhZ2F0ZUZyb21GdW5jdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYm91bmRWYWx1ZUZ1bmN0aW9uOiBmdW5jdGlvbiBib3VuZFZhbHVlRnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2JvdW5kVmFsdWVGdW5jdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zOiBjaGVja0ZvcmdvdHRlblJldHVybnMsXG4gICAgICAgICAgICAgICAgICAgIHNldEJvdW5kczogc2V0Qm91bmRzLFxuICAgICAgICAgICAgICAgICAgICB3YXJuOiB3YXJuLFxuICAgICAgICAgICAgICAgICAgICBkZXByZWNhdGVkOiBkZXByZWNhdGVkLFxuICAgICAgICAgICAgICAgICAgICBDYXB0dXJlZFRyYWNlOiBDYXB0dXJlZFRyYWNlLFxuICAgICAgICAgICAgICAgICAgICBmaXJlRG9tRXZlbnQ6IGZpcmVEb21FdmVudCxcbiAgICAgICAgICAgICAgICAgICAgZmlyZUdsb2JhbEV2ZW50OiBmaXJlR2xvYmFsRXZlbnRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgeyBcIi4vZXJyb3JzXCI6IDEyLCBcIi4vdXRpbFwiOiAzNiB9XSwgMTA6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJldHVybmVyKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdGhyb3dlcigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5yZWFzb247XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGVbXCJyZXR1cm5cIl0gPSBQcm9taXNlLnByb3RvdHlwZS50aGVuUmV0dXJuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHZhbHVlLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhlbihyZXR1cm5lciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgdmFsdWU6IHZhbHVlIH0sIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlW1widGhyb3dcIl0gPSBQcm9taXNlLnByb3RvdHlwZS50aGVuVGhyb3cgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90aGVuKHRocm93ZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7IHJlYXNvbjogcmVhc29uIH0sIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLmNhdGNoVGhyb3cgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90aGVuKHVuZGVmaW5lZCwgdGhyb3dlciwgdW5kZWZpbmVkLCB7IHJlYXNvbjogcmVhc29uIH0sIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlYXNvbiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfcmVhc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhdWdodChyZWFzb24sIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLmNhdGNoUmV0dXJuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHZhbHVlLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RoZW4odW5kZWZpbmVkLCByZXR1cm5lciwgdW5kZWZpbmVkLCB7IHZhbHVlOiB2YWx1ZSB9LCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF92YWx1ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSBfdmFsdWUuc3VwcHJlc3NVbmhhbmRsZWRSZWplY3Rpb25zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYXVnaHQodmFsdWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHt9XSwgMTE6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUHJvbWlzZSwgSU5URVJOQUwpIHtcbiAgICAgICAgICAgICAgICB2YXIgUHJvbWlzZVJlZHVjZSA9IFByb21pc2UucmVkdWNlO1xuICAgICAgICAgICAgICAgIHZhciBQcm9taXNlQWxsID0gUHJvbWlzZS5hbGw7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBwcm9taXNlQWxsVGhpcygpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VBbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gUHJvbWlzZU1hcFNlcmllcyhwcm9taXNlcywgZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VSZWR1Y2UocHJvbWlzZXMsIGZuLCBJTlRFUk5BTCwgSU5URVJOQUwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VSZWR1Y2UodGhpcywgZm4sIElOVEVSTkFMLCAwKS5fdGhlbihwcm9taXNlQWxsVGhpcywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRoaXMsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLm1hcFNlcmllcyA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZVJlZHVjZSh0aGlzLCBmbiwgSU5URVJOQUwsIElOVEVSTkFMKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5lYWNoID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZVJlZHVjZShwcm9taXNlcywgZm4sIElOVEVSTkFMLCAwKS5fdGhlbihwcm9taXNlQWxsVGhpcywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHByb21pc2VzLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLm1hcFNlcmllcyA9IFByb21pc2VNYXBTZXJpZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7fV0sIDEyOiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICAgIHZhciBlczUgPSBfZGVyZXFfKFwiLi9lczVcIik7XG4gICAgICAgICAgICB2YXIgT2JqZWN0ZnJlZXplID0gZXM1LmZyZWV6ZTtcbiAgICAgICAgICAgIHZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbiAgICAgICAgICAgIHZhciBpbmhlcml0cyA9IHV0aWwuaW5oZXJpdHM7XG4gICAgICAgICAgICB2YXIgbm90RW51bWVyYWJsZVByb3AgPSB1dGlsLm5vdEVudW1lcmFibGVQcm9wO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBzdWJFcnJvcihuYW1lUHJvcGVydHksIGRlZmF1bHRNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gU3ViRXJyb3IobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3ViRXJyb3IpKSByZXR1cm4gbmV3IFN1YkVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBub3RFbnVtZXJhYmxlUHJvcCh0aGlzLCBcIm1lc3NhZ2VcIiwgdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlIDogZGVmYXVsdE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBub3RFbnVtZXJhYmxlUHJvcCh0aGlzLCBcIm5hbWVcIiwgbmFtZVByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5oZXJpdHMoU3ViRXJyb3IsIEVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3ViRXJyb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfVHlwZUVycm9yLCBfUmFuZ2VFcnJvcjtcbiAgICAgICAgICAgIHZhciBXYXJuaW5nID0gc3ViRXJyb3IoXCJXYXJuaW5nXCIsIFwid2FybmluZ1wiKTtcbiAgICAgICAgICAgIHZhciBDYW5jZWxsYXRpb25FcnJvciA9IHN1YkVycm9yKFwiQ2FuY2VsbGF0aW9uRXJyb3JcIiwgXCJjYW5jZWxsYXRpb24gZXJyb3JcIik7XG4gICAgICAgICAgICB2YXIgVGltZW91dEVycm9yID0gc3ViRXJyb3IoXCJUaW1lb3V0RXJyb3JcIiwgXCJ0aW1lb3V0IGVycm9yXCIpO1xuICAgICAgICAgICAgdmFyIEFnZ3JlZ2F0ZUVycm9yID0gc3ViRXJyb3IoXCJBZ2dyZWdhdGVFcnJvclwiLCBcImFnZ3JlZ2F0ZSBlcnJvclwiKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgX1R5cGVFcnJvciA9IFR5cGVFcnJvcjtcbiAgICAgICAgICAgICAgICBfUmFuZ2VFcnJvciA9IFJhbmdlRXJyb3I7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgX1R5cGVFcnJvciA9IHN1YkVycm9yKFwiVHlwZUVycm9yXCIsIFwidHlwZSBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICBfUmFuZ2VFcnJvciA9IHN1YkVycm9yKFwiUmFuZ2VFcnJvclwiLCBcInJhbmdlIGVycm9yXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbWV0aG9kcyA9IChcImpvaW4gcG9wIHB1c2ggc2hpZnQgdW5zaGlmdCBzbGljZSBmaWx0ZXIgZm9yRWFjaCBzb21lIFwiICsgXCJldmVyeSBtYXAgaW5kZXhPZiBsYXN0SW5kZXhPZiByZWR1Y2UgcmVkdWNlUmlnaHQgc29ydCByZXZlcnNlXCIpLnNwbGl0KFwiIFwiKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBBcnJheS5wcm90b3R5cGVbbWV0aG9kc1tpXV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBBZ2dyZWdhdGVFcnJvci5wcm90b3R5cGVbbWV0aG9kc1tpXV0gPSBBcnJheS5wcm90b3R5cGVbbWV0aG9kc1tpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlczUuZGVmaW5lUHJvcGVydHkoQWdncmVnYXRlRXJyb3IucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIEFnZ3JlZ2F0ZUVycm9yLnByb3RvdHlwZVtcImlzT3BlcmF0aW9uYWxcIl0gPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGxldmVsID0gMDtcbiAgICAgICAgICAgIEFnZ3JlZ2F0ZUVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZW50ID0gQXJyYXkobGV2ZWwgKiA0ICsgMSkuam9pbihcIiBcIik7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IFwiXFxuXCIgKyBpbmRlbnQgKyBcIkFnZ3JlZ2F0ZUVycm9yIG9mOlwiICsgXCJcXG5cIjtcbiAgICAgICAgICAgICAgICBsZXZlbCsrO1xuICAgICAgICAgICAgICAgIGluZGVudCA9IEFycmF5KGxldmVsICogNCArIDEpLmpvaW4oXCIgXCIpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyID0gdGhpc1tpXSA9PT0gdGhpcyA/IFwiW0NpcmN1bGFyIEFnZ3JlZ2F0ZUVycm9yXVwiIDogdGhpc1tpXSArIFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lcyA9IHN0ci5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXNbal0gPSBpbmRlbnQgKyBsaW5lc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdHIgPSBsaW5lcy5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXQgKz0gc3RyICsgXCJcXG5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV2ZWwtLTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gT3BlcmF0aW9uYWxFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE9wZXJhdGlvbmFsRXJyb3IpKSByZXR1cm4gbmV3IE9wZXJhdGlvbmFsRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJuYW1lXCIsIFwiT3BlcmF0aW9uYWxFcnJvclwiKTtcbiAgICAgICAgICAgICAgICBub3RFbnVtZXJhYmxlUHJvcCh0aGlzLCBcIm1lc3NhZ2VcIiwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXVzZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgdGhpc1tcImlzT3BlcmF0aW9uYWxcIl0gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBub3RFbnVtZXJhYmxlUHJvcCh0aGlzLCBcIm1lc3NhZ2VcIiwgbWVzc2FnZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJzdGFja1wiLCBtZXNzYWdlLnN0YWNrKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluaGVyaXRzKE9wZXJhdGlvbmFsRXJyb3IsIEVycm9yKTtcblxuICAgICAgICAgICAgdmFyIGVycm9yVHlwZXMgPSBFcnJvcltcIl9fQmx1ZWJpcmRFcnJvclR5cGVzX19cIl07XG4gICAgICAgICAgICBpZiAoIWVycm9yVHlwZXMpIHtcbiAgICAgICAgICAgICAgICBlcnJvclR5cGVzID0gT2JqZWN0ZnJlZXplKHtcbiAgICAgICAgICAgICAgICAgICAgQ2FuY2VsbGF0aW9uRXJyb3I6IENhbmNlbGxhdGlvbkVycm9yLFxuICAgICAgICAgICAgICAgICAgICBUaW1lb3V0RXJyb3I6IFRpbWVvdXRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgT3BlcmF0aW9uYWxFcnJvcjogT3BlcmF0aW9uYWxFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgUmVqZWN0aW9uRXJyb3I6IE9wZXJhdGlvbmFsRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIEFnZ3JlZ2F0ZUVycm9yOiBBZ2dyZWdhdGVFcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGVzNS5kZWZpbmVQcm9wZXJ0eShFcnJvciwgXCJfX0JsdWViaXJkRXJyb3JUeXBlc19fXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGVycm9yVHlwZXMsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgICAgICAgICAgRXJyb3I6IEVycm9yLFxuICAgICAgICAgICAgICAgIFR5cGVFcnJvcjogX1R5cGVFcnJvcixcbiAgICAgICAgICAgICAgICBSYW5nZUVycm9yOiBfUmFuZ2VFcnJvcixcbiAgICAgICAgICAgICAgICBDYW5jZWxsYXRpb25FcnJvcjogZXJyb3JUeXBlcy5DYW5jZWxsYXRpb25FcnJvcixcbiAgICAgICAgICAgICAgICBPcGVyYXRpb25hbEVycm9yOiBlcnJvclR5cGVzLk9wZXJhdGlvbmFsRXJyb3IsXG4gICAgICAgICAgICAgICAgVGltZW91dEVycm9yOiBlcnJvclR5cGVzLlRpbWVvdXRFcnJvcixcbiAgICAgICAgICAgICAgICBBZ2dyZWdhdGVFcnJvcjogZXJyb3JUeXBlcy5BZ2dyZWdhdGVFcnJvcixcbiAgICAgICAgICAgICAgICBXYXJuaW5nOiBXYXJuaW5nXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7IFwiLi9lczVcIjogMTMsIFwiLi91dGlsXCI6IDM2IH1dLCAxMzogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIHZhciBpc0VTNSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICAgIGlmIChpc0VTNSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAgICAgICAgICAgICBmcmVlemU6IE9iamVjdC5mcmVlemUsXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5OiBPYmplY3QuZGVmaW5lUHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIGdldERlc2NyaXB0b3I6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gICAgICAgICAgICAgICAgICAgIGtleXM6IE9iamVjdC5rZXlzLFxuICAgICAgICAgICAgICAgICAgICBuYW1lczogT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsXG4gICAgICAgICAgICAgICAgICAgIGdldFByb3RvdHlwZU9mOiBPYmplY3QuZ2V0UHJvdG90eXBlT2YsXG4gICAgICAgICAgICAgICAgICAgIGlzQXJyYXk6IEFycmF5LmlzQXJyYXksXG4gICAgICAgICAgICAgICAgICAgIGlzRVM1OiBpc0VTNSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlJc1dyaXRhYmxlOiBmdW5jdGlvbiBwcm9wZXJ0eUlzV3JpdGFibGUob2JqLCBwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhISghZGVzY3JpcHRvciB8fCBkZXNjcmlwdG9yLndyaXRhYmxlIHx8IGRlc2NyaXB0b3Iuc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBoYXMgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICB2YXIgc3RyID0ge30udG9TdHJpbmc7XG4gICAgICAgICAgICAgICAgdmFyIHByb3RvID0ge30uY29uc3RydWN0b3IucHJvdG90eXBlO1xuXG4gICAgICAgICAgICAgICAgdmFyIE9iamVjdEtleXMgPSBmdW5jdGlvbiBPYmplY3RLZXlzKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhcy5jYWxsKG8sIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBPYmplY3RHZXREZXNjcmlwdG9yID0gZnVuY3Rpb24gT2JqZWN0R2V0RGVzY3JpcHRvcihvLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG9ba2V5XSB9O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgT2JqZWN0RGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBPYmplY3REZWZpbmVQcm9wZXJ0eShvLCBrZXksIGRlc2MpIHtcbiAgICAgICAgICAgICAgICAgICAgb1trZXldID0gZGVzYy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBPYmplY3RGcmVlemUgPSBmdW5jdGlvbiBPYmplY3RGcmVlemUob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBPYmplY3RHZXRQcm90b3R5cGVPZiA9IGZ1bmN0aW9uIE9iamVjdEdldFByb3RvdHlwZU9mKG9iaikge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdChvYmopLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBBcnJheUlzQXJyYXkgPSBmdW5jdGlvbiBBcnJheUlzQXJyYXkob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlzQXJyYXk6IEFycmF5SXNBcnJheSxcbiAgICAgICAgICAgICAgICAgICAga2V5czogT2JqZWN0S2V5cyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZXM6IE9iamVjdEtleXMsXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5OiBPYmplY3REZWZpbmVQcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0RGVzY3JpcHRvcjogT2JqZWN0R2V0RGVzY3JpcHRvcixcbiAgICAgICAgICAgICAgICAgICAgZnJlZXplOiBPYmplY3RGcmVlemUsXG4gICAgICAgICAgICAgICAgICAgIGdldFByb3RvdHlwZU9mOiBPYmplY3RHZXRQcm90b3R5cGVPZixcbiAgICAgICAgICAgICAgICAgICAgaXNFUzU6IGlzRVM1LFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eUlzV3JpdGFibGU6IGZ1bmN0aW9uIHByb3BlcnR5SXNXcml0YWJsZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge31dLCAxNDogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChQcm9taXNlLCBJTlRFUk5BTCkge1xuICAgICAgICAgICAgICAgIHZhciBQcm9taXNlTWFwID0gUHJvbWlzZS5tYXA7XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAoZm4sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VNYXAodGhpcywgZm4sIG9wdGlvbnMsIElOVEVSTkFMKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5maWx0ZXIgPSBmdW5jdGlvbiAocHJvbWlzZXMsIGZuLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlTWFwKHByb21pc2VzLCBmbiwgb3B0aW9ucywgSU5URVJOQUwpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7fV0sIDE1OiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFByb21pc2UsIHRyeUNvbnZlcnRUb1Byb21pc2UsIE5FWFRfRklMVEVSKSB7XG4gICAgICAgICAgICAgICAgdmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xuICAgICAgICAgICAgICAgIHZhciBDYW5jZWxsYXRpb25FcnJvciA9IFByb21pc2UuQ2FuY2VsbGF0aW9uRXJyb3I7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbiAgICAgICAgICAgICAgICB2YXIgY2F0Y2hGaWx0ZXIgPSBfZGVyZXFfKFwiLi9jYXRjaF9maWx0ZXJcIikoTkVYVF9GSUxURVIpO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gUGFzc1Rocm91Z2hIYW5kbGVyQ29udGV4dChwcm9taXNlLCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgUGFzc1Rocm91Z2hIYW5kbGVyQ29udGV4dC5wcm90b3R5cGUuaXNGaW5hbGx5SGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gMDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gRmluYWxseUhhbmRsZXJDYW5jZWxSZWFjdGlvbihmaW5hbGx5SGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmFsbHlIYW5kbGVyID0gZmluYWxseUhhbmRsZXI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgRmluYWxseUhhbmRsZXJDYW5jZWxSZWFjdGlvbi5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tDYW5jZWwodGhpcy5maW5hbGx5SGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrQ2FuY2VsKGN0eCwgcmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHguY2FuY2VsUHJvbWlzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguY2FuY2VsUHJvbWlzZS5fcmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jYW5jZWxQcm9taXNlLl9jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jYW5jZWxQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzdWNjZWVkKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluYWxseUhhbmRsZXIuY2FsbCh0aGlzLCB0aGlzLnByb21pc2UuX3RhcmdldCgpLl9zZXR0bGVkVmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGZhaWwocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVja0NhbmNlbCh0aGlzLCByZWFzb24pKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGVycm9yT2JqLmUgPSByZWFzb247XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvck9iajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZmluYWxseUhhbmRsZXIocmVhc29uT3JWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLmhhbmRsZXI7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNhbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IHRoaXMuaXNGaW5hbGx5SGFuZGxlcigpID8gaGFuZGxlci5jYWxsKHByb21pc2UuX2JvdW5kVmFsdWUoKSkgOiBoYW5kbGVyLmNhbGwocHJvbWlzZS5fYm91bmRWYWx1ZSgpLCByZWFzb25PclZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IE5FWFRfRklMVEVSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9zZXRSZXR1cm5lZE5vblVuZGVmaW5lZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHJldCwgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FuY2VsUHJvbWlzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlLl9pc0NhbmNlbGxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlYXNvbiA9IG5ldyBDYW5jZWxsYXRpb25FcnJvcihcImxhdGUgY2FuY2VsbGF0aW9uIG9ic2VydmVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2UocmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck9iai5lID0gcmVhc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvck9iajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF5YmVQcm9taXNlLmlzUGVuZGluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9hdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayhuZXcgRmluYWxseUhhbmRsZXJDYW5jZWxSZWFjdGlvbih0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZS5fdGhlbihzdWNjZWVkLCBmYWlsLCB1bmRlZmluZWQsIHRoaXMsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb21pc2UuaXNSZWplY3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0NhbmNlbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yT2JqLmUgPSByZWFzb25PclZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tDYW5jZWwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhc29uT3JWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9wYXNzVGhyb3VnaCA9IGZ1bmN0aW9uIChoYW5kbGVyLCB0eXBlLCBzdWNjZXNzLCBmYWlsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdGhpcy50aGVuKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90aGVuKHN1Y2Nlc3MsIGZhaWwsIHVuZGVmaW5lZCwgbmV3IFBhc3NUaHJvdWdoSGFuZGxlckNvbnRleHQodGhpcywgdHlwZSwgaGFuZGxlciksIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLmxhc3RseSA9IFByb21pc2UucHJvdG90eXBlW1wiZmluYWxseVwiXSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXNzVGhyb3VnaChoYW5kbGVyLCAwLCBmaW5hbGx5SGFuZGxlciwgZmluYWxseUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS50YXAgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFzc1Rocm91Z2goaGFuZGxlciwgMSwgZmluYWxseUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS50YXBDYXRjaCA9IGZ1bmN0aW9uIChoYW5kbGVyT3JQcmVkaWNhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZW4gPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXNzVGhyb3VnaChoYW5kbGVyT3JQcmVkaWNhdGUsIDEsIHVuZGVmaW5lZCwgZmluYWxseUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhdGNoSW5zdGFuY2VzID0gbmV3IEFycmF5KGxlbiAtIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuIC0gMTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHV0aWwuaXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2hJbnN0YW5jZXNbaisrXSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoXCJ0YXBDYXRjaCBzdGF0ZW1lbnQgcHJlZGljYXRlOiBcIiArIFwiZXhwZWN0aW5nIGFuIG9iamVjdCBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhpdGVtKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoSW5zdGFuY2VzLmxlbmd0aCA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlciA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXNzVGhyb3VnaChjYXRjaEZpbHRlcihjYXRjaEluc3RhbmNlcywgaGFuZGxlciwgdGhpcyksIDEsIHVuZGVmaW5lZCwgZmluYWxseUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBQYXNzVGhyb3VnaEhhbmRsZXJDb250ZXh0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgeyBcIi4vY2F0Y2hfZmlsdGVyXCI6IDcsIFwiLi91dGlsXCI6IDM2IH1dLCAxNjogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChQcm9taXNlLCBhcGlSZWplY3Rpb24sIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBQcm94eWFibGUsIGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9ycyA9IF9kZXJlcV8oXCIuL2Vycm9yc1wiKTtcbiAgICAgICAgICAgICAgICB2YXIgVHlwZUVycm9yID0gZXJyb3JzLlR5cGVFcnJvcjtcbiAgICAgICAgICAgICAgICB2YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbiAgICAgICAgICAgICAgICB2YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xuICAgICAgICAgICAgICAgIHZhciB5aWVsZEhhbmRsZXJzID0gW107XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBwcm9taXNlRnJvbVlpZWxkSGFuZGxlcih2YWx1ZSwgeWllbGRIYW5kbGVycywgdHJhY2VQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB5aWVsZEhhbmRsZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZVBhcmVudC5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh5aWVsZEhhbmRsZXJzW2ldKSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZVBhcmVudC5fcG9wQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjZVBhcmVudC5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gUHJvbWlzZS5yZWplY3QoZXJyb3JPYmouZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2VQYXJlbnQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocmVzdWx0LCB0cmFjZVBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIG1heWJlUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBQcm9taXNlU3Bhd24oZ2VuZXJhdG9yRnVuY3Rpb24sIHJlY2VpdmVyLCB5aWVsZEhhbmRsZXIsIHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWJ1Zy5jYW5jZWxsYXRpb24oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGludGVybmFsID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9maW5hbGx5UHJvbWlzZSA9IHRoaXMuX2ZpbmFsbHlQcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZSA9IGludGVybmFsLmxhc3RseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9maW5hbGx5UHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWwuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbC5fc2V0T25DYW5jZWwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRvckZ1bmN0aW9uID0gZ2VuZXJhdG9yRnVuY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feWllbGRIYW5kbGVycyA9IHR5cGVvZiB5aWVsZEhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIiA/IFt5aWVsZEhhbmRsZXJdLmNvbmNhdCh5aWVsZEhhbmRsZXJzKSA6IHlpZWxkSGFuZGxlcnM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3lpZWxkZWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsbGF0aW9uUGhhc2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXRpbC5pbmhlcml0cyhQcm9taXNlU3Bhd24sIFByb3h5YWJsZSk7XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlU3Bhd24ucHJvdG90eXBlLl9pc1Jlc29sdmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZSA9PT0gbnVsbDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZVNwYXduLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZSA9IHRoaXMuX2dlbmVyYXRvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWJ1Zy5jYW5jZWxsYXRpb24oKSAmJiB0aGlzLl9maW5hbGx5UHJvbWlzZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmluYWxseVByb21pc2UuX2Z1bGZpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmFsbHlQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlU3Bhd24ucHJvdG90eXBlLl9wcm9taXNlQ2FuY2VsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbXBsZW1lbnRzUmV0dXJuID0gdHlwZW9mIHRoaXMuX2dlbmVyYXRvcltcInJldHVyblwiXSAhPT0gXCJ1bmRlZmluZWRcIjtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWltcGxlbWVudHNSZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWFzb24gPSBuZXcgUHJvbWlzZS5DYW5jZWxsYXRpb25FcnJvcihcImdlbmVyYXRvciAucmV0dXJuKCkgc2VudGluZWxcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmNvcm91dGluZS5yZXR1cm5TZW50aW5lbCA9IHJlYXNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2UuX2F0dGFjaEV4dHJhVHJhY2UocmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLl9nZW5lcmF0b3JbXCJ0aHJvd1wiXSkuY2FsbCh0aGlzLl9nZW5lcmF0b3IsIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZ2VuZXJhdG9yW1wicmV0dXJuXCJdKS5jYWxsKHRoaXMuX2dlbmVyYXRvciwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2UuX3BvcENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYW5jZWxsYXRpb25QaGFzZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3lpZWxkZWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGludWUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZVNwYXduLnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl95aWVsZGVkUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLl9nZW5lcmF0b3IubmV4dCkuY2FsbCh0aGlzLl9nZW5lcmF0b3IsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250aW51ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlU3Bhd24ucHJvdG90eXBlLl9wcm9taXNlUmVqZWN0ZWQgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3lpZWxkZWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZShyZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZ2VuZXJhdG9yW1widGhyb3dcIl0pLmNhbGwodGhpcy5fZ2VuZXJhdG9yLCByZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRpbnVlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2VTcGF3bi5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3lpZWxkZWRQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl95aWVsZGVkUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3lpZWxkZWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZVNwYXduLnByb3RvdHlwZS5wcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZVNwYXduLnByb3RvdHlwZS5fcnVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZW5lcmF0b3IgPSB0aGlzLl9nZW5lcmF0b3JGdW5jdGlvbi5jYWxsKHRoaXMuX3JlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVjZWl2ZXIgPSB0aGlzLl9nZW5lcmF0b3JGdW5jdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZUZ1bGZpbGxlZCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlU3Bhd24ucHJvdG90eXBlLl9jb250aW51ZSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhbmNlbGxhdGlvblBoYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhyZXN1bHQuZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYW5jZWxsYXRpb25QaGFzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5fcmVzb2x2ZUNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHZhbHVlLCB0aGlzLl9wcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlID0gcHJvbWlzZUZyb21ZaWVsZEhhbmRsZXIobWF5YmVQcm9taXNlLCB0aGlzLl95aWVsZEhhbmRsZXJzLCB0aGlzLl9wcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2VSZWplY3RlZChuZXcgVHlwZUVycm9yKFwiQSB2YWx1ZSAlcyB3YXMgeWllbGRlZCB0aGF0IGNvdWxkIG5vdCBiZSB0cmVhdGVkIGFzIGEgcHJvbWlzZVxcblxcbiAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXG5cXG5cIi5yZXBsYWNlKFwiJXNcIiwgU3RyaW5nKHZhbHVlKSkgKyBcIkZyb20gY29yb3V0aW5lOlxcblwiICsgdGhpcy5fc3RhY2suc3BsaXQoXCJcXG5cIikuc2xpY2UoMSwgLTcpLmpvaW4oXCJcXG5cIikpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYml0RmllbGQgPSBtYXliZVByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChiaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3lpZWxkZWRQcm9taXNlID0gbWF5YmVQcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fcHJveHkodGhpcywgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UuX2FzeW5jLmludm9rZSh0aGlzLl9wcm9taXNlRnVsZmlsbGVkLCB0aGlzLCBtYXliZVByb21pc2UuX3ZhbHVlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLl9hc3luYy5pbnZva2UodGhpcy5fcHJvbWlzZVJlamVjdGVkLCB0aGlzLCBtYXliZVByb21pc2UuX3JlYXNvbigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UuY29yb3V0aW5lID0gZnVuY3Rpb24gKGdlbmVyYXRvckZ1bmN0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZ2VuZXJhdG9yRnVuY3Rpb24gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImdlbmVyYXRvckZ1bmN0aW9uIG11c3QgYmUgYSBmdW5jdGlvblxcblxcbiAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXG5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHlpZWxkSGFuZGxlciA9IE9iamVjdChvcHRpb25zKS55aWVsZEhhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBQcm9taXNlU3Bhd24kID0gUHJvbWlzZVNwYXduO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZW5lcmF0b3IgPSBnZW5lcmF0b3JGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwYXduID0gbmV3IFByb21pc2VTcGF3biQodW5kZWZpbmVkLCB1bmRlZmluZWQsIHlpZWxkSGFuZGxlciwgc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IHNwYXduLnByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYXduLl9nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGF3bi5fcHJvbWlzZUZ1bGZpbGxlZCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5jb3JvdXRpbmUuYWRkWWllbGRIYW5kbGVyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeWllbGRIYW5kbGVycy5wdXNoKGZuKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5zcGF3biA9IGZ1bmN0aW9uIChnZW5lcmF0b3JGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Zy5kZXByZWNhdGVkKFwiUHJvbWlzZS5zcGF3bigpXCIsIFwiUHJvbWlzZS5jb3JvdXRpbmUoKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBnZW5lcmF0b3JGdW5jdGlvbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZ2VuZXJhdG9yRnVuY3Rpb24gbXVzdCBiZSBhIGZ1bmN0aW9uXFxuXFxuICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgc3Bhd24gPSBuZXcgUHJvbWlzZVNwYXduKGdlbmVyYXRvckZ1bmN0aW9uLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IHNwYXduLnByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgc3Bhd24uX3J1bihQcm9taXNlLnNwYXduKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgeyBcIi4vZXJyb3JzXCI6IDEyLCBcIi4vdXRpbFwiOiAzNiB9XSwgMTc6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBJTlRFUk5BTCwgYXN5bmMsIGdldERvbWFpbikge1xuICAgICAgICAgICAgICAgIHZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgY2FuRXZhbHVhdGUgPSB1dGlsLmNhbkV2YWx1YXRlO1xuICAgICAgICAgICAgICAgIHZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbiAgICAgICAgICAgICAgICB2YXIgcmVqZWN0O1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW5FdmFsdWF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoZW5DYWxsYmFjayA9IGZ1bmN0aW9uIHRoZW5DYWxsYmFjayhpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInZhbHVlXCIsIFwiaG9sZGVyXCIsIFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaG9sZGVyLnBJbmRleCA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaG9sZGVyLmNoZWNrRnVsZmlsbG1lbnQodGhpcyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgXCIucmVwbGFjZSgvSW5kZXgvZywgaSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2VTZXR0ZXIgPSBmdW5jdGlvbiBwcm9taXNlU2V0dGVyKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwicHJvbWlzZVwiLCBcImhvbGRlclwiLCBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAndXNlIHN0cmljdCc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBob2xkZXIucEluZGV4ID0gcHJvbWlzZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBcIi5yZXBsYWNlKC9JbmRleC9nLCBpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2VuZXJhdGVIb2xkZXJDbGFzcyA9IGZ1bmN0aW9uIGdlbmVyYXRlSG9sZGVyQ2xhc3ModG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBuZXcgQXJyYXkodG90YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbaV0gPSBcInRoaXMucFwiICsgKGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFzc2lnbm1lbnQgPSBwcm9wcy5qb2luKFwiID0gXCIpICsgXCIgPSBudWxsO1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW5jZWxsYXRpb25Db2RlID0gXCJ2YXIgcHJvbWlzZTtcXG5cIiArIHByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHByb21pc2UgPSBcIiArIHByb3AgKyBcIjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgaWYgKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UuY2FuY2VsKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXNzZWRBcmd1bWVudHMgPSBwcm9wcy5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBcIkhvbGRlciRcIiArIHRvdGFsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBcInJldHVybiBmdW5jdGlvbih0cnlDYXRjaCwgZXJyb3JPYmosIFByb21pc2UsIGFzeW5jKSB7ICAgIFxcblxcXG4gICAgICAgICAgICAndXNlIHN0cmljdCc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBmdW5jdGlvbiBbVGhlTmFtZV0oZm4pIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgW1RoZVByb3BlcnRpZXNdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgdGhpcy5mbiA9IGZuOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgdGhpcy5hc3luY05lZWRlZCA9IHRydWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgdGhpcy5ub3cgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBbVGhlTmFtZV0ucHJvdG90eXBlLl9jYWxsRnVuY3Rpb24gPSBmdW5jdGlvbihwcm9taXNlKSB7ICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fcHVzaENvbnRleHQoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IHRyeUNhdGNoKHRoaXMuZm4pKFtUaGVQYXNzZWRBcmd1bWVudHNdKTsgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fcG9wQ29udGV4dCgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHJldC5lLCBmYWxzZSk7ICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UuX3Jlc29sdmVDYWxsYmFjayhyZXQpOyAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBbVGhlTmFtZV0ucHJvdG90eXBlLmNoZWNrRnVsZmlsbG1lbnQgPSBmdW5jdGlvbihwcm9taXNlKSB7ICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgdmFyIG5vdyA9ICsrdGhpcy5ub3c7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgaWYgKG5vdyA9PT0gW1RoZVRvdGFsXSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFzeW5jTmVlZGVkKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3luYy5pbnZva2UodGhpcy5fY2FsbEZ1bmN0aW9uLCB0aGlzLCBwcm9taXNlKTsgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxsRnVuY3Rpb24ocHJvbWlzZSk7ICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBbVGhlTmFtZV0ucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHsgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgW0NhbmNlbGxhdGlvbkNvZGVdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICByZXR1cm4gW1RoZU5hbWVdOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIH0odHJ5Q2F0Y2gsIGVycm9yT2JqLCBQcm9taXNlLCBhc3luYyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIFwiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZSgvXFxbVGhlTmFtZVxcXS9nLCBuYW1lKS5yZXBsYWNlKC9cXFtUaGVUb3RhbFxcXS9nLCB0b3RhbCkucmVwbGFjZSgvXFxbVGhlUGFzc2VkQXJndW1lbnRzXFxdL2csIHBhc3NlZEFyZ3VtZW50cykucmVwbGFjZSgvXFxbVGhlUHJvcGVydGllc1xcXS9nLCBhc3NpZ25tZW50KS5yZXBsYWNlKC9cXFtDYW5jZWxsYXRpb25Db2RlXFxdL2csIGNhbmNlbGxhdGlvbkNvZGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInRyeUNhdGNoXCIsIFwiZXJyb3JPYmpcIiwgXCJQcm9taXNlXCIsIFwiYXN5bmNcIiwgY29kZSkodHJ5Q2F0Y2gsIGVycm9yT2JqLCBQcm9taXNlLCBhc3luYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaG9sZGVyQ2xhc3NlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoZW5DYWxsYmFja3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlU2V0dGVycyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlckNsYXNzZXMucHVzaChnZW5lcmF0ZUhvbGRlckNsYXNzKGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbkNhbGxiYWNrcy5wdXNoKHRoZW5DYWxsYmFjayhpICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VTZXR0ZXJzLnB1c2gocHJvbWlzZVNldHRlcihpICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QgPSBmdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5qb2luID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm47XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0ID4gMCAmJiB0eXBlb2YgYXJndW1lbnRzW2xhc3RdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuID0gYXJndW1lbnRzW2xhc3RdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3QgPD0gOCAmJiBjYW5FdmFsdWF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBIb2xkZXJDbGFzcyA9IGhvbGRlckNsYXNzZXNbbGFzdCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaG9sZGVyID0gbmV3IEhvbGRlckNsYXNzKGZuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoZW5DYWxsYmFja3M7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKGFyZ3VtZW50c1tpXSwgcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlID0gbWF5YmVQcm9taXNlLl90YXJnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYml0RmllbGQgPSBtYXliZVByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fdGhlbihjYWxsYmFja3NbaV0sIHJlamVjdCwgdW5kZWZpbmVkLCByZXQsIGhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VTZXR0ZXJzW2ldKG1heWJlUHJvbWlzZSwgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmFzeW5jTmVlZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzW2ldLmNhbGwocmV0LCBtYXliZVByb21pc2UuX3ZhbHVlKCksIGhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0Ll9yZWplY3QobWF5YmVQcm9taXNlLl9yZWFzb24oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0Ll9jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKHJldCwgbWF5YmVQcm9taXNlLCBob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXQuX2lzRmF0ZVNlYWxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLmFzeW5jTmVlZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbiA9IGdldERvbWFpbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb21haW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmZuID0gdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgaG9sZGVyLmZuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0Ll9zZXRPbkNhbmNlbChob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpOztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZuKSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFByb21pc2VBcnJheShhcmdzKS5wcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gcmV0LnNwcmVhZChmbikgOiByZXQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHsgXCIuL3V0aWxcIjogMzYgfV0sIDE4OiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFByb21pc2UsIFByb21pc2VBcnJheSwgYXBpUmVqZWN0aW9uLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBJTlRFUk5BTCwgZGVidWcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2V0RG9tYWluID0gUHJvbWlzZS5fZ2V0RG9tYWluO1xuICAgICAgICAgICAgICAgIHZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xuICAgICAgICAgICAgICAgIHZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG4gICAgICAgICAgICAgICAgdmFyIGFzeW5jID0gUHJvbWlzZS5fYXN5bmM7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBNYXBwaW5nUHJvbWlzZUFycmF5KHByb21pc2VzLCBmbiwgbGltaXQsIF9maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciQocHJvbWlzZXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9tYWluID0gZ2V0RG9tYWluKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrID0gZG9tYWluID09PSBudWxsID8gZm4gOiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBmbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByZXNlcnZlZFZhbHVlcyA9IF9maWx0ZXIgPT09IElOVEVSTkFMID8gbmV3IEFycmF5KHRoaXMubGVuZ3RoKCkpIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGltaXQgPSBsaW1pdDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5GbGlnaHQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBhc3luYy5pbnZva2UodGhpcy5fYXN5bmNJbml0LCB0aGlzLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1dGlsLmluaGVyaXRzKE1hcHBpbmdQcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cbiAgICAgICAgICAgICAgICBNYXBwaW5nUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fYXN5bmNJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0JCh1bmRlZmluZWQsIC0yKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgICAgICAgICAgIE1hcHBpbmdQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5fdmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXNlcnZlZFZhbHVlcyA9IHRoaXMuX3ByZXNlcnZlZFZhbHVlcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbWl0ID0gdGhpcy5fbGltaXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleCAqIC0xIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW1pdCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5GbGlnaHQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFpblF1ZXVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzUmVzb2x2ZWQoKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGltaXQgPj0gMSAmJiB0aGlzLl9pbkZsaWdodCA+PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlc2VydmVkVmFsdWVzICE9PSBudWxsKSBwcmVzZXJ2ZWRWYWx1ZXNbaW5kZXhdID0gdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IHRoaXMuX2NhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY2VpdmVyID0gcHJvbWlzZS5fYm91bmRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSB0cnlDYXRjaChjYWxsYmFjaykuY2FsbChyZWNlaXZlciwgdmFsdWUsIGluZGV4LCBsZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2VDcmVhdGVkID0gcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcuY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zKHJldCwgcHJvbWlzZUNyZWF0ZWQsIHByZXNlcnZlZFZhbHVlcyAhPT0gbnVsbCA/IFwiUHJvbWlzZS5maWx0ZXJcIiA6IFwiUHJvbWlzZS5tYXBcIiwgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdChyZXQuZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHJldCwgdGhpcy5fcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJpdEZpZWxkID0gbWF5YmVQcm9taXNlLl9iaXRGaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChiaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGltaXQgPj0gMSkgdGhpcy5faW5GbGlnaHQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2luZGV4XSA9IG1heWJlUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9wcm94eSh0aGlzLCAoaW5kZXggKyAxKSAqIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IG1heWJlUHJvbWlzZS5fdmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWplY3QobWF5YmVQcm9taXNlLl9yZWFzb24oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gcmV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbFJlc29sdmVkID0gKyt0aGlzLl90b3RhbFJlc29sdmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG90YWxSZXNvbHZlZCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVzZXJ2ZWRWYWx1ZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9maWx0ZXIodmFsdWVzLCBwcmVzZXJ2ZWRWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIE1hcHBpbmdQcm9taXNlQXJyYXkucHJvdG90eXBlLl9kcmFpblF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcXVldWUgPSB0aGlzLl9xdWV1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbWl0ID0gdGhpcy5fbGltaXQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLl92YWx1ZXM7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwICYmIHRoaXMuX2luRmxpZ2h0IDwgbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHF1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZUZ1bGZpbGxlZCh2YWx1ZXNbaW5kZXhdLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUuX2ZpbHRlciA9IGZ1bmN0aW9uIChib29sZWFucywgdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbmV3IEFycmF5KGxlbik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJvb2xlYW5zW2ldKSByZXRbaisrXSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXQubGVuZ3RoID0gajtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZShyZXQpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBNYXBwaW5nUHJvbWlzZUFycmF5LnByb3RvdHlwZS5wcmVzZXJ2ZWRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcmVzZXJ2ZWRWYWx1ZXM7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG1hcChwcm9taXNlcywgZm4sIG9wdGlvbnMsIF9maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW1pdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIG9wdGlvbnMgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvcHRpb25zKSkgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb25jdXJyZW5jeSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcihcIidjb25jdXJyZW5jeScgbXVzdCBiZSBhIG51bWJlciBidXQgaXQgaXMgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKG9wdGlvbnMuY29uY3VycmVuY3kpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0ID0gb3B0aW9ucy5jb25jdXJyZW5jeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoXCJvcHRpb25zIGFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0IGJ1dCBpdCBpcyBcIiArIHV0aWwuY2xhc3NTdHJpbmcob3B0aW9ucykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsaW1pdCA9IHR5cGVvZiBsaW1pdCA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZShsaW1pdCkgJiYgbGltaXQgPj0gMSA/IGxpbWl0IDogMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXBwaW5nUHJvbWlzZUFycmF5KHByb21pc2VzLCBmbiwgbGltaXQsIF9maWx0ZXIpLnByb21pc2UoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZm4sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcCh0aGlzLCBmbiwgb3B0aW9ucywgbnVsbCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UubWFwID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbiwgb3B0aW9ucywgX2ZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFwKHByb21pc2VzLCBmbiwgb3B0aW9ucywgX2ZpbHRlcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHsgXCIuL3V0aWxcIjogMzYgfV0sIDE5OiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24sIGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xuICAgICAgICAgICAgICAgIHZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLm1ldGhvZCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQcm9taXNlLlR5cGVFcnJvcihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0cnlDYXRjaChmbikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlQ3JlYXRlZCA9IHJldC5fcG9wQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcuY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zKHZhbHVlLCBwcm9taXNlQ3JlYXRlZCwgXCJQcm9taXNlLm1ldGhvZFwiLCByZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0Ll9yZXNvbHZlRnJvbVN5bmNWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLmF0dGVtcHQgPSBQcm9taXNlW1widHJ5XCJdID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXQuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Zy5kZXByZWNhdGVkKFwiY2FsbGluZyBQcm9taXNlLnRyeSB3aXRoIG1vcmUgdGhhbiAxIGFyZ3VtZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdHggPSBhcmd1bWVudHNbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHV0aWwuaXNBcnJheShhcmcpID8gdHJ5Q2F0Y2goZm4pLmFwcGx5KGN0eCwgYXJnKSA6IHRyeUNhdGNoKGZuKS5jYWxsKGN0eCwgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdHJ5Q2F0Y2goZm4pKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2VDcmVhdGVkID0gcmV0Ll9wb3BDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyh2YWx1ZSwgcHJvbWlzZUNyZWF0ZWQsIFwiUHJvbWlzZS50cnlcIiwgcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0Ll9yZXNvbHZlRnJvbVN5bmNWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9yZXNvbHZlRnJvbVN5bmNWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHV0aWwuZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdENhbGxiYWNrKHZhbHVlLmUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVDYWxsYmFjayh2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgeyBcIi4vdXRpbFwiOiAzNiB9XSwgMjA6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgICAgdmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xuICAgICAgICAgICAgdmFyIG1heWJlV3JhcEFzRXJyb3IgPSB1dGlsLm1heWJlV3JhcEFzRXJyb3I7XG4gICAgICAgICAgICB2YXIgZXJyb3JzID0gX2RlcmVxXyhcIi4vZXJyb3JzXCIpO1xuICAgICAgICAgICAgdmFyIE9wZXJhdGlvbmFsRXJyb3IgPSBlcnJvcnMuT3BlcmF0aW9uYWxFcnJvcjtcbiAgICAgICAgICAgIHZhciBlczUgPSBfZGVyZXFfKFwiLi9lczVcIik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzVW50eXBlZEVycm9yKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBFcnJvciAmJiBlczUuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gRXJyb3IucHJvdG90eXBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgckVycm9yS2V5ID0gL14oPzpuYW1lfG1lc3NhZ2V8c3RhY2t8Y2F1c2UpJC87XG4gICAgICAgICAgICBmdW5jdGlvbiB3cmFwQXNPcGVyYXRpb25hbEVycm9yKG9iaikge1xuICAgICAgICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgICAgICAgaWYgKGlzVW50eXBlZEVycm9yKG9iaikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gbmV3IE9wZXJhdGlvbmFsRXJyb3Iob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0Lm5hbWUgPSBvYmoubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0Lm1lc3NhZ2UgPSBvYmoubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnN0YWNrID0gb2JqLnN0YWNrO1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IGVzNS5rZXlzKG9iaik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJFcnJvcktleS50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHV0aWwubWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uKG9iaik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbm9kZWJhY2tGb3JQcm9taXNlKHByb21pc2UsIG11bHRpQXJncykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXJyLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvbWlzZSA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZCA9IHdyYXBBc09wZXJhdGlvbmFsRXJyb3IobWF5YmVXcmFwQXNFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2Uod3JhcHBlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9yZWplY3Qod3JhcHBlZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIW11bHRpQXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5fZnVsZmlsbCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTs7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9mdWxmaWxsKGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gbm9kZWJhY2tGb3JQcm9taXNlO1xuICAgICAgICB9LCB7IFwiLi9lcnJvcnNcIjogMTIsIFwiLi9lczVcIjogMTMsIFwiLi91dGlsXCI6IDM2IH1dLCAyMTogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xuICAgICAgICAgICAgICAgIHZhciBhc3luYyA9IFByb21pc2UuX2FzeW5jO1xuICAgICAgICAgICAgICAgIHZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNwcmVhZEFkYXB0ZXIodmFsLCBub2RlYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdXRpbC5pc0FycmF5KHZhbCkpIHJldHVybiBzdWNjZXNzQWRhcHRlci5jYWxsKHByb21pc2UsIHZhbCwgbm9kZWJhY2spO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gdHJ5Q2F0Y2gobm9kZWJhY2spLmFwcGx5KHByb21pc2UuX2JvdW5kVmFsdWUoKSwgW251bGxdLmNvbmNhdCh2YWwpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jLnRocm93TGF0ZXIocmV0LmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc3VjY2Vzc0FkYXB0ZXIodmFsLCBub2RlYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWNlaXZlciA9IHByb21pc2UuX2JvdW5kVmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IHZhbCA9PT0gdW5kZWZpbmVkID8gdHJ5Q2F0Y2gobm9kZWJhY2spLmNhbGwocmVjZWl2ZXIsIG51bGwpIDogdHJ5Q2F0Y2gobm9kZWJhY2spLmNhbGwocmVjZWl2ZXIsIG51bGwsIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3luYy50aHJvd0xhdGVyKHJldC5lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBlcnJvckFkYXB0ZXIocmVhc29uLCBub2RlYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3UmVhc29uID0gbmV3IEVycm9yKHJlYXNvbiArIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UmVhc29uLmNhdXNlID0gcmVhc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uID0gbmV3UmVhc29uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSB0cnlDYXRjaChub2RlYmFjaykuY2FsbChwcm9taXNlLl9ib3VuZFZhbHVlKCksIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3luYy50aHJvd0xhdGVyKHJldC5lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLmFzQ2FsbGJhY2sgPSBQcm9taXNlLnByb3RvdHlwZS5ub2RlaWZ5ID0gZnVuY3Rpb24gKG5vZGViYWNrLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZWJhY2sgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWRhcHRlciA9IHN1Y2Nlc3NBZGFwdGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBPYmplY3Qob3B0aW9ucykuc3ByZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRhcHRlciA9IHNwcmVhZEFkYXB0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90aGVuKGFkYXB0ZXIsIGVycm9yQWRhcHRlciwgdW5kZWZpbmVkLCB0aGlzLCBub2RlYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHsgXCIuL3V0aWxcIjogMzYgfV0sIDIyOiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBtYWtlU2VsZlJlc29sdXRpb25FcnJvciA9IGZ1bmN0aW9uIG1ha2VTZWxmUmVzb2x1dGlvbkVycm9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcImNpcmN1bGFyIHByb21pc2UgcmVzb2x1dGlvbiBjaGFpblxcblxcbiAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXG5cIik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgcmVmbGVjdEhhbmRsZXIgPSBmdW5jdGlvbiByZWZsZWN0SGFuZGxlcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlLlByb21pc2VJbnNwZWN0aW9uKHRoaXMuX3RhcmdldCgpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBhcGlSZWplY3Rpb24gPSBmdW5jdGlvbiBhcGlSZWplY3Rpb24obXNnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKG1zZykpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gUHJveHlhYmxlKCkge31cbiAgICAgICAgICAgICAgICB2YXIgVU5ERUZJTkVEX0JJTkRJTkcgPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG5cbiAgICAgICAgICAgICAgICB2YXIgZ2V0RG9tYWluO1xuICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBnZXREb21haW4gPSBmdW5jdGlvbiBnZXREb21haW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gcHJvY2Vzcy5kb21haW47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ID09PSB1bmRlZmluZWQpIHJldCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdldERvbWFpbiA9IGZ1bmN0aW9uIGdldERvbWFpbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1dGlsLm5vdEVudW1lcmFibGVQcm9wKFByb21pc2UsIFwiX2dldERvbWFpblwiLCBnZXREb21haW4pO1xuXG4gICAgICAgICAgICAgICAgdmFyIGVzNSA9IF9kZXJlcV8oXCIuL2VzNVwiKTtcbiAgICAgICAgICAgICAgICB2YXIgQXN5bmMgPSBfZGVyZXFfKFwiLi9hc3luY1wiKTtcbiAgICAgICAgICAgICAgICB2YXIgYXN5bmMgPSBuZXcgQXN5bmMoKTtcbiAgICAgICAgICAgICAgICBlczUuZGVmaW5lUHJvcGVydHkoUHJvbWlzZSwgXCJfYXN5bmNcIiwgeyB2YWx1ZTogYXN5bmMgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9ycyA9IF9kZXJlcV8oXCIuL2Vycm9yc1wiKTtcbiAgICAgICAgICAgICAgICB2YXIgVHlwZUVycm9yID0gUHJvbWlzZS5UeXBlRXJyb3IgPSBlcnJvcnMuVHlwZUVycm9yO1xuICAgICAgICAgICAgICAgIFByb21pc2UuUmFuZ2VFcnJvciA9IGVycm9ycy5SYW5nZUVycm9yO1xuICAgICAgICAgICAgICAgIHZhciBDYW5jZWxsYXRpb25FcnJvciA9IFByb21pc2UuQ2FuY2VsbGF0aW9uRXJyb3IgPSBlcnJvcnMuQ2FuY2VsbGF0aW9uRXJyb3I7XG4gICAgICAgICAgICAgICAgUHJvbWlzZS5UaW1lb3V0RXJyb3IgPSBlcnJvcnMuVGltZW91dEVycm9yO1xuICAgICAgICAgICAgICAgIFByb21pc2UuT3BlcmF0aW9uYWxFcnJvciA9IGVycm9ycy5PcGVyYXRpb25hbEVycm9yO1xuICAgICAgICAgICAgICAgIFByb21pc2UuUmVqZWN0aW9uRXJyb3IgPSBlcnJvcnMuT3BlcmF0aW9uYWxFcnJvcjtcbiAgICAgICAgICAgICAgICBQcm9taXNlLkFnZ3JlZ2F0ZUVycm9yID0gZXJyb3JzLkFnZ3JlZ2F0ZUVycm9yO1xuICAgICAgICAgICAgICAgIHZhciBJTlRFUk5BTCA9IGZ1bmN0aW9uIElOVEVSTkFMKCkge307XG4gICAgICAgICAgICAgICAgdmFyIEFQUExZID0ge307XG4gICAgICAgICAgICAgICAgdmFyIE5FWFRfRklMVEVSID0ge307XG4gICAgICAgICAgICAgICAgdmFyIHRyeUNvbnZlcnRUb1Byb21pc2UgPSBfZGVyZXFfKFwiLi90aGVuYWJsZXNcIikoUHJvbWlzZSwgSU5URVJOQUwpO1xuICAgICAgICAgICAgICAgIHZhciBQcm9taXNlQXJyYXkgPSBfZGVyZXFfKFwiLi9wcm9taXNlX2FycmF5XCIpKFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24sIFByb3h5YWJsZSk7XG4gICAgICAgICAgICAgICAgdmFyIENvbnRleHQgPSBfZGVyZXFfKFwiLi9jb250ZXh0XCIpKFByb21pc2UpO1xuICAgICAgICAgICAgICAgIC8qanNoaW50IHVudXNlZDpmYWxzZSovXG4gICAgICAgICAgICAgICAgdmFyIGNyZWF0ZUNvbnRleHQgPSBDb250ZXh0LmNyZWF0ZTtcbiAgICAgICAgICAgICAgICB2YXIgZGVidWcgPSBfZGVyZXFfKFwiLi9kZWJ1Z2dhYmlsaXR5XCIpKFByb21pc2UsIENvbnRleHQpO1xuICAgICAgICAgICAgICAgIHZhciBDYXB0dXJlZFRyYWNlID0gZGVidWcuQ2FwdHVyZWRUcmFjZTtcbiAgICAgICAgICAgICAgICB2YXIgUGFzc1Rocm91Z2hIYW5kbGVyQ29udGV4dCA9IF9kZXJlcV8oXCIuL2ZpbmFsbHlcIikoUHJvbWlzZSwgdHJ5Q29udmVydFRvUHJvbWlzZSwgTkVYVF9GSUxURVIpO1xuICAgICAgICAgICAgICAgIHZhciBjYXRjaEZpbHRlciA9IF9kZXJlcV8oXCIuL2NhdGNoX2ZpbHRlclwiKShORVhUX0ZJTFRFUik7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGViYWNrRm9yUHJvbWlzZSA9IF9kZXJlcV8oXCIuL25vZGViYWNrXCIpO1xuICAgICAgICAgICAgICAgIHZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG4gICAgICAgICAgICAgICAgdmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjaGVjayhzZWxmLCBleGVjdXRvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZiA9PSBudWxsIHx8IHNlbGYuY29uc3RydWN0b3IgIT09IFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgaW52b2tlZCBkaXJlY3RseVxcblxcbiAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXG5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZXhlY3V0b3IpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4ZWN1dG9yICE9PSBJTlRFUk5BTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2sodGhpcywgZXhlY3V0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JpdEZpZWxkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjAgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2UwID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWNlaXZlcjAgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVGcm9tRXhlY3V0b3IoZXhlY3V0b3IpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlQ3JlYXRlZCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQoXCJwcm9taXNlQ3JlYXRlZFwiLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiW29iamVjdCBQcm9taXNlXVwiO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5jYXVnaHQgPSBQcm9taXNlLnByb3RvdHlwZVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhdGNoSW5zdGFuY2VzID0gbmV3IEFycmF5KGxlbiAtIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuIC0gMTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHV0aWwuaXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2hJbnN0YW5jZXNbaisrXSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcIkNhdGNoIHN0YXRlbWVudCBwcmVkaWNhdGU6IFwiICsgXCJleHBlY3RpbmcgYW4gb2JqZWN0IGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGl0ZW0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaEluc3RhbmNlcy5sZW5ndGggPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm4gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgY2F0Y2hGaWx0ZXIoY2F0Y2hJbnN0YW5jZXMsIGZuLCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIGZuKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUucmVmbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RoZW4ocmVmbGVjdEhhbmRsZXIsIHJlZmxlY3RIYW5kbGVyLCB1bmRlZmluZWQsIHRoaXMsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAoZGlkRnVsZmlsbCwgZGlkUmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWJ1Zy53YXJuaW5ncygpICYmIGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHR5cGVvZiBkaWRGdWxmaWxsICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGRpZFJlamVjdCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gXCIudGhlbigpIG9ubHkgYWNjZXB0cyBmdW5jdGlvbnMgYnV0IHdhcyBwYXNzZWQ6IFwiICsgdXRpbC5jbGFzc1N0cmluZyhkaWRGdWxmaWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1zZyArPSBcIiwgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGRpZFJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl93YXJuKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RoZW4oZGlkRnVsZmlsbCwgZGlkUmVqZWN0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uIChkaWRGdWxmaWxsLCBkaWRSZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl90aGVuKGRpZEZ1bGZpbGwsIGRpZFJlamVjdCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UuX3NldElzRmluYWwoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuc3ByZWFkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxsKCkuX3RoZW4oZm4sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBBUFBMWSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNGdWxmaWxsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNSZWplY3RlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsbWVudFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3Rpb25SZWFzb246IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQuZnVsZmlsbG1lbnRWYWx1ZSA9IHRoaXMudmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5pc0Z1bGZpbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1JlamVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5yZWplY3Rpb25SZWFzb24gPSB0aGlzLnJlYXNvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LmlzUmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLmFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl93YXJuKFwiLmFsbCgpIHdhcyBwYXNzZWQgYXJndW1lbnRzIGJ1dCBpdCBkb2VzIG5vdCB0YWtlIGFueVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2VBcnJheSh0aGlzKS5wcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhdWdodCh1dGlsLm9yaWdpbmF0ZXNGcm9tUmVqZWN0aW9uLCBmbik7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UuZ2V0TmV3TGlicmFyeUNvcHkgPSBtb2R1bGUuZXhwb3J0cztcblxuICAgICAgICAgICAgICAgIFByb21pc2UuaXMgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwgaW5zdGFuY2VvZiBQcm9taXNlO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLmZyb21Ob2RlID0gUHJvbWlzZS5mcm9tQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXVsdGlBcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyAhIU9iamVjdChhcmd1bWVudHNbMV0pLm11bHRpQXJncyA6IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2goZm4pKG5vZGViYWNrRm9yUHJvbWlzZShyZXQsIG11bHRpQXJncykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0Ll9yZWplY3RDYWxsYmFjayhyZXN1bHQuZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXQuX2lzRmF0ZVNlYWxlZCgpKSByZXQuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLmFsbCA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2VBcnJheShwcm9taXNlcykucHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLmNhc3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKG9iaik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHJldCBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQuX3NldEZ1bGZpbGxlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0Ll9yZWplY3Rpb25IYW5kbGVyMCA9IG9iajtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUgPSBQcm9taXNlLmZ1bGZpbGxlZCA9IFByb21pc2UuY2FzdDtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucmVqZWN0ID0gUHJvbWlzZS5yZWplY3RlZCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXQuX3JlamVjdENhbGxiYWNrKHJlYXNvbiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2Uuc2V0U2NoZWR1bGVyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzeW5jLnNldFNjaGVkdWxlcihmbik7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl90aGVuID0gZnVuY3Rpb24gKGRpZEZ1bGZpbGwsIGRpZFJlamVjdCwgXywgcmVjZWl2ZXIsIGludGVybmFsRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGF2ZUludGVybmFsRGF0YSA9IGludGVybmFsRGF0YSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGhhdmVJbnRlcm5hbERhdGEgPyBpbnRlcm5hbERhdGEgOiBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpdEZpZWxkID0gdGFyZ2V0Ll9iaXRGaWVsZDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhdmVJbnRlcm5hbERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuX3Byb3BhZ2F0ZUZyb20odGhpcywgMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpdmVyID09PSB1bmRlZmluZWQgJiYgKHRoaXMuX2JpdEZpZWxkICYgMjA5NzE1MikgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyID0gdGhpcy5fYm91bmRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyID0gdGFyZ2V0ID09PSB0aGlzID8gdW5kZWZpbmVkIDogdGhpcy5fYm91bmRUbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQoXCJwcm9taXNlQ2hhaW5lZFwiLCB0aGlzLCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSBnZXREb21haW4oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGxlciA9IHRhcmdldC5fc2V0dGxlUHJvbWlzZUN0eDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRhcmdldC5fcmVqZWN0aW9uSGFuZGxlcjA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlciA9IGRpZEZ1bGZpbGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGFyZ2V0Ll9mdWxmaWxsbWVudEhhbmRsZXIwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBkaWRSZWplY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Ll91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRsZXIgPSB0YXJnZXQuX3NldHRsZVByb21pc2VMYXRlQ2FuY2VsbGF0aW9uT2JzZXJ2ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQ2FuY2VsbGF0aW9uRXJyb3IoXCJsYXRlIGNhbmNlbGxhdGlvbiBvYnNlcnZlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuX2F0dGFjaEV4dHJhVHJhY2UodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBkaWRSZWplY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jLmludm9rZShzZXR0bGVyLCB0YXJnZXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyOiBkb21haW4gPT09IG51bGwgPyBoYW5kbGVyIDogdHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIiAmJiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBoYW5kbGVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlOiBwcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyOiByZWNlaXZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Ll9hZGRDYWxsYmFja3MoZGlkRnVsZmlsbCwgZGlkUmVqZWN0LCBwcm9taXNlLCByZWNlaXZlciwgZG9tYWluKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fbGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYml0RmllbGQgJiA2NTUzNTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2lzRmF0ZVNlYWxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDExNzUwNjA0OCkgIT09IDA7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9pc0ZvbGxvd2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDY3MTA4ODY0KSA9PT0gNjcxMDg4NjQ7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9zZXRMZW5ndGggPSBmdW5jdGlvbiAobGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgJiAtNjU1MzYgfCBsZW4gJiA2NTUzNTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3NldEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDMzNTU0NDMyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQoXCJwcm9taXNlRnVsZmlsbGVkXCIsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fc2V0UmVqZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAxNjc3NzIxNjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZVJlamVjdGVkXCIsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fc2V0Rm9sbG93aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgNjcxMDg4NjQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmVFdmVudChcInByb21pc2VSZXNvbHZlZFwiLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3NldElzRmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCA0MTk0MzA0O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5faXNGaW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDQxOTQzMDQpID4gMDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0Q2FuY2VsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkICYgfjY1NTM2O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fc2V0Q2FuY2VsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgNjU1MzY7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmVFdmVudChcInByb21pc2VDYW5jZWxsZWRcIiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9zZXRXaWxsQmVDYW5jZWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCA4Mzg4NjA4O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fc2V0QXN5bmNHdWFyYW50ZWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXN5bmMuaGFzQ3VzdG9tU2NoZWR1bGVyKCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDEzNDIxNzcyODtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3JlY2VpdmVyQXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IGluZGV4ID09PSAwID8gdGhpcy5fcmVjZWl2ZXIwIDogdGhpc1tpbmRleCAqIDQgLSA0ICsgM107XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IFVOREVGSU5FRF9CSU5ESU5HKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJldCA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2lzQm91bmQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kVmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fcHJvbWlzZUF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2luZGV4ICogNCAtIDQgKyAyXTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2Z1bGZpbGxtZW50SGFuZGxlckF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2luZGV4ICogNCAtIDQgKyAwXTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3JlamVjdGlvbkhhbmRsZXJBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tpbmRleCAqIDQgLSA0ICsgMV07XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9ib3VuZFZhbHVlID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fbWlncmF0ZUNhbGxiYWNrMCA9IGZ1bmN0aW9uIChmb2xsb3dlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYml0RmllbGQgPSBmb2xsb3dlci5fYml0RmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmdWxmaWxsID0gZm9sbG93ZXIuX2Z1bGZpbGxtZW50SGFuZGxlcjA7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWplY3QgPSBmb2xsb3dlci5fcmVqZWN0aW9uSGFuZGxlcjA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gZm9sbG93ZXIuX3Byb21pc2UwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjZWl2ZXIgPSBmb2xsb3dlci5fcmVjZWl2ZXJBdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpdmVyID09PSB1bmRlZmluZWQpIHJlY2VpdmVyID0gVU5ERUZJTkVEX0JJTkRJTkc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZENhbGxiYWNrcyhmdWxmaWxsLCByZWplY3QsIHByb21pc2UsIHJlY2VpdmVyLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX21pZ3JhdGVDYWxsYmFja0F0ID0gZnVuY3Rpb24gKGZvbGxvd2VyLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVsZmlsbCA9IGZvbGxvd2VyLl9mdWxmaWxsbWVudEhhbmRsZXJBdChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWplY3QgPSBmb2xsb3dlci5fcmVqZWN0aW9uSGFuZGxlckF0KGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBmb2xsb3dlci5fcHJvbWlzZUF0KGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY2VpdmVyID0gZm9sbG93ZXIuX3JlY2VpdmVyQXQoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWl2ZXIgPT09IHVuZGVmaW5lZCkgcmVjZWl2ZXIgPSBVTkRFRklORURfQklORElORztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkQ2FsbGJhY2tzKGZ1bGZpbGwsIHJlamVjdCwgcHJvbWlzZSwgcmVjZWl2ZXIsIG51bGwpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fYWRkQ2FsbGJhY2tzID0gZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCwgcHJvbWlzZSwgcmVjZWl2ZXIsIGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9sZW5ndGgoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gNjU1MzUgLSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRMZW5ndGgoMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2UwID0gcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlY2VpdmVyMCA9IHJlY2VpdmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmdWxmaWxsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwID0gZG9tYWluID09PSBudWxsID8gZnVsZmlsbCA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIGZ1bGZpbGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZWplY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwID0gZG9tYWluID09PSBudWxsID8gcmVqZWN0IDogdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiYXNlID0gaW5kZXggKiA0IC0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbYmFzZSArIDJdID0gcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbYmFzZSArIDNdID0gcmVjZWl2ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZ1bGZpbGwgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbYmFzZSArIDBdID0gZG9tYWluID09PSBudWxsID8gZnVsZmlsbCA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIGZ1bGZpbGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZWplY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbYmFzZSArIDFdID0gZG9tYWluID09PSBudWxsID8gcmVqZWN0IDogdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRMZW5ndGgoaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fcHJveHkgPSBmdW5jdGlvbiAocHJveHlhYmxlLCBhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkQ2FsbGJhY2tzKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcmcsIHByb3h5YWJsZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9yZXNvbHZlQ2FsbGJhY2sgPSBmdW5jdGlvbiAodmFsdWUsIHNob3VsZEJpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0aGlzLl9iaXRGaWVsZCAmIDExNzUwNjA0OCkgIT09IDApIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB0aGlzKSByZXR1cm4gdGhpcy5fcmVqZWN0Q2FsbGJhY2sobWFrZVNlbGZSZXNvbHV0aW9uRXJyb3IoKSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh2YWx1ZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpKSByZXR1cm4gdGhpcy5fZnVsZmlsbCh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZEJpbmQpIHRoaXMuX3Byb3BhZ2F0ZUZyb20obWF5YmVQcm9taXNlLCAyKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb21pc2UgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdChtYWtlU2VsZlJlc29sdXRpb25FcnJvcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBiaXRGaWVsZCA9IHByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5fbGVuZ3RoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuID4gMCkgcHJvbWlzZS5fbWlncmF0ZUNhbGxiYWNrMCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9taWdyYXRlQ2FsbGJhY2tBdCh0aGlzLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldEZvbGxvd2luZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0TGVuZ3RoKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0Rm9sbG93ZWUocHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mdWxmaWxsKHByb21pc2UuX3ZhbHVlKCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0KHByb21pc2UuX3JlYXNvbigpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWFzb24gPSBuZXcgQ2FuY2VsbGF0aW9uRXJyb3IoXCJsYXRlIGNhbmNlbGxhdGlvbiBvYnNlcnZlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2UocmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdChyZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9yZWplY3RDYWxsYmFjayA9IGZ1bmN0aW9uIChyZWFzb24sIHN5bmNocm9ub3VzLCBpZ25vcmVOb25FcnJvcldhcm5pbmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFjZSA9IHV0aWwuZW5zdXJlRXJyb3JPYmplY3QocmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc1N0YWNrID0gdHJhY2UgPT09IHJlYXNvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNTdGFjayAmJiAhaWdub3JlTm9uRXJyb3JXYXJuaW5ncyAmJiBkZWJ1Zy53YXJuaW5ncygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwiYSBwcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgbm9uLWVycm9yOiBcIiArIHV0aWwuY2xhc3NTdHJpbmcocmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3dhcm4obWVzc2FnZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXR0YWNoRXh0cmFUcmFjZSh0cmFjZSwgc3luY2hyb25vdXMgPyBoYXNTdGFjayA6IGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9yZXNvbHZlRnJvbUV4ZWN1dG9yID0gZnVuY3Rpb24gKGV4ZWN1dG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleGVjdXRvciA9PT0gSU5URVJOQUwpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wdXNoQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMuX2V4ZWN1dGUoZXhlY3V0b3IsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5fcmVzb2x2ZUNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCBzeW5jaHJvbm91cyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb3BDb250ZXh0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2sociwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3NldHRsZVByb21pc2VGcm9tSGFuZGxlciA9IGZ1bmN0aW9uIChoYW5kbGVyLCByZWNlaXZlciwgdmFsdWUsIHByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpdEZpZWxkID0gcHJvbWlzZS5fYml0RmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoYml0RmllbGQgJiA2NTUzNikgIT09IDApIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PT0gQVBQTFkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlLmxlbmd0aCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBlcnJvck9iajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LmUgPSBuZXcgVHlwZUVycm9yKFwiY2Fubm90IC5zcHJlYWQoKSBhIG5vbi1hcnJheTogXCIgKyB1dGlsLmNsYXNzU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSB0cnlDYXRjaChoYW5kbGVyKS5hcHBseSh0aGlzLl9ib3VuZFZhbHVlKCksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSB0cnlDYXRjaChoYW5kbGVyKS5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2VDcmVhdGVkID0gcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBiaXRGaWVsZCA9IHByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGJpdEZpZWxkICYgNjU1MzYpICE9PSAwKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHggPT09IE5FWFRfRklMVEVSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9yZWplY3QodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHggPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayh4LmUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyh4LCBwcm9taXNlQ3JlYXRlZCwgXCJcIiwgcHJvbWlzZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2soeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3RhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZXQuX2lzRm9sbG93aW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IHJldC5fZm9sbG93ZWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfXJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9mb2xsb3dlZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fc2V0Rm9sbG93ZWUgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWplY3Rpb25IYW5kbGVyMCA9IHByb21pc2U7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlID0gZnVuY3Rpb24gKHByb21pc2UsIGhhbmRsZXIsIHJlY2VpdmVyLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNQcm9taXNlID0gcHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXN5bmNHdWFyYW50ZWVkID0gKGJpdEZpZWxkICYgMTM0MjE3NzI4KSAhPT0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChiaXRGaWVsZCAmIDY1NTM2KSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvbWlzZSkgcHJvbWlzZS5faW52b2tlSW50ZXJuYWxPbkNhbmNlbCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWl2ZXIgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaEhhbmRsZXJDb250ZXh0ICYmIHJlY2VpdmVyLmlzRmluYWxseUhhbmRsZXIoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyLmNhbmNlbFByb21pc2UgPSBwcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cnlDYXRjaChoYW5kbGVyKS5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuX3JlamVjdChlcnJvck9iai5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPT09IHJlZmxlY3RIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5fZnVsZmlsbChyZWZsZWN0SGFuZGxlci5jYWxsKHJlY2VpdmVyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlY2VpdmVyIGluc3RhbmNlb2YgUHJveHlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZXIuX3Byb21pc2VDYW5jZWxsZWQocHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZSB8fCBwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5fY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5jYWxsKHJlY2VpdmVyLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhc3luY0d1YXJhbnRlZWQpIHByb21pc2UuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldHRsZVByb21pc2VGcm9tSGFuZGxlcihoYW5kbGVyLCByZWNlaXZlciwgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlY2VpdmVyIGluc3RhbmNlb2YgUHJveHlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY2VpdmVyLl9pc1Jlc29sdmVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyLl9wcm9taXNlRnVsZmlsbGVkKHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlci5fcHJvbWlzZVJlamVjdGVkKHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXN5bmNHdWFyYW50ZWVkKSBwcm9taXNlLl9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9mdWxmaWxsKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5fcmVqZWN0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZUxhdGVDYW5jZWxsYXRpb25PYnNlcnZlciA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBjdHguaGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBjdHgucHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY2VpdmVyID0gY3R4LnJlY2VpdmVyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjdHgudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwocmVjZWl2ZXIsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0dGxlUHJvbWlzZUZyb21IYW5kbGVyKGhhbmRsZXIsIHJlY2VpdmVyLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuX3JlamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3NldHRsZVByb21pc2VDdHggPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldHRsZVByb21pc2UoY3R4LnByb21pc2UsIGN0eC5oYW5kbGVyLCBjdHgucmVjZWl2ZXIsIGN0eC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlMCA9IGZ1bmN0aW9uIChoYW5kbGVyLCB2YWx1ZSwgYml0RmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY2VpdmVyID0gdGhpcy5fcmVjZWl2ZXJBdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZTAgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlY2VpdmVyMCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0dGxlUHJvbWlzZShwcm9taXNlLCBoYW5kbGVyLCByZWNlaXZlciwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fY2xlYXJDYWxsYmFja0RhdGFBdEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlID0gaW5kZXggKiA0IC0gNDtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tiYXNlICsgMl0gPSB0aGlzW2Jhc2UgKyAzXSA9IHRoaXNbYmFzZSArIDBdID0gdGhpc1tiYXNlICsgMV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9mdWxmaWxsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGJpdEZpZWxkICYgMTE3NTA2MDQ4KSA+Pj4gMTYpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gbWFrZVNlbGZSZXNvbHV0aW9uRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F0dGFjaEV4dHJhVHJhY2UoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRGdWxmaWxsZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjAgPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoKGJpdEZpZWxkICYgNjU1MzUpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChiaXRGaWVsZCAmIDEzNDIxNzcyOCkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luYy5zZXR0bGVQcm9taXNlcyh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fcmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChiaXRGaWVsZCAmIDExNzUwNjA0OCkgPj4+IDE2KSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFJlamVjdGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjAgPSByZWFzb247XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzRmluYWwoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzeW5jLmZhdGFsRXJyb3IocmVhc29uLCB1dGlsLmlzTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoKGJpdEZpZWxkICYgNjU1MzUpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmMuc2V0dGxlUHJvbWlzZXModGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbnN1cmVQb3NzaWJsZVJlamVjdGlvbkhhbmRsZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fZnVsZmlsbFByb21pc2VzID0gZnVuY3Rpb24gKGxlbiwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXJBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZUF0KGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY2VpdmVyID0gdGhpcy5fcmVjZWl2ZXJBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFyQ2FsbGJhY2tEYXRhQXRJbmRleChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldHRsZVByb21pc2UocHJvbWlzZSwgaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fcmVqZWN0UHJvbWlzZXMgPSBmdW5jdGlvbiAobGVuLCByZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLl9yZWplY3Rpb25IYW5kbGVyQXQoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2VBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWNlaXZlciA9IHRoaXMuX3JlY2VpdmVyQXQoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGVhckNhbGxiYWNrRGF0YUF0SW5kZXgoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlKHByb21pc2UsIGhhbmRsZXIsIHJlY2VpdmVyLCByZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpdEZpZWxkID0gdGhpcy5fYml0RmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBiaXRGaWVsZCAmIDY1NTM1O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGJpdEZpZWxkICYgMTY4NDI3NTIpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlYXNvbiA9IHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0dGxlUHJvbWlzZTAodGhpcy5fcmVqZWN0aW9uSGFuZGxlcjAsIHJlYXNvbiwgYml0RmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdFByb21pc2VzKGxlbiwgcmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0dGxlUHJvbWlzZTAodGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMCwgdmFsdWUsIGJpdEZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mdWxmaWxsUHJvbWlzZXMobGVuLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRMZW5ndGgoMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJDYW5jZWxsYXRpb25EYXRhKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9zZXR0bGVkVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKGJpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkZWZlclJlc29sdmUodikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb21pc2UuX3Jlc29sdmVDYWxsYmFjayh2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZGVmZXJSZWplY3Qodikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb21pc2UuX3JlamVjdENhbGxiYWNrKHYsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLmRlZmVyID0gUHJvbWlzZS5wZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Zy5kZXByZWNhdGVkKFwiUHJvbWlzZS5kZWZlclwiLCBcIm5ldyBQcm9taXNlXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2U6IHByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlOiBkZWZlclJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3Q6IGRlZmVyUmVqZWN0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AoUHJvbWlzZSwgXCJfbWFrZVNlbGZSZXNvbHV0aW9uRXJyb3JcIiwgbWFrZVNlbGZSZXNvbHV0aW9uRXJyb3IpO1xuXG4gICAgICAgICAgICAgICAgX2RlcmVxXyhcIi4vbWV0aG9kXCIpKFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24sIGRlYnVnKTtcbiAgICAgICAgICAgICAgICBfZGVyZXFfKFwiLi9iaW5kXCIpKFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBkZWJ1Zyk7XG4gICAgICAgICAgICAgICAgX2RlcmVxXyhcIi4vY2FuY2VsXCIpKFByb21pc2UsIFByb21pc2VBcnJheSwgYXBpUmVqZWN0aW9uLCBkZWJ1Zyk7XG4gICAgICAgICAgICAgICAgX2RlcmVxXyhcIi4vZGlyZWN0X3Jlc29sdmVcIikoUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgX2RlcmVxXyhcIi4vc3luY2hyb25vdXNfaW5zcGVjdGlvblwiKShQcm9taXNlKTtcbiAgICAgICAgICAgICAgICBfZGVyZXFfKFwiLi9qb2luXCIpKFByb21pc2UsIFByb21pc2VBcnJheSwgdHJ5Q29udmVydFRvUHJvbWlzZSwgSU5URVJOQUwsIGFzeW5jLCBnZXREb21haW4pO1xuICAgICAgICAgICAgICAgIFByb21pc2UuUHJvbWlzZSA9IFByb21pc2U7XG4gICAgICAgICAgICAgICAgUHJvbWlzZS52ZXJzaW9uID0gXCIzLjUuMFwiO1xuICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vbWFwLmpzJykoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24sIHRyeUNvbnZlcnRUb1Byb21pc2UsIElOVEVSTkFMLCBkZWJ1Zyk7XG4gICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jYWxsX2dldC5qcycpKFByb21pc2UpO1xuICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vdXNpbmcuanMnKShQcm9taXNlLCBhcGlSZWplY3Rpb24sIHRyeUNvbnZlcnRUb1Byb21pc2UsIGNyZWF0ZUNvbnRleHQsIElOVEVSTkFMLCBkZWJ1Zyk7XG4gICAgICAgICAgICAgICAgX2RlcmVxXygnLi90aW1lcnMuanMnKShQcm9taXNlLCBJTlRFUk5BTCwgZGVidWcpO1xuICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vZ2VuZXJhdG9ycy5qcycpKFByb21pc2UsIGFwaVJlamVjdGlvbiwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsIFByb3h5YWJsZSwgZGVidWcpO1xuICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vbm9kZWlmeS5qcycpKFByb21pc2UpO1xuICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vcHJvbWlzaWZ5LmpzJykoUHJvbWlzZSwgSU5URVJOQUwpO1xuICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vcHJvcHMuanMnKShQcm9taXNlLCBQcm9taXNlQXJyYXksIHRyeUNvbnZlcnRUb1Byb21pc2UsIGFwaVJlamVjdGlvbik7XG4gICAgICAgICAgICAgICAgX2RlcmVxXygnLi9yYWNlLmpzJykoUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsIGFwaVJlamVjdGlvbik7XG4gICAgICAgICAgICAgICAgX2RlcmVxXygnLi9yZWR1Y2UuanMnKShQcm9taXNlLCBQcm9taXNlQXJyYXksIGFwaVJlamVjdGlvbiwgdHJ5Q29udmVydFRvUHJvbWlzZSwgSU5URVJOQUwsIGRlYnVnKTtcbiAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NldHRsZS5qcycpKFByb21pc2UsIFByb21pc2VBcnJheSwgZGVidWcpO1xuICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc29tZS5qcycpKFByb21pc2UsIFByb21pc2VBcnJheSwgYXBpUmVqZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2ZpbHRlci5qcycpKFByb21pc2UsIElOVEVSTkFMKTtcbiAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2VhY2guanMnKShQcm9taXNlLCBJTlRFUk5BTCk7XG4gICAgICAgICAgICAgICAgX2RlcmVxXygnLi9hbnkuanMnKShQcm9taXNlKTtcblxuICAgICAgICAgICAgICAgIHV0aWwudG9GYXN0UHJvcGVydGllcyhQcm9taXNlKTtcbiAgICAgICAgICAgICAgICB1dGlsLnRvRmFzdFByb3BlcnRpZXMoUHJvbWlzZS5wcm90b3R5cGUpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGZpbGxUeXBlcyh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgICAgICAgICAgICAgcC5fZnVsZmlsbG1lbnRIYW5kbGVyMCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBwLl9yZWplY3Rpb25IYW5kbGVyMCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBwLl9wcm9taXNlMCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBwLl9yZWNlaXZlcjAgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ29tcGxldGUgc2xhY2sgdHJhY2tpbmcsIG9wdCBvdXQgb2YgZmllbGQtdHlwZSB0cmFja2luZyBhbmQgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIHN0YWJpbGl6ZSBtYXAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBmaWxsVHlwZXMoeyBhOiAxIH0pO1xuICAgICAgICAgICAgICAgIGZpbGxUeXBlcyh7IGI6IDIgfSk7XG4gICAgICAgICAgICAgICAgZmlsbFR5cGVzKHsgYzogMyB9KTtcbiAgICAgICAgICAgICAgICBmaWxsVHlwZXMoMSk7XG4gICAgICAgICAgICAgICAgZmlsbFR5cGVzKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICAgICAgICBmaWxsVHlwZXModW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICBmaWxsVHlwZXMoZmFsc2UpO1xuICAgICAgICAgICAgICAgIGZpbGxUeXBlcyhuZXcgUHJvbWlzZShJTlRFUk5BTCkpO1xuICAgICAgICAgICAgICAgIGRlYnVnLnNldEJvdW5kcyhBc3luYy5maXJzdExpbmVFcnJvciwgdXRpbC5sYXN0TGluZUVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHsgXCIuL2FueS5qc1wiOiAxLCBcIi4vYXN5bmNcIjogMiwgXCIuL2JpbmRcIjogMywgXCIuL2NhbGxfZ2V0LmpzXCI6IDUsIFwiLi9jYW5jZWxcIjogNiwgXCIuL2NhdGNoX2ZpbHRlclwiOiA3LCBcIi4vY29udGV4dFwiOiA4LCBcIi4vZGVidWdnYWJpbGl0eVwiOiA5LCBcIi4vZGlyZWN0X3Jlc29sdmVcIjogMTAsIFwiLi9lYWNoLmpzXCI6IDExLCBcIi4vZXJyb3JzXCI6IDEyLCBcIi4vZXM1XCI6IDEzLCBcIi4vZmlsdGVyLmpzXCI6IDE0LCBcIi4vZmluYWxseVwiOiAxNSwgXCIuL2dlbmVyYXRvcnMuanNcIjogMTYsIFwiLi9qb2luXCI6IDE3LCBcIi4vbWFwLmpzXCI6IDE4LCBcIi4vbWV0aG9kXCI6IDE5LCBcIi4vbm9kZWJhY2tcIjogMjAsIFwiLi9ub2RlaWZ5LmpzXCI6IDIxLCBcIi4vcHJvbWlzZV9hcnJheVwiOiAyMywgXCIuL3Byb21pc2lmeS5qc1wiOiAyNCwgXCIuL3Byb3BzLmpzXCI6IDI1LCBcIi4vcmFjZS5qc1wiOiAyNywgXCIuL3JlZHVjZS5qc1wiOiAyOCwgXCIuL3NldHRsZS5qc1wiOiAzMCwgXCIuL3NvbWUuanNcIjogMzEsIFwiLi9zeW5jaHJvbm91c19pbnNwZWN0aW9uXCI6IDMyLCBcIi4vdGhlbmFibGVzXCI6IDMzLCBcIi4vdGltZXJzLmpzXCI6IDM0LCBcIi4vdXNpbmcuanNcIjogMzUsIFwiLi91dGlsXCI6IDM2IH1dLCAyMzogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uLCBQcm94eWFibGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG4gICAgICAgICAgICAgICAgdmFyIGlzQXJyYXkgPSB1dGlsLmlzQXJyYXk7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB0b1Jlc29sdXRpb25WYWx1ZSh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgLTI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAtMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIC02OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBQcm9taXNlQXJyYXkodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuX3Byb3BhZ2F0ZUZyb20odmFsdWVzLCAzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9zZXRPbkNhbmNlbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b3RhbFJlc29sdmVkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdCh1bmRlZmluZWQsIC0yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXRpbC5pbmhlcml0cyhQcm9taXNlQXJyYXksIFByb3h5YWJsZSk7XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlQXJyYXkucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZUFycmF5LnByb3RvdHlwZS5wcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoXywgcmVzb2x2ZVZhbHVlSWZFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gdHJ5Q29udmVydFRvUHJvbWlzZSh0aGlzLl92YWx1ZXMsIHRoaXMuX3Byb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLl90YXJnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiaXRGaWVsZCA9IHZhbHVlcy5fYml0RmllbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlLl9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzLl90aGVuKGluaXQsIHRoaXMuX3JlamVjdCwgdW5kZWZpbmVkLCB0aGlzLCByZXNvbHZlVmFsdWVJZkVtcHR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLl92YWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVqZWN0KHZhbHVlcy5fcmVhc29uKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdXRpbC5hc0FycmF5KHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYW4gYXJyYXkgb3IgYW4gaXRlcmFibGUgb2JqZWN0IGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKHZhbHVlcykpLnJlYXNvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2soZXJyLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVWYWx1ZUlmRW1wdHkgPT09IC01KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZUVtcHR5QXJyYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSh0b1Jlc29sdXRpb25WYWx1ZShyZXNvbHZlVmFsdWVJZkVtcHR5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXRlcmF0ZSh2YWx1ZXMpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlQXJyYXkucHJvdG90eXBlLl9pdGVyYXRlID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5nZXRBY3R1YWxMZW5ndGgodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xlbmd0aCA9IGxlbjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzID0gdGhpcy5zaG91bGRDb3B5VmFsdWVzKCkgPyBuZXcgQXJyYXkobGVuKSA6IHRoaXMuX3ZhbHVlcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3Byb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc1Jlc29sdmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaXRGaWVsZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHZhbHVlc1tpXSwgcmVzdWx0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdEZpZWxkID0gbWF5YmVQcm9taXNlLl9iaXRGaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0RmllbGQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaXRGaWVsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2Uuc3VwcHJlc3NVbmhhbmRsZWRSZWplY3Rpb25zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiaXRGaWVsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9wcm94eSh0aGlzLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzW2ldID0gbWF5YmVQcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0aGlzLl9wcm9taXNlRnVsZmlsbGVkKG1heWJlUHJvbWlzZS5fdmFsdWUoKSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNSZXNvbHZlZCA9IHRoaXMuX3Byb21pc2VSZWplY3RlZChtYXliZVByb21pc2UuX3JlYXNvbigpLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1Jlc29sdmVkID0gdGhpcy5fcHJvbWlzZUNhbmNlbGxlZChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0aGlzLl9wcm9taXNlRnVsZmlsbGVkKG1heWJlUHJvbWlzZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Jlc29sdmVkKSByZXN1bHQuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlQXJyYXkucHJvdG90eXBlLl9pc1Jlc29sdmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzID09PSBudWxsO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2UuX2Z1bGZpbGwodmFsdWUpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlQXJyYXkucHJvdG90eXBlLl9jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkgfHwgIXRoaXMuX3Byb21pc2UuX2lzQ2FuY2VsbGFibGUoKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlLl9jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlLl9yZWplY3RDYWxsYmFjayhyZWFzb24sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWxSZXNvbHZlZCA9ICsrdGhpcy5fdG90YWxSZXNvbHZlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvdGFsUmVzb2x2ZWQgPj0gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlKHRoaXMuX3ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VDYW5jZWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZVJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b3RhbFJlc29sdmVkKys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdChyZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLl92YWx1ZXM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2ldIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbaV0uY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2VBcnJheS5wcm90b3R5cGUuc2hvdWxkQ29weVZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2VBcnJheS5wcm90b3R5cGUuZ2V0QWN0dWFsTGVuZ3RoID0gZnVuY3Rpb24gKGxlbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVuO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZUFycmF5O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgeyBcIi4vdXRpbFwiOiAzNiB9XSwgMjQ6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUHJvbWlzZSwgSU5URVJOQUwpIHtcbiAgICAgICAgICAgICAgICB2YXIgVEhJUyA9IHt9O1xuICAgICAgICAgICAgICAgIHZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZWJhY2tGb3JQcm9taXNlID0gX2RlcmVxXyhcIi4vbm9kZWJhY2tcIik7XG4gICAgICAgICAgICAgICAgdmFyIHdpdGhBcHBlbmRlZCA9IHV0aWwud2l0aEFwcGVuZGVkO1xuICAgICAgICAgICAgICAgIHZhciBtYXliZVdyYXBBc0Vycm9yID0gdXRpbC5tYXliZVdyYXBBc0Vycm9yO1xuICAgICAgICAgICAgICAgIHZhciBjYW5FdmFsdWF0ZSA9IHV0aWwuY2FuRXZhbHVhdGU7XG4gICAgICAgICAgICAgICAgdmFyIFR5cGVFcnJvciA9IF9kZXJlcV8oXCIuL2Vycm9yc1wiKS5UeXBlRXJyb3I7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRTdWZmaXggPSBcIkFzeW5jXCI7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRQcm9taXNpZmllZCA9IHsgX19pc1Byb21pc2lmaWVkX186IHRydWUgfTtcbiAgICAgICAgICAgICAgICB2YXIgbm9Db3B5UHJvcHMgPSBbXCJhcml0eVwiLCBcImxlbmd0aFwiLCBcIm5hbWVcIiwgXCJhcmd1bWVudHNcIiwgXCJjYWxsZXJcIiwgXCJjYWxsZWVcIiwgXCJwcm90b3R5cGVcIiwgXCJfX2lzUHJvbWlzaWZpZWRfX1wiXTtcbiAgICAgICAgICAgICAgICB2YXIgbm9Db3B5UHJvcHNQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIl4oPzpcIiArIG5vQ29weVByb3BzLmpvaW4oXCJ8XCIpICsgXCIpJFwiKTtcblxuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0RmlsdGVyID0gZnVuY3Rpb24gZGVmYXVsdEZpbHRlcihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLmlzSWRlbnRpZmllcihuYW1lKSAmJiBuYW1lLmNoYXJBdCgwKSAhPT0gXCJfXCIgJiYgbmFtZSAhPT0gXCJjb25zdHJ1Y3RvclwiO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBwcm9wc0ZpbHRlcihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFub0NvcHlQcm9wc1BhdHRlcm4udGVzdChrZXkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzUHJvbWlzaWZpZWQoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbi5fX2lzUHJvbWlzaWZpZWRfXyA9PT0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaGFzUHJvbWlzaWZpZWQob2JqLCBrZXksIHN1ZmZpeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gdXRpbC5nZXREYXRhUHJvcGVydHlPckRlZmF1bHQob2JqLCBrZXkgKyBzdWZmaXgsIGRlZmF1bHRQcm9taXNpZmllZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwgPyBpc1Byb21pc2lmaWVkKHZhbCkgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY2hlY2tWYWxpZChyZXQsIHN1ZmZpeCwgc3VmZml4UmVnZXhwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gcmV0W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1ZmZpeFJlZ2V4cC50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5V2l0aG91dEFzeW5jU3VmZml4ID0ga2V5LnJlcGxhY2Uoc3VmZml4UmVnZXhwLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJldC5sZW5ndGg7IGogKz0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0W2pdID09PSBrZXlXaXRob3V0QXN5bmNTdWZmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcHJvbWlzaWZ5IGFuIEFQSSB0aGF0IGhhcyBub3JtYWwgbWV0aG9kcyB3aXRoICclcyctc3VmZml4XFxuXFxuICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcblwiLnJlcGxhY2UoXCIlc1wiLCBzdWZmaXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHByb21pc2lmaWFibGVNZXRob2RzKG9iaiwgc3VmZml4LCBzdWZmaXhSZWdleHAsIGZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHV0aWwuaW5oZXJpdGVkRGF0YUtleXMob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFzc2VzRGVmYXVsdEZpbHRlciA9IGZpbHRlciA9PT0gZGVmYXVsdEZpbHRlciA/IHRydWUgOiBkZWZhdWx0RmlsdGVyKGtleSwgdmFsdWUsIG9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgJiYgIWlzUHJvbWlzaWZpZWQodmFsdWUpICYmICFoYXNQcm9taXNpZmllZChvYmosIGtleSwgc3VmZml4KSAmJiBmaWx0ZXIoa2V5LCB2YWx1ZSwgb2JqLCBwYXNzZXNEZWZhdWx0RmlsdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrVmFsaWQocmV0LCBzdWZmaXgsIHN1ZmZpeFJlZ2V4cCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGVzY2FwZUlkZW50UmVnZXggPSBmdW5jdGlvbiBlc2NhcGVJZGVudFJlZ2V4KHN0cikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbJF0pLywgXCJcXFxcJFwiKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIG1ha2VOb2RlUHJvbWlzaWZpZWRFdmFsO1xuICAgICAgICAgICAgICAgIGlmICghdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3dpdGNoQ2FzZUFyZ3VtZW50T3JkZXIgPSBmdW5jdGlvbiBzd2l0Y2hDYXNlQXJndW1lbnRPcmRlcihsaWtlbHlBcmd1bWVudENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gW2xpa2VseUFyZ3VtZW50Q291bnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pbiA9IE1hdGgubWF4KDAsIGxpa2VseUFyZ3VtZW50Q291bnQgLSAxIC0gMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbGlrZWx5QXJndW1lbnRDb3VudCAtIDE7IGkgPj0gbWluOyAtLWkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBsaWtlbHlBcmd1bWVudENvdW50ICsgMTsgaSA8PSAzOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3VtZW50U2VxdWVuY2UgPSBmdW5jdGlvbiBhcmd1bWVudFNlcXVlbmNlKGFyZ3VtZW50Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLmZpbGxlZFJhbmdlKGFyZ3VtZW50Q291bnQsIFwiX2FyZ1wiLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1ldGVyRGVjbGFyYXRpb24gPSBmdW5jdGlvbiBwYXJhbWV0ZXJEZWNsYXJhdGlvbihwYXJhbWV0ZXJDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuZmlsbGVkUmFuZ2UoTWF0aC5tYXgocGFyYW1ldGVyQ291bnQsIDMpLCBcIl9hcmdcIiwgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtZXRlckNvdW50ID0gZnVuY3Rpb24gcGFyYW1ldGVyQ291bnQoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKGZuLmxlbmd0aCwgMTAyMyArIDEpLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIG1ha2VOb2RlUHJvbWlzaWZpZWRFdmFsID0gZnVuY3Rpb24gbWFrZU5vZGVQcm9taXNpZmllZEV2YWwoY2FsbGJhY2ssIHJlY2VpdmVyLCBvcmlnaW5hbE5hbWUsIGZuLCBfLCBtdWx0aUFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdQYXJhbWV0ZXJDb3VudCA9IE1hdGgubWF4KDAsIHBhcmFtZXRlckNvdW50KGZuKSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3VtZW50T3JkZXIgPSBzd2l0Y2hDYXNlQXJndW1lbnRPcmRlcihuZXdQYXJhbWV0ZXJDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2hvdWxkUHJveHlUaGlzID0gdHlwZW9mIGNhbGxiYWNrID09PSBcInN0cmluZ1wiIHx8IHJlY2VpdmVyID09PSBUSElTO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZW5lcmF0ZUNhbGxGb3JBcmd1bWVudENvdW50KGNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudFNlcXVlbmNlKGNvdW50KS5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1hID0gY291bnQgPiAwID8gXCIsIFwiIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRQcm94eVRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gXCJyZXQgPSBjYWxsYmFjay5jYWxsKHRoaXMsIHt7YXJnc319LCBub2RlYmFjayk7IGJyZWFrO1xcblwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IHJlY2VpdmVyID09PSB1bmRlZmluZWQgPyBcInJldCA9IGNhbGxiYWNrKHt7YXJnc319LCBub2RlYmFjayk7IGJyZWFrO1xcblwiIDogXCJyZXQgPSBjYWxsYmFjay5jYWxsKHJlY2VpdmVyLCB7e2FyZ3N9fSwgbm9kZWJhY2spOyBicmVhaztcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldC5yZXBsYWNlKFwie3thcmdzfX1cIiwgYXJncykucmVwbGFjZShcIiwgXCIsIGNvbW1hKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2VuZXJhdGVBcmd1bWVudFN3aXRjaENhc2UoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudE9yZGVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCArPSBcImNhc2UgXCIgKyBhcmd1bWVudE9yZGVyW2ldICsgXCI6XCIgKyBnZW5lcmF0ZUNhbGxGb3JBcmd1bWVudENvdW50KGFyZ3VtZW50T3JkZXJbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCArPSBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBkZWZhdWx0OiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuICsgMSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGkgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgYXJnc1tpXSA9IG5vZGViYWNrOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgW0NvZGVGb3JDYWxsXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgYnJlYWs7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBcIi5yZXBsYWNlKFwiW0NvZGVGb3JDYWxsXVwiLCBzaG91bGRQcm94eVRoaXMgPyBcInJldCA9IGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xcblwiIDogXCJyZXQgPSBjYWxsYmFjay5hcHBseShyZWNlaXZlciwgYXJncyk7XFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZXRGdW5jdGlvbkNvZGUgPSB0eXBlb2YgY2FsbGJhY2sgPT09IFwic3RyaW5nXCIgPyBcInRoaXMgIT0gbnVsbCA/IHRoaXNbJ1wiICsgY2FsbGJhY2sgKyBcIiddIDogZm5cIiA6IFwiZm5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gXCIndXNlIHN0cmljdCc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgdmFyIHJldCA9IGZ1bmN0aW9uIChQYXJhbWV0ZXJzKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHByb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBub2RlYmFjayA9IG5vZGViYWNrRm9yUHJvbWlzZShwcm9taXNlLCBcIiArIG11bHRpQXJncyArIFwiKTsgICBcXG5cXFxuICAgICAgICAgICAgdmFyIHJldDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gdHJ5Q2F0Y2goW0dldEZ1bmN0aW9uQ29kZV0pOyAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgc3dpdGNoKGxlbikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIFtDb2RlRm9yU3dpdGNoQ2FzZV0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKG1heWJlV3JhcEFzRXJyb3IocmV0LmUpLCB0cnVlLCB0cnVlKTtcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaWYgKCFwcm9taXNlLl9pc0ZhdGVTZWFsZWQoKSkgcHJvbWlzZS5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7ICAgICBcXG5cXFxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcChyZXQsICdfX2lzUHJvbWlzaWZpZWRfXycsIHRydWUpOyAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICByZXR1cm4gcmV0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgIFwiLnJlcGxhY2UoXCJbQ29kZUZvclN3aXRjaENhc2VdXCIsIGdlbmVyYXRlQXJndW1lbnRTd2l0Y2hDYXNlKCkpLnJlcGxhY2UoXCJbR2V0RnVuY3Rpb25Db2RlXVwiLCBnZXRGdW5jdGlvbkNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IGJvZHkucmVwbGFjZShcIlBhcmFtZXRlcnNcIiwgcGFyYW1ldGVyRGVjbGFyYXRpb24obmV3UGFyYW1ldGVyQ291bnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJQcm9taXNlXCIsIFwiZm5cIiwgXCJyZWNlaXZlclwiLCBcIndpdGhBcHBlbmRlZFwiLCBcIm1heWJlV3JhcEFzRXJyb3JcIiwgXCJub2RlYmFja0ZvclByb21pc2VcIiwgXCJ0cnlDYXRjaFwiLCBcImVycm9yT2JqXCIsIFwibm90RW51bWVyYWJsZVByb3BcIiwgXCJJTlRFUk5BTFwiLCBib2R5KShQcm9taXNlLCBmbiwgcmVjZWl2ZXIsIHdpdGhBcHBlbmRlZCwgbWF5YmVXcmFwQXNFcnJvciwgbm9kZWJhY2tGb3JQcm9taXNlLCB1dGlsLnRyeUNhdGNoLCB1dGlsLmVycm9yT2JqLCB1dGlsLm5vdEVudW1lcmFibGVQcm9wLCBJTlRFUk5BTCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbWFrZU5vZGVQcm9taXNpZmllZENsb3N1cmUoY2FsbGJhY2ssIHJlY2VpdmVyLCBfLCBmbiwgX18sIG11bHRpQXJncykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdFRoaXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kID0gY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHByb21pc2lmaWVkKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpdmVyID09PSBUSElTKSBfcmVjZWl2ZXIgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNiID0gdHlwZW9mIG1ldGhvZCA9PT0gXCJzdHJpbmdcIiAmJiB0aGlzICE9PSBkZWZhdWx0VGhpcyA/IHRoaXNbbWV0aG9kXSA6IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gbm9kZWJhY2tGb3JQcm9taXNlKHByb21pc2UsIG11bHRpQXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiLmFwcGx5KF9yZWNlaXZlciwgd2l0aEFwcGVuZGVkKGFyZ3VtZW50cywgZm4pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhtYXliZVdyYXBBc0Vycm9yKGUpLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJvbWlzZS5faXNGYXRlU2VhbGVkKCkpIHByb21pc2UuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChwcm9taXNpZmllZCwgXCJfX2lzUHJvbWlzaWZpZWRfX1wiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2lmaWVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBtYWtlTm9kZVByb21pc2lmaWVkID0gY2FuRXZhbHVhdGUgPyBtYWtlTm9kZVByb21pc2lmaWVkRXZhbCA6IG1ha2VOb2RlUHJvbWlzaWZpZWRDbG9zdXJlO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcHJvbWlzaWZ5QWxsKG9iaiwgc3VmZml4LCBmaWx0ZXIsIHByb21pc2lmaWVyLCBtdWx0aUFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1ZmZpeFJlZ2V4cCA9IG5ldyBSZWdFeHAoZXNjYXBlSWRlbnRSZWdleChzdWZmaXgpICsgXCIkXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kcyA9IHByb21pc2lmaWFibGVNZXRob2RzKG9iaiwgc3VmZml4LCBzdWZmaXhSZWdleHAsIGZpbHRlcik7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1ldGhvZHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBtZXRob2RzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gbWV0aG9kc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzaWZpZWRLZXkgPSBrZXkgKyBzdWZmaXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvbWlzaWZpZXIgPT09IG1ha2VOb2RlUHJvbWlzaWZpZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpbcHJvbWlzaWZpZWRLZXldID0gbWFrZU5vZGVQcm9taXNpZmllZChrZXksIFRISVMsIGtleSwgZm4sIHN1ZmZpeCwgbXVsdGlBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2lmaWVkID0gcHJvbWlzaWZpZXIoZm4sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VOb2RlUHJvbWlzaWZpZWQoa2V5LCBUSElTLCBrZXksIGZuLCBzdWZmaXgsIG11bHRpQXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChwcm9taXNpZmllZCwgXCJfX2lzUHJvbWlzaWZpZWRfX1wiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpbcHJvbWlzaWZpZWRLZXldID0gcHJvbWlzaWZpZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdXRpbC50b0Zhc3RQcm9wZXJ0aWVzKG9iaik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcHJvbWlzaWZ5KGNhbGxiYWNrLCByZWNlaXZlciwgbXVsdGlBcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlTm9kZVByb21pc2lmaWVkKGNhbGxiYWNrLCByZWNlaXZlciwgdW5kZWZpbmVkLCBjYWxsYmFjaywgbnVsbCwgbXVsdGlBcmdzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb21pc2lmeSA9IGZ1bmN0aW9uIChmbiwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb21pc2lmaWVkKGZuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3Qob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWNlaXZlciA9IG9wdGlvbnMuY29udGV4dCA9PT0gdW5kZWZpbmVkID8gVEhJUyA6IG9wdGlvbnMuY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG11bHRpQXJncyA9ICEhb3B0aW9ucy5tdWx0aUFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBwcm9taXNpZnkoZm4sIHJlY2VpdmVyLCBtdWx0aUFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB1dGlsLmNvcHlEZXNjcmlwdG9ycyhmbiwgcmV0LCBwcm9wc0ZpbHRlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvbWlzaWZ5QWxsID0gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gXCJmdW5jdGlvblwiICYmICh0eXBlb2YgdGFyZ2V0ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YodGFyZ2V0KSkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ0aGUgdGFyZ2V0IG9mIHByb21pc2lmeUFsbCBtdXN0IGJlIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uXFxuXFxuICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gT2JqZWN0KG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXVsdGlBcmdzID0gISFvcHRpb25zLm11bHRpQXJncztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IG9wdGlvbnMuc3VmZml4O1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN1ZmZpeCAhPT0gXCJzdHJpbmdcIikgc3VmZml4ID0gZGVmYXVsdFN1ZmZpeDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZpbHRlciAhPT0gXCJmdW5jdGlvblwiKSBmaWx0ZXIgPSBkZWZhdWx0RmlsdGVyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzaWZpZXIgPSBvcHRpb25zLnByb21pc2lmaWVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb21pc2lmaWVyICE9PSBcImZ1bmN0aW9uXCIpIHByb21pc2lmaWVyID0gbWFrZU5vZGVQcm9taXNpZmllZDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXV0aWwuaXNJZGVudGlmaWVyKHN1ZmZpeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwic3VmZml4IG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXFxuXFxuICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gdXRpbC5pbmhlcml0ZWREYXRhS2V5cyh0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRhcmdldFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlzW2ldICE9PSBcImNvbnN0cnVjdG9yXCIgJiYgdXRpbC5pc0NsYXNzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2lmeUFsbCh2YWx1ZS5wcm90b3R5cGUsIHN1ZmZpeCwgZmlsdGVyLCBwcm9taXNpZmllciwgbXVsdGlBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNpZnlBbGwodmFsdWUsIHN1ZmZpeCwgZmlsdGVyLCBwcm9taXNpZmllciwgbXVsdGlBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnlBbGwodGFyZ2V0LCBzdWZmaXgsIGZpbHRlciwgcHJvbWlzaWZpZXIsIG11bHRpQXJncyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHsgXCIuL2Vycm9yc1wiOiAxMiwgXCIuL25vZGViYWNrXCI6IDIwLCBcIi4vdXRpbFwiOiAzNiB9XSwgMjU6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG4gICAgICAgICAgICAgICAgdmFyIGlzT2JqZWN0ID0gdXRpbC5pc09iamVjdDtcbiAgICAgICAgICAgICAgICB2YXIgZXM1ID0gX2RlcmVxXyhcIi4vZXM1XCIpO1xuICAgICAgICAgICAgICAgIHZhciBFczZNYXA7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIikgRXM2TWFwID0gTWFwO1xuXG4gICAgICAgICAgICAgICAgdmFyIG1hcFRvRW50cmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpemUgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGV4dHJhY3RFbnRyeSh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tpbmRleCArIHNpemVdID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBtYXBUb0VudHJpZXMobWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplID0gbWFwLnNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbmV3IEFycmF5KG1hcC5zaXplICogMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuZm9yRWFjaChleHRyYWN0RW50cnksIHJldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgICAgIHZhciBlbnRyaWVzVG9NYXAgPSBmdW5jdGlvbiBlbnRyaWVzVG9NYXAoZW50cmllcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbmV3IEVzNk1hcCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gZW50cmllcy5sZW5ndGggLyAyIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGVudHJpZXNbbGVuZ3RoICsgaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBlbnRyaWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBQcm9wZXJ0aWVzUHJvbWlzZUFycmF5KG9iaikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNNYXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJpZXM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChFczZNYXAgIT09IHVuZGVmaW5lZCAmJiBvYmogaW5zdGFuY2VvZiBFczZNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJpZXMgPSBtYXBUb0VudHJpZXMob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTWFwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gZXM1LmtleXMob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJpZXMgPSBuZXcgQXJyYXkobGVuICogMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cmllc1tpXSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJpZXNbaSArIGxlbl0gPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciQoZW50cmllcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzTWFwID0gaXNNYXA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXQkKHVuZGVmaW5lZCwgaXNNYXAgPyAtNiA6IC0zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXRpbC5pbmhlcml0cyhQcm9wZXJ0aWVzUHJvbWlzZUFycmF5LCBQcm9taXNlQXJyYXkpO1xuXG4gICAgICAgICAgICAgICAgUHJvcGVydGllc1Byb21pc2VBcnJheS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgICAgICAgICAgIFByb3BlcnRpZXNQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbFJlc29sdmVkID0gKyt0aGlzLl90b3RhbFJlc29sdmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG90YWxSZXNvbHZlZCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBlbnRyaWVzVG9NYXAodGhpcy5fdmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleU9mZnNldCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMubGVuZ3RoKCk7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxbdGhpcy5fdmFsdWVzW2kgKyBrZXlPZmZzZXRdXSA9IHRoaXMuX3ZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb3BlcnRpZXNQcm9taXNlQXJyYXkucHJvdG90eXBlLnNob3VsZENvcHlWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvcGVydGllc1Byb21pc2VBcnJheS5wcm90b3R5cGUuZ2V0QWN0dWFsTGVuZ3RoID0gZnVuY3Rpb24gKGxlbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVuID4+IDE7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHByb3BzKHByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYXN0VmFsdWUgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHByb21pc2VzKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KGNhc3RWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJjYW5ub3QgYXdhaXQgcHJvcGVydGllcyBvZiBhIG5vbi1vYmplY3RcXG5cXG4gICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNhc3RWYWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IGNhc3RWYWx1ZS5fdGhlbihQcm9taXNlLnByb3BzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gbmV3IFByb3BlcnRpZXNQcm9taXNlQXJyYXkoY2FzdFZhbHVlKS5wcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FzdFZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0Ll9wcm9wYWdhdGVGcm9tKGNhc3RWYWx1ZSwgMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5wcm9wcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzKHRoaXMpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3BzID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcyhwcm9taXNlcyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHsgXCIuL2VzNVwiOiAxMywgXCIuL3V0aWxcIjogMzYgfV0sIDI2OiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFycmF5TW92ZShzcmMsIHNyY0luZGV4LCBkc3QsIGRzdEluZGV4LCBsZW4pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGRzdFtqICsgZHN0SW5kZXhdID0gc3JjW2ogKyBzcmNJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIHNyY1tqICsgc3JjSW5kZXhdID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gUXVldWUoY2FwYWNpdHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgICAgICAgICAgICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnJvbnQgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBRdWV1ZS5wcm90b3R5cGUuX3dpbGxCZU92ZXJDYXBhY2l0eSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhcGFjaXR5IDwgc2l6ZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFF1ZXVlLnByb3RvdHlwZS5fcHVzaE9uZSA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja0NhcGFjaXR5KGxlbmd0aCArIDEpO1xuICAgICAgICAgICAgICAgIHZhciBpID0gdGhpcy5fZnJvbnQgKyBsZW5ndGggJiB0aGlzLl9jYXBhY2l0eSAtIDE7XG4gICAgICAgICAgICAgICAgdGhpc1tpXSA9IGFyZztcbiAgICAgICAgICAgICAgICB0aGlzLl9sZW5ndGggPSBsZW5ndGggKyAxO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgUXVldWUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKSArIDM7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3dpbGxCZU92ZXJDYXBhY2l0eShsZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3B1c2hPbmUoZm4pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wdXNoT25lKHJlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHVzaE9uZShhcmcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBqID0gdGhpcy5fZnJvbnQgKyBsZW5ndGggLSAzO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrQ2FwYWNpdHkobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB2YXIgd3JhcE1hc2sgPSB0aGlzLl9jYXBhY2l0eSAtIDE7XG4gICAgICAgICAgICAgICAgdGhpc1tqICsgMCAmIHdyYXBNYXNrXSA9IGZuO1xuICAgICAgICAgICAgICAgIHRoaXNbaiArIDEgJiB3cmFwTWFza10gPSByZWNlaXZlcjtcbiAgICAgICAgICAgICAgICB0aGlzW2ogKyAyICYgd3JhcE1hc2tdID0gYXJnO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFF1ZXVlLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJvbnQgPSB0aGlzLl9mcm9udCxcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gdGhpc1tmcm9udF07XG5cbiAgICAgICAgICAgICAgICB0aGlzW2Zyb250XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLl9mcm9udCA9IGZyb250ICsgMSAmIHRoaXMuX2NhcGFjaXR5IC0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sZW5ndGgtLTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgUXVldWUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgUXVldWUucHJvdG90eXBlLl9jaGVja0NhcGFjaXR5ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FwYWNpdHkgPCBzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZVRvKHRoaXMuX2NhcGFjaXR5IDw8IDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFF1ZXVlLnByb3RvdHlwZS5fcmVzaXplVG8gPSBmdW5jdGlvbiAoY2FwYWNpdHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkQ2FwYWNpdHkgPSB0aGlzLl9jYXBhY2l0eTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgICAgICAgICAgICAgIHZhciBmcm9udCA9IHRoaXMuX2Zyb250O1xuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSB0aGlzLl9sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIG1vdmVJdGVtc0NvdW50ID0gZnJvbnQgKyBsZW5ndGggJiBvbGRDYXBhY2l0eSAtIDE7XG4gICAgICAgICAgICAgICAgYXJyYXlNb3ZlKHRoaXMsIDAsIHRoaXMsIG9sZENhcGFjaXR5LCBtb3ZlSXRlbXNDb3VudCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFF1ZXVlO1xuICAgICAgICB9LCB7fV0sIDI3OiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmFjZUxhdGVyID0gZnVuY3Rpb24gcmFjZUxhdGVyKHByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByYWNlKGFycmF5LCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJhY2UocHJvbWlzZXMsIHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShwcm9taXNlcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByYWNlTGF0ZXIobWF5YmVQcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzID0gdXRpbC5hc0FycmF5KHByb21pc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9taXNlcyA9PT0gbnVsbCkgcmV0dXJuIGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhbiBhcnJheSBvciBhbiBpdGVyYWJsZSBvYmplY3QgYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcocHJvbWlzZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0Ll9wcm9wYWdhdGVGcm9tKHBhcmVudCwgMyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bGZpbGwgPSByZXQuX2Z1bGZpbGw7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWplY3QgPSByZXQuX3JlamVjdDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb21pc2VzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gcHJvbWlzZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCAmJiAhKGkgaW4gcHJvbWlzZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UuY2FzdCh2YWwpLl90aGVuKGZ1bGZpbGwsIHJlamVjdCwgdW5kZWZpbmVkLCByZXQsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5yYWNlID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByYWNlKHByb21pc2VzLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5yYWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmFjZSh0aGlzLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7IFwiLi91dGlsXCI6IDM2IH1dLCAyODogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChQcm9taXNlLCBQcm9taXNlQXJyYXksIGFwaVJlamVjdGlvbiwgdHJ5Q29udmVydFRvUHJvbWlzZSwgSU5URVJOQUwsIGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdldERvbWFpbiA9IFByb21pc2UuX2dldERvbWFpbjtcbiAgICAgICAgICAgICAgICB2YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG4gICAgICAgICAgICAgICAgdmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFJlZHVjdGlvblByb21pc2VBcnJheShwcm9taXNlcywgZm4sIGluaXRpYWxWYWx1ZSwgX2VhY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciQocHJvbWlzZXMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9tYWluID0gZ2V0RG9tYWluKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZuID0gZG9tYWluID09PSBudWxsID8gZm4gOiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBmbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbml0aWFsVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFZhbHVlID0gUHJvbWlzZS5yZXNvbHZlKGluaXRpYWxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsVmFsdWUuX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudENhbmNlbGxhYmxlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9lYWNoID09PSBJTlRFUk5BTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZWFjaFZhbHVlcyA9IEFycmF5KHRoaXMuX2xlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoX2VhY2ggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VhY2hWYWx1ZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZWFjaFZhbHVlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0JCh1bmRlZmluZWQsIC01KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXRpbC5pbmhlcml0cyhSZWR1Y3Rpb25Qcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cbiAgICAgICAgICAgICAgICBSZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9nb3RBY2N1bSA9IGZ1bmN0aW9uIChhY2N1bSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZWFjaFZhbHVlcyAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX2VhY2hWYWx1ZXMgIT09IG51bGwgJiYgYWNjdW0gIT09IElOVEVSTkFMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lYWNoVmFsdWVzLnB1c2goYWNjdW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX2VhY2hDb21wbGV0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZWFjaFZhbHVlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZWFjaFZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZWFjaFZhbHVlcztcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAgICAgICAgICAgUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVzb2x2ZUVtcHR5QXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUodGhpcy5fZWFjaFZhbHVlcyAhPT0gdW5kZWZpbmVkID8gdGhpcy5fZWFjaFZhbHVlcyA6IHRoaXMuX2luaXRpYWxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuc2hvdWxkQ29weVZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBSZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2UuX3Jlc29sdmVDYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uIChzZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbmRlciA9PT0gdGhpcy5faW5pdGlhbFZhbHVlKSByZXR1cm4gdGhpcy5fY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzdWx0Q2FuY2VsbGVkJCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudENhbmNlbGxhYmxlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudENhbmNlbGxhYmxlLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbml0aWFsVmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsVmFsdWUuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faXRlcmF0ZSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2luaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBQcm9taXNlLnJlc29sdmUodmFsdWVzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudENhbmNlbGxhYmxlID0gdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZS5pc1JlamVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2N1bTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheTogdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5fdGhlbihnb3RBY2N1bSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGN0eCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lYWNoVmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuX3RoZW4odGhpcy5fZWFjaENvbXBsZXRlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhpcywgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5fdGhlbihjb21wbGV0ZWQsIGNvbXBsZXRlZCwgdW5kZWZpbmVkLCB2YWx1ZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChmbiwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWR1Y2UodGhpcywgZm4sIGluaXRpYWxWYWx1ZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucmVkdWNlID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbiwgaW5pdGlhbFZhbHVlLCBfZWFjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVkdWNlKHByb21pc2VzLCBmbiwgaW5pdGlhbFZhbHVlLCBfZWFjaCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlZCh2YWx1ZU9yUmVhc29uLCBhcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheS5fcmVzb2x2ZSh2YWx1ZU9yUmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5Ll9yZWplY3QodmFsdWVPclJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiByZWR1Y2UocHJvbWlzZXMsIGZuLCBpbml0aWFsVmFsdWUsIF9lYWNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFycmF5ID0gbmV3IFJlZHVjdGlvblByb21pc2VBcnJheShwcm9taXNlcywgZm4sIGluaXRpYWxWYWx1ZSwgX2VhY2gpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXkucHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdvdEFjY3VtKGFjY3VtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWNjdW0gPSBhY2N1bTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcnJheS5fZ290QWNjdW0oYWNjdW0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHRoaXMudmFsdWUsIHRoaXMuYXJyYXkuX3Byb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFycmF5Ll9jdXJyZW50Q2FuY2VsbGFibGUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5fdGhlbihnb3RWYWx1ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRoaXMsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ290VmFsdWUuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnb3RWYWx1ZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGFycmF5Ll9wcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSB0cnlDYXRjaChhcnJheS5fZm4pO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJyYXkuX2VhY2hWYWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gZm4uY2FsbChwcm9taXNlLl9ib3VuZFZhbHVlKCksIHZhbHVlLCB0aGlzLmluZGV4LCB0aGlzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBmbi5jYWxsKHByb21pc2UuX2JvdW5kVmFsdWUoKSwgdGhpcy5hY2N1bSwgdmFsdWUsIHRoaXMuaW5kZXgsIHRoaXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXkuX2N1cnJlbnRDYW5jZWxsYWJsZSA9IHJldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZUNyZWF0ZWQgPSBwcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyhyZXQsIHByb21pc2VDcmVhdGVkLCBhcnJheS5fZWFjaFZhbHVlcyAhPT0gdW5kZWZpbmVkID8gXCJQcm9taXNlLmVhY2hcIiA6IFwiUHJvbWlzZS5yZWR1Y2VcIiwgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgeyBcIi4vdXRpbFwiOiAzNiB9XSwgMjk6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgICAgdmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xuICAgICAgICAgICAgdmFyIHNjaGVkdWxlO1xuICAgICAgICAgICAgdmFyIG5vQXN5bmNTY2hlZHVsZXIgPSBmdW5jdGlvbiBub0FzeW5jU2NoZWR1bGVyKCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGFzeW5jIHNjaGVkdWxlciBhdmFpbGFibGVcXG5cXG4gICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFxuXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBOYXRpdmVQcm9taXNlID0gdXRpbC5nZXROYXRpdmVQcm9taXNlKCk7XG4gICAgICAgICAgICBpZiAodXRpbC5pc05vZGUgJiYgdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgR2xvYmFsU2V0SW1tZWRpYXRlID0gZ2xvYmFsLnNldEltbWVkaWF0ZTtcbiAgICAgICAgICAgICAgICB2YXIgUHJvY2Vzc05leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbiAgICAgICAgICAgICAgICBzY2hlZHVsZSA9IHV0aWwuaXNSZWNlbnROb2RlID8gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIEdsb2JhbFNldEltbWVkaWF0ZS5jYWxsKGdsb2JhbCwgZm4pO1xuICAgICAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgUHJvY2Vzc05leHRUaWNrLmNhbGwocHJvY2VzcywgZm4pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBOYXRpdmVQcm9taXNlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIE5hdGl2ZVByb21pc2UucmVzb2x2ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hdGl2ZVByb21pc2UgPSBOYXRpdmVQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZSA9IGZ1bmN0aW9uIHNjaGVkdWxlKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZVByb21pc2UudGhlbihmbik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgISh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5uYXZpZ2F0b3IgJiYgKHdpbmRvdy5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSB8fCB3aW5kb3cuY29yZG92YSkpKSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0cyA9IHsgYXR0cmlidXRlczogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9nZ2xlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXYyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG8yID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJmb29cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2dnbGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG8yLm9ic2VydmUoZGl2Miwgb3B0cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjaGVkdWxlVG9nZ2xlID0gZnVuY3Rpb24gc2NoZWR1bGVUb2dnbGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9nZ2xlU2NoZWR1bGVkKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2dnbGVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGl2Mi5jbGFzc0xpc3QudG9nZ2xlKFwiZm9vXCIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBzY2hlZHVsZShmbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgby5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgby5vYnNlcnZlKGRpdiwgb3B0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZVRvZ2dsZSgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlID0gZnVuY3Rpb24gc2NoZWR1bGUoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2V0VGltZW91dCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlID0gZnVuY3Rpb24gc2NoZWR1bGUoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGUgPSBub0FzeW5jU2NoZWR1bGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBzY2hlZHVsZTtcbiAgICAgICAgfSwgeyBcIi4vdXRpbFwiOiAzNiB9XSwgMzA6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBkZWJ1Zykge1xuICAgICAgICAgICAgICAgIHZhciBQcm9taXNlSW5zcGVjdGlvbiA9IFByb21pc2UuUHJvbWlzZUluc3BlY3Rpb247XG4gICAgICAgICAgICAgICAgdmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gU2V0dGxlZFByb21pc2VBcnJheSh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciQodmFsdWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXRpbC5pbmhlcml0cyhTZXR0bGVkUHJvbWlzZUFycmF5LCBQcm9taXNlQXJyYXkpO1xuXG4gICAgICAgICAgICAgICAgU2V0dGxlZFByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VSZXNvbHZlZCA9IGZ1bmN0aW9uIChpbmRleCwgaW5zcGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gaW5zcGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsUmVzb2x2ZWQgPSArK3RoaXMuX3RvdGFsUmVzb2x2ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbFJlc29sdmVkID49IHRoaXMuX2xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBTZXR0bGVkUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IG5ldyBQcm9taXNlSW5zcGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXQuX2JpdEZpZWxkID0gMzM1NTQ0MzI7XG4gICAgICAgICAgICAgICAgICAgIHJldC5fc2V0dGxlZFZhbHVlRmllbGQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2VSZXNvbHZlZChpbmRleCwgcmV0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFNldHRsZWRQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlUmVqZWN0ZWQgPSBmdW5jdGlvbiAocmVhc29uLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFByb21pc2VJbnNwZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldC5fYml0RmllbGQgPSAxNjc3NzIxNjtcbiAgICAgICAgICAgICAgICAgICAgcmV0Ll9zZXR0bGVkVmFsdWVGaWVsZCA9IHJlYXNvbjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2VSZXNvbHZlZChpbmRleCwgcmV0KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5zZXR0bGUgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcuZGVwcmVjYXRlZChcIi5zZXR0bGUoKVwiLCBcIi5yZWZsZWN0KClcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2V0dGxlZFByb21pc2VBcnJheShwcm9taXNlcykucHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5zZXR0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnNldHRsZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgeyBcIi4vdXRpbFwiOiAzNiB9XSwgMzE6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG4gICAgICAgICAgICAgICAgdmFyIFJhbmdlRXJyb3IgPSBfZGVyZXFfKFwiLi9lcnJvcnNcIikuUmFuZ2VFcnJvcjtcbiAgICAgICAgICAgICAgICB2YXIgQWdncmVnYXRlRXJyb3IgPSBfZGVyZXFfKFwiLi9lcnJvcnNcIikuQWdncmVnYXRlRXJyb3I7XG4gICAgICAgICAgICAgICAgdmFyIGlzQXJyYXkgPSB1dGlsLmlzQXJyYXk7XG4gICAgICAgICAgICAgICAgdmFyIENBTkNFTExBVElPTiA9IHt9O1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gU29tZVByb21pc2VBcnJheSh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciQodmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faG93TWFueSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Vud3JhcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1dGlsLmluaGVyaXRzKFNvbWVQcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cbiAgICAgICAgICAgICAgICBTb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ob3dNYW55ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlKFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0JCh1bmRlZmluZWQsIC01KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzQXJyYXlSZXNvbHZlZCA9IGlzQXJyYXkodGhpcy5fdmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1Jlc29sdmVkKCkgJiYgaXNBcnJheVJlc29sdmVkICYmIHRoaXMuX2hvd01hbnkgPiB0aGlzLl9jYW5Qb3NzaWJseUZ1bGZpbGwoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0KHRoaXMuX2dldFJhbmdlRXJyb3IodGhpcy5sZW5ndGgoKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBTb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5zZXRVbndyYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Vud3JhcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLmhvd01hbnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ob3dNYW55O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBTb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5zZXRIb3dNYW55ID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hvd01hbnkgPSBjb3VudDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRnVsZmlsbGVkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Z1bGZpbGxlZCgpID09PSB0aGlzLmhvd01hbnkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzLmxlbmd0aCA9IHRoaXMuaG93TWFueSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaG93TWFueSgpID09PSAxICYmIHRoaXMuX3Vud3JhcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUodGhpcy5fdmFsdWVzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VSZWplY3RlZCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkUmVqZWN0ZWQocmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrT3V0Y29tZSgpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBTb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUNhbmNlbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ZhbHVlcyBpbnN0YW5jZW9mIFByb21pc2UgfHwgdGhpcy5fdmFsdWVzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRSZWplY3RlZChDQU5DRUxMQVRJT04pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tPdXRjb21lKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9jaGVja091dGNvbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhvd01hbnkoKSA+IHRoaXMuX2NhblBvc3NpYmx5RnVsZmlsbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IG5ldyBBZ2dyZWdhdGVFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoKCk7IGkgPCB0aGlzLl92YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdmFsdWVzW2ldICE9PSBDQU5DRUxMQVRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wdXNoKHRoaXMuX3ZhbHVlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9mdWxmaWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90b3RhbFJlc29sdmVkO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBTb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVqZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXMubGVuZ3RoIC0gdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2FkZFJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMucHVzaChyZWFzb24pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBTb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fYWRkRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1t0aGlzLl90b3RhbFJlc29sdmVkKytdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9jYW5Qb3NzaWJseUZ1bGZpbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCgpIC0gdGhpcy5fcmVqZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2dldFJhbmdlRXJyb3IgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIklucHV0IGFycmF5IG11c3QgY29udGFpbiBhdCBsZWFzdCBcIiArIHRoaXMuX2hvd01hbnkgKyBcIiBpdGVtcyBidXQgY29udGFpbnMgb25seSBcIiArIGNvdW50ICsgXCIgaXRlbXNcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZUVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBTb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVzb2x2ZUVtcHR5QXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdCh0aGlzLl9nZXRSYW5nZUVycm9yKDApKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc29tZShwcm9taXNlcywgaG93TWFueSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGhvd01hbnkgfCAwKSAhPT0gaG93TWFueSB8fCBob3dNYW55IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhIHBvc2l0aXZlIGludGVnZXJcXG5cXG4gICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBuZXcgU29tZVByb21pc2VBcnJheShwcm9taXNlcyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gcmV0LnByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnNldEhvd01hbnkoaG93TWFueSk7XG4gICAgICAgICAgICAgICAgICAgIHJldC5pbml0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIFByb21pc2Uuc29tZSA9IGZ1bmN0aW9uIChwcm9taXNlcywgaG93TWFueSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29tZShwcm9taXNlcywgaG93TWFueSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLnNvbWUgPSBmdW5jdGlvbiAoaG93TWFueSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29tZSh0aGlzLCBob3dNYW55KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5fU29tZVByb21pc2VBcnJheSA9IFNvbWVQcm9taXNlQXJyYXk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7IFwiLi9lcnJvcnNcIjogMTIsIFwiLi91dGlsXCI6IDM2IH1dLCAzMjogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gUHJvbWlzZUluc3BlY3Rpb24ocHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvbWlzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0dGxlZFZhbHVlRmllbGQgPSBwcm9taXNlLl9pc0ZhdGVTZWFsZWQoKSA/IHByb21pc2UuX3NldHRsZWRWYWx1ZSgpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYml0RmllbGQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0dGxlZFZhbHVlRmllbGQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUuX3NldHRsZWRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZUZpZWxkO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBQcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2Fubm90IGdldCBmdWxmaWxsbWVudCB2YWx1ZSBvZiBhIG5vbi1mdWxmaWxsZWQgcHJvbWlzZVxcblxcbiAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXG5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVhc29uID0gUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmVycm9yID0gUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLnJlYXNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCBnZXQgcmVqZWN0aW9uIHJlYXNvbiBvZiBhIG5vbi1yZWplY3RlZCBwcm9taXNlXFxuXFxuICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBpc0Z1bGZpbGxlZCA9IFByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5pc0Z1bGZpbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIGlzUmVqZWN0ZWQgPSBQcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUuaXNSZWplY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIGlzUGVuZGluZyA9IFByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDA7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBpc1Jlc29sdmVkID0gUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmlzUmVzb2x2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA1MDMzMTY0OCkgIT09IDA7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5pc0NhbmNlbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDg0NTQxNDQpICE9PSAwO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fX2lzQ2FuY2VsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgNjU1MzYpID09PSA2NTUzNjtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2lzQ2FuY2VsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0KCkuX19pc0NhbmNlbGxlZCgpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5pc0NhbmNlbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLl90YXJnZXQoKS5fYml0RmllbGQgJiA4NDU0MTQ0KSAhPT0gMDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNQZW5kaW5nLmNhbGwodGhpcy5fdGFyZ2V0KCkpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5pc1JlamVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNSZWplY3RlZC5jYWxsKHRoaXMuX3RhcmdldCgpKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuaXNGdWxmaWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0Z1bGZpbGxlZC5jYWxsKHRoaXMuX3RhcmdldCgpKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuaXNSZXNvbHZlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzUmVzb2x2ZWQuY2FsbCh0aGlzLl90YXJnZXQoKSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuY2FsbCh0aGlzLl90YXJnZXQoKSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLnJlYXNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX3RhcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuX3Vuc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYXNvbi5jYWxsKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl92YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fcmVhc29uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXR0bGVkVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5Qcm9taXNlSW5zcGVjdGlvbiA9IFByb21pc2VJbnNwZWN0aW9uO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwge31dLCAzMzogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChQcm9taXNlLCBJTlRFUk5BTCkge1xuICAgICAgICAgICAgICAgIHZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xuICAgICAgICAgICAgICAgIHZhciBpc09iamVjdCA9IHV0aWwuaXNPYmplY3Q7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB0cnlDb252ZXJ0VG9Qcm9taXNlKG9iaiwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3Qob2JqKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhlbiA9IGdldFRoZW4ob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGVuID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0KSBjb250ZXh0Ll9wdXNoQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBQcm9taXNlLnJlamVjdCh0aGVuLmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0KSBjb250ZXh0Ll9wb3BDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FueUJsdWViaXJkUHJvbWlzZShvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5fdGhlbihyZXQuX2Z1bGZpbGwsIHJldC5fcmVqZWN0LCB1bmRlZmluZWQsIHJldCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb1RoZW5hYmxlKG9iaiwgdGhlbiwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkb0dldFRoZW4ob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmoudGhlbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRUaGVuKG9iaikge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvR2V0VGhlbihvYmopO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck9iai5lID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvck9iajtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaXNBbnlCbHVlYmlyZFByb21pc2Uob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzUHJvcC5jYWxsKG9iaiwgXCJfcHJvbWlzZTBcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRvVGhlbmFibGUoeCwgdGhlbiwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IHByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0KSBjb250ZXh0Ll9wdXNoQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dCkgY29udGV4dC5fcG9wQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdXRpbC50cnlDYXRjaCh0aGVuKS5jYWxsKHgsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHN5bmNocm9ub3VzID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb21pc2UgJiYgcmVzdWx0ID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVzdWx0LmUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiByZXNvbHZlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByb21pc2UpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuX3Jlc29sdmVDYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJvbWlzZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCBzeW5jaHJvbm91cywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnlDb252ZXJ0VG9Qcm9taXNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgeyBcIi4vdXRpbFwiOiAzNiB9XSwgMzQ6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUHJvbWlzZSwgSU5URVJOQUwsIGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xuICAgICAgICAgICAgICAgIHZhciBUaW1lb3V0RXJyb3IgPSBQcm9taXNlLlRpbWVvdXRFcnJvcjtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEhhbmRsZVdyYXBwZXIoaGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlID0gaGFuZGxlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIEhhbmRsZVdyYXBwZXIucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmhhbmRsZSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBhZnRlclZhbHVlID0gZnVuY3Rpb24gYWZ0ZXJWYWx1ZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsYXkoK3RoaXMpLnRoZW5SZXR1cm4odmFsdWUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGRlbGF5ID0gUHJvbWlzZS5kZWxheSA9IGZ1bmN0aW9uIChtcywgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkuX3RoZW4oYWZ0ZXJWYWx1ZSwgbnVsbCwgbnVsbCwgbXMsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVidWcuY2FuY2VsbGF0aW9uKCkgJiYgdmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0Ll9zZXRPbkNhbmNlbCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQuX2Z1bGZpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sICttcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVidWcuY2FuY2VsbGF0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQuX3NldE9uQ2FuY2VsKG5ldyBIYW5kbGVXcmFwcGVyKGhhbmRsZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldC5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24gKG1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWxheShtcywgdGhpcyk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBhZnRlclRpbWVvdXQgPSBmdW5jdGlvbiBhZnRlclRpbWVvdXQocHJvbWlzZSwgbWVzc2FnZSwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IG5ldyBUaW1lb3V0RXJyb3IoXCJvcGVyYXRpb24gdGltZWQgb3V0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gbmV3IFRpbWVvdXRFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1dGlsLm1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbihlcnIpO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UuX3JlamVjdChlcnIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHN1Y2Nlc3NDbGVhcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5oYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZmFpbHVyZUNsZWFyKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5oYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIChtcywgbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBtcyA9ICttcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldCwgcGFyZW50O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVXcmFwcGVyID0gbmV3IEhhbmRsZVdyYXBwZXIoc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0VGltZW91dCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQuaXNQZW5kaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlclRpbWVvdXQocmV0LCBtZXNzYWdlLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBtcykpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWJ1Zy5jYW5jZWxsYXRpb24oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gdGhpcy50aGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBwYXJlbnQuX3RoZW4oc3VjY2Vzc0NsZWFyLCBmYWlsdXJlQ2xlYXIsIHVuZGVmaW5lZCwgaGFuZGxlV3JhcHBlciwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5fc2V0T25DYW5jZWwoaGFuZGxlV3JhcHBlcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSB0aGlzLl90aGVuKHN1Y2Nlc3NDbGVhciwgZmFpbHVyZUNsZWFyLCB1bmRlZmluZWQsIGhhbmRsZVdyYXBwZXIsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7IFwiLi91dGlsXCI6IDM2IH1dLCAzNTogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChQcm9taXNlLCBhcGlSZWplY3Rpb24sIHRyeUNvbnZlcnRUb1Byb21pc2UsIGNyZWF0ZUNvbnRleHQsIElOVEVSTkFMLCBkZWJ1Zykge1xuICAgICAgICAgICAgICAgIHZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgVHlwZUVycm9yID0gX2RlcmVxXyhcIi4vZXJyb3JzXCIpLlR5cGVFcnJvcjtcbiAgICAgICAgICAgICAgICB2YXIgaW5oZXJpdHMgPSBfZGVyZXFfKFwiLi91dGlsXCIpLmluaGVyaXRzO1xuICAgICAgICAgICAgICAgIHZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG4gICAgICAgICAgICAgICAgdmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbiAgICAgICAgICAgICAgICB2YXIgTlVMTCA9IHt9O1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdGhyb3dlcihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY2FzdFByZXNlcnZpbmdEaXNwb3NhYmxlKHRoZW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHRoZW5hYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAhPT0gdGhlbmFibGUgJiYgdHlwZW9mIHRoZW5hYmxlLl9pc0Rpc3Bvc2FibGUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgdGhlbmFibGUuX2dldERpc3Bvc2VyID09PSBcImZ1bmN0aW9uXCIgJiYgdGhlbmFibGUuX2lzRGlzcG9zYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX3NldERpc3Bvc2FibGUodGhlbmFibGUuX2dldERpc3Bvc2VyKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXliZVByb21pc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRpc3Bvc2UocmVzb3VyY2VzLCBpbnNwZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHJlc291cmNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPj0gbGVuKSByZXR1cm4gcmV0Ll9mdWxmaWxsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gY2FzdFByZXNlcnZpbmdEaXNwb3NhYmxlKHJlc291cmNlc1tpKytdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlICYmIG1heWJlUHJvbWlzZS5faXNEaXNwb3NhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKG1heWJlUHJvbWlzZS5fZ2V0RGlzcG9zZXIoKS50cnlEaXNwb3NlKGluc3BlY3Rpb24pLCByZXNvdXJjZXMucHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dlcihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZS5fdGhlbihpdGVyYXRvciwgdGhyb3dlciwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvcigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIERpc3Bvc2VyKGRhdGEsIHByb21pc2UsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2UgPSBwcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBEaXNwb3Nlci5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIERpc3Bvc2VyLnByb3RvdHlwZS5wcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgRGlzcG9zZXIucHJvdG90eXBlLnJlc291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9taXNlKCkuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZSgpLnZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5VTEw7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIERpc3Bvc2VyLnByb3RvdHlwZS50cnlEaXNwb3NlID0gZnVuY3Rpb24gKGluc3BlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc291cmNlID0gdGhpcy5yZXNvdXJjZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQpIGNvbnRleHQuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSByZXNvdXJjZSAhPT0gTlVMTCA/IHRoaXMuZG9EaXNwb3NlKHJlc291cmNlLCBpbnNwZWN0aW9uKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQpIGNvbnRleHQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZS5fdW5zZXREaXNwb3NhYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBEaXNwb3Nlci5pc0Rpc3Bvc2VyID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQgIT0gbnVsbCAmJiB0eXBlb2YgZC5yZXNvdXJjZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkLnRyeURpc3Bvc2UgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gRnVuY3Rpb25EaXNwb3NlcihmbiwgcHJvbWlzZSwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yJChmbiwgcHJvbWlzZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluaGVyaXRzKEZ1bmN0aW9uRGlzcG9zZXIsIERpc3Bvc2VyKTtcblxuICAgICAgICAgICAgICAgIEZ1bmN0aW9uRGlzcG9zZXIucHJvdG90eXBlLmRvRGlzcG9zZSA9IGZ1bmN0aW9uIChyZXNvdXJjZSwgaW5zcGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSB0aGlzLmRhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwocmVzb3VyY2UsIHJlc291cmNlLCBpbnNwZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbWF5YmVVbndyYXBEaXNwb3Nlcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoRGlzcG9zZXIuaXNEaXNwb3Nlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzW3RoaXMuaW5kZXhdLl9zZXREaXNwb3NhYmxlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5wcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFJlc291cmNlTGlzdChsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbbGVuZ3RoIC0gMV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIFJlc291cmNlTGlzdC5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UudXNpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVuIDwgMikgcmV0dXJuIGFwaVJlamVjdGlvbihcInlvdSBtdXN0IHBhc3MgYXQgbGVhc3QgMiBhcmd1bWVudHMgdG8gUHJvbWlzZS51c2luZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gYXJndW1lbnRzW2xlbiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwcmVhZEFyZ3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVuID09PSAyICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcHJlYWRBcmdzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dCA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNvdXJjZXMgPSBuZXcgUmVzb3VyY2VMaXN0KGxlbik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNvdXJjZSA9IGlucHV0W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKERpc3Bvc2VyLmlzRGlzcG9zZXIocmVzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3Bvc2VyID0gcmVzb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UgPSByZXNvdXJjZS5wcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UuX3NldERpc3Bvc2FibGUoZGlzcG9zZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShyZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UgPSBtYXliZVByb21pc2UuX3RoZW4obWF5YmVVbndyYXBEaXNwb3NlciwgbnVsbCwgbnVsbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzOiByZXNvdXJjZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlc1tpXSA9IHJlc291cmNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZmxlY3RlZFJlc291cmNlcyA9IG5ldyBBcnJheShyZXNvdXJjZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWZsZWN0ZWRSZXNvdXJjZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmxlY3RlZFJlc291cmNlc1tpXSA9IFByb21pc2UucmVzb2x2ZShyZXNvdXJjZXNbaV0pLnJlZmxlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRQcm9taXNlID0gUHJvbWlzZS5hbGwocmVmbGVjdGVkUmVzb3VyY2VzKS50aGVuKGZ1bmN0aW9uIChpbnNwZWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnNwZWN0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnNwZWN0aW9uID0gaW5zcGVjdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc3BlY3Rpb24uaXNSZWplY3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yT2JqLmUgPSBpbnNwZWN0aW9uLmVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvck9iajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpbnNwZWN0aW9uLmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UHJvbWlzZS5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNwZWN0aW9uc1tpXSA9IGluc3BlY3Rpb24udmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuX3B1c2hDb250ZXh0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZuID0gdHJ5Q2F0Y2goZm4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IHNwcmVhZEFyZ3MgPyBmbi5hcHBseSh1bmRlZmluZWQsIGluc3BlY3Rpb25zKSA6IGZuKGluc3BlY3Rpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlQ3JlYXRlZCA9IHByb21pc2UuX3BvcENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyhyZXQsIHByb21pc2VDcmVhdGVkLCBcIlByb21pc2UudXNpbmdcIiwgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHJlc3VsdFByb21pc2UubGFzdGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnNwZWN0aW9uID0gbmV3IFByb21pc2UuUHJvbWlzZUluc3BlY3Rpb24ocmVzdWx0UHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlzcG9zZShyZXNvdXJjZXMsIGluc3BlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzLnByb21pc2UgPSBwcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9zZXRPbkNhbmNlbChyZXNvdXJjZXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3NldERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoZGlzcG9zZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDEzMTA3MjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcG9zZXIgPSBkaXNwb3NlcjtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2lzRGlzcG9zYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDEzMTA3MikgPiAwO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fZ2V0RGlzcG9zZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNwb3NlcjtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0RGlzcG9zYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmIH4xMzEwNzI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5kaXNwb3NlciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25EaXNwb3NlcihmbiwgdGhpcywgY3JlYXRlQ29udGV4dCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHsgXCIuL2Vycm9yc1wiOiAxMiwgXCIuL3V0aWxcIjogMzYgfV0sIDM2OiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICAgIHZhciBlczUgPSBfZGVyZXFfKFwiLi9lczVcIik7XG4gICAgICAgICAgICB2YXIgY2FuRXZhbHVhdGUgPSB0eXBlb2YgbmF2aWdhdG9yID09IFwidW5kZWZpbmVkXCI7XG5cbiAgICAgICAgICAgIHZhciBlcnJvck9iaiA9IHsgZToge30gfTtcbiAgICAgICAgICAgIHZhciB0cnlDYXRjaFRhcmdldDtcbiAgICAgICAgICAgIHZhciBnbG9iYWxPYmplY3QgPSB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHRoaXMgIT09IHVuZGVmaW5lZCA/IHRoaXMgOiBudWxsO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB0cnlDYXRjaGVyKCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0cnlDYXRjaFRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5Q2F0Y2hUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck9iai5lID0gZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHRyeUNhdGNoKGZuKSB7XG4gICAgICAgICAgICAgICAgdHJ5Q2F0Y2hUYXJnZXQgPSBmbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ5Q2F0Y2hlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluaGVyaXRzID0gZnVuY3Rpb24gaW5oZXJpdHMoQ2hpbGQsIFBhcmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBUKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gQ2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IkID0gUGFyZW50O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gUGFyZW50LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1Byb3AuY2FsbChQYXJlbnQucHJvdG90eXBlLCBwcm9wZXJ0eU5hbWUpICYmIHByb3BlcnR5TmFtZS5jaGFyQXQocHJvcGVydHlOYW1lLmxlbmd0aCAtIDEpICE9PSBcIiRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcGVydHlOYW1lICsgXCIkXCJdID0gUGFyZW50LnByb3RvdHlwZVtwcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFQucHJvdG90eXBlID0gUGFyZW50LnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICBDaGlsZC5wcm90b3R5cGUgPSBuZXcgVCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBDaGlsZC5wcm90b3R5cGU7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSB0cnVlIHx8IHZhbCA9PT0gZmFsc2UgfHwgdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiB8fCAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YodmFsdWUpKSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbWF5YmVXcmFwQXNFcnJvcihtYXliZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ByaW1pdGl2ZShtYXliZUVycm9yKSkgcmV0dXJuIG1heWJlRXJyb3I7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKHNhZmVUb1N0cmluZyhtYXliZUVycm9yKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHdpdGhBcHBlbmRlZCh0YXJnZXQsIGFwcGVuZGVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IHRhcmdldC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0W2ldID0gdGFyZ2V0W2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXRbaV0gPSBhcHBlbmRlZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXREYXRhUHJvcGVydHlPckRlZmF1bHQob2JqLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChlczUuaXNFUzUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQgPT0gbnVsbCAmJiBkZXNjLnNldCA9PSBudWxsID8gZGVzYy52YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSA/IG9ialtrZXldIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbm90RW51bWVyYWJsZVByb3Aob2JqLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1ByaW1pdGl2ZShvYmopKSByZXR1cm4gb2JqO1xuICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBlczUuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiB0aHJvd2VyKHIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyByO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW5oZXJpdGVkRGF0YUtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4Y2x1ZGVkUHJvdG90eXBlcyA9IFtBcnJheS5wcm90b3R5cGUsIE9iamVjdC5wcm90b3R5cGUsIEZ1bmN0aW9uLnByb3RvdHlwZV07XG5cbiAgICAgICAgICAgICAgICB2YXIgaXNFeGNsdWRlZFByb3RvID0gZnVuY3Rpb24gaXNFeGNsdWRlZFByb3RvKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4Y2x1ZGVkUHJvdG90eXBlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4Y2x1ZGVkUHJvdG90eXBlc1tpXSA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoZXM1LmlzRVM1KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXRLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmlzaXRlZEtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG9iaiAhPSBudWxsICYmICFpc0V4Y2x1ZGVkUHJvdG8ob2JqKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXMgPSBnZXRLZXlzKG9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2aXNpdGVkS2V5c1trZXldKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRlZEtleXNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXNjICE9IG51bGwgJiYgZGVzYy5nZXQgPT0gbnVsbCAmJiBkZXNjLnNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGVzNS5nZXRQcm90b3R5cGVPZihvYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXhjbHVkZWRQcm90byhvYmopKSByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qanNoaW50IGZvcmluOmZhbHNlICovXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhdGlvbjogZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNQcm9wLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleGNsdWRlZFByb3RvdHlwZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNQcm9wLmNhbGwoZXhjbHVkZWRQcm90b3R5cGVzW2ldLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgZW51bWVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgdmFyIHRoaXNBc3NpZ25tZW50UGF0dGVybiA9IC90aGlzXFxzKlxcLlxccypcXFMrXFxzKj0vO1xuICAgICAgICAgICAgZnVuY3Rpb24gaXNDbGFzcyhmbikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBlczUubmFtZXMoZm4ucHJvdG90eXBlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc01ldGhvZHMgPSBlczUuaXNFUzUgJiYga2V5cy5sZW5ndGggPiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc01ldGhvZHNPdGhlclRoYW5Db25zdHJ1Y3RvciA9IGtleXMubGVuZ3RoID4gMCAmJiAhKGtleXMubGVuZ3RoID09PSAxICYmIGtleXNbMF0gPT09IFwiY29uc3RydWN0b3JcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzVGhpc0Fzc2lnbm1lbnRBbmRTdGF0aWNNZXRob2RzID0gdGhpc0Fzc2lnbm1lbnRQYXR0ZXJuLnRlc3QoZm4gKyBcIlwiKSAmJiBlczUubmFtZXMoZm4pLmxlbmd0aCA+IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNNZXRob2RzIHx8IGhhc01ldGhvZHNPdGhlclRoYW5Db25zdHJ1Y3RvciB8fCBoYXNUaGlzQXNzaWdubWVudEFuZFN0YXRpY01ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiB0b0Zhc3RQcm9wZXJ0aWVzKG9iaikge1xuICAgICAgICAgICAgICAgIC8qanNoaW50IC1XMDI3LC1XMDU1LC1XMDMxKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBGYWtlQ29uc3RydWN0b3IoKSB7fVxuICAgICAgICAgICAgICAgIEZha2VDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBvYmo7XG4gICAgICAgICAgICAgICAgdmFyIGwgPSA4O1xuICAgICAgICAgICAgICAgIHdoaWxlIChsLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IEZha2VDb25zdHJ1Y3RvcigpO1xuICAgICAgICAgICAgICAgIH1yZXR1cm4gb2JqO1xuICAgICAgICAgICAgICAgIGV2YWwob2JqKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJpZGVudCA9IC9eW2EteiRfXVthLXokXzAtOV0qJC9pO1xuICAgICAgICAgICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyKHN0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiByaWRlbnQudGVzdChzdHIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBmaWxsZWRSYW5nZShjb3VudCwgcHJlZml4LCBzdWZmaXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0W2ldID0gcHJlZml4ICsgaSArIHN1ZmZpeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gc2FmZVRvU3RyaW5nKG9iaikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmogKyBcIlwiO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiW25vIHN0cmluZyByZXByZXNlbnRhdGlvbl1cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzRXJyb3Iob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiAodHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaikpID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmoubWVzc2FnZSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygb2JqLm5hbWUgPT09IFwic3RyaW5nXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbm90RW51bWVyYWJsZVByb3AoZSwgXCJpc09wZXJhdGlvbmFsXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gb3JpZ2luYXRlc0Zyb21SZWplY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmIChlID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIEVycm9yW1wiX19CbHVlYmlyZEVycm9yVHlwZXNfX1wiXS5PcGVyYXRpb25hbEVycm9yIHx8IGVbXCJpc09wZXJhdGlvbmFsXCJdID09PSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjYW5BdHRhY2hUcmFjZShvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNFcnJvcihvYmopICYmIGVzNS5wcm9wZXJ0eUlzV3JpdGFibGUob2JqLCBcInN0YWNrXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZW5zdXJlRXJyb3JPYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoXCJzdGFja1wiIGluIG5ldyBFcnJvcigpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FuQXR0YWNoVHJhY2UodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzYWZlVG9TdHJpbmcodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbkF0dGFjaFRyYWNlKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihzYWZlVG9TdHJpbmcodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsYXNzU3RyaW5nKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7fS50b1N0cmluZy5jYWxsKG9iaik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvcHlEZXNjcmlwdG9ycyhmcm9tLCB0bywgZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBlczUubmFtZXMoZnJvbSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXM1LmRlZmluZVByb3BlcnR5KHRvLCBrZXksIGVzNS5nZXREZXNjcmlwdG9yKGZyb20sIGtleSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYXNBcnJheSA9IGZ1bmN0aW9uIGFzQXJyYXkodikge1xuICAgICAgICAgICAgICAgIGlmIChlczUuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgQXJyYXlGcm9tID0gdHlwZW9mIEFycmF5LmZyb20gPT09IFwiZnVuY3Rpb25cIiA/IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHYpO1xuICAgICAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdCA9IHZbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICghKGl0UmVzdWx0ID0gaXQubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChpdFJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgYXNBcnJheSA9IGZ1bmN0aW9uIGFzQXJyYXkodikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXM1LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYgIT0gbnVsbCAmJiB0eXBlb2YgdltTeW1ib2wuaXRlcmF0b3JdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBBcnJheUZyb20odik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGlzTm9kZSA9IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIGNsYXNzU3RyaW5nKHByb2Nlc3MpLnRvTG93ZXJDYXNlKCkgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiO1xuXG4gICAgICAgICAgICB2YXIgaGFzRW52VmFyaWFibGVzID0gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHByb2Nlc3MuZW52ICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBlbnYoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhc0VudlZhcmlhYmxlcyA/IHByb2Nlc3MuZW52W2tleV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldE5hdGl2ZVByb21pc2UoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBQcm9taXNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwocHJvbWlzZSkgPT09IFwiW29iamVjdCBQcm9taXNlXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBkb21haW5CaW5kKHNlbGYsIGNiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuYmluZChjYik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXQgPSB7XG4gICAgICAgICAgICAgICAgaXNDbGFzczogaXNDbGFzcyxcbiAgICAgICAgICAgICAgICBpc0lkZW50aWZpZXI6IGlzSWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICBpbmhlcml0ZWREYXRhS2V5czogaW5oZXJpdGVkRGF0YUtleXMsXG4gICAgICAgICAgICAgICAgZ2V0RGF0YVByb3BlcnR5T3JEZWZhdWx0OiBnZXREYXRhUHJvcGVydHlPckRlZmF1bHQsXG4gICAgICAgICAgICAgICAgdGhyb3dlcjogdGhyb3dlcixcbiAgICAgICAgICAgICAgICBpc0FycmF5OiBlczUuaXNBcnJheSxcbiAgICAgICAgICAgICAgICBhc0FycmF5OiBhc0FycmF5LFxuICAgICAgICAgICAgICAgIG5vdEVudW1lcmFibGVQcm9wOiBub3RFbnVtZXJhYmxlUHJvcCxcbiAgICAgICAgICAgICAgICBpc1ByaW1pdGl2ZTogaXNQcmltaXRpdmUsXG4gICAgICAgICAgICAgICAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICAgICAgICAgICAgICAgIGlzRXJyb3I6IGlzRXJyb3IsXG4gICAgICAgICAgICAgICAgY2FuRXZhbHVhdGU6IGNhbkV2YWx1YXRlLFxuICAgICAgICAgICAgICAgIGVycm9yT2JqOiBlcnJvck9iaixcbiAgICAgICAgICAgICAgICB0cnlDYXRjaDogdHJ5Q2F0Y2gsXG4gICAgICAgICAgICAgICAgaW5oZXJpdHM6IGluaGVyaXRzLFxuICAgICAgICAgICAgICAgIHdpdGhBcHBlbmRlZDogd2l0aEFwcGVuZGVkLFxuICAgICAgICAgICAgICAgIG1heWJlV3JhcEFzRXJyb3I6IG1heWJlV3JhcEFzRXJyb3IsXG4gICAgICAgICAgICAgICAgdG9GYXN0UHJvcGVydGllczogdG9GYXN0UHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICBmaWxsZWRSYW5nZTogZmlsbGVkUmFuZ2UsXG4gICAgICAgICAgICAgICAgdG9TdHJpbmc6IHNhZmVUb1N0cmluZyxcbiAgICAgICAgICAgICAgICBjYW5BdHRhY2hUcmFjZTogY2FuQXR0YWNoVHJhY2UsXG4gICAgICAgICAgICAgICAgZW5zdXJlRXJyb3JPYmplY3Q6IGVuc3VyZUVycm9yT2JqZWN0LFxuICAgICAgICAgICAgICAgIG9yaWdpbmF0ZXNGcm9tUmVqZWN0aW9uOiBvcmlnaW5hdGVzRnJvbVJlamVjdGlvbixcbiAgICAgICAgICAgICAgICBtYXJrQXNPcmlnaW5hdGluZ0Zyb21SZWplY3Rpb246IG1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbixcbiAgICAgICAgICAgICAgICBjbGFzc1N0cmluZzogY2xhc3NTdHJpbmcsXG4gICAgICAgICAgICAgICAgY29weURlc2NyaXB0b3JzOiBjb3B5RGVzY3JpcHRvcnMsXG4gICAgICAgICAgICAgICAgaGFzRGV2VG9vbHM6IHR5cGVvZiBjaHJvbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY2hyb21lICYmIHR5cGVvZiBjaHJvbWUubG9hZFRpbWVzID09PSBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgaXNOb2RlOiBpc05vZGUsXG4gICAgICAgICAgICAgICAgaGFzRW52VmFyaWFibGVzOiBoYXNFbnZWYXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgZW52OiBlbnYsXG4gICAgICAgICAgICAgICAgZ2xvYmFsOiBnbG9iYWxPYmplY3QsXG4gICAgICAgICAgICAgICAgZ2V0TmF0aXZlUHJvbWlzZTogZ2V0TmF0aXZlUHJvbWlzZSxcbiAgICAgICAgICAgICAgICBkb21haW5CaW5kOiBkb21haW5CaW5kXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0LmlzUmVjZW50Tm9kZSA9IHJldC5pc05vZGUgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB2ZXJzaW9uID0gcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLnNwbGl0KFwiLlwiKS5tYXAoTnVtYmVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVyc2lvblswXSA9PT0gMCAmJiB2ZXJzaW9uWzFdID4gMTAgfHwgdmVyc2lvblswXSA+IDA7XG4gICAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICAgIGlmIChyZXQuaXNOb2RlKSByZXQudG9GYXN0UHJvcGVydGllcyhwcm9jZXNzKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXQubGFzdExpbmVFcnJvciA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJldDtcbiAgICAgICAgfSwgeyBcIi4vZXM1XCI6IDEzIH1dIH0sIHt9LCBbNF0pKDQpO1xufSk7O2lmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cgIT09IG51bGwpIHtcbiAgICB3aW5kb3cuUCA9IHdpbmRvdy5Qcm9taXNlO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiAhPT0gbnVsbCkge1xuICAgIHNlbGYuUCA9IHNlbGYuUHJvbWlzZTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9icm93c2VyL2JsdWViaXJkLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n");

/***/ }),

/***/ 13:
/*!********************************************************!*\
  !*** ./frontend/devkit-core/timestep/src/userAgent.js ***!
  \********************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _base = __webpack_require__(/*! base */ 0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _exports = {};\n\n/**\n * @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the Mozilla Public License v. 2.0 as published by Mozilla.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * Mozilla Public License v. 2.0 for more details.\n\n * You should have received a copy of the Mozilla Public License v. 2.0\n * along with the Game Closure SDK.  If not, see <http://mozilla.org/MPL/2.0/>.\n */\n/**\n * @module userAgent\n *\n * Uses navigator.userAgent and retrieves information about app runtime, device,\n * OS version, browser version, and simulator status.\n */\nvar ua = navigator && navigator.userAgent;\nvar isIOS = /iPod|iPhone|iPad/i.test(ua);\nvar isAndroid = /Android/.test(ua);\nvar isMac = /Mac OS X [0-9_]+/.test(ua);\nvar isIPhoneOS = /iPhone OS/.test(ua);\nvar isSafari = /Safari/.test(ua);\nvar isChrome = /Chrome/.test(ua);\nvar isFirefox = /Firefox/.test(ua);\nvar isIE = /MSIE/.test(ua);\nvar isIE11 = /Trident/.test(ua);\nvar isEdge = /Edge/.test(ua);\nvar isSimulator = _base.GLOBAL.CONFIG && !!_base.CONFIG.simulator;\n\nvar deviceType = isIOS || isAndroid ? 'mobile' : 'desktop';\nvar osType = 'unknown';\nvar osVersion = 'unknown';\nvar osVersionString = 'unknown';\nvar browserVersion = 'unknown';\nvar browserVersionString = 'unknown';\nvar browserType = 'unknown';\n\nif (isAndroid) {\n  osType = 'Android';\n  osVersionString = ua.match(/Android[/\\s][\\d.]+/)[0];\n  osVersion = osVersionString.match(/[\\d.]+/)[0];\n} else if (isIPhoneOS) {\n  osType = 'iPhone OS';\n  osVersionString = ua.match(/iPhone OS [0-9_]+/)[0];\n  osVersion = osVersionString.match(/[0-9_]+/)[0].replace(/_/g, '.');\n} else if (isMac) {\n  osType = 'Mac OS X';\n  osVersionString = ua.match(/Mac OS X [0-9_]+/)[0];\n  osVersion = osVersionString.match(/[0-9_]+/)[0].replace(/_/g, '.');\n}\n\nif (isChrome) {\n  browserType = 'Chrome';\n  browserVersionString = ua.match(/Chrome[/\\s][\\d.]+/)[0];\n  browserVersion = browserVersionString.match(/[\\d.]+/)[0];\n} else if (isSafari) {\n  browserType = 'Safari';\n  browserVersionString = ua.match(/Safari[/\\s][\\d.]+/)[0];\n  browserVersion = browserVersionString.match(/[\\d.]+/)[0];\n} else if (isFirefox) {\n  browserType = 'Firefox';\n  browserVersionString = ua.match(/Firefox[/\\s][\\d.]+/)[0];\n  browserVersion = browserVersionString.match(/[\\d.]+/)[0];\n} else if (isIE) {\n  browserType = 'Internet Explorer';\n} else if (isIE11) {\n  browserType = 'Internet Explorer';\n} else if (isEdge) {\n  browserType = 'Edge';\n}\n\nvar UserAgent = function UserAgent() {\n  _classCallCheck(this, UserAgent);\n};\n\nUserAgent.prototype.USER_AGENT = ua;\nUserAgent.prototype.OS_TYPE = osType;\nUserAgent.prototype.OS_VERSION = osVersion;\nUserAgent.prototype.DEVICE_TYPE = deviceType;\nUserAgent.prototype.BROWSER_TYPE = browserType;\nUserAgent.prototype.BROWSER_VERSION = browserVersion;\nUserAgent.prototype.SIMULATED = isSimulator;\n_exports = new UserAgent();\n\nexports.default = _exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9mcm9udGVuZC9kZXZraXQtY29yZS90aW1lc3RlcC9zcmMvdXNlckFnZW50LmpzP2IyYTUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7O0FBRUEsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdko7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfYmFzZSA9IHJlcXVpcmUoJ2Jhc2UnKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIF9leHBvcnRzID0ge307XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBHYW1lIENsb3N1cmUgU0RLLlxuICpcbiAqIFRoZSBHYW1lIENsb3N1cmUgU0RLIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWMgTGljZW5zZSB2LiAyLjAgYXMgcHVibGlzaGVkIGJ5IE1vemlsbGEuXG5cbiAqIFRoZSBHYW1lIENsb3N1cmUgU0RLIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXG4gKiBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlIHYuIDIuMCBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlIHYuIDIuMFxuICogYWxvbmcgd2l0aCB0aGUgR2FtZSBDbG9zdXJlIFNESy4gIElmIG5vdCwgc2VlIDxodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8+LlxuICovXG4vKipcbiAqIEBtb2R1bGUgdXNlckFnZW50XG4gKlxuICogVXNlcyBuYXZpZ2F0b3IudXNlckFnZW50IGFuZCByZXRyaWV2ZXMgaW5mb3JtYXRpb24gYWJvdXQgYXBwIHJ1bnRpbWUsIGRldmljZSxcbiAqIE9TIHZlcnNpb24sIGJyb3dzZXIgdmVyc2lvbiwgYW5kIHNpbXVsYXRvciBzdGF0dXMuXG4gKi9cbnZhciB1YSA9IG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50O1xudmFyIGlzSU9TID0gL2lQb2R8aVBob25lfGlQYWQvaS50ZXN0KHVhKTtcbnZhciBpc0FuZHJvaWQgPSAvQW5kcm9pZC8udGVzdCh1YSk7XG52YXIgaXNNYWMgPSAvTWFjIE9TIFggWzAtOV9dKy8udGVzdCh1YSk7XG52YXIgaXNJUGhvbmVPUyA9IC9pUGhvbmUgT1MvLnRlc3QodWEpO1xudmFyIGlzU2FmYXJpID0gL1NhZmFyaS8udGVzdCh1YSk7XG52YXIgaXNDaHJvbWUgPSAvQ2hyb21lLy50ZXN0KHVhKTtcbnZhciBpc0ZpcmVmb3ggPSAvRmlyZWZveC8udGVzdCh1YSk7XG52YXIgaXNJRSA9IC9NU0lFLy50ZXN0KHVhKTtcbnZhciBpc0lFMTEgPSAvVHJpZGVudC8udGVzdCh1YSk7XG52YXIgaXNFZGdlID0gL0VkZ2UvLnRlc3QodWEpO1xudmFyIGlzU2ltdWxhdG9yID0gX2Jhc2UuR0xPQkFMLkNPTkZJRyAmJiAhIV9iYXNlLkNPTkZJRy5zaW11bGF0b3I7XG5cbnZhciBkZXZpY2VUeXBlID0gaXNJT1MgfHwgaXNBbmRyb2lkID8gJ21vYmlsZScgOiAnZGVza3RvcCc7XG52YXIgb3NUeXBlID0gJ3Vua25vd24nO1xudmFyIG9zVmVyc2lvbiA9ICd1bmtub3duJztcbnZhciBvc1ZlcnNpb25TdHJpbmcgPSAndW5rbm93bic7XG52YXIgYnJvd3NlclZlcnNpb24gPSAndW5rbm93bic7XG52YXIgYnJvd3NlclZlcnNpb25TdHJpbmcgPSAndW5rbm93bic7XG52YXIgYnJvd3NlclR5cGUgPSAndW5rbm93bic7XG5cbmlmIChpc0FuZHJvaWQpIHtcbiAgb3NUeXBlID0gJ0FuZHJvaWQnO1xuICBvc1ZlcnNpb25TdHJpbmcgPSB1YS5tYXRjaCgvQW5kcm9pZFsvXFxzXVtcXGQuXSsvKVswXTtcbiAgb3NWZXJzaW9uID0gb3NWZXJzaW9uU3RyaW5nLm1hdGNoKC9bXFxkLl0rLylbMF07XG59IGVsc2UgaWYgKGlzSVBob25lT1MpIHtcbiAgb3NUeXBlID0gJ2lQaG9uZSBPUyc7XG4gIG9zVmVyc2lvblN0cmluZyA9IHVhLm1hdGNoKC9pUGhvbmUgT1MgWzAtOV9dKy8pWzBdO1xuICBvc1ZlcnNpb24gPSBvc1ZlcnNpb25TdHJpbmcubWF0Y2goL1swLTlfXSsvKVswXS5yZXBsYWNlKC9fL2csICcuJyk7XG59IGVsc2UgaWYgKGlzTWFjKSB7XG4gIG9zVHlwZSA9ICdNYWMgT1MgWCc7XG4gIG9zVmVyc2lvblN0cmluZyA9IHVhLm1hdGNoKC9NYWMgT1MgWCBbMC05X10rLylbMF07XG4gIG9zVmVyc2lvbiA9IG9zVmVyc2lvblN0cmluZy5tYXRjaCgvWzAtOV9dKy8pWzBdLnJlcGxhY2UoL18vZywgJy4nKTtcbn1cblxuaWYgKGlzQ2hyb21lKSB7XG4gIGJyb3dzZXJUeXBlID0gJ0Nocm9tZSc7XG4gIGJyb3dzZXJWZXJzaW9uU3RyaW5nID0gdWEubWF0Y2goL0Nocm9tZVsvXFxzXVtcXGQuXSsvKVswXTtcbiAgYnJvd3NlclZlcnNpb24gPSBicm93c2VyVmVyc2lvblN0cmluZy5tYXRjaCgvW1xcZC5dKy8pWzBdO1xufSBlbHNlIGlmIChpc1NhZmFyaSkge1xuICBicm93c2VyVHlwZSA9ICdTYWZhcmknO1xuICBicm93c2VyVmVyc2lvblN0cmluZyA9IHVhLm1hdGNoKC9TYWZhcmlbL1xcc11bXFxkLl0rLylbMF07XG4gIGJyb3dzZXJWZXJzaW9uID0gYnJvd3NlclZlcnNpb25TdHJpbmcubWF0Y2goL1tcXGQuXSsvKVswXTtcbn0gZWxzZSBpZiAoaXNGaXJlZm94KSB7XG4gIGJyb3dzZXJUeXBlID0gJ0ZpcmVmb3gnO1xuICBicm93c2VyVmVyc2lvblN0cmluZyA9IHVhLm1hdGNoKC9GaXJlZm94Wy9cXHNdW1xcZC5dKy8pWzBdO1xuICBicm93c2VyVmVyc2lvbiA9IGJyb3dzZXJWZXJzaW9uU3RyaW5nLm1hdGNoKC9bXFxkLl0rLylbMF07XG59IGVsc2UgaWYgKGlzSUUpIHtcbiAgYnJvd3NlclR5cGUgPSAnSW50ZXJuZXQgRXhwbG9yZXInO1xufSBlbHNlIGlmIChpc0lFMTEpIHtcbiAgYnJvd3NlclR5cGUgPSAnSW50ZXJuZXQgRXhwbG9yZXInO1xufSBlbHNlIGlmIChpc0VkZ2UpIHtcbiAgYnJvd3NlclR5cGUgPSAnRWRnZSc7XG59XG5cbnZhciBVc2VyQWdlbnQgPSBmdW5jdGlvbiBVc2VyQWdlbnQoKSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBVc2VyQWdlbnQpO1xufTtcblxuVXNlckFnZW50LnByb3RvdHlwZS5VU0VSX0FHRU5UID0gdWE7XG5Vc2VyQWdlbnQucHJvdG90eXBlLk9TX1RZUEUgPSBvc1R5cGU7XG5Vc2VyQWdlbnQucHJvdG90eXBlLk9TX1ZFUlNJT04gPSBvc1ZlcnNpb247XG5Vc2VyQWdlbnQucHJvdG90eXBlLkRFVklDRV9UWVBFID0gZGV2aWNlVHlwZTtcblVzZXJBZ2VudC5wcm90b3R5cGUuQlJPV1NFUl9UWVBFID0gYnJvd3NlclR5cGU7XG5Vc2VyQWdlbnQucHJvdG90eXBlLkJST1dTRVJfVkVSU0lPTiA9IGJyb3dzZXJWZXJzaW9uO1xuVXNlckFnZW50LnByb3RvdHlwZS5TSU1VTEFURUQgPSBpc1NpbXVsYXRvcjtcbl9leHBvcnRzID0gbmV3IFVzZXJBZ2VudCgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBfZXhwb3J0cztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Zyb250ZW5kL2RldmtpdC1jb3JlL3RpbWVzdGVwL3NyYy91c2VyQWdlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n");

/***/ }),

/***/ 222:
/*!*********************************************************!*\
  !*** ./frontend/devkit-core/src/clientapi/bootstrap.js ***!
  \*********************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _base = __webpack_require__(/*! base */ 0);\n\nvar _analytics = __webpack_require__(/*! analytics */ 41);\n\nvar _analytics2 = _interopRequireDefault(_analytics);\n\nvar _facebook = __webpack_require__(/*! facebook */ 61);\n\nvar _facebook2 = _interopRequireDefault(_facebook);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /** @license\n                                                                                                                                                           * This file is part of the Game Closure SDK.\n                                                                                                                                                           *\n                                                                                                                                                           * The Game Closure SDK is free software: you can redistribute it and/or modify\n                                                                                                                                                           * it under the terms of the Mozilla Public License v. 2.0 as published by Mozilla.\n                                                                                                                                                          \n                                                                                                                                                           * The Game Closure SDK is distributed in the hope that it will be useful,\n                                                                                                                                                           * but WITHOUT ANY WARRANTY; without even the implied warranty of\n                                                                                                                                                           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n                                                                                                                                                           * Mozilla Public License v. 2.0 for more details.\n                                                                                                                                                          \n                                                                                                                                                           * You should have received a copy of the Mozilla Public License v. 2.0\n                                                                                                                                                           * along with the Game Closure SDK.  If not, see <http://mozilla.org/MPL/2.0/>.\n                                                                                                                                                           */\n\n// TODO: introduce some logic to import desired social platform\n\n\nvar DevkitClient = function () {\n  function DevkitClient(buildURL) {\n    _classCallCheck(this, DevkitClient);\n\n    // might not be the right place for those properties?\n    this.locale = null;\n\n    this.startTime = Date.now();\n\n    this.isOrientationValid = true;\n\n    this.app = null;\n\n    this._buildURL = buildURL;\n\n    this._initializeSocialPlatform();\n  }\n\n  DevkitClient.prototype.attachApp = function attachApp(app) {\n    // TODO: deprecate for security reasons.\n    // We do not want to expose the app\n    // by making it accessible through a global object\n    this.app = app;\n  };\n\n  DevkitClient.prototype._initializeSocialPlatform = function _initializeSocialPlatform() {\n    var _this = this;\n\n    _facebook2.default.initializeAsync().then(function () {\n      var playerID = _facebook2.default.player.getID();\n      var initParams = (0, _base.merge)({ userID: playerID }, CONFIG.analytics);\n      _analytics2.default.initialize(initParams);\n\n      _this.locale = _facebook2.default.getLocale();\n\n      _analytics2.default.pushEvent('PlatformInitSuccess');\n    }).catch(function (e) {\n      _analytics2.default.pushError('PlatformInitFailed', e);\n    }).finally(function () {\n      _this._loadBuild();\n    });\n  };\n\n  DevkitClient.prototype._loadBuild = function _loadBuild() {\n\n    // element.onload = function () {\n    //   this.onload = null;\n    //   this.onerror = null;\n    // };\n\n    var buildURL = this._buildURL;\n    // these are not if/else because we want the dead code\n    // elimination to work nicely.\n    if (true) {\n      var element = document.createElement('script');\n      element.onerror = function (error) {\n        this.onload = null;\n        this.onerror = null;\n        var statusCode = ' Status code: ' + error.status;\n        var reason = ' Reason: ' + error.reason;\n        var response = ' Response: ' + error.response;\n        console.error('Build not found: ' + buildURL + statusCode + reason + response);\n      };\n\n      element.src = buildURL;\n      document.getElementsByTagName('head')[0].appendChild(element);\n    }\n    if (false) {\n      var xhr = new XMLHttpRequest();\n      xhr.onload = function (res) {\n        var src = this.responseText;\n        window.eval(src);\n      };\n      xhr.open('GET', this._buildURL);\n      xhr.send();\n    }\n  };\n\n  return DevkitClient;\n}();\n\n;\n\nwindow.initGC = function (buildURL) {\n  // Attaching browser config onto config (for compatibility with timestep)\n  var browserConfig = CONFIG.browser;\n  CONFIG.useWebGL = browserConfig.canvas.useWebGL;\n  CONFIG.preserveDrawingBuffer = browserConfig.webGL.preserveDrawingBuffer;\n  CONFIG.maxTextureMegabytes = browserConfig.webGL.maxTextureMegabytes;\n  CONFIG.disableServiceWorkers = browserConfig.disableServiceWorkers;\n\n  _base.GLOBAL.GC = new DevkitClient(buildURL);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9mcm9udGVuZC9kZXZraXQtY29yZS9zcmMvY2xpZW50YXBpL2Jvb3RzdHJhcC5qcz8zZGJjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFLEVBQUU7QUFDeko7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzTEFBc0w7QUFDdEw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QyxtQkFBbUI7QUFDNUQ7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMjIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Jhc2UgPSByZXF1aXJlKCdiYXNlJyk7XG5cbnZhciBfYW5hbHl0aWNzID0gcmVxdWlyZSgnYW5hbHl0aWNzJyk7XG5cbnZhciBfYW5hbHl0aWNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FuYWx5dGljcyk7XG5cbnZhciBfZmFjZWJvb2sgPSByZXF1aXJlKCdmYWNlYm9vaycpO1xuXG52YXIgX2ZhY2Vib29rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZhY2Vib29rKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH0gLyoqIEBsaWNlbnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEdhbWUgQ2xvc3VyZSBTREsuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBUaGUgR2FtZSBDbG9zdXJlIFNESyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlIHYuIDIuMCBhcyBwdWJsaXNoZWQgYnkgTW96aWxsYS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBUaGUgR2FtZSBDbG9zdXJlIFNESyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTW96aWxsYSBQdWJsaWMgTGljZW5zZSB2LiAyLjAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlIHYuIDIuMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGFsb25nIHdpdGggdGhlIEdhbWUgQ2xvc3VyZSBTREsuICBJZiBub3QsIHNlZSA8aHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvPi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuLy8gVE9ETzogaW50cm9kdWNlIHNvbWUgbG9naWMgdG8gaW1wb3J0IGRlc2lyZWQgc29jaWFsIHBsYXRmb3JtXG5cblxudmFyIERldmtpdENsaWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGV2a2l0Q2xpZW50KGJ1aWxkVVJMKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERldmtpdENsaWVudCk7XG5cbiAgICAvLyBtaWdodCBub3QgYmUgdGhlIHJpZ2h0IHBsYWNlIGZvciB0aG9zZSBwcm9wZXJ0aWVzP1xuICAgIHRoaXMubG9jYWxlID0gbnVsbDtcblxuICAgIHRoaXMuc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgIHRoaXMuaXNPcmllbnRhdGlvblZhbGlkID0gdHJ1ZTtcblxuICAgIHRoaXMuYXBwID0gbnVsbDtcblxuICAgIHRoaXMuX2J1aWxkVVJMID0gYnVpbGRVUkw7XG5cbiAgICB0aGlzLl9pbml0aWFsaXplU29jaWFsUGxhdGZvcm0oKTtcbiAgfVxuXG4gIERldmtpdENsaWVudC5wcm90b3R5cGUuYXR0YWNoQXBwID0gZnVuY3Rpb24gYXR0YWNoQXBwKGFwcCkge1xuICAgIC8vIFRPRE86IGRlcHJlY2F0ZSBmb3Igc2VjdXJpdHkgcmVhc29ucy5cbiAgICAvLyBXZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhlIGFwcFxuICAgIC8vIGJ5IG1ha2luZyBpdCBhY2Nlc3NpYmxlIHRocm91Z2ggYSBnbG9iYWwgb2JqZWN0XG4gICAgdGhpcy5hcHAgPSBhcHA7XG4gIH07XG5cbiAgRGV2a2l0Q2xpZW50LnByb3RvdHlwZS5faW5pdGlhbGl6ZVNvY2lhbFBsYXRmb3JtID0gZnVuY3Rpb24gX2luaXRpYWxpemVTb2NpYWxQbGF0Zm9ybSgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2ZhY2Vib29rMi5kZWZhdWx0LmluaXRpYWxpemVBc3luYygpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBsYXllcklEID0gX2ZhY2Vib29rMi5kZWZhdWx0LnBsYXllci5nZXRJRCgpO1xuICAgICAgdmFyIGluaXRQYXJhbXMgPSAoMCwgX2Jhc2UubWVyZ2UpKHsgdXNlcklEOiBwbGF5ZXJJRCB9LCBDT05GSUcuYW5hbHl0aWNzKTtcbiAgICAgIF9hbmFseXRpY3MyLmRlZmF1bHQuaW5pdGlhbGl6ZShpbml0UGFyYW1zKTtcblxuICAgICAgX3RoaXMubG9jYWxlID0gX2ZhY2Vib29rMi5kZWZhdWx0LmdldExvY2FsZSgpO1xuXG4gICAgICBfYW5hbHl0aWNzMi5kZWZhdWx0LnB1c2hFdmVudCgnUGxhdGZvcm1Jbml0U3VjY2VzcycpO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICBfYW5hbHl0aWNzMi5kZWZhdWx0LnB1c2hFcnJvcignUGxhdGZvcm1Jbml0RmFpbGVkJywgZSk7XG4gICAgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5fbG9hZEJ1aWxkKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgRGV2a2l0Q2xpZW50LnByb3RvdHlwZS5fbG9hZEJ1aWxkID0gZnVuY3Rpb24gX2xvYWRCdWlsZCgpIHtcblxuICAgIC8vIGVsZW1lbnQub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIC8vICAgdGhpcy5vbmxvYWQgPSBudWxsO1xuICAgIC8vICAgdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICAvLyB9O1xuXG4gICAgdmFyIGJ1aWxkVVJMID0gdGhpcy5fYnVpbGRVUkw7XG4gICAgLy8gdGhlc2UgYXJlIG5vdCBpZi9lbHNlIGJlY2F1c2Ugd2Ugd2FudCB0aGUgZGVhZCBjb2RlXG4gICAgLy8gZWxpbWluYXRpb24gdG8gd29yayBuaWNlbHkuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICBlbGVtZW50Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5vbmxvYWQgPSBudWxsO1xuICAgICAgICB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICB2YXIgc3RhdHVzQ29kZSA9ICcgU3RhdHVzIGNvZGU6ICcgKyBlcnJvci5zdGF0dXM7XG4gICAgICAgIHZhciByZWFzb24gPSAnIFJlYXNvbjogJyArIGVycm9yLnJlYXNvbjtcbiAgICAgICAgdmFyIHJlc3BvbnNlID0gJyBSZXNwb25zZTogJyArIGVycm9yLnJlc3BvbnNlO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdCdWlsZCBub3QgZm91bmQ6ICcgKyBidWlsZFVSTCArIHN0YXR1c0NvZGUgKyByZWFzb24gKyByZXNwb25zZSk7XG4gICAgICB9O1xuXG4gICAgICBlbGVtZW50LnNyYyA9IGJ1aWxkVVJMO1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgdmFyIHNyYyA9IHRoaXMucmVzcG9uc2VUZXh0O1xuICAgICAgICB3aW5kb3cuZXZhbChzcmMpO1xuICAgICAgfTtcbiAgICAgIHhoci5vcGVuKCdHRVQnLCB0aGlzLl9idWlsZFVSTCk7XG4gICAgICB4aHIuc2VuZCgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gRGV2a2l0Q2xpZW50O1xufSgpO1xuXG47XG5cbndpbmRvdy5pbml0R0MgPSBmdW5jdGlvbiAoYnVpbGRVUkwpIHtcbiAgLy8gQXR0YWNoaW5nIGJyb3dzZXIgY29uZmlnIG9udG8gY29uZmlnIChmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHRpbWVzdGVwKVxuICB2YXIgYnJvd3NlckNvbmZpZyA9IENPTkZJRy5icm93c2VyO1xuICBDT05GSUcudXNlV2ViR0wgPSBicm93c2VyQ29uZmlnLmNhbnZhcy51c2VXZWJHTDtcbiAgQ09ORklHLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA9IGJyb3dzZXJDb25maWcud2ViR0wucHJlc2VydmVEcmF3aW5nQnVmZmVyO1xuICBDT05GSUcubWF4VGV4dHVyZU1lZ2FieXRlcyA9IGJyb3dzZXJDb25maWcud2ViR0wubWF4VGV4dHVyZU1lZ2FieXRlcztcbiAgQ09ORklHLmRpc2FibGVTZXJ2aWNlV29ya2VycyA9IGJyb3dzZXJDb25maWcuZGlzYWJsZVNlcnZpY2VXb3JrZXJzO1xuXG4gIF9iYXNlLkdMT0JBTC5HQyA9IG5ldyBEZXZraXRDbGllbnQoYnVpbGRVUkwpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Zyb250ZW5kL2RldmtpdC1jb3JlL3NyYy9jbGllbnRhcGkvYm9vdHN0cmFwLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///222\n");

/***/ }),

/***/ 38:
/*!***********************************!*\
  !*** ./frontend/jsio/jsio-web.js ***!
  \***********************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\n// Copyright (c) 2010\n// Michael Carter (cartermichael@gmail.com)\n// Martin Hunt (mghunt@gmail.com)\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n// Initialization of js.io occurs in a closure, preventing local variables\n// from entering the global scope.  During execution, the method `jsio` is\n// added to the global scope.\n\n;\n(function () {\n  function init(cloneFrom) {\n    // We expect this code to be minified before production use, so we may\n    // write code slightly more verbosely than we otherwise would.\n    var INITIAL_FILE = '<initial file>';\n    var MODULE_NOT_FOUND = 'MODULE_NOT_FOUND';\n\n    // Should we parse syntax errors in the browser?\n    var DEBUG = true;\n\n    // Store a reference to the slice function for converting objects of\n    // type arguments to type array.\n    var SLICE = Array.prototype.slice;\n\n    // js.io supports multiple JavaScript environments such as node.js and\n    // most web browsers (IE, Firefox, WebKit).  The ENV object wraps\n    // any utility functions that contain environment-specific code (e.g.\n    // reading a file using node's `fs` library or a browser's\n    // `XMLHttpRequest`).  Running js.io in other JavaScript environments\n    // is as easy as implementing an environment object that conforms to\n    // the abstract interface for an environment (provided below) and\n    // calling `jsio.setEnv()`.\n    var ENV;\n\n    // Checks if the last character in a string is `/`.\n    var rexpEndSlash = /(\\/|\\\\)$/;\n\n    function getModuleDef(path) {\n      path += '.js';\n      return jsio.__modules[path] || new ModuleDef(path);\n    }\n\n    // Creates an object containing metadata about a module.\n    function ModuleDef(path) {\n      this.path = path;\n      this.friendlyPath = path;\n\n      util.splitPath(path, this);\n      this.directory = util.resolve(ENV.getCwd(), this.directory);\n    }\n\n    ModuleDef.prototype.setBase = function (baseMod, basePath) {\n      this.baseMod = baseMod;\n      this.basePath = basePath + '/' + baseMod;\n    };\n\n    var HOST = /^([a-z][a-z0-9+\\-\\.]*:\\/\\/.*?\\/)(.*)$/;\n    var PROTOCOL = /^[a-z][a-z0-9+\\-\\.]*:/;\n\n    // Utility functions\n    var util = {\n      // `util.bind` returns a function that, when called, will execute\n      // the method passed in with the provided context and any additional\n      // arguments passed to `util.bind`.\n      //       util.bind(obj, 'f', a) -> function() { return obj.f(a); }\n      //       util.bind(obj, g, a, b, c) -> function() { return g.call(g, a, b, c); }\n      bind: function bind(context, method)\n      /*, args... */\n      {\n        var args = SLICE.call(arguments, 2);\n        return function () {\n          method = typeof method == 'string' ? context[method] : method;\n          return method.apply(context, args.concat(SLICE.call(arguments, 0)));\n        };\n      },\n      // `util.addEndSlash` accepts a string.  That string is returned with a `/`\n      // appended if the string did not already end in a `/`.\n      addEndSlash: function addEndSlash(str) {\n        return rexpEndSlash.test(str) ? str : str + '/';\n      },\n      // `util.removeEndSlash` accepts a string.  It removes a trailing `/` if\n      // one is found.\n      removeEndSlash: function removeEndSlash(str) {\n        return str.replace(rexpEndSlash, '');\n      },\n      // `util.relative` accepts two paths (strings) and returns the second path\n      // relative to the first.\n      //\n      //  - if `path` starts with `relativeTo`, then strip `path` off the\n      //    `relativeTo` part\n      //\n      //         util.relative('abc/def/', 'abc') -> 'def'\n      //\n      //  - if `path` starts with some substring of `relativeTo`, remove\n      //    this substring and add `../` for each remaining segment of\n      //    `relativeTo`.\n      //\n      //         util.relative('abc/def/', 'abc/hij') -> '../def'\n      //\n      relative: function relative(relativeTo, path) {\n        var len = relativeTo.length;\n        if (path.substring(0, len) == relativeTo) {\n          // if the relative path now starts with a path separator\n          // either (/ or \\), remove it\n          /* Note: we're casting a boolean to an int by adding len to it */\n          return path.slice(len + /[\\/\\\\]/.test(path.charAt(len)));\n        }\n\n        var sA = util.removeEndSlash(path).split(ENV.pathSep),\n            sB = util.removeEndSlash(relativeTo).split(ENV.pathSep),\n            i = 0;\n\n        /* Count how many segments match. */\n        while (sA[i] == sB[i]) {\n          ++i;\n        }\n\n        if (i) {\n          /* If at least some segments matched, remove them.  The result is our new path. */\n          path = sA.slice(i).join(ENV.pathSep);\n\n          /* Prepend `../` for each segment remaining in `relativeTo`. */\n          for (var j = sB.length - i; j > 0; --j) {\n            path = '../' + path;\n          }\n        }\n\n        return path;\n      },\n      // `buildPath` accepts an arbitrary number of string arguments to concatenate into a path.\n      //     util.buildPath('a', 'b', 'c/', 'd/') -> 'a/b/c/d/'\n      buildPath: function buildPath() {\n        var pieces = [];\n        for (var i = 0, n = arguments.length; i < n; ++i) {\n          var piece = arguments[i];\n          if (PROTOCOL.test(piece)) {\n            pieces.length = 0;\n          }\n\n          if (piece != '.' && piece != './' && piece) {\n            pieces.push(piece);\n          }\n        }\n\n        return util.resolveRelativePath(pieces.join('/'));\n      },\n      // `resolveRelativePath` removes relative path indicators.  For example:\n      //     util.resolveRelativePath('a/../b') -> b\n      resolveRelativePath: function resolveRelativePath(path) {\n        /* If the path starts with a protocol+host, store it and remove it (add it\n             back later) so we don't accidently modify it. */\n        var protocol = path.match(HOST);\n        if (protocol) {\n          path = protocol[2];\n        }\n\n        /* Remove multiple slashes and trivial dots (`/./ -> /`). */\n        path = path.replace(/\\/+/g, '/').replace(/\\/\\.\\//g, '/');\n\n        /* Loop to collapse instances of `../` in the path by matching a previous\n             path segment.  Essentially, we find substrings of the form `/abc/../`\n             where abc is not `.` or `..` and replace the substrings with `/`.\n             We loop until the string no longer changes since after collapsing\n             possible instances once, we may have created more instances that can\n             be collapsed.\n          */\n        var o;\n        while ((o = path) != (path = path.replace(/(^|\\/)(?!\\.?\\.\\/)([^\\/]+)\\/\\.\\.\\//g, '$1'))) {}\n        /* Don't forget to prepend any protocol we might have removed earlier. */\n        return protocol ? protocol[1] + path.replace(/^\\//, '') : path;\n      },\n      isAbsolutePath: function isAbsolutePath(path) {\n        return (/^\\//.test(path) || PROTOCOL.test(path) || ENV.isWindowsNode && /^[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+/.test(path)\n        );\n      },\n      resolve: function resolve(from, to) {\n        return this.isAbsolutePath(to) ? util.resolveRelativePath(to) : util.buildPath(from, to);\n      },\n      resolveRelativeModule: function resolveRelativeModule(modulePath, directory) {\n        var result = [],\n            parts = modulePath.split('.'),\n            len = parts.length,\n            relative = len > 1 && !parts[0],\n            i = relative ? 0 : -1;\n\n        while (++i < len) {\n          result.push(parts[i] ? parts[i] : '..');\n        }\n        return util.buildPath(relative ? directory : '', result.join('/'));\n      },\n      resolveModulePath: function resolveModulePath(modulePath, directory) {\n        // resolve relative paths\n        if (modulePath.charAt(0) == '.') {\n          return [getModuleDef(util.resolveRelativeModule(modulePath, directory)), getModuleDef(util.resolveRelativeModule(modulePath + '.index', directory))];\n        }\n\n        // resolve absolute paths with respect to jsio packages/\n        var pathSegments = modulePath.split('.');\n        var n = pathSegments.length;\n        for (var i = n; i > 0; --i) {\n          var subpath = pathSegments.slice(0, i).join('.');\n          var value = jsioPath.cache[subpath];\n          var pathString = pathSegments.slice(i).join('/');\n          if (value) {\n            return [getModuleDef(util.buildPath(value, pathString)), getModuleDef(util.buildPath(value, pathString + '/index'))];\n          }\n        }\n\n        var baseMod = pathSegments[0];\n        var pathString = pathSegments.join('/');\n        var defs = [];\n        var paths = jsioPath.get();\n        var len = paths.length;\n        for (var i = 0; i < len; ++i) {\n          var base = paths[i];\n          var path = util.buildPath(base, pathString);\n\n          var moduleDef = getModuleDef(path);\n          moduleDef.setBase(baseMod, base);\n          defs.push(moduleDef);\n\n          var moduleDef = getModuleDef(path + '/index');\n          moduleDef.setBase(baseMod, base);\n          defs.push(moduleDef);\n        }\n        return defs;\n      },\n      splitPath: function splitPath(path, result) {\n        if (!result) {\n          result = {};\n        }\n        var i = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\\\')) + 1;\n        result.directory = path.substring(0, i);\n        result.filename = path.substring(i);\n        return result;\n      }\n    };\n\n    // construct the top-level jsio object\n    var jsio = util.bind(this, _require, null, null, null);\n\n    jsio.__util = util;\n    jsio.__init__ = init;\n\n    var srcCache;\n    jsio.setCache = function (cache) {\n      srcCache = jsio.__srcCache = cache;\n    };\n    jsio.setCache(cloneFrom && cloneFrom.__srcCache || {});\n\n    jsio.setCachedSrc = function (path, src, locked) {\n      if (srcCache[path] && srcCache[path].locked) {\n        console.warn('Cache is ignoring (already present and locked) src ' + path);\n        return;\n      }\n      srcCache[path] = {\n        path: path,\n        src: src,\n        locked: locked\n      };\n    };\n    jsio.getCachedSrc = function (path) {\n      return srcCache[path];\n    };\n\n    jsio.__filename = 'jsio.js';\n    jsio.__cmds = [];\n    jsio.__jsio = jsio;\n    jsio.__require = _require;\n    jsio.__modules = { preprocessors: {} };\n    var jsioPath = {\n      set: function set(path) {\n        this.value = [];\n        (typeof path == 'string' ? [path] : path).map(this.add, this);\n      },\n      get: function get() {\n        return jsioPath.value.slice(0);\n      },\n      add: function add(path) {\n        if (arguments.length == 2) {\n          var from = arguments[0];\n          var to = util.resolve(ENV.getCwd(), arguments[1]);\n          this.cache[from] = to;\n        } else {\n          path = util.resolve(ENV.getCwd(), path);\n          var v = jsioPath.value,\n              len = v.length;\n          for (var i = 0; i < len; ++i) {\n            if (v[i] == path) {\n              return;\n            }\n          }\n          v.push(path);\n        }\n      },\n      remove: function remove(path) {\n        var v = jsioPath.value,\n            len = v.length;\n        for (var i = 0; i < len; ++i) {\n          if (v[i] == path) {\n            v.splice(i, 1);\n          }\n        }\n      },\n      value: [],\n      cache: {}\n    };\n\n    jsio.path = jsioPath;\n    jsio.addPath = util.bind(jsioPath, 'add');\n    jsio.addCmd = util.bind(jsio.__cmds, 'push');\n\n    jsio.setEnv = function (envCtor) {\n      if (!envCtor && cloneFrom) {\n        ENV = new cloneFrom.__env.constructor(util);\n      } else {\n        if (typeof envCtor == 'string') {\n          envCtor = {\n            // node: ENV_node,\n            browser: ENV_browser\n          }[envCtor] || ENV_browser;\n        }\n\n        ENV = new envCtor(util);\n      }\n\n      this.__env = ENV;\n      this.__dir = ENV.getCwd();\n\n      if (!ENV.loadModule) {\n        ENV.loadModule = loadModule;\n      }\n\n      jsio.path.cache['jsio'] = cloneFrom ? cloneFrom.path.cache.jsio : ENV.getPath();\n      if (envCtor == ENV_browser) {\n        jsio.path.set(ENV.getPath());\n      }\n    };\n\n    if (cloneFrom) {\n      jsio.setEnv();\n    } else if (typeof JSIO_ENV_CTOR !== 'undefined') {\n      jsio.setEnv(JSIO_ENV_CTOR);\n    } else if (typeof process !== 'undefined' && process.version) {\n      jsio.setEnv('node');\n    } else if (typeof XMLHttpRequest != 'undefined' || typeof ActiveXObject != 'undefined') {\n      jsio.setEnv('browser');\n    }\n\n    jsio.main = ENV && ENV.main;\n\n    var boundJsio;\n    var localJsio = function localJsio(req) {\n      if (!boundJsio) {\n        boundJsio = util.bind(this, _require, {}, ENV.getPath(), 'jsio.js');\n      }\n\n      return boundJsio(req, {\n        dontExport: true,\n        dontPreprocess: true\n      });\n    };\n\n    /*\n    function ENV_abstract() {\n      this.global = null;\n      this.getCwd = function() {};\n      this.getPath = function() {};\n      this.eval = function(code, path) {};\n      this.fetch = function(path) { return contentsOfPath; };\n      this.log = function(args...) {};\n    }\n    */\n\n    function ENV_browser() {\n      var XHR = window.XMLHttpRequest || function () {\n        return new ActiveXObject('Msxml2.XMLHTTP');\n      },\n          cwd = null,\n          path = null,\n          JOIN = Array.prototype.join;\n\n      this.name = 'browser';\n      this.global = window;\n      this.pathSep = '/';\n\n      if (!this.global.jsio) {\n        this.global.jsio = jsio;\n      }\n\n      if (window.console && console.log) {\n        if (!console.log.apply || /Android|iPhone|iPad|iPod/.test(navigator.userAgent)) {\n          this.log = function () {\n            var args = JOIN.call(arguments, ' ');\n            console.log(args);\n            return args;\n          };\n        } else {\n          this.log = function () {\n            console.log.apply(console, arguments);\n            return JOIN.call(arguments, ' ');\n          };\n        }\n      } else {\n        this.log = function () {\n          return JOIN.call(arguments, ' ');\n        };\n      }\n\n      this.getCwd = function () {\n        if (!cwd) {\n          var loc = window.location,\n              path = loc.pathname;\n          cwd = loc.protocol + '//' + loc.host + path.substring(0, path.lastIndexOf('/') + 1);\n        }\n        return cwd;\n      };\n\n      this.getPath = function () {\n        if (!path) {\n          try {\n            var filename = new RegExp('(.*?)' + jsio.__filename + '(\\\\?.*)?$'),\n                scripts = document.getElementsByTagName('script');\n\n            for (var i = 0, script; script = scripts[i]; ++i) {\n              var result = script.src.match(filename);\n              if (result) {\n                path = result[1];\n                if (/^[A-Za-z]*:\\/\\//.test(path)) {\n                  path = util.relative(this.getCwd(), path);\n                }\n                break;\n              }\n            }\n          } catch (e) {}\n\n          if (!path) {\n            path = '.';\n          }\n        }\n        return path;\n      };\n\n      var debugHost = location.protocol + '//' + location.host + '/';\n      var debugPath = location.pathname;\n      this.debugPath = function (path) {\n        return util.buildPath(debugHost, path[0] != '/' && debugPath, path);\n      };\n\n      // IE6 won't return an anonymous function from eval, so use the function constructor instead\n      var rawEval = typeof eval('(function(){})') == 'undefined' ? function (src, path) {\n        return new Function('return ' + src)();\n      } : function (src, path) {\n        var src = src + '\\n//# sourceURL=' + path;\n        return window.eval(src);\n      };\n\n      // provide an eval with reasonable debugging\n      this.eval = function (code, path, origCode) {\n        try {\n          return rawEval(code, this.debugPath(path));\n        } catch (e) {\n          if (e instanceof SyntaxError) {\n            if (DEBUG && this.checkSyntax) {\n              this.checkSyntax(origCode, path);\n            }\n          }\n          throw e;\n        }\n      };\n\n      this.checkSyntax = function (code, path) {\n        // Note: Disabled to avoid esprima import\n        throw new Error('Syntax checking disabled in browser builds');\n        // try {\n        //   // var syntax = jsio('import jsio.util.syntax', {suppressErrors: true, dontExport: true});\n        //   var syntax = require('./util/syntax');\n        //   syntax(code, path);\n        // } catch (e) {}\n      };\n\n      this.fetch = function (path) {\n        var xhr = new XHR();\n        try {\n          xhr.open('GET', path, false);\n          xhr.send(null);\n        } catch (e) {\n          ENV.log('e:', e);\n          return false;\n        }\n\n        // firefox file://\n        if (xhr.status == 404 || // all browsers, http://\n        xhr.status == -1100 || // safari file://\n        // XXX: We have no way to tell in opera if a file exists and is empty, or is 404\n        // XXX: Use flash?\n        // (!failed && xhr.status == 0 && !xhr.responseText && EXISTS)) // opera\n        false) {\n          return false;\n        }\n\n        return xhr.responseText;\n      };\n    };\n\n    var failedFetch = {};\n\n    function findModule(possibilities) {\n      var src;\n      for (var i = 0, possible; possible = possibilities[i]; ++i) {\n        var path = possible.path,\n            cachedVersion = srcCache[path];\n\n        if (cachedVersion) {\n          // extract a non-absolute dirname from the cache key: absolute paths\n          // built into the cache are made relative during compile time since\n          // absolute paths won't match between host and target device. Use\n          // the cache key as the relative path so future imports can also\n          // successfully lookup paths in the cache.\n          var match = path.match(/^(.*\\/)[^\\\\\\/]+$/);\n          possible.directory = match && match[1] || '';\n          possible.src = cachedVersion.src;\n          possible.pre = true;\n          return possible;\n        }\n\n        /* if (/^\\.\\//.test(path)) {\n          // remove one path segment for each dot from the cwd\n          path = addEndSlash(ENV.getCwd()) + path;\n        }*/\n        src = ENV.fetch(path);\n\n        if (src !== false) {\n          possible.src = src;\n          return possible;\n        } else {\n          failedFetch[path] = true;\n        }\n      }\n\n      return false;\n    }\n\n    function processStack() {\n      return importStack.map(function (item, index) {\n        var stack = index == 0 ? new Error().stack : importStack[index - 1].stack;\n        var i = stack.indexOf(item.path);\n        if (i >= 0) {\n          item.line = ':' + parseInt(stack.substring(i + item.path.length + 1));\n        }\n\n        return index + 1 + ': \"' + item.friendlyPath + '\" ' + item.path + (item.line || '');\n      });\n    }\n\n    // load a module from a file\n    function loadModule(baseLoader, fromDir, fromFile, item, opts) {\n      var modulePath = item.from;\n      var possibilities = util.resolveModulePath(modulePath, fromDir);\n      for (var i = 0, p; p = possibilities[i]; ++i) {\n        var path = possibilities[i].path;\n        if (!opts.reload && path in jsio.__modules) {\n          return possibilities[i];\n        }\n\n        if (path in failedFetch) {\n          possibilities.splice(i--, 1);\n        }\n      }\n\n      if (!possibilities.length) {\n        if (opts.suppressErrors) {\n          return false;\n        }\n        var e = new Error('Could not import `' + item.from + '`' + '\\tImport Stack:\\n' + '\\t\\t' + processStack().join('\\n\\t\\t'));\n        e.jsioLogged = true;\n        e.code = MODULE_NOT_FOUND;\n        throw e;\n      }\n\n      var moduleDef = findModule(possibilities);\n      if (!moduleDef) {\n        if (opts.suppressErrors) {\n          return false;\n        }\n        var paths = [];\n        for (var i = 0, p; p = possibilities[i]; ++i) {\n          paths.push(p.path);\n        }\n        var e = new Error('Could not import `' + modulePath + '`\\n' + '\\tlooked in:\\n' + '\\t\\t' + paths.join('\\n\\t\\t') + '\\n' + '\\tImport Stack:\\n' + '\\t\\t' + processStack().join('\\n\\t\\t'));\n        e.code = MODULE_NOT_FOUND;\n        throw e;\n      }\n\n      // a (potentially) nicer way to refer to a module -- how it was referenced in code when it was first imported\n      moduleDef.friendlyPath = modulePath;\n\n      // cache the base module's path in the path cache so we don't have to\n      // try out all paths the next time we see the same base module.\n      if (moduleDef.baseMod && !(moduleDef.baseMod in jsioPath.cache)) {\n        jsioPath.cache[moduleDef.baseMod] = moduleDef.basePath;\n      }\n\n      // don't apply the standard preprocessors to base.js.  If we're reloading\n      // the source code, always apply them.  We also don't want to run them\n      // if they've been run once -- moduleDef.pre is set to true already\n      // if we're reading the code from the source cache.\n      if (modulePath != 'base' && (opts.reload || !opts.dontPreprocess && !moduleDef.pre)) {\n        moduleDef.pre = true;\n\n        applyPreprocessors(fromDir, moduleDef, ['import', 'inlineSlice'], opts);\n      }\n\n      // any additional preprocessors?\n      if (opts.preprocessors) {\n        applyPreprocessors(fromDir, moduleDef, opts.preprocessors, opts);\n      }\n\n      return moduleDef;\n    }\n\n    function applyPreprocessors(path, moduleDef, names, opts) {\n      for (var i = 0, len = names.length; i < len; ++i) {\n        var p = getPreprocessor(names[i]);\n\n        // if we have a recursive import and p isn't a function, just\n        // skip it (handles the case where a preprocessor imports\n        // other modules).\n        if (p && typeof p == 'function') {\n          p(path, moduleDef, opts);\n        }\n      }\n    }\n\n    function getPreprocessor(name) {\n      var module = jsio.__modules['jsio.preprocessors.' + name];\n      return typeof name == 'function' ? name : module && module.exports || localJsio('import jsio.preprocessors.' + name);\n    }\n\n    function execModuleDef(context, moduleDef) {\n      var src = moduleDef.src;\n      delete moduleDef.src;\n\n      var code = '(function(_){with(_){delete _;return function $$' + moduleDef.friendlyPath.replace(/[\\:\\\\\\/.-]/g, '_') + '(){' + src + '\\n}}})';\n\n      var exports = moduleDef.exports = context.exports;\n\n      var fn = ENV.eval(code, moduleDef.path, src);\n      fn = fn(context);\n\n      fn.call(exports);\n\n      if (exports != context.module.exports) {\n        // Emulate node.js-style ability to reassign module.exports:\n        //   module.exports = ...\n        //\n        // Note that in node.js and js.io, setting `module.exports` invalidates\n        // the context's `exports` alias. See\n        // http://nodejs.org/api/modules.html#modules_exports_alias for more\n        moduleDef.exports = context.module.exports;\n      } else {\n        // js.io-style ability to override exports directly (`exports = `)\n        moduleDef.exports = context.exports;\n      }\n    }\n\n    function resolveImportRequest(context, request, opts) {\n      var cmds = jsio.__cmds,\n          imports = [],\n          result = false;\n\n      for (var i = 0, imp; imp = cmds[i]; ++i) {\n        if (result = imp(context, request, opts, imports)) {\n          break;\n        }\n      }\n\n      if (result !== true) {\n        throw new (typeof SyntaxError != 'undefined' ? SyntaxError : Error)(String(result || 'invalid jsio command: jsio(\\'' + request + '\\')'));\n      }\n\n      return imports;\n    }\n\n    function makeContext(ctx, modulePath, moduleDef, dontAddBase) {\n      if (!ctx) {\n        ctx = {};\n      }\n      if (!ctx.exports) {\n        ctx.exports = {};\n      }\n\n      ctx.jsio = util.bind(this, _require, ctx, moduleDef.directory, moduleDef.filename);\n      ctx.require = function (request, opts) {\n        if (!opts) {\n          opts = {};\n        }\n        opts.dontExport = true;\n        return ctx.jsio(request, opts);\n      };\n\n      ctx.require.main = ENV.main;\n\n      ctx.module = {\n        id: modulePath,\n        exports: ctx.exports\n      };\n      if (!dontAddBase && modulePath != 'jsio.base') {\n        ctx.jsio('from jsio.base import *', { dontPreprocess: true });\n        ctx.logging.__create(modulePath, ctx);\n      }\n\n      // TODO: FIX for \"trailing .\" case\n      ctx.jsio.__jsio = jsio;\n      ctx.jsio.__env = jsio.__env;\n      ctx.jsio.__dir = moduleDef.directory;\n      ctx.jsio.__filename = moduleDef.filename;\n      ctx.jsio.path = jsioPath;\n\n      ctx.__dirname = moduleDef.directory;\n      ctx.__filename = util.buildPath(ctx.__dirname, moduleDef.filename);\n      return ctx;\n    }\n\n    var importStack = [];\n\n    function _require(boundContext, fromDir, fromFile, request, opts) {\n      opts = opts || {};\n      fromDir = fromDir || './';\n      fromFile = fromFile || INITIAL_FILE;\n\n      // require is bound to a module's (or global) context -- we can override this\n      // by using opts.exportInto\n      var exportInto = opts.exportInto || boundContext || ENV.global;\n\n      // parse the import request(s)\n      var imports = resolveImportRequest(exportInto, request, opts),\n          numImports = imports.length,\n          retVal = numImports > 1 ? {} : null;\n\n      // import each requested item\n      for (var i = 0; i < numImports; ++i) {\n        var item = imports[i];\n        var modulePath = item.from;\n        var modules = jsio.__modules;\n        var path;\n        var moduleDef;\n        var err;\n\n        try {\n          moduleDef = jsio.__env.loadModule(loadModule, fromDir, fromFile, item, opts);\n        } catch (e) {\n          err = e;\n        }\n\n        if (moduleDef) {\n          path = moduleDef.path;\n        } else if (moduleDef === false) {\n          return false;\n        }\n\n        if (err) {\n          if (opts.suppressErrors) {\n            return false;\n          }\n          if (!err.jsioLogged) {\n            ENV.log('\\nError loading module:\\n', '    [[', request, ']]\\n', '    requested by:', fromDir + fromFile, '\\n', '    current directory:', jsio.__env.getCwd(), '\\n', '  ' + err.stack.split('\\n').join('\\n  '));\n            err.jsioLogged = true;\n          }\n\n          throw err;\n        }\n\n        if (moduleDef) {\n          importStack.push({\n            friendlyPath: moduleDef.friendlyPath,\n            path: moduleDef.path,\n            stack: new Error().stack\n          });\n        }\n\n        // eval any packages that we don't know about already\n        if (!(path in modules)) {\n          modules[path] = moduleDef;\n        }\n\n        if (!moduleDef.exports) {\n          var newContext = makeContext(opts.context, modulePath, moduleDef, item.dontAddBase);\n          if (item.dontUseExports) {\n            var src = [';(function(){'],\n                k = 1;\n            for (var j in item['import']) {\n              newContext.exports[j] = undefined;\n              src[k++] = 'if(typeof ' + j + '!=\"undefined\"&&exports.' + j + '==undefined)exports.' + j + '=' + j + ';';\n            }\n            src[k] = '})();';\n            moduleDef.src += src.join('');\n          }\n\n          execModuleDef(newContext, moduleDef);\n        }\n\n        importStack.pop();\n\n        var module = moduleDef.exports;\n\n        // return the module if we're only importing one module\n        if (numImports == 1) {\n          retVal = module;\n        }\n\n        if (!opts.dontExport) {\n          // add the module to the current context\n          if (item.as) {\n            // remove trailing/leading dots\n            var as = item.as.match(/^\\.*(.*?)\\.*$/)[1],\n                segments = as.split('.'),\n                kMax = segments.length - 1,\n                c = exportInto;\n\n            // build the object in the context\n            for (var k = 0; k < kMax; ++k) {\n              var segment = segments[k];\n              if (!segment) continue;\n              if (!c[segment]) {\n                c[segment] = {};\n              }\n              c = c[segment];\n            }\n\n            c[segments[kMax]] = module;\n\n            // there can be multiple module imports with this syntax (import foo, bar)\n            if (numImports > 1) {\n              retVal[as] = module;\n            }\n          } else if (item['import']) {\n            // there can only be one module import with this syntax\n            // (from foo import bar), so retVal will already be set here\n            if (item['import']['*']) {\n              for (var k in modules[path].exports) {\n                exportInto[k] = module[k];\n              }\n            } else {\n              for (var k in item['import']) {\n                exportInto[item['import'][k]] = module[k];\n              }\n            }\n          }\n        }\n      }\n\n      return retVal;\n    }\n\n    // DEFINE SYNTAX FOR JSIO('cmd')\n    // from myPackage import myFunc\n    // external myPackage import myFunc\n    jsio.addCmd(function (context, request, opts, imports) {\n      var match = request.match(/^\\s*(from|external)\\s+([\\w.\\-$]+)\\s+(import|grab)\\s+(.*)$/);\n      if (match) {\n        imports.push({\n          from: match[2],\n          dontAddBase: match[1] == 'external',\n          dontUseExports: match[3] == 'grab' || match[1] == 'external',\n          'import': {}\n        });\n\n        match[4].replace(/\\s*([\\w.\\-$*]+)(?:\\s+as\\s+([\\w.\\-$]+))?/g, function (_, item, as) {\n          imports[0]['import'][item] = as || item;\n        });\n        return true;\n      }\n    });\n\n    // import myPackage\n    jsio.addCmd(function (context, request, opts, imports) {\n      var match = request.match(/^\\s*import\\s+(.*)$/);\n      if (match) {\n        match[1].replace(/\\s*([\\w.\\-$]+)(?:\\s+as\\s+([\\w.\\-$]+))?,?/g, function (_, fullPath, as) {\n          imports.push(as ? {\n            from: fullPath,\n            as: as\n          } : {\n            from: fullPath,\n            as: fullPath\n          });\n        });\n        return true;\n      }\n    });\n\n    // CommonJS syntax\n    jsio.addCmd(function (context, request, opts, imports) {\n      //    ./../b -> ..b\n      //    ../../b -> ...b\n      //    ../b -> ..b\n      //    ./b -> .b\n      var match = request.match(/^\\s*[\\w.0-9$\\/\\-:\\\\]+\\s*$/);\n      if (match) {\n        var req = util.resolveRelativePath(match[0]),\n            isRelative = req.charAt(0) == '.';\n\n        req = req.replace(/\\.\\.\\//g, '.').replace(/\\.\\//g, '').replace(/\\/+$/g, '');\n\n        if (ENV.pathSep === '\\\\' && req.match(/^[a-zA-Z]:.*/)) {} else {\n          // any remaining slashes are path separators\n          req = req.replace(/\\//g, '.');\n        }\n\n        imports[0] = {\n          from: (isRelative ? '.' : '') + req,\n          original: request\n        };\n        return true;\n      }\n    });\n\n    jsio.install = function () {\n      var base = __webpack_require__(/*! ./base */ 0);\n      base.GLOBAL['logger'] = base.logging.get('jsiocore');\n    };\n\n    jsio.eval = function (src, path) {\n      path = ENV.getCwd() || '/';\n      var moduleDef = new ModuleDef(path);\n      moduleDef.src = src;\n      applyPreprocessors(path, moduleDef, ['import', 'cls'], {});\n      execModuleDef(ENV.global, moduleDef);\n    };\n\n    jsio.clone = util.bind(null, init, jsio);\n\n    // in node, defines jsio as a module that can be imported\n    var moduleInfo = util.resolveModulePath('jsio')[0];\n    if (moduleInfo) {\n      jsio.__modules[moduleInfo.path] = new ModuleDef(moduleInfo.path);\n      jsio.__modules[moduleInfo.path].exports = jsio;\n    }\n\n    return jsio;\n  }\n\n  var J = init(null, {});\n  if (true) {\n    module.exports = J;\n  } else {\n    jsio = J;\n  }\n})();\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../node_modules/node-libs-browser/node_modules/process/browser.js */ 6)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9mcm9udGVuZC9qc2lvL2pzaW8td2ViLmpzPzQxNjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IitDQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGlCQUFpQjtBQUN0RSx5REFBeUQsMkJBQTJCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxtR0FBbUcsRUFBRTtBQUNyRztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHVCQUF1QjtBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxxQkFBcUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCx1Q0FBdUM7QUFDckc7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsNkJBQTZCO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUErQixRQUFRLFNBQVMsK0VBQStFLGdCQUFnQjs7QUFFL0k7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx1QkFBdUI7QUFDcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLHFIQUFxSDtBQUNySDtBQUNBLHVCQUF1QixJQUFJO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDLEkiLCJmaWxlIjoiMzguanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIENvcHlyaWdodCAoYykgMjAxMFxuLy8gTWljaGFlbCBDYXJ0ZXIgKGNhcnRlcm1pY2hhZWxAZ21haWwuY29tKVxuLy8gTWFydGluIEh1bnQgKG1naHVudEBnbWFpbC5jb20pXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cbi8vIEluaXRpYWxpemF0aW9uIG9mIGpzLmlvIG9jY3VycyBpbiBhIGNsb3N1cmUsIHByZXZlbnRpbmcgbG9jYWwgdmFyaWFibGVzXG4vLyBmcm9tIGVudGVyaW5nIHRoZSBnbG9iYWwgc2NvcGUuICBEdXJpbmcgZXhlY3V0aW9uLCB0aGUgbWV0aG9kIGBqc2lvYCBpc1xuLy8gYWRkZWQgdG8gdGhlIGdsb2JhbCBzY29wZS5cblxuO1xuKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gaW5pdChjbG9uZUZyb20pIHtcbiAgICAvLyBXZSBleHBlY3QgdGhpcyBjb2RlIHRvIGJlIG1pbmlmaWVkIGJlZm9yZSBwcm9kdWN0aW9uIHVzZSwgc28gd2UgbWF5XG4gICAgLy8gd3JpdGUgY29kZSBzbGlnaHRseSBtb3JlIHZlcmJvc2VseSB0aGFuIHdlIG90aGVyd2lzZSB3b3VsZC5cbiAgICB2YXIgSU5JVElBTF9GSUxFID0gJzxpbml0aWFsIGZpbGU+JztcbiAgICB2YXIgTU9EVUxFX05PVF9GT1VORCA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblxuICAgIC8vIFNob3VsZCB3ZSBwYXJzZSBzeW50YXggZXJyb3JzIGluIHRoZSBicm93c2VyP1xuICAgIHZhciBERUJVRyA9IHRydWU7XG5cbiAgICAvLyBTdG9yZSBhIHJlZmVyZW5jZSB0byB0aGUgc2xpY2UgZnVuY3Rpb24gZm9yIGNvbnZlcnRpbmcgb2JqZWN0cyBvZlxuICAgIC8vIHR5cGUgYXJndW1lbnRzIHRvIHR5cGUgYXJyYXkuXG4gICAgdmFyIFNMSUNFID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gICAgLy8ganMuaW8gc3VwcG9ydHMgbXVsdGlwbGUgSmF2YVNjcmlwdCBlbnZpcm9ubWVudHMgc3VjaCBhcyBub2RlLmpzIGFuZFxuICAgIC8vIG1vc3Qgd2ViIGJyb3dzZXJzIChJRSwgRmlyZWZveCwgV2ViS2l0KS4gIFRoZSBFTlYgb2JqZWN0IHdyYXBzXG4gICAgLy8gYW55IHV0aWxpdHkgZnVuY3Rpb25zIHRoYXQgY29udGFpbiBlbnZpcm9ubWVudC1zcGVjaWZpYyBjb2RlIChlLmcuXG4gICAgLy8gcmVhZGluZyBhIGZpbGUgdXNpbmcgbm9kZSdzIGBmc2AgbGlicmFyeSBvciBhIGJyb3dzZXInc1xuICAgIC8vIGBYTUxIdHRwUmVxdWVzdGApLiAgUnVubmluZyBqcy5pbyBpbiBvdGhlciBKYXZhU2NyaXB0IGVudmlyb25tZW50c1xuICAgIC8vIGlzIGFzIGVhc3kgYXMgaW1wbGVtZW50aW5nIGFuIGVudmlyb25tZW50IG9iamVjdCB0aGF0IGNvbmZvcm1zIHRvXG4gICAgLy8gdGhlIGFic3RyYWN0IGludGVyZmFjZSBmb3IgYW4gZW52aXJvbm1lbnQgKHByb3ZpZGVkIGJlbG93KSBhbmRcbiAgICAvLyBjYWxsaW5nIGBqc2lvLnNldEVudigpYC5cbiAgICB2YXIgRU5WO1xuXG4gICAgLy8gQ2hlY2tzIGlmIHRoZSBsYXN0IGNoYXJhY3RlciBpbiBhIHN0cmluZyBpcyBgL2AuXG4gICAgdmFyIHJleHBFbmRTbGFzaCA9IC8oXFwvfFxcXFwpJC87XG5cbiAgICBmdW5jdGlvbiBnZXRNb2R1bGVEZWYocGF0aCkge1xuICAgICAgcGF0aCArPSAnLmpzJztcbiAgICAgIHJldHVybiBqc2lvLl9fbW9kdWxlc1twYXRoXSB8fCBuZXcgTW9kdWxlRGVmKHBhdGgpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgbWV0YWRhdGEgYWJvdXQgYSBtb2R1bGUuXG4gICAgZnVuY3Rpb24gTW9kdWxlRGVmKHBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICB0aGlzLmZyaWVuZGx5UGF0aCA9IHBhdGg7XG5cbiAgICAgIHV0aWwuc3BsaXRQYXRoKHBhdGgsIHRoaXMpO1xuICAgICAgdGhpcy5kaXJlY3RvcnkgPSB1dGlsLnJlc29sdmUoRU5WLmdldEN3ZCgpLCB0aGlzLmRpcmVjdG9yeSk7XG4gICAgfVxuXG4gICAgTW9kdWxlRGVmLnByb3RvdHlwZS5zZXRCYXNlID0gZnVuY3Rpb24gKGJhc2VNb2QsIGJhc2VQYXRoKSB7XG4gICAgICB0aGlzLmJhc2VNb2QgPSBiYXNlTW9kO1xuICAgICAgdGhpcy5iYXNlUGF0aCA9IGJhc2VQYXRoICsgJy8nICsgYmFzZU1vZDtcbiAgICB9O1xuXG4gICAgdmFyIEhPU1QgPSAvXihbYS16XVthLXowLTkrXFwtXFwuXSo6XFwvXFwvLio/XFwvKSguKikkLztcbiAgICB2YXIgUFJPVE9DT0wgPSAvXlthLXpdW2EtejAtOStcXC1cXC5dKjovO1xuXG4gICAgLy8gVXRpbGl0eSBmdW5jdGlvbnNcbiAgICB2YXIgdXRpbCA9IHtcbiAgICAgIC8vIGB1dGlsLmJpbmRgIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgd2lsbCBleGVjdXRlXG4gICAgICAvLyB0aGUgbWV0aG9kIHBhc3NlZCBpbiB3aXRoIHRoZSBwcm92aWRlZCBjb250ZXh0IGFuZCBhbnkgYWRkaXRpb25hbFxuICAgICAgLy8gYXJndW1lbnRzIHBhc3NlZCB0byBgdXRpbC5iaW5kYC5cbiAgICAgIC8vICAgICAgIHV0aWwuYmluZChvYmosICdmJywgYSkgLT4gZnVuY3Rpb24oKSB7IHJldHVybiBvYmouZihhKTsgfVxuICAgICAgLy8gICAgICAgdXRpbC5iaW5kKG9iaiwgZywgYSwgYiwgYykgLT4gZnVuY3Rpb24oKSB7IHJldHVybiBnLmNhbGwoZywgYSwgYiwgYyk7IH1cbiAgICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoY29udGV4dCwgbWV0aG9kKVxuICAgICAgLyosIGFyZ3MuLi4gKi9cbiAgICAgIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBTTElDRS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWV0aG9kID0gdHlwZW9mIG1ldGhvZCA9PSAnc3RyaW5nJyA/IGNvbnRleHRbbWV0aG9kXSA6IG1ldGhvZDtcbiAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KGNvbnRleHQsIGFyZ3MuY29uY2F0KFNMSUNFLmNhbGwoYXJndW1lbnRzLCAwKSkpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIC8vIGB1dGlsLmFkZEVuZFNsYXNoYCBhY2NlcHRzIGEgc3RyaW5nLiAgVGhhdCBzdHJpbmcgaXMgcmV0dXJuZWQgd2l0aCBhIGAvYFxuICAgICAgLy8gYXBwZW5kZWQgaWYgdGhlIHN0cmluZyBkaWQgbm90IGFscmVhZHkgZW5kIGluIGEgYC9gLlxuICAgICAgYWRkRW5kU2xhc2g6IGZ1bmN0aW9uIGFkZEVuZFNsYXNoKHN0cikge1xuICAgICAgICByZXR1cm4gcmV4cEVuZFNsYXNoLnRlc3Qoc3RyKSA/IHN0ciA6IHN0ciArICcvJztcbiAgICAgIH0sXG4gICAgICAvLyBgdXRpbC5yZW1vdmVFbmRTbGFzaGAgYWNjZXB0cyBhIHN0cmluZy4gIEl0IHJlbW92ZXMgYSB0cmFpbGluZyBgL2AgaWZcbiAgICAgIC8vIG9uZSBpcyBmb3VuZC5cbiAgICAgIHJlbW92ZUVuZFNsYXNoOiBmdW5jdGlvbiByZW1vdmVFbmRTbGFzaChzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKHJleHBFbmRTbGFzaCwgJycpO1xuICAgICAgfSxcbiAgICAgIC8vIGB1dGlsLnJlbGF0aXZlYCBhY2NlcHRzIHR3byBwYXRocyAoc3RyaW5ncykgYW5kIHJldHVybnMgdGhlIHNlY29uZCBwYXRoXG4gICAgICAvLyByZWxhdGl2ZSB0byB0aGUgZmlyc3QuXG4gICAgICAvL1xuICAgICAgLy8gIC0gaWYgYHBhdGhgIHN0YXJ0cyB3aXRoIGByZWxhdGl2ZVRvYCwgdGhlbiBzdHJpcCBgcGF0aGAgb2ZmIHRoZVxuICAgICAgLy8gICAgYHJlbGF0aXZlVG9gIHBhcnRcbiAgICAgIC8vXG4gICAgICAvLyAgICAgICAgIHV0aWwucmVsYXRpdmUoJ2FiYy9kZWYvJywgJ2FiYycpIC0+ICdkZWYnXG4gICAgICAvL1xuICAgICAgLy8gIC0gaWYgYHBhdGhgIHN0YXJ0cyB3aXRoIHNvbWUgc3Vic3RyaW5nIG9mIGByZWxhdGl2ZVRvYCwgcmVtb3ZlXG4gICAgICAvLyAgICB0aGlzIHN1YnN0cmluZyBhbmQgYWRkIGAuLi9gIGZvciBlYWNoIHJlbWFpbmluZyBzZWdtZW50IG9mXG4gICAgICAvLyAgICBgcmVsYXRpdmVUb2AuXG4gICAgICAvL1xuICAgICAgLy8gICAgICAgICB1dGlsLnJlbGF0aXZlKCdhYmMvZGVmLycsICdhYmMvaGlqJykgLT4gJy4uL2RlZidcbiAgICAgIC8vXG4gICAgICByZWxhdGl2ZTogZnVuY3Rpb24gcmVsYXRpdmUocmVsYXRpdmVUbywgcGF0aCkge1xuICAgICAgICB2YXIgbGVuID0gcmVsYXRpdmVUby5sZW5ndGg7XG4gICAgICAgIGlmIChwYXRoLnN1YnN0cmluZygwLCBsZW4pID09IHJlbGF0aXZlVG8pIHtcbiAgICAgICAgICAvLyBpZiB0aGUgcmVsYXRpdmUgcGF0aCBub3cgc3RhcnRzIHdpdGggYSBwYXRoIHNlcGFyYXRvclxuICAgICAgICAgIC8vIGVpdGhlciAoLyBvciBcXCksIHJlbW92ZSBpdFxuICAgICAgICAgIC8qIE5vdGU6IHdlJ3JlIGNhc3RpbmcgYSBib29sZWFuIHRvIGFuIGludCBieSBhZGRpbmcgbGVuIHRvIGl0ICovXG4gICAgICAgICAgcmV0dXJuIHBhdGguc2xpY2UobGVuICsgL1tcXC9cXFxcXS8udGVzdChwYXRoLmNoYXJBdChsZW4pKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc0EgPSB1dGlsLnJlbW92ZUVuZFNsYXNoKHBhdGgpLnNwbGl0KEVOVi5wYXRoU2VwKSxcbiAgICAgICAgICAgIHNCID0gdXRpbC5yZW1vdmVFbmRTbGFzaChyZWxhdGl2ZVRvKS5zcGxpdChFTlYucGF0aFNlcCksXG4gICAgICAgICAgICBpID0gMDtcblxuICAgICAgICAvKiBDb3VudCBob3cgbWFueSBzZWdtZW50cyBtYXRjaC4gKi9cbiAgICAgICAgd2hpbGUgKHNBW2ldID09IHNCW2ldKSB7XG4gICAgICAgICAgKytpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAvKiBJZiBhdCBsZWFzdCBzb21lIHNlZ21lbnRzIG1hdGNoZWQsIHJlbW92ZSB0aGVtLiAgVGhlIHJlc3VsdCBpcyBvdXIgbmV3IHBhdGguICovXG4gICAgICAgICAgcGF0aCA9IHNBLnNsaWNlKGkpLmpvaW4oRU5WLnBhdGhTZXApO1xuXG4gICAgICAgICAgLyogUHJlcGVuZCBgLi4vYCBmb3IgZWFjaCBzZWdtZW50IHJlbWFpbmluZyBpbiBgcmVsYXRpdmVUb2AuICovXG4gICAgICAgICAgZm9yICh2YXIgaiA9IHNCLmxlbmd0aCAtIGk7IGogPiAwOyAtLWopIHtcbiAgICAgICAgICAgIHBhdGggPSAnLi4vJyArIHBhdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9LFxuICAgICAgLy8gYGJ1aWxkUGF0aGAgYWNjZXB0cyBhbiBhcmJpdHJhcnkgbnVtYmVyIG9mIHN0cmluZyBhcmd1bWVudHMgdG8gY29uY2F0ZW5hdGUgaW50byBhIHBhdGguXG4gICAgICAvLyAgICAgdXRpbC5idWlsZFBhdGgoJ2EnLCAnYicsICdjLycsICdkLycpIC0+ICdhL2IvYy9kLydcbiAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gYnVpbGRQYXRoKCkge1xuICAgICAgICB2YXIgcGllY2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIHZhciBwaWVjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICBpZiAoUFJPVE9DT0wudGVzdChwaWVjZSkpIHtcbiAgICAgICAgICAgIHBpZWNlcy5sZW5ndGggPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwaWVjZSAhPSAnLicgJiYgcGllY2UgIT0gJy4vJyAmJiBwaWVjZSkge1xuICAgICAgICAgICAgcGllY2VzLnB1c2gocGllY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1dGlsLnJlc29sdmVSZWxhdGl2ZVBhdGgocGllY2VzLmpvaW4oJy8nKSk7XG4gICAgICB9LFxuICAgICAgLy8gYHJlc29sdmVSZWxhdGl2ZVBhdGhgIHJlbW92ZXMgcmVsYXRpdmUgcGF0aCBpbmRpY2F0b3JzLiAgRm9yIGV4YW1wbGU6XG4gICAgICAvLyAgICAgdXRpbC5yZXNvbHZlUmVsYXRpdmVQYXRoKCdhLy4uL2InKSAtPiBiXG4gICAgICByZXNvbHZlUmVsYXRpdmVQYXRoOiBmdW5jdGlvbiByZXNvbHZlUmVsYXRpdmVQYXRoKHBhdGgpIHtcbiAgICAgICAgLyogSWYgdGhlIHBhdGggc3RhcnRzIHdpdGggYSBwcm90b2NvbCtob3N0LCBzdG9yZSBpdCBhbmQgcmVtb3ZlIGl0IChhZGQgaXRcbiAgICAgICAgICAgICBiYWNrIGxhdGVyKSBzbyB3ZSBkb24ndCBhY2NpZGVudGx5IG1vZGlmeSBpdC4gKi9cbiAgICAgICAgdmFyIHByb3RvY29sID0gcGF0aC5tYXRjaChIT1NUKTtcbiAgICAgICAgaWYgKHByb3RvY29sKSB7XG4gICAgICAgICAgcGF0aCA9IHByb3RvY29sWzJdO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogUmVtb3ZlIG11bHRpcGxlIHNsYXNoZXMgYW5kIHRyaXZpYWwgZG90cyAoYC8uLyAtPiAvYCkuICovXG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcLysvZywgJy8nKS5yZXBsYWNlKC9cXC9cXC5cXC8vZywgJy8nKTtcblxuICAgICAgICAvKiBMb29wIHRvIGNvbGxhcHNlIGluc3RhbmNlcyBvZiBgLi4vYCBpbiB0aGUgcGF0aCBieSBtYXRjaGluZyBhIHByZXZpb3VzXG4gICAgICAgICAgICAgcGF0aCBzZWdtZW50LiAgRXNzZW50aWFsbHksIHdlIGZpbmQgc3Vic3RyaW5ncyBvZiB0aGUgZm9ybSBgL2FiYy8uLi9gXG4gICAgICAgICAgICAgd2hlcmUgYWJjIGlzIG5vdCBgLmAgb3IgYC4uYCBhbmQgcmVwbGFjZSB0aGUgc3Vic3RyaW5ncyB3aXRoIGAvYC5cbiAgICAgICAgICAgICBXZSBsb29wIHVudGlsIHRoZSBzdHJpbmcgbm8gbG9uZ2VyIGNoYW5nZXMgc2luY2UgYWZ0ZXIgY29sbGFwc2luZ1xuICAgICAgICAgICAgIHBvc3NpYmxlIGluc3RhbmNlcyBvbmNlLCB3ZSBtYXkgaGF2ZSBjcmVhdGVkIG1vcmUgaW5zdGFuY2VzIHRoYXQgY2FuXG4gICAgICAgICAgICAgYmUgY29sbGFwc2VkLlxuICAgICAgICAgICovXG4gICAgICAgIHZhciBvO1xuICAgICAgICB3aGlsZSAoKG8gPSBwYXRoKSAhPSAocGF0aCA9IHBhdGgucmVwbGFjZSgvKF58XFwvKSg/IVxcLj9cXC5cXC8pKFteXFwvXSspXFwvXFwuXFwuXFwvL2csICckMScpKSkge31cbiAgICAgICAgLyogRG9uJ3QgZm9yZ2V0IHRvIHByZXBlbmQgYW55IHByb3RvY29sIHdlIG1pZ2h0IGhhdmUgcmVtb3ZlZCBlYXJsaWVyLiAqL1xuICAgICAgICByZXR1cm4gcHJvdG9jb2wgPyBwcm90b2NvbFsxXSArIHBhdGgucmVwbGFjZSgvXlxcLy8sICcnKSA6IHBhdGg7XG4gICAgICB9LFxuICAgICAgaXNBYnNvbHV0ZVBhdGg6IGZ1bmN0aW9uIGlzQWJzb2x1dGVQYXRoKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuICgvXlxcLy8udGVzdChwYXRoKSB8fCBQUk9UT0NPTC50ZXN0KHBhdGgpIHx8IEVOVi5pc1dpbmRvd3NOb2RlICYmIC9eW2EtekEtWl06fFtcXFxcXFwvXXsyfVteXFxcXFxcL10rW1xcXFxcXC9dK1teXFxcXFxcL10rLy50ZXN0KHBhdGgpXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZShmcm9tLCB0bykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0Fic29sdXRlUGF0aCh0bykgPyB1dGlsLnJlc29sdmVSZWxhdGl2ZVBhdGgodG8pIDogdXRpbC5idWlsZFBhdGgoZnJvbSwgdG8pO1xuICAgICAgfSxcbiAgICAgIHJlc29sdmVSZWxhdGl2ZU1vZHVsZTogZnVuY3Rpb24gcmVzb2x2ZVJlbGF0aXZlTW9kdWxlKG1vZHVsZVBhdGgsIGRpcmVjdG9yeSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICBwYXJ0cyA9IG1vZHVsZVBhdGguc3BsaXQoJy4nKSxcbiAgICAgICAgICAgIGxlbiA9IHBhcnRzLmxlbmd0aCxcbiAgICAgICAgICAgIHJlbGF0aXZlID0gbGVuID4gMSAmJiAhcGFydHNbMF0sXG4gICAgICAgICAgICBpID0gcmVsYXRpdmUgPyAwIDogLTE7XG5cbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnRzW2ldID8gcGFydHNbaV0gOiAnLi4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbC5idWlsZFBhdGgocmVsYXRpdmUgPyBkaXJlY3RvcnkgOiAnJywgcmVzdWx0LmpvaW4oJy8nKSk7XG4gICAgICB9LFxuICAgICAgcmVzb2x2ZU1vZHVsZVBhdGg6IGZ1bmN0aW9uIHJlc29sdmVNb2R1bGVQYXRoKG1vZHVsZVBhdGgsIGRpcmVjdG9yeSkge1xuICAgICAgICAvLyByZXNvbHZlIHJlbGF0aXZlIHBhdGhzXG4gICAgICAgIGlmIChtb2R1bGVQYXRoLmNoYXJBdCgwKSA9PSAnLicpIHtcbiAgICAgICAgICByZXR1cm4gW2dldE1vZHVsZURlZih1dGlsLnJlc29sdmVSZWxhdGl2ZU1vZHVsZShtb2R1bGVQYXRoLCBkaXJlY3RvcnkpKSwgZ2V0TW9kdWxlRGVmKHV0aWwucmVzb2x2ZVJlbGF0aXZlTW9kdWxlKG1vZHVsZVBhdGggKyAnLmluZGV4JywgZGlyZWN0b3J5KSldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzb2x2ZSBhYnNvbHV0ZSBwYXRocyB3aXRoIHJlc3BlY3QgdG8ganNpbyBwYWNrYWdlcy9cbiAgICAgICAgdmFyIHBhdGhTZWdtZW50cyA9IG1vZHVsZVBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIG4gPSBwYXRoU2VnbWVudHMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gbjsgaSA+IDA7IC0taSkge1xuICAgICAgICAgIHZhciBzdWJwYXRoID0gcGF0aFNlZ21lbnRzLnNsaWNlKDAsIGkpLmpvaW4oJy4nKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBqc2lvUGF0aC5jYWNoZVtzdWJwYXRoXTtcbiAgICAgICAgICB2YXIgcGF0aFN0cmluZyA9IHBhdGhTZWdtZW50cy5zbGljZShpKS5qb2luKCcvJyk7XG4gICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gW2dldE1vZHVsZURlZih1dGlsLmJ1aWxkUGF0aCh2YWx1ZSwgcGF0aFN0cmluZykpLCBnZXRNb2R1bGVEZWYodXRpbC5idWlsZFBhdGgodmFsdWUsIHBhdGhTdHJpbmcgKyAnL2luZGV4JykpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmFzZU1vZCA9IHBhdGhTZWdtZW50c1swXTtcbiAgICAgICAgdmFyIHBhdGhTdHJpbmcgPSBwYXRoU2VnbWVudHMuam9pbignLycpO1xuICAgICAgICB2YXIgZGVmcyA9IFtdO1xuICAgICAgICB2YXIgcGF0aHMgPSBqc2lvUGF0aC5nZXQoKTtcbiAgICAgICAgdmFyIGxlbiA9IHBhdGhzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIHZhciBiYXNlID0gcGF0aHNbaV07XG4gICAgICAgICAgdmFyIHBhdGggPSB1dGlsLmJ1aWxkUGF0aChiYXNlLCBwYXRoU3RyaW5nKTtcblxuICAgICAgICAgIHZhciBtb2R1bGVEZWYgPSBnZXRNb2R1bGVEZWYocGF0aCk7XG4gICAgICAgICAgbW9kdWxlRGVmLnNldEJhc2UoYmFzZU1vZCwgYmFzZSk7XG4gICAgICAgICAgZGVmcy5wdXNoKG1vZHVsZURlZik7XG5cbiAgICAgICAgICB2YXIgbW9kdWxlRGVmID0gZ2V0TW9kdWxlRGVmKHBhdGggKyAnL2luZGV4Jyk7XG4gICAgICAgICAgbW9kdWxlRGVmLnNldEJhc2UoYmFzZU1vZCwgYmFzZSk7XG4gICAgICAgICAgZGVmcy5wdXNoKG1vZHVsZURlZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZnM7XG4gICAgICB9LFxuICAgICAgc3BsaXRQYXRoOiBmdW5jdGlvbiBzcGxpdFBhdGgocGF0aCwgcmVzdWx0KSB7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSBNYXRoLm1heChwYXRoLmxhc3RJbmRleE9mKCcvJyksIHBhdGgubGFzdEluZGV4T2YoJ1xcXFwnKSkgKyAxO1xuICAgICAgICByZXN1bHQuZGlyZWN0b3J5ID0gcGF0aC5zdWJzdHJpbmcoMCwgaSk7XG4gICAgICAgIHJlc3VsdC5maWxlbmFtZSA9IHBhdGguc3Vic3RyaW5nKGkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBjb25zdHJ1Y3QgdGhlIHRvcC1sZXZlbCBqc2lvIG9iamVjdFxuICAgIHZhciBqc2lvID0gdXRpbC5iaW5kKHRoaXMsIF9yZXF1aXJlLCBudWxsLCBudWxsLCBudWxsKTtcblxuICAgIGpzaW8uX191dGlsID0gdXRpbDtcbiAgICBqc2lvLl9faW5pdF9fID0gaW5pdDtcblxuICAgIHZhciBzcmNDYWNoZTtcbiAgICBqc2lvLnNldENhY2hlID0gZnVuY3Rpb24gKGNhY2hlKSB7XG4gICAgICBzcmNDYWNoZSA9IGpzaW8uX19zcmNDYWNoZSA9IGNhY2hlO1xuICAgIH07XG4gICAganNpby5zZXRDYWNoZShjbG9uZUZyb20gJiYgY2xvbmVGcm9tLl9fc3JjQ2FjaGUgfHwge30pO1xuXG4gICAganNpby5zZXRDYWNoZWRTcmMgPSBmdW5jdGlvbiAocGF0aCwgc3JjLCBsb2NrZWQpIHtcbiAgICAgIGlmIChzcmNDYWNoZVtwYXRoXSAmJiBzcmNDYWNoZVtwYXRoXS5sb2NrZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdDYWNoZSBpcyBpZ25vcmluZyAoYWxyZWFkeSBwcmVzZW50IGFuZCBsb2NrZWQpIHNyYyAnICsgcGF0aCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNyY0NhY2hlW3BhdGhdID0ge1xuICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICBzcmM6IHNyYyxcbiAgICAgICAgbG9ja2VkOiBsb2NrZWRcbiAgICAgIH07XG4gICAgfTtcbiAgICBqc2lvLmdldENhY2hlZFNyYyA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICByZXR1cm4gc3JjQ2FjaGVbcGF0aF07XG4gICAgfTtcblxuICAgIGpzaW8uX19maWxlbmFtZSA9ICdqc2lvLmpzJztcbiAgICBqc2lvLl9fY21kcyA9IFtdO1xuICAgIGpzaW8uX19qc2lvID0ganNpbztcbiAgICBqc2lvLl9fcmVxdWlyZSA9IF9yZXF1aXJlO1xuICAgIGpzaW8uX19tb2R1bGVzID0geyBwcmVwcm9jZXNzb3JzOiB7fSB9O1xuICAgIHZhciBqc2lvUGF0aCA9IHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHBhdGgpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xuICAgICAgICAodHlwZW9mIHBhdGggPT0gJ3N0cmluZycgPyBbcGF0aF0gOiBwYXRoKS5tYXAodGhpcy5hZGQsIHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4ganNpb1BhdGgudmFsdWUuc2xpY2UoMCk7XG4gICAgICB9LFxuICAgICAgYWRkOiBmdW5jdGlvbiBhZGQocGF0aCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgdmFyIGZyb20gPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgdmFyIHRvID0gdXRpbC5yZXNvbHZlKEVOVi5nZXRDd2QoKSwgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgICB0aGlzLmNhY2hlW2Zyb21dID0gdG87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aCA9IHV0aWwucmVzb2x2ZShFTlYuZ2V0Q3dkKCksIHBhdGgpO1xuICAgICAgICAgIHZhciB2ID0ganNpb1BhdGgudmFsdWUsXG4gICAgICAgICAgICAgIGxlbiA9IHYubGVuZ3RoO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh2W2ldID09IHBhdGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2LnB1c2gocGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShwYXRoKSB7XG4gICAgICAgIHZhciB2ID0ganNpb1BhdGgudmFsdWUsXG4gICAgICAgICAgICBsZW4gPSB2Lmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIGlmICh2W2ldID09IHBhdGgpIHtcbiAgICAgICAgICAgIHYuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZhbHVlOiBbXSxcbiAgICAgIGNhY2hlOiB7fVxuICAgIH07XG5cbiAgICBqc2lvLnBhdGggPSBqc2lvUGF0aDtcbiAgICBqc2lvLmFkZFBhdGggPSB1dGlsLmJpbmQoanNpb1BhdGgsICdhZGQnKTtcbiAgICBqc2lvLmFkZENtZCA9IHV0aWwuYmluZChqc2lvLl9fY21kcywgJ3B1c2gnKTtcblxuICAgIGpzaW8uc2V0RW52ID0gZnVuY3Rpb24gKGVudkN0b3IpIHtcbiAgICAgIGlmICghZW52Q3RvciAmJiBjbG9uZUZyb20pIHtcbiAgICAgICAgRU5WID0gbmV3IGNsb25lRnJvbS5fX2Vudi5jb25zdHJ1Y3Rvcih1dGlsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW52Q3RvciA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIGVudkN0b3IgPSB7XG4gICAgICAgICAgICAvLyBub2RlOiBFTlZfbm9kZSxcbiAgICAgICAgICAgIGJyb3dzZXI6IEVOVl9icm93c2VyXG4gICAgICAgICAgfVtlbnZDdG9yXSB8fCBFTlZfYnJvd3NlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIEVOViA9IG5ldyBlbnZDdG9yKHV0aWwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9fZW52ID0gRU5WO1xuICAgICAgdGhpcy5fX2RpciA9IEVOVi5nZXRDd2QoKTtcblxuICAgICAgaWYgKCFFTlYubG9hZE1vZHVsZSkge1xuICAgICAgICBFTlYubG9hZE1vZHVsZSA9IGxvYWRNb2R1bGU7XG4gICAgICB9XG5cbiAgICAgIGpzaW8ucGF0aC5jYWNoZVsnanNpbyddID0gY2xvbmVGcm9tID8gY2xvbmVGcm9tLnBhdGguY2FjaGUuanNpbyA6IEVOVi5nZXRQYXRoKCk7XG4gICAgICBpZiAoZW52Q3RvciA9PSBFTlZfYnJvd3Nlcikge1xuICAgICAgICBqc2lvLnBhdGguc2V0KEVOVi5nZXRQYXRoKCkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoY2xvbmVGcm9tKSB7XG4gICAgICBqc2lvLnNldEVudigpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIEpTSU9fRU5WX0NUT1IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBqc2lvLnNldEVudihKU0lPX0VOVl9DVE9SKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb24pIHtcbiAgICAgIGpzaW8uc2V0RW52KCdub2RlJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIEFjdGl2ZVhPYmplY3QgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGpzaW8uc2V0RW52KCdicm93c2VyJyk7XG4gICAgfVxuXG4gICAganNpby5tYWluID0gRU5WICYmIEVOVi5tYWluO1xuXG4gICAgdmFyIGJvdW5kSnNpbztcbiAgICB2YXIgbG9jYWxKc2lvID0gZnVuY3Rpb24gbG9jYWxKc2lvKHJlcSkge1xuICAgICAgaWYgKCFib3VuZEpzaW8pIHtcbiAgICAgICAgYm91bmRKc2lvID0gdXRpbC5iaW5kKHRoaXMsIF9yZXF1aXJlLCB7fSwgRU5WLmdldFBhdGgoKSwgJ2pzaW8uanMnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJvdW5kSnNpbyhyZXEsIHtcbiAgICAgICAgZG9udEV4cG9ydDogdHJ1ZSxcbiAgICAgICAgZG9udFByZXByb2Nlc3M6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKlxuICAgIGZ1bmN0aW9uIEVOVl9hYnN0cmFjdCgpIHtcbiAgICAgIHRoaXMuZ2xvYmFsID0gbnVsbDtcbiAgICAgIHRoaXMuZ2V0Q3dkID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgIHRoaXMuZ2V0UGF0aCA9IGZ1bmN0aW9uKCkge307XG4gICAgICB0aGlzLmV2YWwgPSBmdW5jdGlvbihjb2RlLCBwYXRoKSB7fTtcbiAgICAgIHRoaXMuZmV0Y2ggPSBmdW5jdGlvbihwYXRoKSB7IHJldHVybiBjb250ZW50c09mUGF0aDsgfTtcbiAgICAgIHRoaXMubG9nID0gZnVuY3Rpb24oYXJncy4uLikge307XG4gICAgfVxuICAgICovXG5cbiAgICBmdW5jdGlvbiBFTlZfYnJvd3NlcigpIHtcbiAgICAgIHZhciBYSFIgPSB3aW5kb3cuWE1MSHR0cFJlcXVlc3QgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQJyk7XG4gICAgICB9LFxuICAgICAgICAgIGN3ZCA9IG51bGwsXG4gICAgICAgICAgcGF0aCA9IG51bGwsXG4gICAgICAgICAgSk9JTiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xuXG4gICAgICB0aGlzLm5hbWUgPSAnYnJvd3Nlcic7XG4gICAgICB0aGlzLmdsb2JhbCA9IHdpbmRvdztcbiAgICAgIHRoaXMucGF0aFNlcCA9ICcvJztcblxuICAgICAgaWYgKCF0aGlzLmdsb2JhbC5qc2lvKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsLmpzaW8gPSBqc2lvO1xuICAgICAgfVxuXG4gICAgICBpZiAod2luZG93LmNvbnNvbGUgJiYgY29uc29sZS5sb2cpIHtcbiAgICAgICAgaWYgKCFjb25zb2xlLmxvZy5hcHBseSB8fCAvQW5kcm9pZHxpUGhvbmV8aVBhZHxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgICAgdGhpcy5sb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEpPSU4uY2FsbChhcmd1bWVudHMsICcgJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIEpPSU4uY2FsbChhcmd1bWVudHMsICcgJyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIEpPSU4uY2FsbChhcmd1bWVudHMsICcgJyk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZ2V0Q3dkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWN3ZCkge1xuICAgICAgICAgIHZhciBsb2MgPSB3aW5kb3cubG9jYXRpb24sXG4gICAgICAgICAgICAgIHBhdGggPSBsb2MucGF0aG5hbWU7XG4gICAgICAgICAgY3dkID0gbG9jLnByb3RvY29sICsgJy8vJyArIGxvYy5ob3N0ICsgcGF0aC5zdWJzdHJpbmcoMCwgcGF0aC5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN3ZDtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZ2V0UGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBmaWxlbmFtZSA9IG5ldyBSZWdFeHAoJyguKj8pJyArIGpzaW8uX19maWxlbmFtZSArICcoXFxcXD8uKik/JCcpLFxuICAgICAgICAgICAgICAgIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBzY3JpcHQ7IHNjcmlwdCA9IHNjcmlwdHNbaV07ICsraSkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gc2NyaXB0LnNyYy5tYXRjaChmaWxlbmFtZSk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gcmVzdWx0WzFdO1xuICAgICAgICAgICAgICAgIGlmICgvXltBLVphLXpdKjpcXC9cXC8vLnRlc3QocGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgIHBhdGggPSB1dGlsLnJlbGF0aXZlKHRoaXMuZ2V0Q3dkKCksIHBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgIHBhdGggPSAnLic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfTtcblxuICAgICAgdmFyIGRlYnVnSG9zdCA9IGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGxvY2F0aW9uLmhvc3QgKyAnLyc7XG4gICAgICB2YXIgZGVidWdQYXRoID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgICB0aGlzLmRlYnVnUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHJldHVybiB1dGlsLmJ1aWxkUGF0aChkZWJ1Z0hvc3QsIHBhdGhbMF0gIT0gJy8nICYmIGRlYnVnUGF0aCwgcGF0aCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBJRTYgd29uJ3QgcmV0dXJuIGFuIGFub255bW91cyBmdW5jdGlvbiBmcm9tIGV2YWwsIHNvIHVzZSB0aGUgZnVuY3Rpb24gY29uc3RydWN0b3IgaW5zdGVhZFxuICAgICAgdmFyIHJhd0V2YWwgPSB0eXBlb2YgZXZhbCgnKGZ1bmN0aW9uKCl7fSknKSA9PSAndW5kZWZpbmVkJyA/IGZ1bmN0aW9uIChzcmMsIHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbigncmV0dXJuICcgKyBzcmMpKCk7XG4gICAgICB9IDogZnVuY3Rpb24gKHNyYywgcGF0aCkge1xuICAgICAgICB2YXIgc3JjID0gc3JjICsgJ1xcbi8vIyBzb3VyY2VVUkw9JyArIHBhdGg7XG4gICAgICAgIHJldHVybiB3aW5kb3cuZXZhbChzcmMpO1xuICAgICAgfTtcblxuICAgICAgLy8gcHJvdmlkZSBhbiBldmFsIHdpdGggcmVhc29uYWJsZSBkZWJ1Z2dpbmdcbiAgICAgIHRoaXMuZXZhbCA9IGZ1bmN0aW9uIChjb2RlLCBwYXRoLCBvcmlnQ29kZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByYXdFdmFsKGNvZGUsIHRoaXMuZGVidWdQYXRoKHBhdGgpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgU3ludGF4RXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChERUJVRyAmJiB0aGlzLmNoZWNrU3ludGF4KSB7XG4gICAgICAgICAgICAgIHRoaXMuY2hlY2tTeW50YXgob3JpZ0NvZGUsIHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmNoZWNrU3ludGF4ID0gZnVuY3Rpb24gKGNvZGUsIHBhdGgpIHtcbiAgICAgICAgLy8gTm90ZTogRGlzYWJsZWQgdG8gYXZvaWQgZXNwcmltYSBpbXBvcnRcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTeW50YXggY2hlY2tpbmcgZGlzYWJsZWQgaW4gYnJvd3NlciBidWlsZHMnKTtcbiAgICAgICAgLy8gdHJ5IHtcbiAgICAgICAgLy8gICAvLyB2YXIgc3ludGF4ID0ganNpbygnaW1wb3J0IGpzaW8udXRpbC5zeW50YXgnLCB7c3VwcHJlc3NFcnJvcnM6IHRydWUsIGRvbnRFeHBvcnQ6IHRydWV9KTtcbiAgICAgICAgLy8gICB2YXIgc3ludGF4ID0gcmVxdWlyZSgnLi91dGlsL3N5bnRheCcpO1xuICAgICAgICAvLyAgIHN5bnRheChjb2RlLCBwYXRoKTtcbiAgICAgICAgLy8gfSBjYXRjaCAoZSkge31cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZmV0Y2ggPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgeGhyID0gbmV3IFhIUigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCBwYXRoLCBmYWxzZSk7XG4gICAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBFTlYubG9nKCdlOicsIGUpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpcmVmb3ggZmlsZTovL1xuICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PSA0MDQgfHwgLy8gYWxsIGJyb3dzZXJzLCBodHRwOi8vXG4gICAgICAgIHhoci5zdGF0dXMgPT0gLTExMDAgfHwgLy8gc2FmYXJpIGZpbGU6Ly9cbiAgICAgICAgLy8gWFhYOiBXZSBoYXZlIG5vIHdheSB0byB0ZWxsIGluIG9wZXJhIGlmIGEgZmlsZSBleGlzdHMgYW5kIGlzIGVtcHR5LCBvciBpcyA0MDRcbiAgICAgICAgLy8gWFhYOiBVc2UgZmxhc2g/XG4gICAgICAgIC8vICghZmFpbGVkICYmIHhoci5zdGF0dXMgPT0gMCAmJiAheGhyLnJlc3BvbnNlVGV4dCAmJiBFWElTVFMpKSAvLyBvcGVyYVxuICAgICAgICBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGZhaWxlZEZldGNoID0ge307XG5cbiAgICBmdW5jdGlvbiBmaW5kTW9kdWxlKHBvc3NpYmlsaXRpZXMpIHtcbiAgICAgIHZhciBzcmM7XG4gICAgICBmb3IgKHZhciBpID0gMCwgcG9zc2libGU7IHBvc3NpYmxlID0gcG9zc2liaWxpdGllc1tpXTsgKytpKSB7XG4gICAgICAgIHZhciBwYXRoID0gcG9zc2libGUucGF0aCxcbiAgICAgICAgICAgIGNhY2hlZFZlcnNpb24gPSBzcmNDYWNoZVtwYXRoXTtcblxuICAgICAgICBpZiAoY2FjaGVkVmVyc2lvbikge1xuICAgICAgICAgIC8vIGV4dHJhY3QgYSBub24tYWJzb2x1dGUgZGlybmFtZSBmcm9tIHRoZSBjYWNoZSBrZXk6IGFic29sdXRlIHBhdGhzXG4gICAgICAgICAgLy8gYnVpbHQgaW50byB0aGUgY2FjaGUgYXJlIG1hZGUgcmVsYXRpdmUgZHVyaW5nIGNvbXBpbGUgdGltZSBzaW5jZVxuICAgICAgICAgIC8vIGFic29sdXRlIHBhdGhzIHdvbid0IG1hdGNoIGJldHdlZW4gaG9zdCBhbmQgdGFyZ2V0IGRldmljZS4gVXNlXG4gICAgICAgICAgLy8gdGhlIGNhY2hlIGtleSBhcyB0aGUgcmVsYXRpdmUgcGF0aCBzbyBmdXR1cmUgaW1wb3J0cyBjYW4gYWxzb1xuICAgICAgICAgIC8vIHN1Y2Nlc3NmdWxseSBsb29rdXAgcGF0aHMgaW4gdGhlIGNhY2hlLlxuICAgICAgICAgIHZhciBtYXRjaCA9IHBhdGgubWF0Y2goL14oLipcXC8pW15cXFxcXFwvXSskLyk7XG4gICAgICAgICAgcG9zc2libGUuZGlyZWN0b3J5ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICAgICAgcG9zc2libGUuc3JjID0gY2FjaGVkVmVyc2lvbi5zcmM7XG4gICAgICAgICAgcG9zc2libGUucHJlID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gcG9zc2libGU7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBpZiAoL15cXC5cXC8vLnRlc3QocGF0aCkpIHtcbiAgICAgICAgICAvLyByZW1vdmUgb25lIHBhdGggc2VnbWVudCBmb3IgZWFjaCBkb3QgZnJvbSB0aGUgY3dkXG4gICAgICAgICAgcGF0aCA9IGFkZEVuZFNsYXNoKEVOVi5nZXRDd2QoKSkgKyBwYXRoO1xuICAgICAgICB9Ki9cbiAgICAgICAgc3JjID0gRU5WLmZldGNoKHBhdGgpO1xuXG4gICAgICAgIGlmIChzcmMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgcG9zc2libGUuc3JjID0gc3JjO1xuICAgICAgICAgIHJldHVybiBwb3NzaWJsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmYWlsZWRGZXRjaFtwYXRoXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NTdGFjaygpIHtcbiAgICAgIHJldHVybiBpbXBvcnRTdGFjay5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHZhciBzdGFjayA9IGluZGV4ID09IDAgPyBuZXcgRXJyb3IoKS5zdGFjayA6IGltcG9ydFN0YWNrW2luZGV4IC0gMV0uc3RhY2s7XG4gICAgICAgIHZhciBpID0gc3RhY2suaW5kZXhPZihpdGVtLnBhdGgpO1xuICAgICAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgICAgaXRlbS5saW5lID0gJzonICsgcGFyc2VJbnQoc3RhY2suc3Vic3RyaW5nKGkgKyBpdGVtLnBhdGgubGVuZ3RoICsgMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZGV4ICsgMSArICc6IFwiJyArIGl0ZW0uZnJpZW5kbHlQYXRoICsgJ1wiICcgKyBpdGVtLnBhdGggKyAoaXRlbS5saW5lIHx8ICcnKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGxvYWQgYSBtb2R1bGUgZnJvbSBhIGZpbGVcbiAgICBmdW5jdGlvbiBsb2FkTW9kdWxlKGJhc2VMb2FkZXIsIGZyb21EaXIsIGZyb21GaWxlLCBpdGVtLCBvcHRzKSB7XG4gICAgICB2YXIgbW9kdWxlUGF0aCA9IGl0ZW0uZnJvbTtcbiAgICAgIHZhciBwb3NzaWJpbGl0aWVzID0gdXRpbC5yZXNvbHZlTW9kdWxlUGF0aChtb2R1bGVQYXRoLCBmcm9tRGlyKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBwOyBwID0gcG9zc2liaWxpdGllc1tpXTsgKytpKSB7XG4gICAgICAgIHZhciBwYXRoID0gcG9zc2liaWxpdGllc1tpXS5wYXRoO1xuICAgICAgICBpZiAoIW9wdHMucmVsb2FkICYmIHBhdGggaW4ganNpby5fX21vZHVsZXMpIHtcbiAgICAgICAgICByZXR1cm4gcG9zc2liaWxpdGllc1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXRoIGluIGZhaWxlZEZldGNoKSB7XG4gICAgICAgICAgcG9zc2liaWxpdGllcy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXBvc3NpYmlsaXRpZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChvcHRzLnN1cHByZXNzRXJyb3JzKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlID0gbmV3IEVycm9yKCdDb3VsZCBub3QgaW1wb3J0IGAnICsgaXRlbS5mcm9tICsgJ2AnICsgJ1xcdEltcG9ydCBTdGFjazpcXG4nICsgJ1xcdFxcdCcgKyBwcm9jZXNzU3RhY2soKS5qb2luKCdcXG5cXHRcXHQnKSk7XG4gICAgICAgIGUuanNpb0xvZ2dlZCA9IHRydWU7XG4gICAgICAgIGUuY29kZSA9IE1PRFVMRV9OT1RfRk9VTkQ7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBtb2R1bGVEZWYgPSBmaW5kTW9kdWxlKHBvc3NpYmlsaXRpZXMpO1xuICAgICAgaWYgKCFtb2R1bGVEZWYpIHtcbiAgICAgICAgaWYgKG9wdHMuc3VwcHJlc3NFcnJvcnMpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhdGhzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwOyBwID0gcG9zc2liaWxpdGllc1tpXTsgKytpKSB7XG4gICAgICAgICAgcGF0aHMucHVzaChwLnBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlID0gbmV3IEVycm9yKCdDb3VsZCBub3QgaW1wb3J0IGAnICsgbW9kdWxlUGF0aCArICdgXFxuJyArICdcXHRsb29rZWQgaW46XFxuJyArICdcXHRcXHQnICsgcGF0aHMuam9pbignXFxuXFx0XFx0JykgKyAnXFxuJyArICdcXHRJbXBvcnQgU3RhY2s6XFxuJyArICdcXHRcXHQnICsgcHJvY2Vzc1N0YWNrKCkuam9pbignXFxuXFx0XFx0JykpO1xuICAgICAgICBlLmNvZGUgPSBNT0RVTEVfTk9UX0ZPVU5EO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuXG4gICAgICAvLyBhIChwb3RlbnRpYWxseSkgbmljZXIgd2F5IHRvIHJlZmVyIHRvIGEgbW9kdWxlIC0tIGhvdyBpdCB3YXMgcmVmZXJlbmNlZCBpbiBjb2RlIHdoZW4gaXQgd2FzIGZpcnN0IGltcG9ydGVkXG4gICAgICBtb2R1bGVEZWYuZnJpZW5kbHlQYXRoID0gbW9kdWxlUGF0aDtcblxuICAgICAgLy8gY2FjaGUgdGhlIGJhc2UgbW9kdWxlJ3MgcGF0aCBpbiB0aGUgcGF0aCBjYWNoZSBzbyB3ZSBkb24ndCBoYXZlIHRvXG4gICAgICAvLyB0cnkgb3V0IGFsbCBwYXRocyB0aGUgbmV4dCB0aW1lIHdlIHNlZSB0aGUgc2FtZSBiYXNlIG1vZHVsZS5cbiAgICAgIGlmIChtb2R1bGVEZWYuYmFzZU1vZCAmJiAhKG1vZHVsZURlZi5iYXNlTW9kIGluIGpzaW9QYXRoLmNhY2hlKSkge1xuICAgICAgICBqc2lvUGF0aC5jYWNoZVttb2R1bGVEZWYuYmFzZU1vZF0gPSBtb2R1bGVEZWYuYmFzZVBhdGg7XG4gICAgICB9XG5cbiAgICAgIC8vIGRvbid0IGFwcGx5IHRoZSBzdGFuZGFyZCBwcmVwcm9jZXNzb3JzIHRvIGJhc2UuanMuICBJZiB3ZSdyZSByZWxvYWRpbmdcbiAgICAgIC8vIHRoZSBzb3VyY2UgY29kZSwgYWx3YXlzIGFwcGx5IHRoZW0uICBXZSBhbHNvIGRvbid0IHdhbnQgdG8gcnVuIHRoZW1cbiAgICAgIC8vIGlmIHRoZXkndmUgYmVlbiBydW4gb25jZSAtLSBtb2R1bGVEZWYucHJlIGlzIHNldCB0byB0cnVlIGFscmVhZHlcbiAgICAgIC8vIGlmIHdlJ3JlIHJlYWRpbmcgdGhlIGNvZGUgZnJvbSB0aGUgc291cmNlIGNhY2hlLlxuICAgICAgaWYgKG1vZHVsZVBhdGggIT0gJ2Jhc2UnICYmIChvcHRzLnJlbG9hZCB8fCAhb3B0cy5kb250UHJlcHJvY2VzcyAmJiAhbW9kdWxlRGVmLnByZSkpIHtcbiAgICAgICAgbW9kdWxlRGVmLnByZSA9IHRydWU7XG5cbiAgICAgICAgYXBwbHlQcmVwcm9jZXNzb3JzKGZyb21EaXIsIG1vZHVsZURlZiwgWydpbXBvcnQnLCAnaW5saW5lU2xpY2UnXSwgb3B0cyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFueSBhZGRpdGlvbmFsIHByZXByb2Nlc3NvcnM/XG4gICAgICBpZiAob3B0cy5wcmVwcm9jZXNzb3JzKSB7XG4gICAgICAgIGFwcGx5UHJlcHJvY2Vzc29ycyhmcm9tRGlyLCBtb2R1bGVEZWYsIG9wdHMucHJlcHJvY2Vzc29ycywgb3B0cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtb2R1bGVEZWY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlQcmVwcm9jZXNzb3JzKHBhdGgsIG1vZHVsZURlZiwgbmFtZXMsIG9wdHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBuYW1lcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgcCA9IGdldFByZXByb2Nlc3NvcihuYW1lc1tpXSk7XG5cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIHJlY3Vyc2l2ZSBpbXBvcnQgYW5kIHAgaXNuJ3QgYSBmdW5jdGlvbiwganVzdFxuICAgICAgICAvLyBza2lwIGl0IChoYW5kbGVzIHRoZSBjYXNlIHdoZXJlIGEgcHJlcHJvY2Vzc29yIGltcG9ydHNcbiAgICAgICAgLy8gb3RoZXIgbW9kdWxlcykuXG4gICAgICAgIGlmIChwICYmIHR5cGVvZiBwID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBwKHBhdGgsIG1vZHVsZURlZiwgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQcmVwcm9jZXNzb3IobmFtZSkge1xuICAgICAgdmFyIG1vZHVsZSA9IGpzaW8uX19tb2R1bGVzWydqc2lvLnByZXByb2Nlc3NvcnMuJyArIG5hbWVdO1xuICAgICAgcmV0dXJuIHR5cGVvZiBuYW1lID09ICdmdW5jdGlvbicgPyBuYW1lIDogbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzIHx8IGxvY2FsSnNpbygnaW1wb3J0IGpzaW8ucHJlcHJvY2Vzc29ycy4nICsgbmFtZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhlY01vZHVsZURlZihjb250ZXh0LCBtb2R1bGVEZWYpIHtcbiAgICAgIHZhciBzcmMgPSBtb2R1bGVEZWYuc3JjO1xuICAgICAgZGVsZXRlIG1vZHVsZURlZi5zcmM7XG5cbiAgICAgIHZhciBjb2RlID0gJyhmdW5jdGlvbihfKXt3aXRoKF8pe2RlbGV0ZSBfO3JldHVybiBmdW5jdGlvbiAkJCcgKyBtb2R1bGVEZWYuZnJpZW5kbHlQYXRoLnJlcGxhY2UoL1tcXDpcXFxcXFwvLi1dL2csICdfJykgKyAnKCl7JyArIHNyYyArICdcXG59fX0pJztcblxuICAgICAgdmFyIGV4cG9ydHMgPSBtb2R1bGVEZWYuZXhwb3J0cyA9IGNvbnRleHQuZXhwb3J0cztcblxuICAgICAgdmFyIGZuID0gRU5WLmV2YWwoY29kZSwgbW9kdWxlRGVmLnBhdGgsIHNyYyk7XG4gICAgICBmbiA9IGZuKGNvbnRleHQpO1xuXG4gICAgICBmbi5jYWxsKGV4cG9ydHMpO1xuXG4gICAgICBpZiAoZXhwb3J0cyAhPSBjb250ZXh0Lm1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIC8vIEVtdWxhdGUgbm9kZS5qcy1zdHlsZSBhYmlsaXR5IHRvIHJlYXNzaWduIG1vZHVsZS5leHBvcnRzOlxuICAgICAgICAvLyAgIG1vZHVsZS5leHBvcnRzID0gLi4uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE5vdGUgdGhhdCBpbiBub2RlLmpzIGFuZCBqcy5pbywgc2V0dGluZyBgbW9kdWxlLmV4cG9ydHNgIGludmFsaWRhdGVzXG4gICAgICAgIC8vIHRoZSBjb250ZXh0J3MgYGV4cG9ydHNgIGFsaWFzLiBTZWVcbiAgICAgICAgLy8gaHR0cDovL25vZGVqcy5vcmcvYXBpL21vZHVsZXMuaHRtbCNtb2R1bGVzX2V4cG9ydHNfYWxpYXMgZm9yIG1vcmVcbiAgICAgICAgbW9kdWxlRGVmLmV4cG9ydHMgPSBjb250ZXh0Lm1vZHVsZS5leHBvcnRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8ganMuaW8tc3R5bGUgYWJpbGl0eSB0byBvdmVycmlkZSBleHBvcnRzIGRpcmVjdGx5IChgZXhwb3J0cyA9IGApXG4gICAgICAgIG1vZHVsZURlZi5leHBvcnRzID0gY29udGV4dC5leHBvcnRzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVJbXBvcnRSZXF1ZXN0KGNvbnRleHQsIHJlcXVlc3QsIG9wdHMpIHtcbiAgICAgIHZhciBjbWRzID0ganNpby5fX2NtZHMsXG4gICAgICAgICAgaW1wb3J0cyA9IFtdLFxuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaW1wOyBpbXAgPSBjbWRzW2ldOyArK2kpIHtcbiAgICAgICAgaWYgKHJlc3VsdCA9IGltcChjb250ZXh0LCByZXF1ZXN0LCBvcHRzLCBpbXBvcnRzKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQgIT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3ICh0eXBlb2YgU3ludGF4RXJyb3IgIT0gJ3VuZGVmaW5lZCcgPyBTeW50YXhFcnJvciA6IEVycm9yKShTdHJpbmcocmVzdWx0IHx8ICdpbnZhbGlkIGpzaW8gY29tbWFuZDoganNpbyhcXCcnICsgcmVxdWVzdCArICdcXCcpJykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW1wb3J0cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQ29udGV4dChjdHgsIG1vZHVsZVBhdGgsIG1vZHVsZURlZiwgZG9udEFkZEJhc2UpIHtcbiAgICAgIGlmICghY3R4KSB7XG4gICAgICAgIGN0eCA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKCFjdHguZXhwb3J0cykge1xuICAgICAgICBjdHguZXhwb3J0cyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBjdHguanNpbyA9IHV0aWwuYmluZCh0aGlzLCBfcmVxdWlyZSwgY3R4LCBtb2R1bGVEZWYuZGlyZWN0b3J5LCBtb2R1bGVEZWYuZmlsZW5hbWUpO1xuICAgICAgY3R4LnJlcXVpcmUgPSBmdW5jdGlvbiAocmVxdWVzdCwgb3B0cykge1xuICAgICAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgb3B0cy5kb250RXhwb3J0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGN0eC5qc2lvKHJlcXVlc3QsIG9wdHMpO1xuICAgICAgfTtcblxuICAgICAgY3R4LnJlcXVpcmUubWFpbiA9IEVOVi5tYWluO1xuXG4gICAgICBjdHgubW9kdWxlID0ge1xuICAgICAgICBpZDogbW9kdWxlUGF0aCxcbiAgICAgICAgZXhwb3J0czogY3R4LmV4cG9ydHNcbiAgICAgIH07XG4gICAgICBpZiAoIWRvbnRBZGRCYXNlICYmIG1vZHVsZVBhdGggIT0gJ2pzaW8uYmFzZScpIHtcbiAgICAgICAgY3R4LmpzaW8oJ2Zyb20ganNpby5iYXNlIGltcG9ydCAqJywgeyBkb250UHJlcHJvY2VzczogdHJ1ZSB9KTtcbiAgICAgICAgY3R4LmxvZ2dpbmcuX19jcmVhdGUobW9kdWxlUGF0aCwgY3R4KTtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogRklYIGZvciBcInRyYWlsaW5nIC5cIiBjYXNlXG4gICAgICBjdHguanNpby5fX2pzaW8gPSBqc2lvO1xuICAgICAgY3R4LmpzaW8uX19lbnYgPSBqc2lvLl9fZW52O1xuICAgICAgY3R4LmpzaW8uX19kaXIgPSBtb2R1bGVEZWYuZGlyZWN0b3J5O1xuICAgICAgY3R4LmpzaW8uX19maWxlbmFtZSA9IG1vZHVsZURlZi5maWxlbmFtZTtcbiAgICAgIGN0eC5qc2lvLnBhdGggPSBqc2lvUGF0aDtcblxuICAgICAgY3R4Ll9fZGlybmFtZSA9IG1vZHVsZURlZi5kaXJlY3Rvcnk7XG4gICAgICBjdHguX19maWxlbmFtZSA9IHV0aWwuYnVpbGRQYXRoKGN0eC5fX2Rpcm5hbWUsIG1vZHVsZURlZi5maWxlbmFtZSk7XG4gICAgICByZXR1cm4gY3R4O1xuICAgIH1cblxuICAgIHZhciBpbXBvcnRTdGFjayA9IFtdO1xuXG4gICAgZnVuY3Rpb24gX3JlcXVpcmUoYm91bmRDb250ZXh0LCBmcm9tRGlyLCBmcm9tRmlsZSwgcmVxdWVzdCwgb3B0cykge1xuICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICBmcm9tRGlyID0gZnJvbURpciB8fCAnLi8nO1xuICAgICAgZnJvbUZpbGUgPSBmcm9tRmlsZSB8fCBJTklUSUFMX0ZJTEU7XG5cbiAgICAgIC8vIHJlcXVpcmUgaXMgYm91bmQgdG8gYSBtb2R1bGUncyAob3IgZ2xvYmFsKSBjb250ZXh0IC0tIHdlIGNhbiBvdmVycmlkZSB0aGlzXG4gICAgICAvLyBieSB1c2luZyBvcHRzLmV4cG9ydEludG9cbiAgICAgIHZhciBleHBvcnRJbnRvID0gb3B0cy5leHBvcnRJbnRvIHx8IGJvdW5kQ29udGV4dCB8fCBFTlYuZ2xvYmFsO1xuXG4gICAgICAvLyBwYXJzZSB0aGUgaW1wb3J0IHJlcXVlc3QocylcbiAgICAgIHZhciBpbXBvcnRzID0gcmVzb2x2ZUltcG9ydFJlcXVlc3QoZXhwb3J0SW50bywgcmVxdWVzdCwgb3B0cyksXG4gICAgICAgICAgbnVtSW1wb3J0cyA9IGltcG9ydHMubGVuZ3RoLFxuICAgICAgICAgIHJldFZhbCA9IG51bUltcG9ydHMgPiAxID8ge30gOiBudWxsO1xuXG4gICAgICAvLyBpbXBvcnQgZWFjaCByZXF1ZXN0ZWQgaXRlbVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1JbXBvcnRzOyArK2kpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBpbXBvcnRzW2ldO1xuICAgICAgICB2YXIgbW9kdWxlUGF0aCA9IGl0ZW0uZnJvbTtcbiAgICAgICAgdmFyIG1vZHVsZXMgPSBqc2lvLl9fbW9kdWxlcztcbiAgICAgICAgdmFyIHBhdGg7XG4gICAgICAgIHZhciBtb2R1bGVEZWY7XG4gICAgICAgIHZhciBlcnI7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtb2R1bGVEZWYgPSBqc2lvLl9fZW52LmxvYWRNb2R1bGUobG9hZE1vZHVsZSwgZnJvbURpciwgZnJvbUZpbGUsIGl0ZW0sIG9wdHMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZXJyID0gZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb2R1bGVEZWYpIHtcbiAgICAgICAgICBwYXRoID0gbW9kdWxlRGVmLnBhdGg7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kdWxlRGVmID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBpZiAob3B0cy5zdXBwcmVzc0Vycm9ycykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWVyci5qc2lvTG9nZ2VkKSB7XG4gICAgICAgICAgICBFTlYubG9nKCdcXG5FcnJvciBsb2FkaW5nIG1vZHVsZTpcXG4nLCAnICAgIFtbJywgcmVxdWVzdCwgJ11dXFxuJywgJyAgICByZXF1ZXN0ZWQgYnk6JywgZnJvbURpciArIGZyb21GaWxlLCAnXFxuJywgJyAgICBjdXJyZW50IGRpcmVjdG9yeTonLCBqc2lvLl9fZW52LmdldEN3ZCgpLCAnXFxuJywgJyAgJyArIGVyci5zdGFjay5zcGxpdCgnXFxuJykuam9pbignXFxuICAnKSk7XG4gICAgICAgICAgICBlcnIuanNpb0xvZ2dlZCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vZHVsZURlZikge1xuICAgICAgICAgIGltcG9ydFN0YWNrLnB1c2goe1xuICAgICAgICAgICAgZnJpZW5kbHlQYXRoOiBtb2R1bGVEZWYuZnJpZW5kbHlQYXRoLFxuICAgICAgICAgICAgcGF0aDogbW9kdWxlRGVmLnBhdGgsXG4gICAgICAgICAgICBzdGFjazogbmV3IEVycm9yKCkuc3RhY2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGV2YWwgYW55IHBhY2thZ2VzIHRoYXQgd2UgZG9uJ3Qga25vdyBhYm91dCBhbHJlYWR5XG4gICAgICAgIGlmICghKHBhdGggaW4gbW9kdWxlcykpIHtcbiAgICAgICAgICBtb2R1bGVzW3BhdGhdID0gbW9kdWxlRGVmO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtb2R1bGVEZWYuZXhwb3J0cykge1xuICAgICAgICAgIHZhciBuZXdDb250ZXh0ID0gbWFrZUNvbnRleHQob3B0cy5jb250ZXh0LCBtb2R1bGVQYXRoLCBtb2R1bGVEZWYsIGl0ZW0uZG9udEFkZEJhc2UpO1xuICAgICAgICAgIGlmIChpdGVtLmRvbnRVc2VFeHBvcnRzKSB7XG4gICAgICAgICAgICB2YXIgc3JjID0gWyc7KGZ1bmN0aW9uKCl7J10sXG4gICAgICAgICAgICAgICAgayA9IDE7XG4gICAgICAgICAgICBmb3IgKHZhciBqIGluIGl0ZW1bJ2ltcG9ydCddKSB7XG4gICAgICAgICAgICAgIG5ld0NvbnRleHQuZXhwb3J0c1tqXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgc3JjW2srK10gPSAnaWYodHlwZW9mICcgKyBqICsgJyE9XCJ1bmRlZmluZWRcIiYmZXhwb3J0cy4nICsgaiArICc9PXVuZGVmaW5lZClleHBvcnRzLicgKyBqICsgJz0nICsgaiArICc7JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNyY1trXSA9ICd9KSgpOyc7XG4gICAgICAgICAgICBtb2R1bGVEZWYuc3JjICs9IHNyYy5qb2luKCcnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleGVjTW9kdWxlRGVmKG5ld0NvbnRleHQsIG1vZHVsZURlZik7XG4gICAgICAgIH1cblxuICAgICAgICBpbXBvcnRTdGFjay5wb3AoKTtcblxuICAgICAgICB2YXIgbW9kdWxlID0gbW9kdWxlRGVmLmV4cG9ydHM7XG5cbiAgICAgICAgLy8gcmV0dXJuIHRoZSBtb2R1bGUgaWYgd2UncmUgb25seSBpbXBvcnRpbmcgb25lIG1vZHVsZVxuICAgICAgICBpZiAobnVtSW1wb3J0cyA9PSAxKSB7XG4gICAgICAgICAgcmV0VmFsID0gbW9kdWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcHRzLmRvbnRFeHBvcnQpIHtcbiAgICAgICAgICAvLyBhZGQgdGhlIG1vZHVsZSB0byB0aGUgY3VycmVudCBjb250ZXh0XG4gICAgICAgICAgaWYgKGl0ZW0uYXMpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZy9sZWFkaW5nIGRvdHNcbiAgICAgICAgICAgIHZhciBhcyA9IGl0ZW0uYXMubWF0Y2goL15cXC4qKC4qPylcXC4qJC8pWzFdLFxuICAgICAgICAgICAgICAgIHNlZ21lbnRzID0gYXMuc3BsaXQoJy4nKSxcbiAgICAgICAgICAgICAgICBrTWF4ID0gc2VnbWVudHMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICBjID0gZXhwb3J0SW50bztcblxuICAgICAgICAgICAgLy8gYnVpbGQgdGhlIG9iamVjdCBpbiB0aGUgY29udGV4dFxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBrTWF4OyArK2spIHtcbiAgICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1trXTtcbiAgICAgICAgICAgICAgaWYgKCFzZWdtZW50KSBjb250aW51ZTtcbiAgICAgICAgICAgICAgaWYgKCFjW3NlZ21lbnRdKSB7XG4gICAgICAgICAgICAgICAgY1tzZWdtZW50XSA9IHt9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGMgPSBjW3NlZ21lbnRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjW3NlZ21lbnRzW2tNYXhdXSA9IG1vZHVsZTtcblxuICAgICAgICAgICAgLy8gdGhlcmUgY2FuIGJlIG11bHRpcGxlIG1vZHVsZSBpbXBvcnRzIHdpdGggdGhpcyBzeW50YXggKGltcG9ydCBmb28sIGJhcilcbiAgICAgICAgICAgIGlmIChudW1JbXBvcnRzID4gMSkge1xuICAgICAgICAgICAgICByZXRWYWxbYXNdID0gbW9kdWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbVsnaW1wb3J0J10pIHtcbiAgICAgICAgICAgIC8vIHRoZXJlIGNhbiBvbmx5IGJlIG9uZSBtb2R1bGUgaW1wb3J0IHdpdGggdGhpcyBzeW50YXhcbiAgICAgICAgICAgIC8vIChmcm9tIGZvbyBpbXBvcnQgYmFyKSwgc28gcmV0VmFsIHdpbGwgYWxyZWFkeSBiZSBzZXQgaGVyZVxuICAgICAgICAgICAgaWYgKGl0ZW1bJ2ltcG9ydCddWycqJ10pIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBtb2R1bGVzW3BhdGhdLmV4cG9ydHMpIHtcbiAgICAgICAgICAgICAgICBleHBvcnRJbnRvW2tdID0gbW9kdWxlW2tdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIGl0ZW1bJ2ltcG9ydCddKSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0SW50b1tpdGVtWydpbXBvcnQnXVtrXV0gPSBtb2R1bGVba107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldFZhbDtcbiAgICB9XG5cbiAgICAvLyBERUZJTkUgU1lOVEFYIEZPUiBKU0lPKCdjbWQnKVxuICAgIC8vIGZyb20gbXlQYWNrYWdlIGltcG9ydCBteUZ1bmNcbiAgICAvLyBleHRlcm5hbCBteVBhY2thZ2UgaW1wb3J0IG15RnVuY1xuICAgIGpzaW8uYWRkQ21kKGZ1bmN0aW9uIChjb250ZXh0LCByZXF1ZXN0LCBvcHRzLCBpbXBvcnRzKSB7XG4gICAgICB2YXIgbWF0Y2ggPSByZXF1ZXN0Lm1hdGNoKC9eXFxzKihmcm9tfGV4dGVybmFsKVxccysoW1xcdy5cXC0kXSspXFxzKyhpbXBvcnR8Z3JhYilcXHMrKC4qKSQvKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBpbXBvcnRzLnB1c2goe1xuICAgICAgICAgIGZyb206IG1hdGNoWzJdLFxuICAgICAgICAgIGRvbnRBZGRCYXNlOiBtYXRjaFsxXSA9PSAnZXh0ZXJuYWwnLFxuICAgICAgICAgIGRvbnRVc2VFeHBvcnRzOiBtYXRjaFszXSA9PSAnZ3JhYicgfHwgbWF0Y2hbMV0gPT0gJ2V4dGVybmFsJyxcbiAgICAgICAgICAnaW1wb3J0Jzoge31cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWF0Y2hbNF0ucmVwbGFjZSgvXFxzKihbXFx3LlxcLSQqXSspKD86XFxzK2FzXFxzKyhbXFx3LlxcLSRdKykpPy9nLCBmdW5jdGlvbiAoXywgaXRlbSwgYXMpIHtcbiAgICAgICAgICBpbXBvcnRzWzBdWydpbXBvcnQnXVtpdGVtXSA9IGFzIHx8IGl0ZW07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGltcG9ydCBteVBhY2thZ2VcbiAgICBqc2lvLmFkZENtZChmdW5jdGlvbiAoY29udGV4dCwgcmVxdWVzdCwgb3B0cywgaW1wb3J0cykge1xuICAgICAgdmFyIG1hdGNoID0gcmVxdWVzdC5tYXRjaCgvXlxccyppbXBvcnRcXHMrKC4qKSQvKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBtYXRjaFsxXS5yZXBsYWNlKC9cXHMqKFtcXHcuXFwtJF0rKSg/Olxccythc1xccysoW1xcdy5cXC0kXSspKT8sPy9nLCBmdW5jdGlvbiAoXywgZnVsbFBhdGgsIGFzKSB7XG4gICAgICAgICAgaW1wb3J0cy5wdXNoKGFzID8ge1xuICAgICAgICAgICAgZnJvbTogZnVsbFBhdGgsXG4gICAgICAgICAgICBhczogYXNcbiAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgZnJvbTogZnVsbFBhdGgsXG4gICAgICAgICAgICBhczogZnVsbFBhdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ29tbW9uSlMgc3ludGF4XG4gICAganNpby5hZGRDbWQoZnVuY3Rpb24gKGNvbnRleHQsIHJlcXVlc3QsIG9wdHMsIGltcG9ydHMpIHtcbiAgICAgIC8vICAgIC4vLi4vYiAtPiAuLmJcbiAgICAgIC8vICAgIC4uLy4uL2IgLT4gLi4uYlxuICAgICAgLy8gICAgLi4vYiAtPiAuLmJcbiAgICAgIC8vICAgIC4vYiAtPiAuYlxuICAgICAgdmFyIG1hdGNoID0gcmVxdWVzdC5tYXRjaCgvXlxccypbXFx3LjAtOSRcXC9cXC06XFxcXF0rXFxzKiQvKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB2YXIgcmVxID0gdXRpbC5yZXNvbHZlUmVsYXRpdmVQYXRoKG1hdGNoWzBdKSxcbiAgICAgICAgICAgIGlzUmVsYXRpdmUgPSByZXEuY2hhckF0KDApID09ICcuJztcblxuICAgICAgICByZXEgPSByZXEucmVwbGFjZSgvXFwuXFwuXFwvL2csICcuJykucmVwbGFjZSgvXFwuXFwvL2csICcnKS5yZXBsYWNlKC9cXC8rJC9nLCAnJyk7XG5cbiAgICAgICAgaWYgKEVOVi5wYXRoU2VwID09PSAnXFxcXCcgJiYgcmVxLm1hdGNoKC9eW2EtekEtWl06LiovKSkge30gZWxzZSB7XG4gICAgICAgICAgLy8gYW55IHJlbWFpbmluZyBzbGFzaGVzIGFyZSBwYXRoIHNlcGFyYXRvcnNcbiAgICAgICAgICByZXEgPSByZXEucmVwbGFjZSgvXFwvL2csICcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpbXBvcnRzWzBdID0ge1xuICAgICAgICAgIGZyb206IChpc1JlbGF0aXZlID8gJy4nIDogJycpICsgcmVxLFxuICAgICAgICAgIG9yaWdpbmFsOiByZXF1ZXN0XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAganNpby5pbnN0YWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbiAgICAgIGJhc2UuR0xPQkFMWydsb2dnZXInXSA9IGJhc2UubG9nZ2luZy5nZXQoJ2pzaW9jb3JlJyk7XG4gICAgfTtcblxuICAgIGpzaW8uZXZhbCA9IGZ1bmN0aW9uIChzcmMsIHBhdGgpIHtcbiAgICAgIHBhdGggPSBFTlYuZ2V0Q3dkKCkgfHwgJy8nO1xuICAgICAgdmFyIG1vZHVsZURlZiA9IG5ldyBNb2R1bGVEZWYocGF0aCk7XG4gICAgICBtb2R1bGVEZWYuc3JjID0gc3JjO1xuICAgICAgYXBwbHlQcmVwcm9jZXNzb3JzKHBhdGgsIG1vZHVsZURlZiwgWydpbXBvcnQnLCAnY2xzJ10sIHt9KTtcbiAgICAgIGV4ZWNNb2R1bGVEZWYoRU5WLmdsb2JhbCwgbW9kdWxlRGVmKTtcbiAgICB9O1xuXG4gICAganNpby5jbG9uZSA9IHV0aWwuYmluZChudWxsLCBpbml0LCBqc2lvKTtcblxuICAgIC8vIGluIG5vZGUsIGRlZmluZXMganNpbyBhcyBhIG1vZHVsZSB0aGF0IGNhbiBiZSBpbXBvcnRlZFxuICAgIHZhciBtb2R1bGVJbmZvID0gdXRpbC5yZXNvbHZlTW9kdWxlUGF0aCgnanNpbycpWzBdO1xuICAgIGlmIChtb2R1bGVJbmZvKSB7XG4gICAgICBqc2lvLl9fbW9kdWxlc1ttb2R1bGVJbmZvLnBhdGhdID0gbmV3IE1vZHVsZURlZihtb2R1bGVJbmZvLnBhdGgpO1xuICAgICAganNpby5fX21vZHVsZXNbbW9kdWxlSW5mby5wYXRoXS5leHBvcnRzID0ganNpbztcbiAgICB9XG5cbiAgICByZXR1cm4ganNpbztcbiAgfVxuXG4gIHZhciBKID0gaW5pdChudWxsLCB7fSk7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gSjtcbiAgfSBlbHNlIHtcbiAgICBqc2lvID0gSjtcbiAgfVxufSkoKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Zyb250ZW5kL2pzaW8vanNpby13ZWIuanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///38\n");

/***/ }),

/***/ 41:
/*!***************************************************************!*\
  !*** ./frontend/devkit-core/src/clientapi/analytics/index.js ***!
  \***************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _debug = __webpack_require__(/*! debug */ 7);\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _userAgent = __webpack_require__(/*! userAgent */ 13);\n\nvar _userAgent2 = _interopRequireDefault(_userAgent);\n\nvar _amplitudeJs = __webpack_require__(/*! amplitude-js */ 44);\n\nvar _amplitudeJs2 = _interopRequireDefault(_amplitudeJs);\n\nvar _facebookPixel = __webpack_require__(/*! facebook-pixel */ 49);\n\nvar _facebookPixel2 = _interopRequireDefault(_facebookPixel);\n\nvar _base = __webpack_require__(/*! base */ 0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// QA - added CONFIG to get appID for local storage\n\n\n////////////////////\n////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////\n//////////////////////////////////////////////////////\n//////////\n\n/**\n * Ployfill for toISOString from:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString\n */\nif (!Date.prototype.toISOString) {\n  (function () {\n\n    function pad(number) {\n      if (number < 10) {\n        return '0' + number;\n      }\n      return number;\n    }\n\n    Date.prototype.toISOString = function () {\n      return this.getUTCFullYear() + '-' + pad(this.getUTCMonth() + 1) + '-' + pad(this.getUTCDate()) + 'T' + pad(this.getUTCHours()) + ':' + pad(this.getUTCMinutes()) + ':' + pad(this.getUTCSeconds()) + '.' + (this.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';\n    };\n  })();\n}\n\nvar log = (0, _debug2.default)('devkit:Analytics');\n\nvar Analytics = function () {\n  function Analytics() {\n    _classCallCheck(this, Analytics);\n\n    this.isInitialized = false;\n    this.eventQueue = [];\n    this.sessionData = {};\n    this._amplitudeClient = null;\n    this.pixelEnabled = false;\n////////////////////////\n/////////////////////////////////////////\n//////////////\n  }\n\n  Analytics.prototype._initAmplitude = function _initAmplitude(key) {\n    this._amplitudeClient = _amplitudeJs2.default.getInstance();\n    this._amplitudeClient.init(key);\n    if (!this.userID) {\n      throw new Error('userID is falsey');\n    }\n    this._amplitudeClient.setUserId(this.userID);\n  };\n\n  /**\n   * Initialize session storage\n   * @param initialSessionData {object} - An object that contains initial information about this session\n   */\n\n\n  Analytics.prototype.initializeSessionData = function initializeSessionData(initialSessionData) {\n    this.sessionData = initialSessionData;\n  };\n\n  /**\n  * Initialize engine related information (such as FPS)\n  * @param params {Engine} - the engine controlling the game\n  */\n\n\n  Analytics.prototype.initializeEngine = function initializeEngine(engine) {\n    this.lastTime = performance.now();\n    this.frameCount = 0;\n    this.fps = 0;\n    engine.subscribe('Render', this, this.trackFPS);\n  };\n\n  /**\n  * Initialize user information for this session.\n  * @param params {object} - An object that contains initialization parameters\n  * @param params.userID {string} - A string that uniquely identifies this user\n  */\n\n\n  Analytics.prototype.initialize = function initialize(params) {\n    var _this = this;\n\n    this.isInitialized = true;\n    this.sessionID = this.createGuid();\n    this.userID = params.userID;\n\n    var isDev = _userAgent2.default.SIMULATED || \"development\" === 'development';\n    this.enabled = !_userAgent2.default.SIMULATED && (params.dev || !isDev);\n\n    params = isDev && params.dev ? (0, _base.merge)(params.dev, params.prod) : params.prod;\n\n    if (params.pixel && params.pixel.enabled) {\n      this.pixelEnabled = params.pixel.enabled && _facebookPixel2.default.enabled;\n      this.pixelWhitelist = params.pixel.whitelist || [];\n    }\n\n    if (params.amplitude) {\n      this.amplitudeEnabled = true;\n      this.amplitudeBlacklist = params.amplitude.blacklist || [];\n      this._initAmplitude(params.amplitude.key);\n    }\n\n    // force update amplitude with any user properties it may have missed\n    this.setUserProperties({});\n\n    this.pushEvent('session', {\n      sessionID: this.sessionID,\n      userAgent: window.navigator.userAgent\n    });\n\n    try {\n      if (!localStorage.getItem('device-install')) {\n        localStorage.setItem('device-install', 'true');\n        this.pushEvent('device-install');\n      }\n    } catch (e) {}\n\n    this.processEventQueue();\n\n    window.setInterval(function () {\n      return _this.processEventQueue();\n    }, 5000);\n  };\n\n  /**\n   * Amplitude API for tracking cohorts\n   */\n\n\n  Analytics.prototype.setUserProperties = function setUserProperties(opts) {\n    if (this.userProperties) {\n      this.userProperties = (0, _base.merge)(opts, this.userProperties);\n    } else {\n      this.userProperties = (0, _base.merge)({}, opts);\n    }\n\n    if (this._amplitudeClient) {\n      this._amplitudeClient.setUserProperties(this.userProperties);\n    }\n  };\n\n//////////////////////\n//////////////////////////////////////////////////////////////////////////\n/////\n//////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n////\n\n\n////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////\n////////////////////\n\n///////////////\n////////////////////////////////\n////////////\n////////////////////////////////////////////\n/////\n\n//////////////////\n////\n\n/////\n////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////\n/////\n\n\n////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////\n////\n\n/////\n////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////\n/////\n\n\n/////////////////////////////////////////////////////////////////////\n///////////////\n////////////////////////////////\n\n//////////////////////\n///////////////////////////////////////////////////\n\n/////////////////////////////////////////\n/////////////////////////\n////\n/////////////////////////////////\n////////////\n\n  /**\n  * Queues an analytics event to be sent to the server.\n  * @param category {string} - the event category, this can be an arbitrary string such as 'sessionComplete'\n  * @param data {object} - this is an arbitrary object that represents the state of the event\n  */\n\n\n  Analytics.prototype.pushEvent = function pushEvent(name, event) {\n    event = event || {};\n    event.timestamp = new Date().toISOString();\n\n    // strip nested objects to avoid breaking analytics' event properties\n    for (var key in event) {\n      if (_typeof(event[key]) === 'object') {\n        delete event[key];\n      }\n    }\n\n////////////////////////\n/////////////////////////////////\n//////////////\n    this.eventQueue.push([name, event]);\n  };\n\n  Analytics.prototype.pushError = function pushError(name, error, event) {\n    event = event || {};\n    error = error || {};\n\n    _base.logger.error('Sending ERROR:', name, error, event);\n\n    this.pushEvent(name, (0, _base.merge)({\n      errorCode: error.code || 'No Code',\n      errorMessage: error.message || 'No Message',\n      errorStack: error.stack || 'No Stack'\n    }, event));\n  };\n\n  /**\n   * Process all pending events\n   */\n\n\n  Analytics.prototype.processEventQueue = function processEventQueue() {\n    var length = this.eventQueue.length;\n    if (this.isInitialized && length > 0) {\n      var batch = {};\n      for (var i = 0; i < length; i++) {\n        var event = this.eventQueue[i];\n        var key = event[0];\n        var data = event[1];\n        data.version = _base.CONFIG.version;\n        data.sessionID = this.sessionID;\n        data.userID = this.userID;\n        data.OS_TYPE = _userAgent2.default.OS_TYPE;\n        data.OS_VERSION = _userAgent2.default.OS_VERSION;\n        data.APP_RUNTIME = _userAgent2.default.APP_RUNTIME;\n        data.DEVICE_TYPE = _userAgent2.default.DEVICE_TYPE;\n        data.BROWSER_TYPE = _userAgent2.default.BROWSER_TYPE;\n        data.BROWSER_VERSION = _userAgent2.default.BROWSER_VERSION;\n        data.SIMULATED = _userAgent2.default.SIMULATED;\n\n        if (!this.enabled) {\n          log('Skipping event send (no config for current environment): key= ' + key + ' data=', data);\n          continue;\n        }\n\n        // for now just send it straight to amplitude - they do their own batching\n        if (this.amplitudeBlacklist.indexOf(key) === -1) {\n          // Only send to amplitude if it's not in the blacklist.\n          this._amplitudeClient.logEvent(key, (0, _base.merge)({}, data));\n        }\n\n        // Duplicate events over to Facebook pixel if they are on the PIXEL whitelist\n        var sendToPixel = this.pixelEnabled && (!this.pixelWhitelist || this.pixelWhitelist.indexOf(key) >= 0);\n        if (sendToPixel) {\n          _facebookPixel2.default.trackCustom(key, (0, _base.merge)({}, data));\n        }\n      }\n\n      this.eventQueue = [];\n    }\n  };\n\n  /**\n   * tracking average FPS of the game for analytics purposes\n   */\n\n\n  Analytics.prototype.trackFPS = function trackFPS() {\n    var now = window.performance.now();\n    var dt = now - this.lastTime;\n    var fps = 1 / (dt / 1000);\n    this.frameCount++;\n    this.fps += (fps - this.fps) / this.frameCount;\n    this.lastTime = now;\n  };\n\n  /**\n   * Get the current snapshot of the rolling average fps\n   * @returns {number} - Average frames per second\n   */\n\n\n  Analytics.prototype.getAverageFPS = function getAverageFPS() {\n    return this.fps;\n  };\n\n  /**\n   * Reset FPS tracker values to 0\n   */\n\n\n  Analytics.prototype.resetAverageFPS = function resetAverageFPS() {\n    this.frameCount = 0;\n    this.fps = 0;\n  };\n\n  /**\n   * Quick createGuid taken from the internet:\n   * http://byronsalau.com/blog/how-to-create-a-guid-uuid-in-javascript/\n   * I reccomend that we switch to Chance.js or some other seeded random\n   * lib in the future.\n   */\n\n\n  Analytics.prototype.createGuid = function createGuid() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n      var r = Math.random() * 16 | 0,\n          v = c === 'x' ? r : r & 0x3 | 0x8;\n      return v.toString(16);\n    });\n  };\n\n  return Analytics;\n}();\n\nexports.default = new Analytics();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9mcm9udGVuZC9kZXZraXQtY29yZS9zcmMvY2xpZW50YXBpL2FuYWx5dGljcy9pbmRleC5qcz84MzIyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBLG9HQUFvRyxtQkFBbUIsRUFBRSxtQkFBbUIsOEhBQThIOztBQUUxUTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0YsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdko7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2Qzs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQiwwQkFBMEIsT0FBTztBQUNqQzs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUIsaUJBQWlCLE9BQU87QUFDeEI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUM7O0FBRUQiLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9kZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJyk7XG5cbnZhciBfZGVidWcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVidWcpO1xuXG52YXIgX3VzZXJBZ2VudCA9IHJlcXVpcmUoJ3VzZXJBZ2VudCcpO1xuXG52YXIgX3VzZXJBZ2VudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VyQWdlbnQpO1xuXG52YXIgX2FtcGxpdHVkZUpzID0gcmVxdWlyZSgnYW1wbGl0dWRlLWpzJyk7XG5cbnZhciBfYW1wbGl0dWRlSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYW1wbGl0dWRlSnMpO1xuXG52YXIgX2ZhY2Vib29rUGl4ZWwgPSByZXF1aXJlKCdmYWNlYm9vay1waXhlbCcpO1xuXG52YXIgX2ZhY2Vib29rUGl4ZWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZmFjZWJvb2tQaXhlbCk7XG5cbnZhciBfYmFzZSA9IHJlcXVpcmUoJ2Jhc2UnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLy8gUUEgLSBhZGRlZCBDT05GSUcgdG8gZ2V0IGFwcElEIGZvciBsb2NhbCBzdG9yYWdlXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy9cblxuLyoqXG4gKiBQbG95ZmlsbCBmb3IgdG9JU09TdHJpbmcgZnJvbTpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvdG9JU09TdHJpbmdcbiAqL1xuaWYgKCFEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykge1xuICAoZnVuY3Rpb24gKCkge1xuXG4gICAgZnVuY3Rpb24gcGFkKG51bWJlcikge1xuICAgICAgaWYgKG51bWJlciA8IDEwKSB7XG4gICAgICAgIHJldHVybiAnMCcgKyBudW1iZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cblxuICAgIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VVRDRnVsbFllYXIoKSArICctJyArIHBhZCh0aGlzLmdldFVUQ01vbnRoKCkgKyAxKSArICctJyArIHBhZCh0aGlzLmdldFVUQ0RhdGUoKSkgKyAnVCcgKyBwYWQodGhpcy5nZXRVVENIb3VycygpKSArICc6JyArIHBhZCh0aGlzLmdldFVUQ01pbnV0ZXMoKSkgKyAnOicgKyBwYWQodGhpcy5nZXRVVENTZWNvbmRzKCkpICsgJy4nICsgKHRoaXMuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgLyAxMDAwKS50b0ZpeGVkKDMpLnNsaWNlKDIsIDUpICsgJ1onO1xuICAgIH07XG4gIH0pKCk7XG59XG5cbnZhciBsb2cgPSAoMCwgX2RlYnVnMi5kZWZhdWx0KSgnZGV2a2l0OkFuYWx5dGljcycpO1xuXG52YXIgQW5hbHl0aWNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBbmFseXRpY3MoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFuYWx5dGljcyk7XG5cbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmV2ZW50UXVldWUgPSBbXTtcbiAgICB0aGlzLnNlc3Npb25EYXRhID0ge307XG4gICAgdGhpcy5fYW1wbGl0dWRlQ2xpZW50ID0gbnVsbDtcbiAgICB0aGlzLnBpeGVsRW5hYmxlZCA9IGZhbHNlO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy9cbiAgfVxuXG4gIEFuYWx5dGljcy5wcm90b3R5cGUuX2luaXRBbXBsaXR1ZGUgPSBmdW5jdGlvbiBfaW5pdEFtcGxpdHVkZShrZXkpIHtcbiAgICB0aGlzLl9hbXBsaXR1ZGVDbGllbnQgPSBfYW1wbGl0dWRlSnMyLmRlZmF1bHQuZ2V0SW5zdGFuY2UoKTtcbiAgICB0aGlzLl9hbXBsaXR1ZGVDbGllbnQuaW5pdChrZXkpO1xuICAgIGlmICghdGhpcy51c2VySUQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndXNlcklEIGlzIGZhbHNleScpO1xuICAgIH1cbiAgICB0aGlzLl9hbXBsaXR1ZGVDbGllbnQuc2V0VXNlcklkKHRoaXMudXNlcklEKTtcbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBzZXNzaW9uIHN0b3JhZ2VcbiAgICogQHBhcmFtIGluaXRpYWxTZXNzaW9uRGF0YSB7b2JqZWN0fSAtIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGluaXRpYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBzZXNzaW9uXG4gICAqL1xuXG5cbiAgQW5hbHl0aWNzLnByb3RvdHlwZS5pbml0aWFsaXplU2Vzc2lvbkRhdGEgPSBmdW5jdGlvbiBpbml0aWFsaXplU2Vzc2lvbkRhdGEoaW5pdGlhbFNlc3Npb25EYXRhKSB7XG4gICAgdGhpcy5zZXNzaW9uRGF0YSA9IGluaXRpYWxTZXNzaW9uRGF0YTtcbiAgfTtcblxuICAvKipcbiAgKiBJbml0aWFsaXplIGVuZ2luZSByZWxhdGVkIGluZm9ybWF0aW9uIChzdWNoIGFzIEZQUylcbiAgKiBAcGFyYW0gcGFyYW1zIHtFbmdpbmV9IC0gdGhlIGVuZ2luZSBjb250cm9sbGluZyB0aGUgZ2FtZVxuICAqL1xuXG5cbiAgQW5hbHl0aWNzLnByb3RvdHlwZS5pbml0aWFsaXplRW5naW5lID0gZnVuY3Rpb24gaW5pdGlhbGl6ZUVuZ2luZShlbmdpbmUpIHtcbiAgICB0aGlzLmxhc3RUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdGhpcy5mcmFtZUNvdW50ID0gMDtcbiAgICB0aGlzLmZwcyA9IDA7XG4gICAgZW5naW5lLnN1YnNjcmliZSgnUmVuZGVyJywgdGhpcywgdGhpcy50cmFja0ZQUyk7XG4gIH07XG5cbiAgLyoqXG4gICogSW5pdGlhbGl6ZSB1c2VyIGluZm9ybWF0aW9uIGZvciB0aGlzIHNlc3Npb24uXG4gICogQHBhcmFtIHBhcmFtcyB7b2JqZWN0fSAtIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGluaXRpYWxpemF0aW9uIHBhcmFtZXRlcnNcbiAgKiBAcGFyYW0gcGFyYW1zLnVzZXJJRCB7c3RyaW5nfSAtIEEgc3RyaW5nIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyB0aGlzIHVzZXJcbiAgKi9cblxuXG4gIEFuYWx5dGljcy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIGluaXRpYWxpemUocGFyYW1zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgdGhpcy5zZXNzaW9uSUQgPSB0aGlzLmNyZWF0ZUd1aWQoKTtcbiAgICB0aGlzLnVzZXJJRCA9IHBhcmFtcy51c2VySUQ7XG5cbiAgICB2YXIgaXNEZXYgPSBfdXNlckFnZW50Mi5kZWZhdWx0LlNJTVVMQVRFRCB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JztcbiAgICB0aGlzLmVuYWJsZWQgPSAhX3VzZXJBZ2VudDIuZGVmYXVsdC5TSU1VTEFURUQgJiYgKHBhcmFtcy5kZXYgfHwgIWlzRGV2KTtcblxuICAgIHBhcmFtcyA9IGlzRGV2ICYmIHBhcmFtcy5kZXYgPyAoMCwgX2Jhc2UubWVyZ2UpKHBhcmFtcy5kZXYsIHBhcmFtcy5wcm9kKSA6IHBhcmFtcy5wcm9kO1xuXG4gICAgaWYgKHBhcmFtcy5waXhlbCAmJiBwYXJhbXMucGl4ZWwuZW5hYmxlZCkge1xuICAgICAgdGhpcy5waXhlbEVuYWJsZWQgPSBwYXJhbXMucGl4ZWwuZW5hYmxlZCAmJiBfZmFjZWJvb2tQaXhlbDIuZGVmYXVsdC5lbmFibGVkO1xuICAgICAgdGhpcy5waXhlbFdoaXRlbGlzdCA9IHBhcmFtcy5waXhlbC53aGl0ZWxpc3QgfHwgW107XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5hbXBsaXR1ZGUpIHtcbiAgICAgIHRoaXMuYW1wbGl0dWRlRW5hYmxlZCA9IHRydWU7XG4gICAgICB0aGlzLmFtcGxpdHVkZUJsYWNrbGlzdCA9IHBhcmFtcy5hbXBsaXR1ZGUuYmxhY2tsaXN0IHx8IFtdO1xuICAgICAgdGhpcy5faW5pdEFtcGxpdHVkZShwYXJhbXMuYW1wbGl0dWRlLmtleSk7XG4gICAgfVxuXG4gICAgLy8gZm9yY2UgdXBkYXRlIGFtcGxpdHVkZSB3aXRoIGFueSB1c2VyIHByb3BlcnRpZXMgaXQgbWF5IGhhdmUgbWlzc2VkXG4gICAgdGhpcy5zZXRVc2VyUHJvcGVydGllcyh7fSk7XG5cbiAgICB0aGlzLnB1c2hFdmVudCgnc2Vzc2lvbicsIHtcbiAgICAgIHNlc3Npb25JRDogdGhpcy5zZXNzaW9uSUQsXG4gICAgICB1c2VyQWdlbnQ6IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50XG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKCFsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZGV2aWNlLWluc3RhbGwnKSkge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnZGV2aWNlLWluc3RhbGwnLCAndHJ1ZScpO1xuICAgICAgICB0aGlzLnB1c2hFdmVudCgnZGV2aWNlLWluc3RhbGwnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgdGhpcy5wcm9jZXNzRXZlbnRRdWV1ZSgpO1xuXG4gICAgd2luZG93LnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5wcm9jZXNzRXZlbnRRdWV1ZSgpO1xuICAgIH0sIDUwMDApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBbXBsaXR1ZGUgQVBJIGZvciB0cmFja2luZyBjb2hvcnRzXG4gICAqL1xuXG5cbiAgQW5hbHl0aWNzLnByb3RvdHlwZS5zZXRVc2VyUHJvcGVydGllcyA9IGZ1bmN0aW9uIHNldFVzZXJQcm9wZXJ0aWVzKG9wdHMpIHtcbiAgICBpZiAodGhpcy51c2VyUHJvcGVydGllcykge1xuICAgICAgdGhpcy51c2VyUHJvcGVydGllcyA9ICgwLCBfYmFzZS5tZXJnZSkob3B0cywgdGhpcy51c2VyUHJvcGVydGllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXNlclByb3BlcnRpZXMgPSAoMCwgX2Jhc2UubWVyZ2UpKHt9LCBvcHRzKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYW1wbGl0dWRlQ2xpZW50KSB7XG4gICAgICB0aGlzLl9hbXBsaXR1ZGVDbGllbnQuc2V0VXNlclByb3BlcnRpZXModGhpcy51c2VyUHJvcGVydGllcyk7XG4gICAgfVxuICB9O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy9cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vXG5cbi8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vL1xuXG4vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vXG5cbiAgLyoqXG4gICogUXVldWVzIGFuIGFuYWx5dGljcyBldmVudCB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICogQHBhcmFtIGNhdGVnb3J5IHtzdHJpbmd9IC0gdGhlIGV2ZW50IGNhdGVnb3J5LCB0aGlzIGNhbiBiZSBhbiBhcmJpdHJhcnkgc3RyaW5nIHN1Y2ggYXMgJ3Nlc3Npb25Db21wbGV0ZSdcbiAgKiBAcGFyYW0gZGF0YSB7b2JqZWN0fSAtIHRoaXMgaXMgYW4gYXJiaXRyYXJ5IG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSBldmVudFxuICAqL1xuXG5cbiAgQW5hbHl0aWNzLnByb3RvdHlwZS5wdXNoRXZlbnQgPSBmdW5jdGlvbiBwdXNoRXZlbnQobmFtZSwgZXZlbnQpIHtcbiAgICBldmVudCA9IGV2ZW50IHx8IHt9O1xuICAgIGV2ZW50LnRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcblxuICAgIC8vIHN0cmlwIG5lc3RlZCBvYmplY3RzIHRvIGF2b2lkIGJyZWFraW5nIGFuYWx5dGljcycgZXZlbnQgcHJvcGVydGllc1xuICAgIGZvciAodmFyIGtleSBpbiBldmVudCkge1xuICAgICAgaWYgKF90eXBlb2YoZXZlbnRba2V5XSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGRlbGV0ZSBldmVudFtrZXldO1xuICAgICAgfVxuICAgIH1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vXG4gICAgdGhpcy5ldmVudFF1ZXVlLnB1c2goW25hbWUsIGV2ZW50XSk7XG4gIH07XG5cbiAgQW5hbHl0aWNzLnByb3RvdHlwZS5wdXNoRXJyb3IgPSBmdW5jdGlvbiBwdXNoRXJyb3IobmFtZSwgZXJyb3IsIGV2ZW50KSB7XG4gICAgZXZlbnQgPSBldmVudCB8fCB7fTtcbiAgICBlcnJvciA9IGVycm9yIHx8IHt9O1xuXG4gICAgX2Jhc2UubG9nZ2VyLmVycm9yKCdTZW5kaW5nIEVSUk9SOicsIG5hbWUsIGVycm9yLCBldmVudCk7XG5cbiAgICB0aGlzLnB1c2hFdmVudChuYW1lLCAoMCwgX2Jhc2UubWVyZ2UpKHtcbiAgICAgIGVycm9yQ29kZTogZXJyb3IuY29kZSB8fCAnTm8gQ29kZScsXG4gICAgICBlcnJvck1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfHwgJ05vIE1lc3NhZ2UnLFxuICAgICAgZXJyb3JTdGFjazogZXJyb3Iuc3RhY2sgfHwgJ05vIFN0YWNrJ1xuICAgIH0sIGV2ZW50KSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgYWxsIHBlbmRpbmcgZXZlbnRzXG4gICAqL1xuXG5cbiAgQW5hbHl0aWNzLnByb3RvdHlwZS5wcm9jZXNzRXZlbnRRdWV1ZSA9IGZ1bmN0aW9uIHByb2Nlc3NFdmVudFF1ZXVlKCkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmV2ZW50UXVldWUubGVuZ3RoO1xuICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQgJiYgbGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGJhdGNoID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBldmVudCA9IHRoaXMuZXZlbnRRdWV1ZVtpXTtcbiAgICAgICAgdmFyIGtleSA9IGV2ZW50WzBdO1xuICAgICAgICB2YXIgZGF0YSA9IGV2ZW50WzFdO1xuICAgICAgICBkYXRhLnZlcnNpb24gPSBfYmFzZS5DT05GSUcudmVyc2lvbjtcbiAgICAgICAgZGF0YS5zZXNzaW9uSUQgPSB0aGlzLnNlc3Npb25JRDtcbiAgICAgICAgZGF0YS51c2VySUQgPSB0aGlzLnVzZXJJRDtcbiAgICAgICAgZGF0YS5PU19UWVBFID0gX3VzZXJBZ2VudDIuZGVmYXVsdC5PU19UWVBFO1xuICAgICAgICBkYXRhLk9TX1ZFUlNJT04gPSBfdXNlckFnZW50Mi5kZWZhdWx0Lk9TX1ZFUlNJT047XG4gICAgICAgIGRhdGEuQVBQX1JVTlRJTUUgPSBfdXNlckFnZW50Mi5kZWZhdWx0LkFQUF9SVU5USU1FO1xuICAgICAgICBkYXRhLkRFVklDRV9UWVBFID0gX3VzZXJBZ2VudDIuZGVmYXVsdC5ERVZJQ0VfVFlQRTtcbiAgICAgICAgZGF0YS5CUk9XU0VSX1RZUEUgPSBfdXNlckFnZW50Mi5kZWZhdWx0LkJST1dTRVJfVFlQRTtcbiAgICAgICAgZGF0YS5CUk9XU0VSX1ZFUlNJT04gPSBfdXNlckFnZW50Mi5kZWZhdWx0LkJST1dTRVJfVkVSU0lPTjtcbiAgICAgICAgZGF0YS5TSU1VTEFURUQgPSBfdXNlckFnZW50Mi5kZWZhdWx0LlNJTVVMQVRFRDtcblxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgICAgIGxvZygnU2tpcHBpbmcgZXZlbnQgc2VuZCAobm8gY29uZmlnIGZvciBjdXJyZW50IGVudmlyb25tZW50KToga2V5PSAnICsga2V5ICsgJyBkYXRhPScsIGRhdGEpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZm9yIG5vdyBqdXN0IHNlbmQgaXQgc3RyYWlnaHQgdG8gYW1wbGl0dWRlIC0gdGhleSBkbyB0aGVpciBvd24gYmF0Y2hpbmdcbiAgICAgICAgaWYgKHRoaXMuYW1wbGl0dWRlQmxhY2tsaXN0LmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBPbmx5IHNlbmQgdG8gYW1wbGl0dWRlIGlmIGl0J3Mgbm90IGluIHRoZSBibGFja2xpc3QuXG4gICAgICAgICAgdGhpcy5fYW1wbGl0dWRlQ2xpZW50LmxvZ0V2ZW50KGtleSwgKDAsIF9iYXNlLm1lcmdlKSh7fSwgZGF0YSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRHVwbGljYXRlIGV2ZW50cyBvdmVyIHRvIEZhY2Vib29rIHBpeGVsIGlmIHRoZXkgYXJlIG9uIHRoZSBQSVhFTCB3aGl0ZWxpc3RcbiAgICAgICAgdmFyIHNlbmRUb1BpeGVsID0gdGhpcy5waXhlbEVuYWJsZWQgJiYgKCF0aGlzLnBpeGVsV2hpdGVsaXN0IHx8IHRoaXMucGl4ZWxXaGl0ZWxpc3QuaW5kZXhPZihrZXkpID49IDApO1xuICAgICAgICBpZiAoc2VuZFRvUGl4ZWwpIHtcbiAgICAgICAgICBfZmFjZWJvb2tQaXhlbDIuZGVmYXVsdC50cmFja0N1c3RvbShrZXksICgwLCBfYmFzZS5tZXJnZSkoe30sIGRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmV2ZW50UXVldWUgPSBbXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIHRyYWNraW5nIGF2ZXJhZ2UgRlBTIG9mIHRoZSBnYW1lIGZvciBhbmFseXRpY3MgcHVycG9zZXNcbiAgICovXG5cblxuICBBbmFseXRpY3MucHJvdG90eXBlLnRyYWNrRlBTID0gZnVuY3Rpb24gdHJhY2tGUFMoKSB7XG4gICAgdmFyIG5vdyA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB2YXIgZHQgPSBub3cgLSB0aGlzLmxhc3RUaW1lO1xuICAgIHZhciBmcHMgPSAxIC8gKGR0IC8gMTAwMCk7XG4gICAgdGhpcy5mcmFtZUNvdW50Kys7XG4gICAgdGhpcy5mcHMgKz0gKGZwcyAtIHRoaXMuZnBzKSAvIHRoaXMuZnJhbWVDb3VudDtcbiAgICB0aGlzLmxhc3RUaW1lID0gbm93O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc25hcHNob3Qgb2YgdGhlIHJvbGxpbmcgYXZlcmFnZSBmcHNcbiAgICogQHJldHVybnMge251bWJlcn0gLSBBdmVyYWdlIGZyYW1lcyBwZXIgc2Vjb25kXG4gICAqL1xuXG5cbiAgQW5hbHl0aWNzLnByb3RvdHlwZS5nZXRBdmVyYWdlRlBTID0gZnVuY3Rpb24gZ2V0QXZlcmFnZUZQUygpIHtcbiAgICByZXR1cm4gdGhpcy5mcHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc2V0IEZQUyB0cmFja2VyIHZhbHVlcyB0byAwXG4gICAqL1xuXG5cbiAgQW5hbHl0aWNzLnByb3RvdHlwZS5yZXNldEF2ZXJhZ2VGUFMgPSBmdW5jdGlvbiByZXNldEF2ZXJhZ2VGUFMoKSB7XG4gICAgdGhpcy5mcmFtZUNvdW50ID0gMDtcbiAgICB0aGlzLmZwcyA9IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIFF1aWNrIGNyZWF0ZUd1aWQgdGFrZW4gZnJvbSB0aGUgaW50ZXJuZXQ6XG4gICAqIGh0dHA6Ly9ieXJvbnNhbGF1LmNvbS9ibG9nL2hvdy10by1jcmVhdGUtYS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdC9cbiAgICogSSByZWNjb21lbmQgdGhhdCB3ZSBzd2l0Y2ggdG8gQ2hhbmNlLmpzIG9yIHNvbWUgb3RoZXIgc2VlZGVkIHJhbmRvbVxuICAgKiBsaWIgaW4gdGhlIGZ1dHVyZS5cbiAgICovXG5cblxuICBBbmFseXRpY3MucHJvdG90eXBlLmNyZWF0ZUd1aWQgPSBmdW5jdGlvbiBjcmVhdGVHdWlkKCkge1xuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDAsXG4gICAgICAgICAgdiA9IGMgPT09ICd4JyA/IHIgOiByICYgMHgzIHwgMHg4O1xuICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBBbmFseXRpY3M7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBBbmFseXRpY3MoKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Zyb250ZW5kL2RldmtpdC1jb3JlL3NyYy9jbGllbnRhcGkvYW5hbHl0aWNzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///41\n");

/***/ }),

/***/ 42:
/*!**************************************************!*\
  !*** ./frontend/node_modules/debug/src/debug.js ***!
  \**************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(/*! ms */ 43);\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0,\n      i;\n\n  for (i in namespace) {\n    hash = (hash << 5) - hash + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy() {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2RlYnVnLmpzP2EwMDYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLFNBQVM7QUFDdEIsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsYUFBYSw4QkFBOEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNDIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Z1snZGVmYXVsdCddID0gY3JlYXRlRGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBBY3RpdmUgYGRlYnVnYCBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydHMuaW5zdGFuY2VzID0gW107XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgdmFyIGhhc2ggPSAwLFxuICAgICAgaTtcblxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICB2YXIgcHJldlRpbWU7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbiAobWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICAvLyBhcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuICAgIGV4cG9ydHMuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG4gICAgdmFyIGxvZ0ZuID0gZGVidWcubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cblxuICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIGRlYnVnLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgZGVidWcudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuICBkZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuaW5pdCkge1xuICAgIGV4cG9ydHMuaW5pdChkZWJ1Zyk7XG4gIH1cblxuICBleHBvcnRzLmluc3RhbmNlcy5wdXNoKGRlYnVnKTtcblxuICByZXR1cm4gZGVidWc7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gIHZhciBpbmRleCA9IGV4cG9ydHMuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBleHBvcnRzLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBpO1xuICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwb3J0cy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBleHBvcnRzLmluc3RhbmNlc1tpXTtcbiAgICBpbnN0YW5jZS5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9kZWJ1Zy5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///42\n");

/***/ }),

/***/ 43:
/*!*******************************************!*\
  !*** ./frontend/node_modules/ms/index.js ***!
  \*******************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvbXMvaW5kZXguanM/M2U5YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxvR0FBb0csbUJBQW1CLEVBQUUsbUJBQW1CLDhIQUE4SDs7QUFFMVE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksTUFBTTtBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjQzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcigndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICsgSlNPTi5zdHJpbmdpZnkodmFsKSk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoc3RyKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtcyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpIHx8IHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fCBwbHVyYWwobXMsIG0sICdtaW51dGUnKSB8fCBwbHVyYWwobXMsIHMsICdzZWNvbmQnKSB8fCBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtcyA8IG4gKiAxLjUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgfVxuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///43\n");

/***/ }),

/***/ 44:
/*!*********************************************************!*\
  !*** ./frontend/node_modules/amplitude-js/amplitude.js ***!
  \*********************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, process, Buffer) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n(function (global, factory) {\n  ( false ? 'undefined' : _typeof2(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.amplitude = factory();\n})(undefined, function () {\n  'use strict';\n\n  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n  function createCommonjsModule(fn, module) {\n    return module = { exports: {} }, fn(module, module.exports), module.exports;\n  }\n\n  var json3 = createCommonjsModule(function (module, exports) {\n    /*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */\n    (function () {\n      // Detect the `define` function exposed by asynchronous module loaders. The\n      // strict `define` check is necessary for compatibility with `r.js`.\n      var isLoader = typeof undefined === \"function\" && undefined.amd;\n\n      // A set of types used to distinguish objects from primitives.\n      var objectTypes = {\n        \"function\": true,\n        \"object\": true\n      };\n\n      // Detect the `exports` object exposed by CommonJS implementations.\n      var freeExports = objectTypes['object'] && exports && !exports.nodeType && exports;\n\n      // Use the `global` object exposed by Node (including Browserify via\n      // `insert-module-globals`), Narwhal, and Ringo as the default context,\n      // and the `window` object in browsers. Rhino exports a `global` function\n      // instead.\n      var root = objectTypes[typeof window === 'undefined' ? 'undefined' : _typeof2(window)] && window || this,\n          freeGlobal = freeExports && objectTypes['object'] && module && !module.nodeType && (typeof commonjsGlobal === 'undefined' ? 'undefined' : _typeof2(commonjsGlobal)) == \"object\" && commonjsGlobal;\n\n      if (freeGlobal && (freeGlobal[\"global\"] === freeGlobal || freeGlobal[\"window\"] === freeGlobal || freeGlobal[\"self\"] === freeGlobal)) {\n        root = freeGlobal;\n      }\n\n      // Public: Initializes JSON 3 using the given `context` object, attaching the\n      // `stringify` and `parse` functions to the specified `exports` object.\n      function runInContext(context, exports) {\n        context || (context = root[\"Object\"]());\n        exports || (exports = root[\"Object\"]());\n\n        // Native constructor aliases.\n        var Number = context[\"Number\"] || root[\"Number\"],\n            String = context[\"String\"] || root[\"String\"],\n            Object = context[\"Object\"] || root[\"Object\"],\n            Date = context[\"Date\"] || root[\"Date\"],\n            SyntaxError = context[\"SyntaxError\"] || root[\"SyntaxError\"],\n            TypeError = context[\"TypeError\"] || root[\"TypeError\"],\n            Math = context[\"Math\"] || root[\"Math\"],\n            nativeJSON = context[\"JSON\"] || root[\"JSON\"];\n\n        // Delegate to the native `stringify` and `parse` implementations.\n        if ((typeof nativeJSON === 'undefined' ? 'undefined' : _typeof2(nativeJSON)) == \"object\" && nativeJSON) {\n          exports.stringify = nativeJSON.stringify;\n          exports.parse = nativeJSON.parse;\n        }\n\n        // Convenience aliases.\n        var objectProto = Object.prototype,\n            getClass = objectProto.toString,\n            _isProperty,\n            _forEach,\n            undef;\n\n        // Test the `Date#getUTC*` methods. Based on work by @Yaffle.\n        var isExtended = new Date(-3509827334573292);\n        try {\n          // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical\n          // results for certain dates in Opera >= 10.53.\n          isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&\n          // Safari < 2.0.2 stores the internal millisecond time value correctly,\n          // but clips the values returned by the date methods to the range of\n          // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).\n          isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;\n        } catch (exception) {}\n\n        // Internal: Determines whether the native `JSON.stringify` and `parse`\n        // implementations are spec-compliant. Based on work by Ken Snyder.\n        function has(name) {\n          if (has[name] !== undef) {\n            // Return cached feature test result.\n            return has[name];\n          }\n          var isSupported;\n          if (name == \"bug-string-char-index\") {\n            // IE <= 7 doesn't support accessing string characters using square\n            // bracket notation. IE 8 only supports this for primitives.\n            isSupported = \"a\"[0] != \"a\";\n          } else if (name == \"json\") {\n            // Indicates whether both `JSON.stringify` and `JSON.parse` are\n            // supported.\n            isSupported = has(\"json-stringify\") && has(\"json-parse\");\n          } else {\n            var value,\n                serialized = '{\"a\":[1,true,false,null,\"\\\\u0000\\\\b\\\\n\\\\f\\\\r\\\\t\"]}';\n            // Test `JSON.stringify`.\n            if (name == \"json-stringify\") {\n              var stringify = exports.stringify,\n                  stringifySupported = typeof stringify == \"function\" && isExtended;\n              if (stringifySupported) {\n                // A test function object with a custom `toJSON` method.\n                (value = function value() {\n                  return 1;\n                }).toJSON = value;\n                try {\n                  stringifySupported =\n                  // Firefox 3.1b1 and b2 serialize string, number, and boolean\n                  // primitives as object literals.\n                  stringify(0) === \"0\" &&\n                  // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object\n                  // literals.\n                  stringify(new Number()) === \"0\" && stringify(new String()) == '\"\"' &&\n                  // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or\n                  // does not define a canonical JSON representation (this applies to\n                  // objects with `toJSON` properties as well, *unless* they are nested\n                  // within an object or array).\n                  stringify(getClass) === undef &&\n                  // IE 8 serializes `undefined` as `\"undefined\"`. Safari <= 5.1.7 and\n                  // FF 3.1b3 pass this test.\n                  stringify(undef) === undef &&\n                  // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,\n                  // respectively, if the value is omitted entirely.\n                  stringify() === undef &&\n                  // FF 3.1b1, 2 throw an error if the given value is not a number,\n                  // string, array, object, Boolean, or `null` literal. This applies to\n                  // objects with custom `toJSON` methods as well, unless they are nested\n                  // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`\n                  // methods entirely.\n                  stringify(value) === \"1\" && stringify([value]) == \"[1]\" &&\n                  // Prototype <= 1.6.1 serializes `[undefined]` as `\"[]\"` instead of\n                  // `\"[null]\"`.\n                  stringify([undef]) == \"[null]\" &&\n                  // YUI 3.0.0b1 fails to serialize `null` literals.\n                  stringify(null) == \"null\" &&\n                  // FF 3.1b1, 2 halts serialization if an array contains a function:\n                  // `[1, true, getClass, 1]` serializes as \"[1,true,],\". FF 3.1b3\n                  // elides non-JSON values from objects and arrays, unless they\n                  // define custom `toJSON` methods.\n                  stringify([undef, getClass, null]) == \"[null,null,null]\" &&\n                  // Simple serialization test. FF 3.1b1 uses Unicode escape sequences\n                  // where character escape codes are expected (e.g., `\\b` => `\\u0008`).\n                  stringify({ \"a\": [value, true, false, null, \"\\x00\\b\\n\\f\\r\\t\"] }) == serialized &&\n                  // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.\n                  stringify(null, value) === \"1\" && stringify([1, 2], null, 1) == \"[\\n 1,\\n 2\\n]\" &&\n                  // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly\n                  // serialize extended years.\n                  stringify(new Date(-8.64e15)) == '\"-271821-04-20T00:00:00.000Z\"' &&\n                  // The milliseconds are optional in ES 5, but required in 5.1.\n                  stringify(new Date(8.64e15)) == '\"+275760-09-13T00:00:00.000Z\"' &&\n                  // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative\n                  // four-digit years instead of six-digit years. Credits: @Yaffle.\n                  stringify(new Date(-621987552e5)) == '\"-000001-01-01T00:00:00.000Z\"' &&\n                  // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond\n                  // values less than 1000. Credits: @Yaffle.\n                  stringify(new Date(-1)) == '\"1969-12-31T23:59:59.999Z\"';\n                } catch (exception) {\n                  stringifySupported = false;\n                }\n              }\n              isSupported = stringifySupported;\n            }\n            // Test `JSON.parse`.\n            if (name == \"json-parse\") {\n              var parse = exports.parse;\n              if (typeof parse == \"function\") {\n                try {\n                  // FF 3.1b1, b2 will throw an exception if a bare literal is provided.\n                  // Conforming implementations should also coerce the initial argument to\n                  // a string prior to parsing.\n                  if (parse(\"0\") === 0 && !parse(false)) {\n                    // Simple parsing test.\n                    value = parse(serialized);\n                    var parseSupported = value[\"a\"].length == 5 && value[\"a\"][0] === 1;\n                    if (parseSupported) {\n                      try {\n                        // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.\n                        parseSupported = !parse('\"\\t\"');\n                      } catch (exception) {}\n                      if (parseSupported) {\n                        try {\n                          // FF 4.0 and 4.0.1 allow leading `+` signs and leading\n                          // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow\n                          // certain octal literals.\n                          parseSupported = parse(\"01\") !== 1;\n                        } catch (exception) {}\n                      }\n                      if (parseSupported) {\n                        try {\n                          // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal\n                          // points. These environments, along with FF 3.1b1 and 2,\n                          // also allow trailing commas in JSON objects and arrays.\n                          parseSupported = parse(\"1.\") !== 1;\n                        } catch (exception) {}\n                      }\n                    }\n                  }\n                } catch (exception) {\n                  parseSupported = false;\n                }\n              }\n              isSupported = parseSupported;\n            }\n          }\n          return has[name] = !!isSupported;\n        }\n\n        if (!has(\"json\")) {\n          // Common `[[Class]]` name aliases.\n          var functionClass = \"[object Function]\",\n              dateClass = \"[object Date]\",\n              numberClass = \"[object Number]\",\n              stringClass = \"[object String]\",\n              arrayClass = \"[object Array]\",\n              booleanClass = \"[object Boolean]\";\n\n          // Detect incomplete support for accessing string characters by index.\n          var charIndexBuggy = has(\"bug-string-char-index\");\n\n          // Define additional utility methods if the `Date` methods are buggy.\n          if (!isExtended) {\n            var floor = Math.floor;\n            // A mapping between the months of the year and the number of days between\n            // January 1st and the first of the respective month.\n            var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n            // Internal: Calculates the number of days between the Unix epoch and the\n            // first day of the given month.\n            var getDay = function getDay(year, month) {\n              return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\n            };\n          }\n\n          // Internal: Determines if a property is a direct property of the given\n          // object. Delegates to the native `Object#hasOwnProperty` method.\n          if (!(_isProperty = objectProto.hasOwnProperty)) {\n            _isProperty = function isProperty(property) {\n              var members = {},\n                  constructor;\n              if ((members.__proto__ = null, members.__proto__ = {\n                // The *proto* property cannot be set multiple times in recent\n                // versions of Firefox and SeaMonkey.\n                \"toString\": 1\n              }, members).toString != getClass) {\n                // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but\n                // supports the mutable *proto* property.\n                _isProperty = function isProperty(property) {\n                  // Capture and break the object's prototype chain (see section 8.6.2\n                  // of the ES 5.1 spec). The parenthesized expression prevents an\n                  // unsafe transformation by the Closure Compiler.\n                  var original = this.__proto__,\n                      result = property in (this.__proto__ = null, this);\n                  // Restore the original prototype chain.\n                  this.__proto__ = original;\n                  return result;\n                };\n              } else {\n                // Capture a reference to the top-level `Object` constructor.\n                constructor = members.constructor;\n                // Use the `constructor` property to simulate `Object#hasOwnProperty` in\n                // other environments.\n                _isProperty = function isProperty(property) {\n                  var parent = (this.constructor || constructor).prototype;\n                  return property in this && !(property in parent && this[property] === parent[property]);\n                };\n              }\n              members = null;\n              return _isProperty.call(this, property);\n            };\n          }\n\n          // Internal: Normalizes the `for...in` iteration algorithm across\n          // environments. Each enumerated key is yielded to a `callback` function.\n          _forEach = function forEach(object, callback) {\n            var size = 0,\n                Properties,\n                members,\n                property;\n\n            // Tests for bugs in the current environment's `for...in` algorithm. The\n            // `valueOf` property inherits the non-enumerable flag from\n            // `Object.prototype` in older versions of IE, Netscape, and Mozilla.\n            (Properties = function Properties() {\n              this.valueOf = 0;\n            }).prototype.valueOf = 0;\n\n            // Iterate over a new instance of the `Properties` class.\n            members = new Properties();\n            for (property in members) {\n              // Ignore all properties inherited from `Object.prototype`.\n              if (_isProperty.call(members, property)) {\n                size++;\n              }\n            }\n            Properties = members = null;\n\n            // Normalize the iteration algorithm.\n            if (!size) {\n              // A list of non-enumerable properties inherited from `Object.prototype`.\n              members = [\"valueOf\", \"toString\", \"toLocaleString\", \"propertyIsEnumerable\", \"isPrototypeOf\", \"hasOwnProperty\", \"constructor\"];\n              // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable\n              // properties.\n              _forEach = function forEach(object, callback) {\n                var isFunction = getClass.call(object) == functionClass,\n                    property,\n                    length;\n                var hasProperty = !isFunction && typeof object.constructor != \"function\" && objectTypes[_typeof2(object.hasOwnProperty)] && object.hasOwnProperty || _isProperty;\n                for (property in object) {\n                  // Gecko <= 1.0 enumerates the `prototype` property of functions under\n                  // certain conditions; IE does not.\n                  if (!(isFunction && property == \"prototype\") && hasProperty.call(object, property)) {\n                    callback(property);\n                  }\n                }\n                // Manually invoke the callback for each non-enumerable property.\n                for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property)) {}\n              };\n            } else if (size == 2) {\n              // Safari <= 2.0.4 enumerates shadowed properties twice.\n              _forEach = function forEach(object, callback) {\n                // Create a set of iterated properties.\n                var members = {},\n                    isFunction = getClass.call(object) == functionClass,\n                    property;\n                for (property in object) {\n                  // Store each property name to prevent double enumeration. The\n                  // `prototype` property of functions is not enumerated due to cross-\n                  // environment inconsistencies.\n                  if (!(isFunction && property == \"prototype\") && !_isProperty.call(members, property) && (members[property] = 1) && _isProperty.call(object, property)) {\n                    callback(property);\n                  }\n                }\n              };\n            } else {\n              // No bugs detected; use the standard `for...in` algorithm.\n              _forEach = function forEach(object, callback) {\n                var isFunction = getClass.call(object) == functionClass,\n                    property,\n                    isConstructor;\n                for (property in object) {\n                  if (!(isFunction && property == \"prototype\") && _isProperty.call(object, property) && !(isConstructor = property === \"constructor\")) {\n                    callback(property);\n                  }\n                }\n                // Manually invoke the callback for the `constructor` property due to\n                // cross-environment inconsistencies.\n                if (isConstructor || _isProperty.call(object, property = \"constructor\")) {\n                  callback(property);\n                }\n              };\n            }\n            return _forEach(object, callback);\n          };\n\n          // Public: Serializes a JavaScript `value` as a JSON string. The optional\n          // `filter` argument may specify either a function that alters how object and\n          // array members are serialized, or an array of strings and numbers that\n          // indicates which properties should be serialized. The optional `width`\n          // argument may be either a string or number that specifies the indentation\n          // level of the output.\n          if (!has(\"json-stringify\")) {\n            // Internal: A map of control characters and their escaped equivalents.\n            var Escapes = {\n              92: \"\\\\\\\\\",\n              34: '\\\\\"',\n              8: \"\\\\b\",\n              12: \"\\\\f\",\n              10: \"\\\\n\",\n              13: \"\\\\r\",\n              9: \"\\\\t\"\n            };\n\n            // Internal: Converts `value` into a zero-padded string such that its\n            // length is at least equal to `width`. The `width` must be <= 6.\n            var leadingZeroes = \"000000\";\n            var toPaddedString = function toPaddedString(width, value) {\n              // The `|| 0` expression is necessary to work around a bug in\n              // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== \"0\"`.\n              return (leadingZeroes + (value || 0)).slice(-width);\n            };\n\n            // Internal: Double-quotes a string `value`, replacing all ASCII control\n            // characters (characters with code unit values between 0 and 31) with\n            // their escaped equivalents. This is an implementation of the\n            // `Quote(value)` operation defined in ES 5.1 section 15.12.3.\n            var unicodePrefix = '\\\\u00';\n            var quote = function quote(value) {\n              var result = '\"',\n                  index = 0,\n                  length = value.length,\n                  useCharIndex = !charIndexBuggy || length > 10;\n              var symbols = useCharIndex && (charIndexBuggy ? value.split(\"\") : value);\n              for (; index < length; index++) {\n                var charCode = value.charCodeAt(index);\n                // If the character is a control character, append its Unicode or\n                // shorthand escape sequence; otherwise, append the character as-is.\n                switch (charCode) {\n                  case 8:case 9:case 10:case 12:case 13:case 34:case 92:\n                    result += Escapes[charCode];\n                    break;\n                  default:\n                    if (charCode < 32) {\n                      result += unicodePrefix + toPaddedString(2, charCode.toString(16));\n                      break;\n                    }\n                    result += useCharIndex ? symbols[index] : value.charAt(index);\n                }\n              }\n              return result + '\"';\n            };\n\n            // Internal: Recursively serializes an object. Implements the\n            // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.\n            var serialize = function serialize(property, object, callback, properties, whitespace, indentation, stack) {\n              var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;\n              try {\n                // Necessary for host object support.\n                value = object[property];\n              } catch (exception) {}\n              if ((typeof value === 'undefined' ? 'undefined' : _typeof2(value)) == \"object\" && value) {\n                className = getClass.call(value);\n                if (className == dateClass && !_isProperty.call(value, \"toJSON\")) {\n                  if (value > -1 / 0 && value < 1 / 0) {\n                    // Dates are serialized according to the `Date#toJSON` method\n                    // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15\n                    // for the ISO 8601 date time string format.\n                    if (getDay) {\n                      // Manually compute the year, month, date, hours, minutes,\n                      // seconds, and milliseconds if the `getUTC*` methods are\n                      // buggy. Adapted from @Yaffle's `date-shim` project.\n                      date = floor(value / 864e5);\n                      for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++) {}\n                      for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++) {}\n                      date = 1 + date - getDay(year, month);\n                      // The `time` value specifies the time within the day (see ES\n                      // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used\n                      // to compute `A modulo B`, as the `%` operator does not\n                      // correspond to the `modulo` operation for negative numbers.\n                      time = (value % 864e5 + 864e5) % 864e5;\n                      // The hours, minutes, seconds, and milliseconds are obtained by\n                      // decomposing the time within the day. See section 15.9.1.10.\n                      hours = floor(time / 36e5) % 24;\n                      minutes = floor(time / 6e4) % 60;\n                      seconds = floor(time / 1e3) % 60;\n                      milliseconds = time % 1e3;\n                    } else {\n                      year = value.getUTCFullYear();\n                      month = value.getUTCMonth();\n                      date = value.getUTCDate();\n                      hours = value.getUTCHours();\n                      minutes = value.getUTCMinutes();\n                      seconds = value.getUTCSeconds();\n                      milliseconds = value.getUTCMilliseconds();\n                    }\n                    // Serialize extended years correctly.\n                    value = (year <= 0 || year >= 1e4 ? (year < 0 ? \"-\" : \"+\") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) + \"-\" + toPaddedString(2, month + 1) + \"-\" + toPaddedString(2, date) +\n                    // Months, dates, hours, minutes, and seconds should have two\n                    // digits; milliseconds should have three.\n                    \"T\" + toPaddedString(2, hours) + \":\" + toPaddedString(2, minutes) + \":\" + toPaddedString(2, seconds) +\n                    // Milliseconds are optional in ES 5.0, but required in 5.1.\n                    \".\" + toPaddedString(3, milliseconds) + \"Z\";\n                  } else {\n                    value = null;\n                  }\n                } else if (typeof value.toJSON == \"function\" && (className != numberClass && className != stringClass && className != arrayClass || _isProperty.call(value, \"toJSON\"))) {\n                  // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the\n                  // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3\n                  // ignores all `toJSON` methods on these objects unless they are\n                  // defined directly on an instance.\n                  value = value.toJSON(property);\n                }\n              }\n              if (callback) {\n                // If a replacement function was provided, call it to obtain the value\n                // for serialization.\n                value = callback.call(object, property, value);\n              }\n              if (value === null) {\n                return \"null\";\n              }\n              className = getClass.call(value);\n              if (className == booleanClass) {\n                // Booleans are represented literally.\n                return \"\" + value;\n              } else if (className == numberClass) {\n                // JSON numbers must be finite. `Infinity` and `NaN` are serialized as\n                // `\"null\"`.\n                return value > -1 / 0 && value < 1 / 0 ? \"\" + value : \"null\";\n              } else if (className == stringClass) {\n                // Strings are double-quoted and escaped.\n                return quote(\"\" + value);\n              }\n              // Recursively serialize objects and arrays.\n              if ((typeof value === 'undefined' ? 'undefined' : _typeof2(value)) == \"object\") {\n                // Check for cyclic structures. This is a linear search; performance\n                // is inversely proportional to the number of unique nested objects.\n                for (length = stack.length; length--;) {\n                  if (stack[length] === value) {\n                    // Cyclic structures cannot be serialized by `JSON.stringify`.\n                    throw TypeError();\n                  }\n                }\n                // Add the object to the stack of traversed objects.\n                stack.push(value);\n                results = [];\n                // Save the current indentation level and indent one additional level.\n                prefix = indentation;\n                indentation += whitespace;\n                if (className == arrayClass) {\n                  // Recursively serialize array elements.\n                  for (index = 0, length = value.length; index < length; index++) {\n                    element = serialize(index, value, callback, properties, whitespace, indentation, stack);\n                    results.push(element === undef ? \"null\" : element);\n                  }\n                  result = results.length ? whitespace ? \"[\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"]\" : \"[\" + results.join(\",\") + \"]\" : \"[]\";\n                } else {\n                  // Recursively serialize object members. Members are selected from\n                  // either a user-specified list of property names, or the object\n                  // itself.\n                  _forEach(properties || value, function (property) {\n                    var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\n                    if (element !== undef) {\n                      // According to ES 5.1 section 15.12.3: \"If `gap` {whitespace}\n                      // is not the empty string, let `member` {quote(property) + \":\"}\n                      // be the concatenation of `member` and the `space` character.\"\n                      // The \"`space` character\" refers to the literal space\n                      // character, not the `space` {width} argument provided to\n                      // `JSON.stringify`.\n                      results.push(quote(property) + \":\" + (whitespace ? \" \" : \"\") + element);\n                    }\n                  });\n                  result = results.length ? whitespace ? \"{\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"}\" : \"{\" + results.join(\",\") + \"}\" : \"{}\";\n                }\n                // Remove the object from the traversed object stack.\n                stack.pop();\n                return result;\n              }\n            };\n\n            // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.\n            exports.stringify = function (source, filter, width) {\n              var whitespace, callback, properties, className;\n              if (objectTypes[typeof filter === 'undefined' ? 'undefined' : _typeof2(filter)] && filter) {\n                if ((className = getClass.call(filter)) == functionClass) {\n                  callback = filter;\n                } else if (className == arrayClass) {\n                  // Convert the property names array into a makeshift set.\n                  properties = {};\n                  for (var index = 0, length = filter.length, value; index < length; value = filter[index++], (className = getClass.call(value), className == stringClass || className == numberClass) && (properties[value] = 1)) {}\n                }\n              }\n              if (width) {\n                if ((className = getClass.call(width)) == numberClass) {\n                  // Convert the `width` to an integer and create a string containing\n                  // `width` number of space characters.\n                  if ((width -= width % 1) > 0) {\n                    for (whitespace = \"\", width > 10 && (width = 10); whitespace.length < width; whitespace += \" \") {}\n                  }\n                } else if (className == stringClass) {\n                  whitespace = width.length <= 10 ? width : width.slice(0, 10);\n                }\n              }\n              // Opera <= 7.54u2 discards the values associated with empty string keys\n              // (`\"\"`) only if they are used directly within an object member list\n              // (e.g., `!(\"\" in { \"\": 1})`).\n              return serialize(\"\", (value = {}, value[\"\"] = source, value), callback, properties, whitespace, \"\", []);\n            };\n          }\n\n          // Public: Parses a JSON source string.\n          if (!has(\"json-parse\")) {\n            var fromCharCode = String.fromCharCode;\n\n            // Internal: A map of escaped control characters and their unescaped\n            // equivalents.\n            var Unescapes = {\n              92: \"\\\\\",\n              34: '\"',\n              47: \"/\",\n              98: \"\\b\",\n              116: \"\\t\",\n              110: \"\\n\",\n              102: \"\\f\",\n              114: \"\\r\"\n            };\n\n            // Internal: Stores the parser state.\n            var Index, Source;\n\n            // Internal: Resets the parser state and throws a `SyntaxError`.\n            var abort = function abort() {\n              Index = Source = null;\n              throw SyntaxError();\n            };\n\n            // Internal: Returns the next token, or `\"$\"` if the parser has reached\n            // the end of the source string. A token may be a string, number, `null`\n            // literal, or Boolean literal.\n            var lex = function lex() {\n              var source = Source,\n                  length = source.length,\n                  value,\n                  begin,\n                  position,\n                  isSigned,\n                  charCode;\n              while (Index < length) {\n                charCode = source.charCodeAt(Index);\n                switch (charCode) {\n                  case 9:case 10:case 13:case 32:\n                    // Skip whitespace tokens, including tabs, carriage returns, line\n                    // feeds, and space characters.\n                    Index++;\n                    break;\n                  case 123:case 125:case 91:case 93:case 58:case 44:\n                    // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at\n                    // the current position.\n                    value = charIndexBuggy ? source.charAt(Index) : source[Index];\n                    Index++;\n                    return value;\n                  case 34:\n                    // `\"` delimits a JSON string; advance to the next character and\n                    // begin parsing the string. String tokens are prefixed with the\n                    // sentinel `@` character to distinguish them from punctuators and\n                    // end-of-string tokens.\n                    for (value = \"@\", Index++; Index < length;) {\n                      charCode = source.charCodeAt(Index);\n                      if (charCode < 32) {\n                        // Unescaped ASCII control characters (those with a code unit\n                        // less than the space character) are not permitted.\n                        abort();\n                      } else if (charCode == 92) {\n                        // A reverse solidus (`\\`) marks the beginning of an escaped\n                        // control character (including `\"`, `\\`, and `/`) or Unicode\n                        // escape sequence.\n                        charCode = source.charCodeAt(++Index);\n                        switch (charCode) {\n                          case 92:case 34:case 47:case 98:case 116:case 110:case 102:case 114:\n                            // Revive escaped control characters.\n                            value += Unescapes[charCode];\n                            Index++;\n                            break;\n                          case 117:\n                            // `\\u` marks the beginning of a Unicode escape sequence.\n                            // Advance to the first character and validate the\n                            // four-digit code point.\n                            begin = ++Index;\n                            for (position = Index + 4; Index < position; Index++) {\n                              charCode = source.charCodeAt(Index);\n                              // A valid sequence comprises four hexdigits (case-\n                              // insensitive) that form a single hexadecimal value.\n                              if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {\n                                // Invalid Unicode escape sequence.\n                                abort();\n                              }\n                            }\n                            // Revive the escaped character.\n                            value += fromCharCode(\"0x\" + source.slice(begin, Index));\n                            break;\n                          default:\n                            // Invalid escape sequence.\n                            abort();\n                        }\n                      } else {\n                        if (charCode == 34) {\n                          // An unescaped double-quote character marks the end of the\n                          // string.\n                          break;\n                        }\n                        charCode = source.charCodeAt(Index);\n                        begin = Index;\n                        // Optimize for the common case where a string is valid.\n                        while (charCode >= 32 && charCode != 92 && charCode != 34) {\n                          charCode = source.charCodeAt(++Index);\n                        }\n                        // Append the string as-is.\n                        value += source.slice(begin, Index);\n                      }\n                    }\n                    if (source.charCodeAt(Index) == 34) {\n                      // Advance to the next character and return the revived string.\n                      Index++;\n                      return value;\n                    }\n                    // Unterminated string.\n                    abort();\n                  default:\n                    // Parse numbers and literals.\n                    begin = Index;\n                    // Advance past the negative sign, if one is specified.\n                    if (charCode == 45) {\n                      isSigned = true;\n                      charCode = source.charCodeAt(++Index);\n                    }\n                    // Parse an integer or floating-point value.\n                    if (charCode >= 48 && charCode <= 57) {\n                      // Leading zeroes are interpreted as octal literals.\n                      if (charCode == 48 && (charCode = source.charCodeAt(Index + 1), charCode >= 48 && charCode <= 57)) {\n                        // Illegal octal literal.\n                        abort();\n                      }\n                      isSigned = false;\n                      // Parse the integer component.\n                      for (; Index < length && (charCode = source.charCodeAt(Index), charCode >= 48 && charCode <= 57); Index++) {}\n                      // Floats cannot contain a leading decimal point; however, this\n                      // case is already accounted for by the parser.\n                      if (source.charCodeAt(Index) == 46) {\n                        position = ++Index;\n                        // Parse the decimal component.\n                        for (; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++) {}\n                        if (position == Index) {\n                          // Illegal trailing decimal.\n                          abort();\n                        }\n                        Index = position;\n                      }\n                      // Parse exponents. The `e` denoting the exponent is\n                      // case-insensitive.\n                      charCode = source.charCodeAt(Index);\n                      if (charCode == 101 || charCode == 69) {\n                        charCode = source.charCodeAt(++Index);\n                        // Skip past the sign following the exponent, if one is\n                        // specified.\n                        if (charCode == 43 || charCode == 45) {\n                          Index++;\n                        }\n                        // Parse the exponential component.\n                        for (position = Index; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++) {}\n                        if (position == Index) {\n                          // Illegal empty exponent.\n                          abort();\n                        }\n                        Index = position;\n                      }\n                      // Coerce the parsed value to a JavaScript number.\n                      return +source.slice(begin, Index);\n                    }\n                    // A negative sign may only precede numbers.\n                    if (isSigned) {\n                      abort();\n                    }\n                    // `true`, `false`, and `null` literals.\n                    if (source.slice(Index, Index + 4) == \"true\") {\n                      Index += 4;\n                      return true;\n                    } else if (source.slice(Index, Index + 5) == \"false\") {\n                      Index += 5;\n                      return false;\n                    } else if (source.slice(Index, Index + 4) == \"null\") {\n                      Index += 4;\n                      return null;\n                    }\n                    // Unrecognized token.\n                    abort();\n                }\n              }\n              // Return the sentinel `$` character if the parser has reached the end\n              // of the source string.\n              return \"$\";\n            };\n\n            // Internal: Parses a JSON `value` token.\n            var get = function get(value) {\n              var results, hasMembers;\n              if (value == \"$\") {\n                // Unexpected end of input.\n                abort();\n              }\n              if (typeof value == \"string\") {\n                if ((charIndexBuggy ? value.charAt(0) : value[0]) == \"@\") {\n                  // Remove the sentinel `@` character.\n                  return value.slice(1);\n                }\n                // Parse object and array literals.\n                if (value == \"[\") {\n                  // Parses a JSON array, returning a new JavaScript array.\n                  results = [];\n                  for (;; hasMembers || (hasMembers = true)) {\n                    value = lex();\n                    // A closing square bracket marks the end of the array literal.\n                    if (value == \"]\") {\n                      break;\n                    }\n                    // If the array literal contains elements, the current token\n                    // should be a comma separating the previous element from the\n                    // next.\n                    if (hasMembers) {\n                      if (value == \",\") {\n                        value = lex();\n                        if (value == \"]\") {\n                          // Unexpected trailing `,` in array literal.\n                          abort();\n                        }\n                      } else {\n                        // A `,` must separate each array element.\n                        abort();\n                      }\n                    }\n                    // Elisions and leading commas are not permitted.\n                    if (value == \",\") {\n                      abort();\n                    }\n                    results.push(get(value));\n                  }\n                  return results;\n                } else if (value == \"{\") {\n                  // Parses a JSON object, returning a new JavaScript object.\n                  results = {};\n                  for (;; hasMembers || (hasMembers = true)) {\n                    value = lex();\n                    // A closing curly brace marks the end of the object literal.\n                    if (value == \"}\") {\n                      break;\n                    }\n                    // If the object literal contains members, the current token\n                    // should be a comma separator.\n                    if (hasMembers) {\n                      if (value == \",\") {\n                        value = lex();\n                        if (value == \"}\") {\n                          // Unexpected trailing `,` in object literal.\n                          abort();\n                        }\n                      } else {\n                        // A `,` must separate each object member.\n                        abort();\n                      }\n                    }\n                    // Leading commas are not permitted, object property names must be\n                    // double-quoted strings, and a `:` must separate each property\n                    // name and value.\n                    if (value == \",\" || typeof value != \"string\" || (charIndexBuggy ? value.charAt(0) : value[0]) != \"@\" || lex() != \":\") {\n                      abort();\n                    }\n                    results[value.slice(1)] = get(lex());\n                  }\n                  return results;\n                }\n                // Unexpected token encountered.\n                abort();\n              }\n              return value;\n            };\n\n            // Internal: Updates a traversed object member.\n            var update = function update(source, property, callback) {\n              var element = walk(source, property, callback);\n              if (element === undef) {\n                delete source[property];\n              } else {\n                source[property] = element;\n              }\n            };\n\n            // Internal: Recursively traverses a parsed JSON object, invoking the\n            // `callback` function for each value. This is an implementation of the\n            // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.\n            var walk = function walk(source, property, callback) {\n              var value = source[property],\n                  length;\n              if ((typeof value === 'undefined' ? 'undefined' : _typeof2(value)) == \"object\" && value) {\n                // `forEach` can't be used to traverse an array in Opera <= 8.54\n                // because its `Object#hasOwnProperty` implementation returns `false`\n                // for array indices (e.g., `![1, 2, 3].hasOwnProperty(\"0\")`).\n                if (getClass.call(value) == arrayClass) {\n                  for (length = value.length; length--;) {\n                    update(value, length, callback);\n                  }\n                } else {\n                  _forEach(value, function (property) {\n                    update(value, property, callback);\n                  });\n                }\n              }\n              return callback.call(source, property, value);\n            };\n\n            // Public: `JSON.parse`. See ES 5.1 section 15.12.2.\n            exports.parse = function (source, callback) {\n              var result, value;\n              Index = 0;\n              Source = \"\" + source;\n              result = get(lex());\n              // If a JSON string contains multiple tokens, it is invalid.\n              if (lex() != \"$\") {\n                abort();\n              }\n              // Reset the parser state.\n              Index = Source = null;\n              return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[\"\"] = result, value), \"\", callback) : result;\n            };\n          }\n        }\n\n        exports[\"runInContext\"] = runInContext;\n        return exports;\n      }\n\n      if (freeExports && !isLoader) {\n        // Export for CommonJS environments.\n        runInContext(root, freeExports);\n      } else {\n        // Export for web browsers and JavaScript engines.\n        var nativeJSON = root.JSON,\n            previousJSON = root[\"JSON3\"],\n            isRestored = false;\n\n        var JSON3 = runInContext(root, root[\"JSON3\"] = {\n          // Public: Restores the original value of the global `JSON` object and\n          // returns a reference to the `JSON3` object.\n          \"noConflict\": function noConflict() {\n            if (!isRestored) {\n              isRestored = true;\n              root.JSON = nativeJSON;\n              root[\"JSON3\"] = previousJSON;\n              nativeJSON = previousJSON = null;\n            }\n            return JSON3;\n          }\n        });\n\n        root.JSON = {\n          \"parse\": JSON3.parse,\n          \"stringify\": JSON3.stringify\n        };\n      }\n\n      // Export for asynchronous module loaders.\n      if (isLoader) {\n        undefined(function () {\n          return JSON3;\n        });\n      }\n    }).call(commonjsGlobal);\n  });\n\n  var constants = {\n    DEFAULT_INSTANCE: '$default_instance',\n    API_VERSION: 2,\n    MAX_STRING_LENGTH: 4096,\n    MAX_PROPERTY_KEYS: 1000,\n    IDENTIFY_EVENT: '$identify',\n\n    // localStorageKeys\n    LAST_EVENT_ID: 'amplitude_lastEventId',\n    LAST_EVENT_TIME: 'amplitude_lastEventTime',\n    LAST_IDENTIFY_ID: 'amplitude_lastIdentifyId',\n    LAST_SEQUENCE_NUMBER: 'amplitude_lastSequenceNumber',\n    SESSION_ID: 'amplitude_sessionId',\n\n    // Used in cookie as well\n    DEVICE_ID: 'amplitude_deviceId',\n    OPT_OUT: 'amplitude_optOut',\n    USER_ID: 'amplitude_userId',\n\n    COOKIE_TEST: 'amplitude_cookie_test',\n\n    // revenue keys\n    REVENUE_EVENT: 'revenue_amount',\n    REVENUE_PRODUCT_ID: '$productId',\n    REVENUE_QUANTITY: '$quantity',\n    REVENUE_PRICE: '$price',\n    REVENUE_REVENUE_TYPE: '$revenueType',\n\n    AMP_DEVICE_ID_PARAM: 'amp_device_id' // url param\n  };\n\n  /* jshint bitwise: false */\n\n  /*\n   * UTF-8 encoder/decoder\n   * http://www.webtoolkit.info/\n   */\n  var UTF8 = {\n    encode: function encode(s) {\n      var utftext = '';\n\n      for (var n = 0; n < s.length; n++) {\n        var c = s.charCodeAt(n);\n\n        if (c < 128) {\n          utftext += String.fromCharCode(c);\n        } else if (c > 127 && c < 2048) {\n          utftext += String.fromCharCode(c >> 6 | 192);\n          utftext += String.fromCharCode(c & 63 | 128);\n        } else {\n          utftext += String.fromCharCode(c >> 12 | 224);\n          utftext += String.fromCharCode(c >> 6 & 63 | 128);\n          utftext += String.fromCharCode(c & 63 | 128);\n        }\n      }\n      return utftext;\n    },\n\n    decode: function decode(utftext) {\n      var s = '';\n      var i = 0;\n      var c = 0,\n          c1 = 0,\n          c2 = 0;\n\n      while (i < utftext.length) {\n        c = utftext.charCodeAt(i);\n        if (c < 128) {\n          s += String.fromCharCode(c);\n          i++;\n        } else if (c > 191 && c < 224) {\n          c1 = utftext.charCodeAt(i + 1);\n          s += String.fromCharCode((c & 31) << 6 | c1 & 63);\n          i += 2;\n        } else {\n          c1 = utftext.charCodeAt(i + 1);\n          c2 = utftext.charCodeAt(i + 2);\n          s += String.fromCharCode((c & 15) << 12 | (c1 & 63) << 6 | c2 & 63);\n          i += 3;\n        }\n      }\n      return s;\n    }\n  };\n\n  /* jshint bitwise: false */\n  /* global escape, unescape */\n\n  /*\n   * Base64 encoder/decoder\n   * http://www.webtoolkit.info/\n   */\n  var Base64 = {\n    _keyStr: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n\n    encode: function encode(input) {\n      try {\n        if (window.btoa && window.atob) {\n          return window.btoa(unescape(encodeURIComponent(input)));\n        }\n      } catch (e) {\n        //log(e);\n      }\n      return Base64._encode(input);\n    },\n\n    _encode: function _encode(input) {\n      var output = '';\n      var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n      var i = 0;\n\n      input = UTF8.encode(input);\n\n      while (i < input.length) {\n        chr1 = input.charCodeAt(i++);\n        chr2 = input.charCodeAt(i++);\n        chr3 = input.charCodeAt(i++);\n\n        enc1 = chr1 >> 2;\n        enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n        enc3 = (chr2 & 15) << 2 | chr3 >> 6;\n        enc4 = chr3 & 63;\n\n        if (isNaN(chr2)) {\n          enc3 = enc4 = 64;\n        } else if (isNaN(chr3)) {\n          enc4 = 64;\n        }\n\n        output = output + Base64._keyStr.charAt(enc1) + Base64._keyStr.charAt(enc2) + Base64._keyStr.charAt(enc3) + Base64._keyStr.charAt(enc4);\n      }\n      return output;\n    },\n\n    decode: function decode(input) {\n      try {\n        if (window.btoa && window.atob) {\n          return decodeURIComponent(escape(window.atob(input)));\n        }\n      } catch (e) {\n        //log(e);\n      }\n      return Base64._decode(input);\n    },\n\n    _decode: function _decode(input) {\n      var output = '';\n      var chr1, chr2, chr3;\n      var enc1, enc2, enc3, enc4;\n      var i = 0;\n\n      input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n\n      while (i < input.length) {\n        enc1 = Base64._keyStr.indexOf(input.charAt(i++));\n        enc2 = Base64._keyStr.indexOf(input.charAt(i++));\n        enc3 = Base64._keyStr.indexOf(input.charAt(i++));\n        enc4 = Base64._keyStr.indexOf(input.charAt(i++));\n\n        chr1 = enc1 << 2 | enc2 >> 4;\n        chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n        chr3 = (enc3 & 3) << 6 | enc4;\n\n        output = output + String.fromCharCode(chr1);\n\n        if (enc3 !== 64) {\n          output = output + String.fromCharCode(chr2);\n        }\n        if (enc4 !== 64) {\n          output = output + String.fromCharCode(chr3);\n        }\n      }\n      output = UTF8.decode(output);\n      return output;\n    }\n  };\n\n  var componentUrl = createCommonjsModule(function (module, exports) {\n    /**\n     * Parse the given `url`.\n     *\n     * @param {String} str\n     * @return {Object}\n     * @api public\n     */\n\n    exports.parse = function (url) {\n      var a = document.createElement('a');\n      a.href = url;\n      return {\n        href: a.href,\n        host: a.host || location.host,\n        port: '0' === a.port || '' === a.port ? port(a.protocol) : a.port,\n        hash: a.hash,\n        hostname: a.hostname || location.hostname,\n        pathname: a.pathname.charAt(0) != '/' ? '/' + a.pathname : a.pathname,\n        protocol: !a.protocol || ':' == a.protocol ? location.protocol : a.protocol,\n        search: a.search,\n        query: a.search.slice(1)\n      };\n    };\n\n    /**\n     * Check if `url` is absolute.\n     *\n     * @param {String} url\n     * @return {Boolean}\n     * @api public\n     */\n\n    exports.isAbsolute = function (url) {\n      return 0 == url.indexOf('//') || !!~url.indexOf('://');\n    };\n\n    /**\n     * Check if `url` is relative.\n     *\n     * @param {String} url\n     * @return {Boolean}\n     * @api public\n     */\n\n    exports.isRelative = function (url) {\n      return !exports.isAbsolute(url);\n    };\n\n    /**\n     * Check if `url` is cross domain.\n     *\n     * @param {String} url\n     * @return {Boolean}\n     * @api public\n     */\n\n    exports.isCrossDomain = function (url) {\n      url = exports.parse(url);\n      var location = exports.parse(window.location.href);\n      return url.hostname !== location.hostname || url.port !== location.port || url.protocol !== location.protocol;\n    };\n\n    /**\n     * Return default port for `protocol`.\n     *\n     * @param  {String} protocol\n     * @return {String}\n     * @api private\n     */\n    function port(protocol) {\n      switch (protocol) {\n        case 'http:':\n          return 80;\n        case 'https:':\n          return 443;\n        default:\n          return location.port;\n      }\n    }\n  });\n\n  /**\n   * Helpers.\n   */\n\n  var s = 1000;\n  var m = s * 60;\n  var h = m * 60;\n  var d = h * 24;\n  var y = d * 365.25;\n\n  /**\n   * Parse or format the given `val`.\n   *\n   * Options:\n   *\n   *  - `long` verbose formatting [false]\n   *\n   * @param {String|Number} val\n   * @param {Object} [options]\n   * @throws {Error} throw an error if val is not a non-empty string or a number\n   * @return {String|Number}\n   * @api public\n   */\n\n  var ms = function ms(val, options) {\n    options = options || {};\n    var type = typeof val === 'undefined' ? 'undefined' : _typeof2(val);\n    if (type === 'string' && val.length > 0) {\n      return parse$1(val);\n    } else if (type === 'number' && isNaN(val) === false) {\n      return options.long ? fmtLong(val) : fmtShort(val);\n    }\n    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));\n  };\n\n  /**\n   * Parse the given `str` and return milliseconds.\n   *\n   * @param {String} str\n   * @return {Number}\n   * @api private\n   */\n\n  function parse$1(str) {\n    str = String(str);\n    if (str.length > 100) {\n      return;\n    }\n    var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n    if (!match) {\n      return;\n    }\n    var n = parseFloat(match[1]);\n    var type = (match[2] || 'ms').toLowerCase();\n    switch (type) {\n      case 'years':\n      case 'year':\n      case 'yrs':\n      case 'yr':\n      case 'y':\n        return n * y;\n      case 'days':\n      case 'day':\n      case 'd':\n        return n * d;\n      case 'hours':\n      case 'hour':\n      case 'hrs':\n      case 'hr':\n      case 'h':\n        return n * h;\n      case 'minutes':\n      case 'minute':\n      case 'mins':\n      case 'min':\n      case 'm':\n        return n * m;\n      case 'seconds':\n      case 'second':\n      case 'secs':\n      case 'sec':\n      case 's':\n        return n * s;\n      case 'milliseconds':\n      case 'millisecond':\n      case 'msecs':\n      case 'msec':\n      case 'ms':\n        return n;\n      default:\n        return undefined;\n    }\n  }\n\n  /**\n   * Short format for `ms`.\n   *\n   * @param {Number} ms\n   * @return {String}\n   * @api private\n   */\n\n  function fmtShort(ms) {\n    if (ms >= d) {\n      return Math.round(ms / d) + 'd';\n    }\n    if (ms >= h) {\n      return Math.round(ms / h) + 'h';\n    }\n    if (ms >= m) {\n      return Math.round(ms / m) + 'm';\n    }\n    if (ms >= s) {\n      return Math.round(ms / s) + 's';\n    }\n    return ms + 'ms';\n  }\n\n  /**\n   * Long format for `ms`.\n   *\n   * @param {Number} ms\n   * @return {String}\n   * @api private\n   */\n\n  function fmtLong(ms) {\n    return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';\n  }\n\n  /**\n   * Pluralization helper.\n   */\n\n  function plural(ms, n, name) {\n    if (ms < n) {\n      return;\n    }\n    if (ms < n * 1.5) {\n      return Math.floor(ms / n) + ' ' + name;\n    }\n    return Math.ceil(ms / n) + ' ' + name + 's';\n  }\n\n  var debug$1 = createCommonjsModule(function (module, exports) {\n    /**\n     * This is the common logic for both the Node.js and web browser\n     * implementations of `debug()`.\n     *\n     * Expose `debug()` as the module.\n     */\n\n    exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\n    exports.coerce = coerce;\n    exports.disable = disable;\n    exports.enable = enable;\n    exports.enabled = enabled;\n    exports.humanize = ms;\n\n    /**\n     * Active `debug` instances.\n     */\n    exports.instances = [];\n\n    /**\n     * The currently active debug mode names, and names to skip.\n     */\n\n    exports.names = [];\n    exports.skips = [];\n\n    /**\n     * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n     *\n     * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n     */\n\n    exports.formatters = {};\n\n    /**\n     * Select a color.\n     * @param {String} namespace\n     * @return {Number}\n     * @api private\n     */\n\n    function selectColor(namespace) {\n      var hash = 0,\n          i;\n\n      for (i in namespace) {\n        hash = (hash << 5) - hash + namespace.charCodeAt(i);\n        hash |= 0; // Convert to 32bit integer\n      }\n\n      return exports.colors[Math.abs(hash) % exports.colors.length];\n    }\n\n    /**\n     * Create a debugger with the given `namespace`.\n     *\n     * @param {String} namespace\n     * @return {Function}\n     * @api public\n     */\n\n    function createDebug(namespace) {\n\n      var prevTime;\n\n      function debug() {\n        // disabled?\n        if (!debug.enabled) return;\n\n        var self = debug;\n\n        // set `diff` timestamp\n        var curr = +new Date();\n        var ms$$1 = curr - (prevTime || curr);\n        self.diff = ms$$1;\n        self.prev = prevTime;\n        self.curr = curr;\n        prevTime = curr;\n\n        // turn the `arguments` into a proper Array\n        var args = new Array(arguments.length);\n        for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i];\n        }\n\n        args[0] = exports.coerce(args[0]);\n\n        if ('string' !== typeof args[0]) {\n          // anything else let's inspect with %O\n          args.unshift('%O');\n        }\n\n        // apply any `formatters` transformations\n        var index = 0;\n        args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n          // if we encounter an escaped % then don't increase the array index\n          if (match === '%%') return match;\n          index++;\n          var formatter = exports.formatters[format];\n          if ('function' === typeof formatter) {\n            var val = args[index];\n            match = formatter.call(self, val);\n\n            // now we need to remove `args[index]` since it's inlined in the `format`\n            args.splice(index, 1);\n            index--;\n          }\n          return match;\n        });\n\n        // apply env-specific formatting (colors, etc.)\n        exports.formatArgs.call(self, args);\n\n        var logFn = debug.log || exports.log || console.log.bind(console);\n        logFn.apply(self, args);\n      }\n\n      debug.namespace = namespace;\n      debug.enabled = exports.enabled(namespace);\n      debug.useColors = exports.useColors();\n      debug.color = selectColor(namespace);\n      debug.destroy = destroy;\n\n      // env-specific initialization logic for debug instances\n      if ('function' === typeof exports.init) {\n        exports.init(debug);\n      }\n\n      exports.instances.push(debug);\n\n      return debug;\n    }\n\n    function destroy() {\n      var index = exports.instances.indexOf(this);\n      if (index !== -1) {\n        exports.instances.splice(index, 1);\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Enables a debug mode by namespaces. This can include modes\n     * separated by a colon and wildcards.\n     *\n     * @param {String} namespaces\n     * @api public\n     */\n\n    function enable(namespaces) {\n      exports.save(namespaces);\n\n      exports.names = [];\n      exports.skips = [];\n\n      var i;\n      var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n      var len = split.length;\n\n      for (i = 0; i < len; i++) {\n        if (!split[i]) continue; // ignore empty strings\n        namespaces = split[i].replace(/\\*/g, '.*?');\n        if (namespaces[0] === '-') {\n          exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n        } else {\n          exports.names.push(new RegExp('^' + namespaces + '$'));\n        }\n      }\n\n      for (i = 0; i < exports.instances.length; i++) {\n        var instance = exports.instances[i];\n        instance.enabled = exports.enabled(instance.namespace);\n      }\n    }\n\n    /**\n     * Disable debug output.\n     *\n     * @api public\n     */\n\n    function disable() {\n      exports.enable('');\n    }\n\n    /**\n     * Returns true if the given mode name is enabled, false otherwise.\n     *\n     * @param {String} name\n     * @return {Boolean}\n     * @api public\n     */\n\n    function enabled(name) {\n      if (name[name.length - 1] === '*') {\n        return true;\n      }\n      var i, len;\n      for (i = 0, len = exports.skips.length; i < len; i++) {\n        if (exports.skips[i].test(name)) {\n          return false;\n        }\n      }\n      for (i = 0, len = exports.names.length; i < len; i++) {\n        if (exports.names[i].test(name)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Coerce `val`.\n     *\n     * @param {Mixed} val\n     * @return {Mixed}\n     * @api private\n     */\n\n    function coerce(val) {\n      if (val instanceof Error) return val.stack || val.message;\n      return val;\n    }\n  });\n\n  var browser = createCommonjsModule(function (module, exports) {\n    /**\n     * This is the web browser implementation of `debug()`.\n     *\n     * Expose `debug()` as the module.\n     */\n\n    exports = module.exports = debug$1;\n    exports.log = log;\n    exports.formatArgs = formatArgs;\n    exports.save = save;\n    exports.load = load;\n    exports.useColors = useColors;\n    exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();\n\n    /**\n     * Colors.\n     */\n\n    exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\n\n    /**\n     * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n     * and the Firebug extension (any Firefox version) are known\n     * to support \"%c\" CSS customizations.\n     *\n     * TODO: add a `localStorage` variable to explicitly enable/disable colors\n     */\n\n    function useColors() {\n      // NB: In an Electron preload script, document will be defined but not fully\n      // initialized. Since we know we're in Chrome, we'll just detect this case\n      // explicitly\n      if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n        return true;\n      }\n\n      // Internet Explorer and Edge do not support colors.\n      if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n        return false;\n      }\n\n      // is webkit? http://stackoverflow.com/a/16459606/376773\n      // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n      return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||\n      // is firebug? http://stackoverflow.com/a/398120/376773\n      typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||\n      // is firefox >= v31?\n      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||\n      // double check webkit in userAgent just in case we are in a worker\n      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n    }\n\n    /**\n     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n     */\n\n    exports.formatters.j = function (v) {\n      try {\n        return JSON.stringify(v);\n      } catch (err) {\n        return '[UnexpectedJSONParseError]: ' + err.message;\n      }\n    };\n\n    /**\n     * Colorize log arguments if enabled.\n     *\n     * @api public\n     */\n\n    function formatArgs(args) {\n      var useColors = this.useColors;\n\n      args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);\n\n      if (!useColors) return;\n\n      var c = 'color: ' + this.color;\n      args.splice(1, 0, c, 'color: inherit');\n\n      // the final \"%c\" is somewhat tricky, because there could be other\n      // arguments passed either before or after the %c, so we need to\n      // figure out the correct index to insert the CSS into\n      var index = 0;\n      var lastC = 0;\n      args[0].replace(/%[a-zA-Z%]/g, function (match) {\n        if ('%%' === match) return;\n        index++;\n        if ('%c' === match) {\n          // we only are interested in the *last* %c\n          // (the user may have provided their own)\n          lastC = index;\n        }\n      });\n\n      args.splice(lastC, 0, c);\n    }\n\n    /**\n     * Invokes `console.log()` when available.\n     * No-op when `console.log` is not a \"function\".\n     *\n     * @api public\n     */\n\n    function log() {\n      // this hackery is required for IE8/9, where\n      // the `console.log` function doesn't have 'apply'\n      return 'object' === (typeof console === 'undefined' ? 'undefined' : _typeof2(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);\n    }\n\n    /**\n     * Save `namespaces`.\n     *\n     * @param {String} namespaces\n     * @api private\n     */\n\n    function save(namespaces) {\n      try {\n        if (null == namespaces) {\n          exports.storage.removeItem('debug');\n        } else {\n          exports.storage.debug = namespaces;\n        }\n      } catch (e) {}\n    }\n\n    /**\n     * Load `namespaces`.\n     *\n     * @return {String} returns the previously persisted debug modes\n     * @api private\n     */\n\n    function load() {\n      var r;\n      try {\n        r = exports.storage.debug;\n      } catch (e) {}\n\n      // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n      if (!r && typeof process !== 'undefined' && 'env' in process) {\n        r = Object({\"NODE_ENV\":\"development\",\"SIMULATED\":\"true\",\"FLATLINE_APP_ID\":\"tsumtsum-dev\",\"FLATLINE_HOST\":\"https://deferred-actions-a4365e9-dot-wintermute-151001.appspot.com\",\"FLATLINE_USE_V2_SESSION\":\"true\",\"FLATLINE_ADMIN_TOKEN\":\"tsumtsum_5601879890534\",\"FREESIDE_HOST\":\"https://onions.science\",\"FREESIDE_CONTEXT_STORAGE_HOST\":\"https://context-storage-dot-freeside-152323.appspot.com\",\"SOCIAL_MESSAGING_HOST\":\"https://sms-dot-wintermute-151001.appspot.com\",\"FB_INSTANT_USE_MOCK_DATA\":\"true\",\"FB_INSTANT_MOCK_SIGNATURE\":\"b67607cb5ecba55fbcc3c72771ebf9df\",\"COMMITHASH\":\"94ac762\",\"GIT_BRANCH\":\"sim_garrett\",\"BUILD_NUMBER\":\"-1\",\"IS_TEST\":undefined,\"IS_AUTOMATED\":undefined}).DEBUG;\n      }\n\n      return r;\n    }\n\n    /**\n     * Enable namespaces listed in `localStorage.debug` initially.\n     */\n\n    exports.enable(load());\n\n    /**\n     * Localstorage attempts to return the localstorage.\n     *\n     * This is necessary because safari throws\n     * when a user disables cookies/localstorage\n     * and you attempt to access it.\n     *\n     * @return {LocalStorage}\n     * @api private\n     */\n\n    function localstorage() {\n      try {\n        return window.localStorage;\n      } catch (e) {}\n    }\n  });\n\n  /**\n   * Module dependencies.\n   */\n\n  var debug = browser('cookie');\n\n  /**\n   * Set or get cookie `name` with `value` and `options` object.\n   *\n   * @param {String} name\n   * @param {String} value\n   * @param {Object} options\n   * @return {Mixed}\n   * @api public\n   */\n\n  var componentCookie = function componentCookie(name, value, options) {\n    switch (arguments.length) {\n      case 3:\n      case 2:\n        return set$1(name, value, options);\n      case 1:\n        return get$1(name);\n      default:\n        return all();\n    }\n  };\n\n  /**\n   * Set cookie `name` to `value`.\n   *\n   * @param {String} name\n   * @param {String} value\n   * @param {Object} options\n   * @api private\n   */\n\n  function set$1(name, value, options) {\n    options = options || {};\n    var str = encode(name) + '=' + encode(value);\n\n    if (null == value) options.maxage = -1;\n\n    if (options.maxage) {\n      options.expires = new Date(+new Date() + options.maxage);\n    }\n\n    if (options.path) str += '; path=' + options.path;\n    if (options.domain) str += '; domain=' + options.domain;\n    if (options.expires) str += '; expires=' + options.expires.toUTCString();\n    if (options.secure) str += '; secure';\n\n    document.cookie = str;\n  }\n\n  /**\n   * Return all cookies.\n   *\n   * @return {Object}\n   * @api private\n   */\n\n  function all() {\n    var str;\n    try {\n      str = document.cookie;\n    } catch (err) {\n      if (typeof console !== 'undefined' && typeof console.error === 'function') {\n        console.error(err.stack || err);\n      }\n      return {};\n    }\n    return parse(str);\n  }\n\n  /**\n   * Get cookie `name`.\n   *\n   * @param {String} name\n   * @return {String}\n   * @api private\n   */\n\n  function get$1(name) {\n    return all()[name];\n  }\n\n  /**\n   * Parse cookie `str`.\n   *\n   * @param {String} str\n   * @return {Object}\n   * @api private\n   */\n\n  function parse(str) {\n    var obj = {};\n    var pairs = str.split(/ *; */);\n    var pair;\n    if ('' == pairs[0]) return obj;\n    for (var i = 0; i < pairs.length; ++i) {\n      pair = pairs[i].split('=');\n      obj[decode(pair[0])] = decode(pair[1]);\n    }\n    return obj;\n  }\n\n  /**\n   * Encode.\n   */\n\n  function encode(value) {\n    try {\n      return encodeURIComponent(value);\n    } catch (e) {\n      debug('error `encode(%o)` - %o', value, e);\n    }\n  }\n\n  /**\n   * Decode.\n   */\n\n  function decode(value) {\n    try {\n      return decodeURIComponent(value);\n    } catch (e) {\n      debug('error `decode(%o)` - %o', value, e);\n    }\n  }\n\n  var lib = createCommonjsModule(function (module, exports) {\n    'use strict';\n\n    /**\n     * Module dependencies.\n     */\n\n    var parse = componentUrl.parse;\n\n    /**\n     * Get the top domain.\n     *\n     * The function constructs the levels of domain and attempts to set a global\n     * cookie on each one when it succeeds it returns the top level domain.\n     *\n     * The method returns an empty string when the hostname is an ip or `localhost`.\n     *\n     * Example levels:\n     *\n     *      domain.levels('http://www.google.co.uk');\n     *      // => [\"co.uk\", \"google.co.uk\", \"www.google.co.uk\"]\n     *\n     * Example:\n     *\n     *      domain('http://localhost:3000/baz');\n     *      // => ''\n     *      domain('http://dev:3000/baz');\n     *      // => ''\n     *      domain('http://127.0.0.1:3000/baz');\n     *      // => ''\n     *      domain('http://segment.io/baz');\n     *      // => 'segment.io'\n     *\n     * @param {string} url\n     * @return {string}\n     * @api public\n     */\n    function domain(url) {\n      var cookie$$1 = exports.cookie;\n      var levels = exports.levels(url);\n\n      // Lookup the real top level one.\n      for (var i = 0; i < levels.length; ++i) {\n        var cname = '__tld__';\n        var domain = levels[i];\n        var opts = { domain: '.' + domain };\n\n        cookie$$1(cname, 1, opts);\n        if (cookie$$1(cname)) {\n          cookie$$1(cname, null, opts);\n          return domain;\n        }\n      }\n\n      return '';\n    }\n\n    /**\n     * Levels returns all levels of the given url.\n     *\n     * @param {string} url\n     * @return {Array}\n     * @api public\n     */\n    domain.levels = function (url) {\n      var host = parse(url).hostname;\n      var parts = host.split('.');\n      var last = parts[parts.length - 1];\n      var levels = [];\n\n      // Ip address.\n      if (parts.length === 4 && last === parseInt(last, 10)) {\n        return levels;\n      }\n\n      // Localhost.\n      if (parts.length <= 1) {\n        return levels;\n      }\n\n      // Create levels.\n      for (var i = parts.length - 2; i >= 0; --i) {\n        levels.push(parts.slice(i).join('.'));\n      }\n\n      return levels;\n    };\n\n    /**\n     * Expose cookie on domain.\n     */\n    domain.cookie = componentCookie;\n\n    /*\n     * Exports.\n     */\n\n    exports = module.exports = domain;\n  });\n\n  var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n    return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n  };\n\n  /**\n   * toString ref.\n   * @private\n   */\n\n  var toString = Object.prototype.toString;\n\n  /**\n   * Return the type of `val`.\n   * @private\n   * @param {Mixed} val\n   * @return {String}\n   * @api public\n   */\n\n  var type = function type(val) {\n    switch (toString.call(val)) {\n      case '[object Date]':\n        return 'date';\n      case '[object RegExp]':\n        return 'regexp';\n      case '[object Arguments]':\n        return 'arguments';\n      case '[object Array]':\n        return 'array';\n      case '[object Error]':\n        return 'error';\n    }\n\n    if (val === null) {\n      return 'null';\n    }\n    if (val === undefined) {\n      return 'undefined';\n    }\n    if (val !== val) {\n      return 'nan';\n    }\n    if (val && val.nodeType === 1) {\n      return 'element';\n    }\n\n    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(val)) {\n      return 'buffer';\n    }\n\n    val = val.valueOf ? val.valueOf() : Object.prototype.valueOf.apply(val);\n    return typeof val === 'undefined' ? 'undefined' : _typeof(val);\n  };\n\n  var logLevel = 'WARN';\n\n  var logLevels = {\n    DISABLE: 0,\n    ERROR: 1,\n    WARN: 2,\n    INFO: 3\n  };\n\n  var setLogLevel = function setLogLevel(logLevelName) {\n    logLevel = logLevels[logLevelName] || logLevel;\n  };\n\n  var getLogLevel = function getLogLevel() {\n    return logLevel;\n  };\n\n  var log = {\n    error: function error(s) {\n      if (logLevel >= logLevels.ERROR) {\n        _log(s);\n      }\n    },\n\n    warn: function warn(s) {\n      if (logLevel >= logLevels.WARN) {\n        _log(s);\n      }\n    },\n\n    info: function info(s) {\n      if (logLevel >= logLevels.INFO) {\n        _log(s);\n      }\n    }\n  };\n\n  var _log = function _log(s) {\n    try {\n      console.log('[Amplitude] ' + s);\n    } catch (e) {\n      // console logging not available\n    }\n  };\n\n  var isEmptyString = function isEmptyString(str) {\n    return !str || str.length === 0;\n  };\n\n  var sessionStorageEnabled = function sessionStorageEnabled() {\n    try {\n      if (window.sessionStorage) {\n        return true;\n      }\n    } catch (e) {} // sessionStorage disabled\n    return false;\n  };\n\n  // truncate string values in event and user properties so that request size does not get too large\n  var truncate = function truncate(value) {\n    if (type(value) === 'array') {\n      for (var i = 0; i < value.length; i++) {\n        value[i] = truncate(value[i]);\n      }\n    } else if (type(value) === 'object') {\n      for (var key in value) {\n        if (value.hasOwnProperty(key)) {\n          value[key] = truncate(value[key]);\n        }\n      }\n    } else {\n      value = _truncateValue(value);\n    }\n\n    return value;\n  };\n\n  var _truncateValue = function _truncateValue(value) {\n    if (type(value) === 'string') {\n      return value.length > constants.MAX_STRING_LENGTH ? value.substring(0, constants.MAX_STRING_LENGTH) : value;\n    }\n    return value;\n  };\n\n  var validateInput = function validateInput(input, name, expectedType) {\n    if (type(input) !== expectedType) {\n      log.error('Invalid ' + name + ' input type. Expected ' + expectedType + ' but received ' + type(input));\n      return false;\n    }\n    return true;\n  };\n\n  // do some basic sanitization and type checking, also catch property dicts with more than 1000 key/value pairs\n  var validateProperties = function validateProperties(properties) {\n    var propsType = type(properties);\n    if (propsType !== 'object') {\n      log.error('Error: invalid properties format. Expecting Javascript object, received ' + propsType + ', ignoring');\n      return {};\n    }\n\n    if (Object.keys(properties).length > constants.MAX_PROPERTY_KEYS) {\n      log.error('Error: too many properties (more than 1000), ignoring');\n      return {};\n    }\n\n    var copy = {}; // create a copy with all of the valid properties\n    for (var property in properties) {\n      if (!properties.hasOwnProperty(property)) {\n        continue;\n      }\n\n      // validate key\n      var key = property;\n      var keyType = type(key);\n      if (keyType !== 'string') {\n        key = String(key);\n        log.warn('WARNING: Non-string property key, received type ' + keyType + ', coercing to string \"' + key + '\"');\n      }\n\n      // validate value\n      var value = validatePropertyValue(key, properties[property]);\n      if (value === null) {\n        continue;\n      }\n      copy[key] = value;\n    }\n    return copy;\n  };\n\n  var invalidValueTypes = ['null', 'nan', 'undefined', 'function', 'arguments', 'regexp', 'element'];\n\n  var validatePropertyValue = function validatePropertyValue(key, value) {\n    var valueType = type(value);\n    if (invalidValueTypes.indexOf(valueType) !== -1) {\n      log.warn('WARNING: Property key \"' + key + '\" with invalid value type ' + valueType + ', ignoring');\n      value = null;\n    } else if (valueType === 'error') {\n      value = String(value);\n      log.warn('WARNING: Property key \"' + key + '\" with value type error, coercing to ' + value);\n    } else if (valueType === 'array') {\n      // check for nested arrays or objects\n      var arrayCopy = [];\n      for (var i = 0; i < value.length; i++) {\n        var element = value[i];\n        var elemType = type(element);\n        if (elemType === 'array' || elemType === 'object') {\n          log.warn('WARNING: Cannot have ' + elemType + ' nested in an array property value, skipping');\n          continue;\n        }\n        arrayCopy.push(validatePropertyValue(key, element));\n      }\n      value = arrayCopy;\n    } else if (valueType === 'object') {\n      value = validateProperties(value);\n    }\n    return value;\n  };\n\n  var validateGroups = function validateGroups(groups) {\n    var groupsType = type(groups);\n    if (groupsType !== 'object') {\n      log.error('Error: invalid groups format. Expecting Javascript object, received ' + groupsType + ', ignoring');\n      return {};\n    }\n\n    var copy = {}; // create a copy with all of the valid properties\n    for (var group in groups) {\n      if (!groups.hasOwnProperty(group)) {\n        continue;\n      }\n\n      // validate key\n      var key = group;\n      var keyType = type(key);\n      if (keyType !== 'string') {\n        key = String(key);\n        log.warn('WARNING: Non-string groupType, received type ' + keyType + ', coercing to string \"' + key + '\"');\n      }\n\n      // validate value\n      var value = validateGroupName(key, groups[group]);\n      if (value === null) {\n        continue;\n      }\n      copy[key] = value;\n    }\n    return copy;\n  };\n\n  var validateGroupName = function validateGroupName(key, groupName) {\n    var groupNameType = type(groupName);\n    if (groupNameType === 'string') {\n      return groupName;\n    }\n    if (groupNameType === 'date' || groupNameType === 'number' || groupNameType === 'boolean') {\n      groupName = String(groupName);\n      log.warn('WARNING: Non-string groupName, received type ' + groupNameType + ', coercing to string \"' + groupName + '\"');\n      return groupName;\n    }\n    if (groupNameType === 'array') {\n      // check for nested arrays or objects\n      var arrayCopy = [];\n      for (var i = 0; i < groupName.length; i++) {\n        var element = groupName[i];\n        var elemType = type(element);\n        if (elemType === 'array' || elemType === 'object') {\n          log.warn('WARNING: Skipping nested ' + elemType + ' in array groupName');\n          continue;\n        } else if (elemType === 'string') {\n          arrayCopy.push(element);\n        } else if (elemType === 'date' || elemType === 'number' || elemType === 'boolean') {\n          element = String(element);\n          log.warn('WARNING: Non-string groupName, received type ' + elemType + ', coercing to string \"' + element + '\"');\n          arrayCopy.push(element);\n        }\n      }\n      return arrayCopy;\n    }\n    log.warn('WARNING: Non-string groupName, received type ' + groupNameType + '. Please use strings or array of strings for groupName');\n  };\n\n  // parses the value of a url param (for example ?gclid=1234&...)\n  var getQueryParam = function getQueryParam(name, query) {\n    name = name.replace(/[\\[]/, \"\\\\[\").replace(/[\\]]/, \"\\\\]\");\n    var regex = new RegExp(\"[\\\\?&]\" + name + \"=([^&#]*)\");\n    var results = regex.exec(query);\n    return results === null ? undefined : decodeURIComponent(results[1].replace(/\\+/g, \" \"));\n  };\n\n  var utils = {\n    setLogLevel: setLogLevel,\n    getLogLevel: getLogLevel,\n    log: log,\n    isEmptyString: isEmptyString,\n    getQueryParam: getQueryParam,\n    sessionStorageEnabled: sessionStorageEnabled,\n    truncate: truncate,\n    validateGroups: validateGroups,\n    validateInput: validateInput,\n    validateProperties: validateProperties\n  };\n\n  /*\n   * Cookie data\n   */\n\n  var _options = {\n    expirationDays: undefined,\n    domain: undefined\n  };\n\n  var reset = function reset() {\n    _options = {\n      expirationDays: undefined,\n      domain: undefined\n    };\n  };\n\n  var options = function options(opts) {\n    if (arguments.length === 0) {\n      return _options;\n    }\n\n    opts = opts || {};\n\n    _options.expirationDays = opts.expirationDays;\n\n    var domain = !utils.isEmptyString(opts.domain) ? opts.domain : '.' + lib(window.location.href);\n    var token = Math.random();\n    _options.domain = domain;\n    set('amplitude_test', token);\n    var stored = get('amplitude_test');\n    if (!stored || stored !== token) {\n      domain = null;\n    }\n    remove('amplitude_test');\n    _options.domain = domain;\n  };\n\n  var _domainSpecific = function _domainSpecific(name) {\n    // differentiate between cookies on different domains\n    var suffix = '';\n    if (_options.domain) {\n      suffix = _options.domain.charAt(0) === '.' ? _options.domain.substring(1) : _options.domain;\n    }\n    return name + suffix;\n  };\n\n  var get = function get(name) {\n    try {\n      var nameEq = _domainSpecific(name) + '=';\n      var ca = document.cookie.split(';');\n      var value = null;\n      for (var i = 0; i < ca.length; i++) {\n        var c = ca[i];\n        while (c.charAt(0) === ' ') {\n          c = c.substring(1, c.length);\n        }\n        if (c.indexOf(nameEq) === 0) {\n          value = c.substring(nameEq.length, c.length);\n          break;\n        }\n      }\n\n      if (value) {\n        return JSON.parse(Base64.decode(value));\n      }\n      return null;\n    } catch (e) {\n      return null;\n    }\n  };\n\n  var set = function set(name, value) {\n    try {\n      _set(_domainSpecific(name), Base64.encode(JSON.stringify(value)), _options);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  var _set = function _set(name, value, opts) {\n    var expires = value !== null ? opts.expirationDays : -1;\n    if (expires) {\n      var date = new Date();\n      date.setTime(date.getTime() + expires * 24 * 60 * 60 * 1000);\n      expires = date;\n    }\n    var str = name + '=' + value;\n    if (expires) {\n      str += '; expires=' + expires.toUTCString();\n    }\n    str += '; path=/';\n    if (opts.domain) {\n      str += '; domain=' + opts.domain;\n    }\n    document.cookie = str;\n  };\n\n  var remove = function remove(name) {\n    try {\n      _set(_domainSpecific(name), null, _options);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  var Cookie = {\n    reset: reset,\n    options: options,\n    get: get,\n    set: set,\n    remove: remove\n\n  };\n\n  /* jshint -W020, unused: false, noempty: false, boss: true */\n\n  /*\n   * Implement localStorage to support Firefox 2-3 and IE 5-7\n   */\n  var localStorage; // jshint ignore:line\n\n  // test that Window.localStorage is available and works\n  function windowLocalStorageAvailable() {\n    var uid = new Date();\n    var result;\n    try {\n      window.localStorage.setItem(uid, uid);\n      result = window.localStorage.getItem(uid) === String(uid);\n      window.localStorage.removeItem(uid);\n      return result;\n    } catch (e) {\n      // localStorage not available\n    }\n    return false;\n  }\n\n  if (windowLocalStorageAvailable()) {\n    localStorage = window.localStorage;\n  } else if (window.globalStorage) {\n    // Firefox 2-3 use globalStorage\n    // See https://developer.mozilla.org/en/dom/storage#globalStorage\n    try {\n      localStorage = window.globalStorage[window.location.hostname];\n    } catch (e) {\n      // Something bad happened...\n    }\n  } else {\n    // IE 5-7 use userData\n    // See http://msdn.microsoft.com/en-us/library/ms531424(v=vs.85).aspx\n    var div = document.createElement('div'),\n        attrKey = 'localStorage';\n    div.style.display = 'none';\n    document.getElementsByTagName('head')[0].appendChild(div);\n    if (div.addBehavior) {\n      div.addBehavior('#default#userdata');\n      localStorage = {\n        length: 0,\n        setItem: function setItem(k, v) {\n          div.load(attrKey);\n          if (!div.getAttribute(k)) {\n            this.length++;\n          }\n          div.setAttribute(k, v);\n          div.save(attrKey);\n        },\n        getItem: function getItem(k) {\n          div.load(attrKey);\n          return div.getAttribute(k);\n        },\n        removeItem: function removeItem(k) {\n          div.load(attrKey);\n          if (div.getAttribute(k)) {\n            this.length--;\n          }\n          div.removeAttribute(k);\n          div.save(attrKey);\n        },\n        clear: function clear() {\n          div.load(attrKey);\n          var i = 0;\n          var attr;\n          while (attr = div.XMLDocument.documentElement.attributes[i++]) {\n            div.removeAttribute(attr.name);\n          }\n          div.save(attrKey);\n          this.length = 0;\n        },\n        key: function key(k) {\n          div.load(attrKey);\n          return div.XMLDocument.documentElement.attributes[k];\n        }\n      };\n      div.load(attrKey);\n      localStorage.length = div.XMLDocument.documentElement.attributes.length;\n    } else {\n      /* Nothing we can do ... */\n    }\n  }\n  if (!localStorage) {\n    localStorage = {\n      length: 0,\n      setItem: function setItem(k, v) {},\n      getItem: function getItem(k) {},\n      removeItem: function removeItem(k) {},\n      clear: function clear() {},\n      key: function key(k) {}\n    };\n  }\n\n  var localStorage$1 = localStorage;\n\n  /* jshint -W020, unused: false, noempty: false, boss: true */\n\n  /*\n   * Abstraction layer for cookie storage.\n   * Uses cookie if available, otherwise fallback to localstorage.\n   */\n\n  var cookieStorage = function cookieStorage() {\n    this.storage = null;\n  };\n\n  // test that cookies are enabled - navigator.cookiesEnabled yields false positives in IE, need to test directly\n  cookieStorage.prototype._cookiesEnabled = function () {\n    var uid = String(new Date());\n    var result;\n    try {\n      Cookie.set(constants.COOKIE_TEST, uid);\n      result = Cookie.get(constants.COOKIE_TEST) === uid;\n      Cookie.remove(constants.COOKIE_TEST);\n      return result;\n    } catch (e) {\n      // cookies are not enabled\n    }\n    return false;\n  };\n\n  cookieStorage.prototype.getStorage = function () {\n    if (this.storage !== null) {\n      return this.storage;\n    }\n\n    if (this._cookiesEnabled()) {\n      this.storage = Cookie;\n    } else {\n      // if cookies disabled, fallback to localstorage\n      // note: localstorage does not persist across subdomains\n      var keyPrefix = 'amp_cookiestore_';\n      this.storage = {\n        _options: {\n          expirationDays: undefined,\n          domain: undefined\n        },\n        reset: function reset() {\n          this._options = {\n            expirationDays: undefined,\n            domain: undefined\n          };\n        },\n        options: function options(opts) {\n          if (arguments.length === 0) {\n            return this._options;\n          }\n          opts = opts || {};\n          this._options.expirationDays = opts.expirationDays || this._options.expirationDays;\n          // localStorage is specific to subdomains\n          this._options.domain = opts.domain || this._options.domain || window.location.hostname;\n          return this._options;\n        },\n        get: function get(name) {\n          try {\n            return JSON.parse(localStorage$1.getItem(keyPrefix + name));\n          } catch (e) {}\n          return null;\n        },\n        set: function set(name, value) {\n          try {\n            localStorage$1.setItem(keyPrefix + name, JSON.stringify(value));\n            return true;\n          } catch (e) {}\n          return false;\n        },\n        remove: function remove(name) {\n          try {\n            localStorage$1.removeItem(keyPrefix + name);\n          } catch (e) {\n            return false;\n          }\n        }\n      };\n    }\n\n    return this.storage;\n  };\n\n  var getUtmData = function getUtmData(rawCookie, query) {\n    // Translate the utmz cookie format into url query string format.\n    var cookie = rawCookie ? '?' + rawCookie.split('.').slice(-1)[0].replace(/\\|/g, '&') : '';\n\n    var fetchParam = function fetchParam(queryName, query, cookieName, cookie) {\n      return utils.getQueryParam(queryName, query) || utils.getQueryParam(cookieName, cookie);\n    };\n\n    var utmSource = fetchParam('utm_source', query, 'utmcsr', cookie);\n    var utmMedium = fetchParam('utm_medium', query, 'utmcmd', cookie);\n    var utmCampaign = fetchParam('utm_campaign', query, 'utmccn', cookie);\n    var utmTerm = fetchParam('utm_term', query, 'utmctr', cookie);\n    var utmContent = fetchParam('utm_content', query, 'utmcct', cookie);\n\n    var utmData = {};\n    var addIfNotNull = function addIfNotNull(key, value) {\n      if (!utils.isEmptyString(value)) {\n        utmData[key] = value;\n      }\n    };\n\n    addIfNotNull('utm_source', utmSource);\n    addIfNotNull('utm_medium', utmMedium);\n    addIfNotNull('utm_campaign', utmCampaign);\n    addIfNotNull('utm_term', utmTerm);\n    addIfNotNull('utm_content', utmContent);\n\n    return utmData;\n  };\n\n  /*\n   * Wrapper for a user properties JSON object that supports operations.\n   * Note: if a user property is used in multiple operations on the same Identify object,\n   * only the first operation will be saved, and the rest will be ignored.\n   */\n\n  var AMP_OP_ADD = '$add';\n  var AMP_OP_APPEND = '$append';\n  var AMP_OP_CLEAR_ALL = '$clearAll';\n  var AMP_OP_PREPEND = '$prepend';\n  var AMP_OP_SET = '$set';\n  var AMP_OP_SET_ONCE = '$setOnce';\n  var AMP_OP_UNSET = '$unset';\n\n  /**\n   * Identify API - instance constructor. Identify objects are a wrapper for user property operations.\n   * Each method adds a user property operation to the Identify object, and returns the same Identify object,\n   * allowing you to chain multiple method calls together.\n   * Note: if the same user property is used in multiple operations on a single Identify object,\n   * only the first operation on that property will be saved, and the rest will be ignored.\n   * See [Readme]{@link https://github.com/amplitude/Amplitude-Javascript#user-properties-and-user-property-operations}\n   * for more information on the Identify API and user property operations.\n   * @constructor Identify\n   * @public\n   * @example var identify = new amplitude.Identify();\n   */\n  var Identify = function Identify() {\n    this.userPropertiesOperations = {};\n    this.properties = []; // keep track of keys that have been added\n  };\n\n  /**\n   * Increment a user property by a given value (can also be negative to decrement).\n   * If the user property does not have a value set yet, it will be initialized to 0 before being incremented.\n   * @public\n   * @param {string} property - The user property key.\n   * @param {number|string} value - The amount by which to increment the user property. Allows numbers as strings (ex: '123').\n   * @return {Identify} Returns the same Identify object, allowing you to chain multiple method calls together.\n   * @example var identify = new amplitude.Identify().add('karma', 1).add('friends', 1);\n   * amplitude.identify(identify); // send the Identify call\n   */\n  Identify.prototype.add = function (property, value) {\n    if (type(value) === 'number' || type(value) === 'string') {\n      this._addOperation(AMP_OP_ADD, property, value);\n    } else {\n      utils.log.error('Unsupported type for value: ' + type(value) + ', expecting number or string');\n    }\n    return this;\n  };\n\n  /**\n   * Append a value or values to a user property.\n   * If the user property does not have a value set yet,\n   * it will be initialized to an empty list before the new values are appended.\n   * If the user property has an existing value and it is not a list,\n   * the existing value will be converted into a list with the new values appended.\n   * @public\n   * @param {string} property - The user property key.\n   * @param {number|string|list|object} value - A value or values to append.\n   * Values can be numbers, strings, lists, or object (key:value dict will be flattened).\n   * @return {Identify} Returns the same Identify object, allowing you to chain multiple method calls together.\n   * @example var identify = new amplitude.Identify().append('ab-tests', 'new-user-tests');\n   * identify.append('some_list', [1, 2, 3, 4, 'values']);\n   * amplitude.identify(identify); // send the Identify call\n   */\n  Identify.prototype.append = function (property, value) {\n    this._addOperation(AMP_OP_APPEND, property, value);\n    return this;\n  };\n\n  /**\n   * Clear all user properties for the current user.\n   * SDK user should instead call amplitude.clearUserProperties() instead of using this.\n   * $clearAll needs to be sent on its own Identify object. If there are already other operations, then don't add $clearAll.\n   * If $clearAll already in an Identify object, don't allow other operations to be added.\n   * @private\n   */\n  Identify.prototype.clearAll = function () {\n    if (Object.keys(this.userPropertiesOperations).length > 0) {\n      if (!this.userPropertiesOperations.hasOwnProperty(AMP_OP_CLEAR_ALL)) {\n        utils.log.error('Need to send $clearAll on its own Identify object without any other operations, skipping $clearAll');\n      }\n      return this;\n    }\n    this.userPropertiesOperations[AMP_OP_CLEAR_ALL] = '-';\n    return this;\n  };\n\n  /**\n   * Prepend a value or values to a user property.\n   * Prepend means inserting the value or values at the front of a list.\n   * If the user property does not have a value set yet,\n   * it will be initialized to an empty list before the new values are prepended.\n   * If the user property has an existing value and it is not a list,\n   * the existing value will be converted into a list with the new values prepended.\n   * @public\n   * @param {string} property - The user property key.\n   * @param {number|string|list|object} value - A value or values to prepend.\n   * Values can be numbers, strings, lists, or object (key:value dict will be flattened).\n   * @return {Identify} Returns the same Identify object, allowing you to chain multiple method calls together.\n   * @example var identify = new amplitude.Identify().prepend('ab-tests', 'new-user-tests');\n   * identify.prepend('some_list', [1, 2, 3, 4, 'values']);\n   * amplitude.identify(identify); // send the Identify call\n   */\n  Identify.prototype.prepend = function (property, value) {\n    this._addOperation(AMP_OP_PREPEND, property, value);\n    return this;\n  };\n\n  /**\n   * Sets the value of a given user property. If a value already exists, it will be overwriten with the new value.\n   * @public\n   * @param {string} property - The user property key.\n   * @param {number|string|list|object} value - A value or values to set.\n   * Values can be numbers, strings, lists, or object (key:value dict will be flattened).\n   * @return {Identify} Returns the same Identify object, allowing you to chain multiple method calls together.\n   * @example var identify = new amplitude.Identify().set('user_type', 'beta');\n   * identify.set('name', {'first': 'John', 'last': 'Doe'}); // dict is flattened and becomes name.first: John, name.last: Doe\n   * amplitude.identify(identify); // send the Identify call\n   */\n  Identify.prototype.set = function (property, value) {\n    this._addOperation(AMP_OP_SET, property, value);\n    return this;\n  };\n\n  /**\n   * Sets the value of a given user property only once. Subsequent setOnce operations on that user property will be ignored;\n   * however, that user property can still be modified through any of the other operations.\n   * Useful for capturing properties such as 'initial_signup_date', 'initial_referrer', etc.\n   * @public\n   * @param {string} property - The user property key.\n   * @param {number|string|list|object} value - A value or values to set once.\n   * Values can be numbers, strings, lists, or object (key:value dict will be flattened).\n   * @return {Identify} Returns the same Identify object, allowing you to chain multiple method calls together.\n   * @example var identify = new amplitude.Identify().setOnce('sign_up_date', '2016-04-01');\n   * amplitude.identify(identify); // send the Identify call\n   */\n  Identify.prototype.setOnce = function (property, value) {\n    this._addOperation(AMP_OP_SET_ONCE, property, value);\n    return this;\n  };\n\n  /**\n   * Unset and remove a user property. This user property will no longer show up in a user's profile.\n   * @public\n   * @param {string} property - The user property key.\n   * @return {Identify} Returns the same Identify object, allowing you to chain multiple method calls together.\n   * @example var identify = new amplitude.Identify().unset('user_type').unset('age');\n   * amplitude.identify(identify); // send the Identify call\n   */\n  Identify.prototype.unset = function (property) {\n    this._addOperation(AMP_OP_UNSET, property, '-');\n    return this;\n  };\n\n  /**\n   * Helper function that adds operation to the Identify's object\n   * Handle's filtering of duplicate user property keys, and filtering for clearAll.\n   * @private\n   */\n  Identify.prototype._addOperation = function (operation, property, value) {\n    // check that the identify doesn't already contain a clearAll\n    if (this.userPropertiesOperations.hasOwnProperty(AMP_OP_CLEAR_ALL)) {\n      utils.log.error('This identify already contains a $clearAll operation, skipping operation ' + operation);\n      return;\n    }\n\n    // check that property wasn't already used in this Identify\n    if (this.properties.indexOf(property) !== -1) {\n      utils.log.error('User property \"' + property + '\" already used in this identify, skipping operation ' + operation);\n      return;\n    }\n\n    if (!this.userPropertiesOperations.hasOwnProperty(operation)) {\n      this.userPropertiesOperations[operation] = {};\n    }\n    this.userPropertiesOperations[operation][property] = value;\n    this.properties.push(property);\n  };\n\n  var md5 = createCommonjsModule(function (module) {\n    /*\n     * JavaScript MD5\n     * https://github.com/blueimp/JavaScript-MD5\n     *\n     * Copyright 2011, Sebastian Tschan\n     * https://blueimp.net\n     *\n     * Licensed under the MIT license:\n     * https://opensource.org/licenses/MIT\n     *\n     * Based on\n     * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n     * Digest Algorithm, as defined in RFC 1321.\n     * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n     * Distributed under the BSD License\n     * See http://pajhome.org.uk/crypt/md5 for more info.\n     */\n\n    /* global define */\n\n    (function ($) {\n      'use strict';\n\n      /*\n      * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n      * to work around bugs in some JS interpreters.\n      */\n\n      function safeAdd(x, y) {\n        var lsw = (x & 0xffff) + (y & 0xffff);\n        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n        return msw << 16 | lsw & 0xffff;\n      }\n\n      /*\n      * Bitwise rotate a 32-bit number to the left.\n      */\n      function bitRotateLeft(num, cnt) {\n        return num << cnt | num >>> 32 - cnt;\n      }\n\n      /*\n      * These functions implement the four basic operations the algorithm uses.\n      */\n      function md5cmn(q, a, b, x, s, t) {\n        return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n      }\n      function md5ff(a, b, c, d, x, s, t) {\n        return md5cmn(b & c | ~b & d, a, b, x, s, t);\n      }\n      function md5gg(a, b, c, d, x, s, t) {\n        return md5cmn(b & d | c & ~d, a, b, x, s, t);\n      }\n      function md5hh(a, b, c, d, x, s, t) {\n        return md5cmn(b ^ c ^ d, a, b, x, s, t);\n      }\n      function md5ii(a, b, c, d, x, s, t) {\n        return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n      }\n\n      /*\n      * Calculate the MD5 of an array of little-endian words, and a bit length.\n      */\n      function binlMD5(x, len) {\n        /* append padding */\n        x[len >> 5] |= 0x80 << len % 32;\n        x[(len + 64 >>> 9 << 4) + 14] = len;\n\n        var i;\n        var olda;\n        var oldb;\n        var oldc;\n        var oldd;\n        var a = 1732584193;\n        var b = -271733879;\n        var c = -1732584194;\n        var d = 271733878;\n\n        for (i = 0; i < x.length; i += 16) {\n          olda = a;\n          oldb = b;\n          oldc = c;\n          oldd = d;\n\n          a = md5ff(a, b, c, d, x[i], 7, -680876936);\n          d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n          c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n          b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n          a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n          d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n          c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n          b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n          a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n          d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n          c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n          b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n          a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n          d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n          c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n          b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n\n          a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n          d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n          c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n          b = md5gg(b, c, d, a, x[i], 20, -373897302);\n          a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n          d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n          c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n          b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n          a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n          d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n          c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n          b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n          a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n          d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n          c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n          b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n\n          a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n          d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n          c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n          b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n          a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n          d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n          c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n          b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n          a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n          d = md5hh(d, a, b, c, x[i], 11, -358537222);\n          c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n          b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n          a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n          d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n          c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n          b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n\n          a = md5ii(a, b, c, d, x[i], 6, -198630844);\n          d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n          c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n          b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n          a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n          d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n          c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n          b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n          a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n          d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n          c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n          b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n          a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n          d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n          c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n          b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n\n          a = safeAdd(a, olda);\n          b = safeAdd(b, oldb);\n          c = safeAdd(c, oldc);\n          d = safeAdd(d, oldd);\n        }\n        return [a, b, c, d];\n      }\n\n      /*\n      * Convert an array of little-endian words to a string\n      */\n      function binl2rstr(input) {\n        var i;\n        var output = '';\n        var length32 = input.length * 32;\n        for (i = 0; i < length32; i += 8) {\n          output += String.fromCharCode(input[i >> 5] >>> i % 32 & 0xff);\n        }\n        return output;\n      }\n\n      /*\n      * Convert a raw string to an array of little-endian words\n      * Characters >255 have their high-byte silently ignored.\n      */\n      function rstr2binl(input) {\n        var i;\n        var output = [];\n        output[(input.length >> 2) - 1] = undefined;\n        for (i = 0; i < output.length; i += 1) {\n          output[i] = 0;\n        }\n        var length8 = input.length * 8;\n        for (i = 0; i < length8; i += 8) {\n          output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << i % 32;\n        }\n        return output;\n      }\n\n      /*\n      * Calculate the MD5 of a raw string\n      */\n      function rstrMD5(s) {\n        return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));\n      }\n\n      /*\n      * Calculate the HMAC-MD5, of a key and some data (raw strings)\n      */\n      function rstrHMACMD5(key, data) {\n        var i;\n        var bkey = rstr2binl(key);\n        var ipad = [];\n        var opad = [];\n        var hash;\n        ipad[15] = opad[15] = undefined;\n        if (bkey.length > 16) {\n          bkey = binlMD5(bkey, key.length * 8);\n        }\n        for (i = 0; i < 16; i += 1) {\n          ipad[i] = bkey[i] ^ 0x36363636;\n          opad[i] = bkey[i] ^ 0x5c5c5c5c;\n        }\n        hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);\n        return binl2rstr(binlMD5(opad.concat(hash), 512 + 128));\n      }\n\n      /*\n      * Convert a raw string to a hex string\n      */\n      function rstr2hex(input) {\n        var hexTab = '0123456789abcdef';\n        var output = '';\n        var x;\n        var i;\n        for (i = 0; i < input.length; i += 1) {\n          x = input.charCodeAt(i);\n          output += hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f);\n        }\n        return output;\n      }\n\n      /*\n      * Encode a string as utf-8\n      */\n      function str2rstrUTF8(input) {\n        return unescape(encodeURIComponent(input));\n      }\n\n      /*\n      * Take string arguments and return either raw or hex encoded strings\n      */\n      function rawMD5(s) {\n        return rstrMD5(str2rstrUTF8(s));\n      }\n      function hexMD5(s) {\n        return rstr2hex(rawMD5(s));\n      }\n      function rawHMACMD5(k, d) {\n        return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d));\n      }\n      function hexHMACMD5(k, d) {\n        return rstr2hex(rawHMACMD5(k, d));\n      }\n\n      function md5(string, key, raw) {\n        if (!key) {\n          if (!raw) {\n            return hexMD5(string);\n          }\n          return rawMD5(string);\n        }\n        if (!raw) {\n          return hexHMACMD5(key, string);\n        }\n        return rawHMACMD5(key, string);\n      }\n\n      if (false) {\n        undefined(function () {\n          return md5;\n        });\n      } else if ('object' === 'object' && module.exports) {\n        module.exports = md5;\n      } else {\n        $.md5 = md5;\n      }\n    })(commonjsGlobal);\n  });\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = (typeof commonjsGlobal === 'undefined' ? 'undefined' : _typeof2(commonjsGlobal)) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n\n  var _freeGlobal = freeGlobal;\n\n  /** Detect free variable `self`. */\n  var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof2(self)) == 'object' && self && self.Object === Object && self;\n\n  /** Used as a reference to the global object. */\n  var root = _freeGlobal || freeSelf || Function('return this')();\n\n  var _root = root;\n\n  /** Built-in value references. */\n  var Symbol$1 = _root.Symbol;\n\n  var _Symbol = Symbol$1;\n\n  /** Used for built-in method references. */\n  var objectProto$3 = Object.prototype;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$3 = objectProto$3.hasOwnProperty;\n\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n  var nativeObjectToString = objectProto$3.toString;\n\n  /** Built-in value references. */\n  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;\n\n  /**\n   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the raw `toStringTag`.\n   */\n  function getRawTag(value) {\n    var isOwn = hasOwnProperty$3.call(value, symToStringTag$1),\n        tag = value[symToStringTag$1];\n\n    try {\n      value[symToStringTag$1] = undefined;\n      var unmasked = true;\n    } catch (e) {}\n\n    var result = nativeObjectToString.call(value);\n    if (unmasked) {\n      if (isOwn) {\n        value[symToStringTag$1] = tag;\n      } else {\n        delete value[symToStringTag$1];\n      }\n    }\n    return result;\n  }\n\n  var _getRawTag = getRawTag;\n\n  /** Used for built-in method references. */\n  var objectProto$4 = Object.prototype;\n\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n  var nativeObjectToString$1 = objectProto$4.toString;\n\n  /**\n   * Converts `value` to a string using `Object.prototype.toString`.\n   *\n   * @private\n   * @param {*} value The value to convert.\n   * @returns {string} Returns the converted string.\n   */\n  function objectToString(value) {\n    return nativeObjectToString$1.call(value);\n  }\n\n  var _objectToString = objectToString;\n\n  /** `Object#toString` result references. */\n  var nullTag = '[object Null]';\n  var undefinedTag = '[object Undefined]';\n\n  /** Built-in value references. */\n  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;\n\n  /**\n   * The base implementation of `getTag` without fallbacks for buggy environments.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the `toStringTag`.\n   */\n  function baseGetTag(value) {\n    if (value == null) {\n      return value === undefined ? undefinedTag : nullTag;\n    }\n    return symToStringTag && symToStringTag in Object(value) ? _getRawTag(value) : _objectToString(value);\n  }\n\n  var _baseGetTag = baseGetTag;\n\n  /**\n   * Checks if `value` is the\n   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n   * @example\n   *\n   * _.isObject({});\n   * // => true\n   *\n   * _.isObject([1, 2, 3]);\n   * // => true\n   *\n   * _.isObject(_.noop);\n   * // => true\n   *\n   * _.isObject(null);\n   * // => false\n   */\n  function isObject(value) {\n    var type = typeof value === 'undefined' ? 'undefined' : _typeof2(value);\n    return value != null && (type == 'object' || type == 'function');\n  }\n\n  var isObject_1 = isObject;\n\n  /** `Object#toString` result references. */\n  var asyncTag = '[object AsyncFunction]';\n  var funcTag = '[object Function]';\n  var genTag = '[object GeneratorFunction]';\n  var proxyTag = '[object Proxy]';\n\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n   * @example\n   *\n   * _.isFunction(_);\n   * // => true\n   *\n   * _.isFunction(/abc/);\n   * // => false\n   */\n  function isFunction(value) {\n    if (!isObject_1(value)) {\n      return false;\n    }\n    // The use of `Object#toString` avoids issues with the `typeof` operator\n    // in Safari 9 which returns 'object' for typed arrays and other constructors.\n    var tag = _baseGetTag(value);\n    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n  }\n\n  var isFunction_1 = isFunction;\n\n  /** Used to detect overreaching core-js shims. */\n  var coreJsData = _root['__core-js_shared__'];\n\n  var _coreJsData = coreJsData;\n\n  /** Used to detect methods masquerading as native. */\n  var maskSrcKey = function () {\n    var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');\n    return uid ? 'Symbol(src)_1.' + uid : '';\n  }();\n\n  /**\n   * Checks if `func` has its source masked.\n   *\n   * @private\n   * @param {Function} func The function to check.\n   * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n   */\n  function isMasked(func) {\n    return !!maskSrcKey && maskSrcKey in func;\n  }\n\n  var _isMasked = isMasked;\n\n  /** Used for built-in method references. */\n  var funcProto$1 = Function.prototype;\n\n  /** Used to resolve the decompiled source of functions. */\n  var funcToString$1 = funcProto$1.toString;\n\n  /**\n   * Converts `func` to its source code.\n   *\n   * @private\n   * @param {Function} func The function to convert.\n   * @returns {string} Returns the source code.\n   */\n  function toSource(func) {\n    if (func != null) {\n      try {\n        return funcToString$1.call(func);\n      } catch (e) {}\n      try {\n        return func + '';\n      } catch (e) {}\n    }\n    return '';\n  }\n\n  var _toSource = toSource;\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used for built-in method references. */\n  var funcProto = Function.prototype;\n  var objectProto$2 = Object.prototype;\n\n  /** Used to resolve the decompiled source of functions. */\n  var funcToString = funcProto.toString;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$2 = objectProto$2.hasOwnProperty;\n\n  /** Used to detect if a method is native. */\n  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty$2).replace(reRegExpChar, '\\\\$&').replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$');\n\n  /**\n   * The base implementation of `_.isNative` without bad shim checks.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a native function,\n   *  else `false`.\n   */\n  function baseIsNative(value) {\n    if (!isObject_1(value) || _isMasked(value)) {\n      return false;\n    }\n    var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;\n    return pattern.test(_toSource(value));\n  }\n\n  var _baseIsNative = baseIsNative;\n\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n\n  var _getValue = getValue;\n\n  /**\n   * Gets the native function at `key` of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {string} key The key of the method to get.\n   * @returns {*} Returns the function if it's native, else `undefined`.\n   */\n  function getNative(object, key) {\n    var value = _getValue(object, key);\n    return _baseIsNative(value) ? value : undefined;\n  }\n\n  var _getNative = getNative;\n\n  var defineProperty = function () {\n    try {\n      var func = _getNative(Object, 'defineProperty');\n      func({}, '', {});\n      return func;\n    } catch (e) {}\n  }();\n\n  var _defineProperty = defineProperty;\n\n  /**\n   * The base implementation of `assignValue` and `assignMergeValue` without\n   * value checks.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */\n  function baseAssignValue(object, key, value) {\n    if (key == '__proto__' && _defineProperty) {\n      _defineProperty(object, key, {\n        'configurable': true,\n        'enumerable': true,\n        'value': value,\n        'writable': true\n      });\n    } else {\n      object[key] = value;\n    }\n  }\n\n  var _baseAssignValue = baseAssignValue;\n\n  /**\n   * Performs a\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * comparison between two values to determine if they are equivalent.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n   * @example\n   *\n   * var object = { 'a': 1 };\n   * var other = { 'a': 1 };\n   *\n   * _.eq(object, object);\n   * // => true\n   *\n   * _.eq(object, other);\n   * // => false\n   *\n   * _.eq('a', 'a');\n   * // => true\n   *\n   * _.eq('a', Object('a'));\n   * // => false\n   *\n   * _.eq(NaN, NaN);\n   * // => true\n   */\n  function eq(value, other) {\n    return value === other || value !== value && other !== other;\n  }\n\n  var eq_1 = eq;\n\n  /** Used for built-in method references. */\n  var objectProto$1 = Object.prototype;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$1 = objectProto$1.hasOwnProperty;\n\n  /**\n   * Assigns `value` to `key` of `object` if the existing value is not equivalent\n   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * for equality comparisons.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */\n  function assignValue(object, key, value) {\n    var objValue = object[key];\n    if (!(hasOwnProperty$1.call(object, key) && eq_1(objValue, value)) || value === undefined && !(key in object)) {\n      _baseAssignValue(object, key, value);\n    }\n  }\n\n  var _assignValue = assignValue;\n\n  /**\n   * Copies properties of `source` to `object`.\n   *\n   * @private\n   * @param {Object} source The object to copy properties from.\n   * @param {Array} props The property identifiers to copy.\n   * @param {Object} [object={}] The object to copy properties to.\n   * @param {Function} [customizer] The function to customize copied values.\n   * @returns {Object} Returns `object`.\n   */\n  function copyObject(source, props, object, customizer) {\n    var isNew = !object;\n    object || (object = {});\n\n    var index = -1,\n        length = props.length;\n\n    while (++index < length) {\n      var key = props[index];\n\n      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;\n\n      if (newValue === undefined) {\n        newValue = source[key];\n      }\n      if (isNew) {\n        _baseAssignValue(object, key, newValue);\n      } else {\n        _assignValue(object, key, newValue);\n      }\n    }\n    return object;\n  }\n\n  var _copyObject = copyObject;\n\n  /**\n   * This method returns the first argument it receives.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Util\n   * @param {*} value Any value.\n   * @returns {*} Returns `value`.\n   * @example\n   *\n   * var object = { 'a': 1 };\n   *\n   * console.log(_.identity(object) === object);\n   * // => true\n   */\n  function identity(value) {\n    return value;\n  }\n\n  var identity_1 = identity;\n\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n  function apply(func, thisArg, args) {\n    switch (args.length) {\n      case 0:\n        return func.call(thisArg);\n      case 1:\n        return func.call(thisArg, args[0]);\n      case 2:\n        return func.call(thisArg, args[0], args[1]);\n      case 3:\n        return func.call(thisArg, args[0], args[1], args[2]);\n    }\n    return func.apply(thisArg, args);\n  }\n\n  var _apply = apply;\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeMax = Math.max;\n\n  /**\n   * A specialized version of `baseRest` which transforms the rest array.\n   *\n   * @private\n   * @param {Function} func The function to apply a rest parameter to.\n   * @param {number} [start=func.length-1] The start position of the rest parameter.\n   * @param {Function} transform The rest array transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overRest(func, start, transform) {\n    start = nativeMax(start === undefined ? func.length - 1 : start, 0);\n    return function () {\n      var args = arguments,\n          index = -1,\n          length = nativeMax(args.length - start, 0),\n          array = Array(length);\n\n      while (++index < length) {\n        array[index] = args[start + index];\n      }\n      index = -1;\n      var otherArgs = Array(start + 1);\n      while (++index < start) {\n        otherArgs[index] = args[index];\n      }\n      otherArgs[start] = transform(array);\n      return _apply(func, this, otherArgs);\n    };\n  }\n\n  var _overRest = overRest;\n\n  /**\n   * Creates a function that returns `value`.\n   *\n   * @static\n   * @memberOf _\n   * @since 2.4.0\n   * @category Util\n   * @param {*} value The value to return from the new function.\n   * @returns {Function} Returns the new constant function.\n   * @example\n   *\n   * var objects = _.times(2, _.constant({ 'a': 1 }));\n   *\n   * console.log(objects);\n   * // => [{ 'a': 1 }, { 'a': 1 }]\n   *\n   * console.log(objects[0] === objects[1]);\n   * // => true\n   */\n  function constant(value) {\n    return function () {\n      return value;\n    };\n  }\n\n  var constant_1 = constant;\n\n  /**\n   * The base implementation of `setToString` without support for hot loop shorting.\n   *\n   * @private\n   * @param {Function} func The function to modify.\n   * @param {Function} string The `toString` result.\n   * @returns {Function} Returns `func`.\n   */\n  var baseSetToString = !_defineProperty ? identity_1 : function (func, string) {\n    return _defineProperty(func, 'toString', {\n      'configurable': true,\n      'enumerable': false,\n      'value': constant_1(string),\n      'writable': true\n    });\n  };\n\n  var _baseSetToString = baseSetToString;\n\n  /** Used to detect hot functions by number of calls within a span of milliseconds. */\n  var HOT_COUNT = 800;\n  var HOT_SPAN = 16;\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeNow = Date.now;\n\n  /**\n   * Creates a function that'll short out and invoke `identity` instead\n   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n   * milliseconds.\n   *\n   * @private\n   * @param {Function} func The function to restrict.\n   * @returns {Function} Returns the new shortable function.\n   */\n  function shortOut(func) {\n    var count = 0,\n        lastCalled = 0;\n\n    return function () {\n      var stamp = nativeNow(),\n          remaining = HOT_SPAN - (stamp - lastCalled);\n\n      lastCalled = stamp;\n      if (remaining > 0) {\n        if (++count >= HOT_COUNT) {\n          return arguments[0];\n        }\n      } else {\n        count = 0;\n      }\n      return func.apply(undefined, arguments);\n    };\n  }\n\n  var _shortOut = shortOut;\n\n  /**\n   * Sets the `toString` method of `func` to return `string`.\n   *\n   * @private\n   * @param {Function} func The function to modify.\n   * @param {Function} string The `toString` result.\n   * @returns {Function} Returns `func`.\n   */\n  var setToString = _shortOut(_baseSetToString);\n\n  var _setToString = setToString;\n\n  /**\n   * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n   *\n   * @private\n   * @param {Function} func The function to apply a rest parameter to.\n   * @param {number} [start=func.length-1] The start position of the rest parameter.\n   * @returns {Function} Returns the new function.\n   */\n  function baseRest(func, start) {\n    return _setToString(_overRest(func, start, identity_1), func + '');\n  }\n\n  var _baseRest = baseRest;\n\n  /** Used as references for various `Number` constants. */\n  var MAX_SAFE_INTEGER = 9007199254740991;\n\n  /**\n   * Checks if `value` is a valid array-like length.\n   *\n   * **Note:** This method is loosely based on\n   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n   * @example\n   *\n   * _.isLength(3);\n   * // => true\n   *\n   * _.isLength(Number.MIN_VALUE);\n   * // => false\n   *\n   * _.isLength(Infinity);\n   * // => false\n   *\n   * _.isLength('3');\n   * // => false\n   */\n  function isLength(value) {\n    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n  }\n\n  var isLength_1 = isLength;\n\n  /**\n   * Checks if `value` is array-like. A value is considered array-like if it's\n   * not a function and has a `value.length` that's an integer greater than or\n   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n   * @example\n   *\n   * _.isArrayLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isArrayLike(document.body.children);\n   * // => true\n   *\n   * _.isArrayLike('abc');\n   * // => true\n   *\n   * _.isArrayLike(_.noop);\n   * // => false\n   */\n  function isArrayLike(value) {\n    return value != null && isLength_1(value.length) && !isFunction_1(value);\n  }\n\n  var isArrayLike_1 = isArrayLike;\n\n  /** Used as references for various `Number` constants. */\n  var MAX_SAFE_INTEGER$1 = 9007199254740991;\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n  /**\n   * Checks if `value` is a valid array-like index.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n   */\n  function isIndex(value, length) {\n    length = length == null ? MAX_SAFE_INTEGER$1 : length;\n    return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n  }\n\n  var _isIndex = isIndex;\n\n  /**\n   * Checks if the given arguments are from an iteratee call.\n   *\n   * @private\n   * @param {*} value The potential iteratee value argument.\n   * @param {*} index The potential iteratee index or key argument.\n   * @param {*} object The potential iteratee object argument.\n   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n   *  else `false`.\n   */\n  function isIterateeCall(value, index, object) {\n    if (!isObject_1(object)) {\n      return false;\n    }\n    var type = typeof index === 'undefined' ? 'undefined' : _typeof2(index);\n    if (type == 'number' ? isArrayLike_1(object) && _isIndex(index, object.length) : type == 'string' && index in object) {\n      return eq_1(object[index], value);\n    }\n    return false;\n  }\n\n  var _isIterateeCall = isIterateeCall;\n\n  /**\n   * Creates a function like `_.assign`.\n   *\n   * @private\n   * @param {Function} assigner The function to assign values.\n   * @returns {Function} Returns the new assigner function.\n   */\n  function createAssigner(assigner) {\n    return _baseRest(function (object, sources) {\n      var index = -1,\n          length = sources.length,\n          customizer = length > 1 ? sources[length - 1] : undefined,\n          guard = length > 2 ? sources[2] : undefined;\n\n      customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;\n\n      if (guard && _isIterateeCall(sources[0], sources[1], guard)) {\n        customizer = length < 3 ? undefined : customizer;\n        length = 1;\n      }\n      object = Object(object);\n      while (++index < length) {\n        var source = sources[index];\n        if (source) {\n          assigner(object, source, index, customizer);\n        }\n      }\n      return object;\n    });\n  }\n\n  var _createAssigner = createAssigner;\n\n  /** Used for built-in method references. */\n  var objectProto$5 = Object.prototype;\n\n  /**\n   * Checks if `value` is likely a prototype object.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n   */\n  function isPrototype(value) {\n    var Ctor = value && value.constructor,\n        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$5;\n\n    return value === proto;\n  }\n\n  var _isPrototype = isPrototype;\n\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n    return result;\n  }\n\n  var _baseTimes = baseTimes;\n\n  /**\n   * Checks if `value` is object-like. A value is object-like if it's not `null`\n   * and has a `typeof` result of \"object\".\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   * @example\n   *\n   * _.isObjectLike({});\n   * // => true\n   *\n   * _.isObjectLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isObjectLike(_.noop);\n   * // => false\n   *\n   * _.isObjectLike(null);\n   * // => false\n   */\n  function isObjectLike(value) {\n    return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof2(value)) == 'object';\n  }\n\n  var isObjectLike_1 = isObjectLike;\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]';\n\n  /**\n   * The base implementation of `_.isArguments`.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n   */\n  function baseIsArguments(value) {\n    return isObjectLike_1(value) && _baseGetTag(value) == argsTag;\n  }\n\n  var _baseIsArguments = baseIsArguments;\n\n  /** Used for built-in method references. */\n  var objectProto$7 = Object.prototype;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$5 = objectProto$7.hasOwnProperty;\n\n  /** Built-in value references. */\n  var propertyIsEnumerable = objectProto$7.propertyIsEnumerable;\n\n  /**\n   * Checks if `value` is likely an `arguments` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n   *  else `false`.\n   * @example\n   *\n   * _.isArguments(function() { return arguments; }());\n   * // => true\n   *\n   * _.isArguments([1, 2, 3]);\n   * // => false\n   */\n  var isArguments = _baseIsArguments(function () {\n    return arguments;\n  }()) ? _baseIsArguments : function (value) {\n    return isObjectLike_1(value) && hasOwnProperty$5.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');\n  };\n\n  var isArguments_1 = isArguments;\n\n  /**\n   * Checks if `value` is classified as an `Array` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n   * @example\n   *\n   * _.isArray([1, 2, 3]);\n   * // => true\n   *\n   * _.isArray(document.body.children);\n   * // => false\n   *\n   * _.isArray('abc');\n   * // => false\n   *\n   * _.isArray(_.noop);\n   * // => false\n   */\n  var isArray = Array.isArray;\n\n  var isArray_1 = isArray;\n\n  /**\n   * This method returns `false`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.13.0\n   * @category Util\n   * @returns {boolean} Returns `false`.\n   * @example\n   *\n   * _.times(2, _.stubFalse);\n   * // => [false, false]\n   */\n  function stubFalse() {\n    return false;\n  }\n\n  var stubFalse_1 = stubFalse;\n\n  var isBuffer_1 = createCommonjsModule(function (module, exports) {\n    /** Detect free variable `exports`. */\n    var freeExports = 'object' == 'object' && exports && !exports.nodeType && exports;\n\n    /** Detect free variable `module`. */\n    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;\n\n    /** Detect the popular CommonJS extension `module.exports`. */\n    var moduleExports = freeModule && freeModule.exports === freeExports;\n\n    /** Built-in value references. */\n    var Buffer = moduleExports ? _root.Buffer : undefined;\n\n    /* Built-in method references for those with the same name as other `lodash` methods. */\n    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n    /**\n     * Checks if `value` is a buffer.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n     * @example\n     *\n     * _.isBuffer(new Buffer(2));\n     * // => true\n     *\n     * _.isBuffer(new Uint8Array(2));\n     * // => false\n     */\n    var isBuffer = nativeIsBuffer || stubFalse_1;\n\n    module.exports = isBuffer;\n  });\n\n  /** `Object#toString` result references. */\n  var argsTag$1 = '[object Arguments]';\n  var arrayTag = '[object Array]';\n  var boolTag = '[object Boolean]';\n  var dateTag = '[object Date]';\n  var errorTag = '[object Error]';\n  var funcTag$1 = '[object Function]';\n  var mapTag = '[object Map]';\n  var numberTag = '[object Number]';\n  var objectTag = '[object Object]';\n  var regexpTag = '[object RegExp]';\n  var setTag = '[object Set]';\n  var stringTag = '[object String]';\n  var weakMapTag = '[object WeakMap]';\n\n  var arrayBufferTag = '[object ArrayBuffer]';\n  var dataViewTag = '[object DataView]';\n  var float32Tag = '[object Float32Array]';\n  var float64Tag = '[object Float64Array]';\n  var int8Tag = '[object Int8Array]';\n  var int16Tag = '[object Int16Array]';\n  var int32Tag = '[object Int32Array]';\n  var uint8Tag = '[object Uint8Array]';\n  var uint8ClampedTag = '[object Uint8ClampedArray]';\n  var uint16Tag = '[object Uint16Array]';\n  var uint32Tag = '[object Uint32Array]';\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n\n  /**\n   * The base implementation of `_.isTypedArray` without Node.js optimizations.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n   */\n  function baseIsTypedArray(value) {\n    return isObjectLike_1(value) && isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];\n  }\n\n  var _baseIsTypedArray = baseIsTypedArray;\n\n  /**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */\n  function baseUnary(func) {\n    return function (value) {\n      return func(value);\n    };\n  }\n\n  var _baseUnary = baseUnary;\n\n  var _nodeUtil = createCommonjsModule(function (module, exports) {\n    /** Detect free variable `exports`. */\n    var freeExports = 'object' == 'object' && exports && !exports.nodeType && exports;\n\n    /** Detect free variable `module`. */\n    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;\n\n    /** Detect the popular CommonJS extension `module.exports`. */\n    var moduleExports = freeModule && freeModule.exports === freeExports;\n\n    /** Detect free variable `process` from Node.js. */\n    var freeProcess = moduleExports && _freeGlobal.process;\n\n    /** Used to access faster Node.js helpers. */\n    var nodeUtil = function () {\n      try {\n        return freeProcess && freeProcess.binding && freeProcess.binding('util');\n      } catch (e) {}\n    }();\n\n    module.exports = nodeUtil;\n  });\n\n  /* Node.js helper references. */\n  var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;\n\n  /**\n   * Checks if `value` is classified as a typed array.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n   * @example\n   *\n   * _.isTypedArray(new Uint8Array);\n   * // => true\n   *\n   * _.isTypedArray([]);\n   * // => false\n   */\n  var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;\n\n  var isTypedArray_1 = isTypedArray;\n\n  /** Used for built-in method references. */\n  var objectProto$6 = Object.prototype;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$4 = objectProto$6.hasOwnProperty;\n\n  /**\n   * Creates an array of the enumerable property names of the array-like `value`.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @param {boolean} inherited Specify returning inherited property names.\n   * @returns {Array} Returns the array of property names.\n   */\n  function arrayLikeKeys(value, inherited) {\n    var isArr = isArray_1(value),\n        isArg = !isArr && isArguments_1(value),\n        isBuff = !isArr && !isArg && isBuffer_1(value),\n        isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),\n        skipIndexes = isArr || isArg || isBuff || isType,\n        result = skipIndexes ? _baseTimes(value.length, String) : [],\n        length = result.length;\n\n    for (var key in value) {\n      if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && (\n      // Safari 9 has enumerable `arguments.length` in strict mode.\n      key == 'length' ||\n      // Node.js 0.10 has enumerable non-index properties on buffers.\n      isBuff && (key == 'offset' || key == 'parent') ||\n      // PhantomJS 2 has enumerable non-index properties on typed arrays.\n      isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||\n      // Skip index properties.\n      _isIndex(key, length)))) {\n        result.push(key);\n      }\n    }\n    return result;\n  }\n\n  var _arrayLikeKeys = arrayLikeKeys;\n\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overArg(func, transform) {\n    return function (arg) {\n      return func(transform(arg));\n    };\n  }\n\n  var _overArg = overArg;\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeKeys = _overArg(Object.keys, Object);\n\n  var _nativeKeys = nativeKeys;\n\n  /** Used for built-in method references. */\n  var objectProto$8 = Object.prototype;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$6 = objectProto$8.hasOwnProperty;\n\n  /**\n   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   */\n  function baseKeys(object) {\n    if (!_isPrototype(object)) {\n      return _nativeKeys(object);\n    }\n    var result = [];\n    for (var key in Object(object)) {\n      if (hasOwnProperty$6.call(object, key) && key != 'constructor') {\n        result.push(key);\n      }\n    }\n    return result;\n  }\n\n  var _baseKeys = baseKeys;\n\n  /**\n   * Creates an array of the own enumerable property names of `object`.\n   *\n   * **Note:** Non-object values are coerced to objects. See the\n   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n   * for more details.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Object\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   *   this.b = 2;\n   * }\n   *\n   * Foo.prototype.c = 3;\n   *\n   * _.keys(new Foo);\n   * // => ['a', 'b'] (iteration order is not guaranteed)\n   *\n   * _.keys('hi');\n   * // => ['0', '1']\n   */\n  function keys(object) {\n    return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);\n  }\n\n  var keys_1 = keys;\n\n  /** Used for built-in method references. */\n  var objectProto = Object.prototype;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty = objectProto.hasOwnProperty;\n\n  /**\n   * Assigns own enumerable string keyed properties of source objects to the\n   * destination object. Source objects are applied from left to right.\n   * Subsequent sources overwrite property assignments of previous sources.\n   *\n   * **Note:** This method mutates `object` and is loosely based on\n   * [`Object.assign`](https://mdn.io/Object/assign).\n   *\n   * @static\n   * @memberOf _\n   * @since 0.10.0\n   * @category Object\n   * @param {Object} object The destination object.\n   * @param {...Object} [sources] The source objects.\n   * @returns {Object} Returns `object`.\n   * @see _.assignIn\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   * }\n   *\n   * function Bar() {\n   *   this.c = 3;\n   * }\n   *\n   * Foo.prototype.b = 2;\n   * Bar.prototype.d = 4;\n   *\n   * _.assign({ 'a': 0 }, new Foo, new Bar);\n   * // => { 'a': 1, 'c': 3 }\n   */\n  var assign = _createAssigner(function (object, source) {\n    if (_isPrototype(source) || isArrayLike_1(source)) {\n      _copyObject(source, keys_1(source), object);\n      return;\n    }\n    for (var key in source) {\n      if (hasOwnProperty.call(source, key)) {\n        _assignValue(object, key, source[key]);\n      }\n    }\n  });\n\n  var assign_1$1 = assign;\n\n  // Copyright Joyent, Inc. and other Node contributors.\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a\n  // copy of this software and associated documentation files (the\n  // \"Software\"), to deal in the Software without restriction, including\n  // without limitation the rights to use, copy, modify, merge, publish,\n  // distribute, sublicense, and/or sell copies of the Software, and to permit\n  // persons to whom the Software is furnished to do so, subject to the\n  // following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included\n  // in all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n  // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n  // If obj.hasOwnProperty has been overridden, then calling\n  // obj.hasOwnProperty(prop) will break.\n  // See: https://github.com/joyent/node/issues/1707\n  function hasOwnProperty$7(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  }\n  var isArray$2 = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n  };\n  function stringifyPrimitive(v) {\n    switch (typeof v === 'undefined' ? 'undefined' : _typeof2(v)) {\n      case 'string':\n        return v;\n\n      case 'boolean':\n        return v ? 'true' : 'false';\n\n      case 'number':\n        return isFinite(v) ? v : '';\n\n      default:\n        return '';\n    }\n  }\n\n  function stringify(obj, sep, eq, name) {\n    sep = sep || '&';\n    eq = eq || '=';\n    if (obj === null) {\n      obj = undefined;\n    }\n\n    if ((typeof obj === 'undefined' ? 'undefined' : _typeof2(obj)) === 'object') {\n      return map(objectKeys(obj), function (k) {\n        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n        if (isArray$2(obj[k])) {\n          return map(obj[k], function (v) {\n            return ks + encodeURIComponent(stringifyPrimitive(v));\n          }).join(sep);\n        } else {\n          return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n        }\n      }).join(sep);\n    }\n\n    if (!name) return '';\n    return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));\n  }\n\n  function map(xs, f) {\n    if (xs.map) return xs.map(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n      res.push(f(xs[i], i));\n    }\n    return res;\n  }\n\n  var objectKeys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n  };\n\n  function parse$2(qs, sep, eq, options) {\n    sep = sep || '&';\n    eq = eq || '=';\n    var obj = {};\n\n    if (typeof qs !== 'string' || qs.length === 0) {\n      return obj;\n    }\n\n    var regexp = /\\+/g;\n    qs = qs.split(sep);\n\n    var maxKeys = 1000;\n    if (options && typeof options.maxKeys === 'number') {\n      maxKeys = options.maxKeys;\n    }\n\n    var len = qs.length;\n    // maxKeys <= 0 means that we should not limit keys count\n    if (maxKeys > 0 && len > maxKeys) {\n      len = maxKeys;\n    }\n\n    for (var i = 0; i < len; ++i) {\n      var x = qs[i].replace(regexp, '%20'),\n          idx = x.indexOf(eq),\n          kstr,\n          vstr,\n          k,\n          v;\n\n      if (idx >= 0) {\n        kstr = x.substr(0, idx);\n        vstr = x.substr(idx + 1);\n      } else {\n        kstr = x;\n        vstr = '';\n      }\n\n      k = decodeURIComponent(kstr);\n      v = decodeURIComponent(vstr);\n\n      if (!hasOwnProperty$7(obj, k)) {\n        obj[k] = v;\n      } else if (isArray$2(obj[k])) {\n        obj[k].push(v);\n      } else {\n        obj[k] = [obj[k], v];\n      }\n    }\n\n    return obj;\n  }\n  var querystring = {\n    encode: stringify,\n    stringify: stringify,\n    decode: parse$2,\n    parse: parse$2\n  };\n\n  /*\n   * Simple AJAX request object\n   */\n  var Request = function Request(url, data) {\n    this.url = url;\n    this.data = data || {};\n  };\n\n  Request.prototype.send = function (callback) {\n    var isIE = window.XDomainRequest ? true : false;\n    if (isIE) {\n      var xdr = new window.XDomainRequest();\n      xdr.open('POST', this.url, true);\n      xdr.onload = function () {\n        callback(200, xdr.responseText);\n      };\n      xdr.onerror = function () {\n        // status code not available from xdr, try string matching on responseText\n        if (xdr.responseText === 'Request Entity Too Large') {\n          callback(413, xdr.responseText);\n        } else {\n          callback(500, xdr.responseText);\n        }\n      };\n      xdr.ontimeout = function () {};\n      xdr.onprogress = function () {};\n      xdr.send(querystring.stringify(this.data));\n    } else {\n      var xhr = new XMLHttpRequest();\n      xhr.open('POST', this.url, true);\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState === 4) {\n          callback(xhr.status, xhr.responseText);\n        }\n      };\n      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');\n      xhr.send(querystring.stringify(this.data));\n    }\n    //log('sent request to ' + this.url + ' with data ' + decodeURIComponent(queryString(this.data)));\n  };\n\n  /*\n   * Wrapper for logging Revenue data. Revenue objects get passed to amplitude.logRevenueV2 to send to Amplitude servers.\n   * Note: price is the only required field. If quantity is not specified, then defaults to 1.\n   */\n\n  /**\n   * Revenue API - instance constructor. Revenue objects are a wrapper for revenue data.\n   * Each method updates a revenue property in the Revenue object, and returns the same Revenue object,\n   * allowing you to chain multiple method calls together.\n   * Note: price is a required field to log revenue events.\n   * If quantity is not specified then defaults to 1.\n   * See [Readme]{@link https://github.com/amplitude/Amplitude-Javascript#tracking-revenue} for more information\n   * about logging Revenue.\n   * @constructor Revenue\n   * @public\n   * @example var revenue = new amplitude.Revenue();\n   */\n  var Revenue = function Revenue() {\n    // required fields\n    this._price = null;\n\n    // optional fields\n    this._productId = null;\n    this._quantity = 1;\n    this._revenueType = null;\n    this._properties = null;\n  };\n\n  /**\n   * Set a value for the product identifer.\n   * @public\n   * @param {string} productId - The value for the product identifier. Empty and invalid strings are ignored.\n   * @return {Revenue} Returns the same Revenue object, allowing you to chain multiple method calls together.\n   * @example var revenue = new amplitude.Revenue().setProductId('productIdentifier').setPrice(10.99);\n   * amplitude.logRevenueV2(revenue);\n   */\n  Revenue.prototype.setProductId = function setProductId(productId) {\n    if (type(productId) !== 'string') {\n      utils.log.error('Unsupported type for productId: ' + type(productId) + ', expecting string');\n    } else if (utils.isEmptyString(productId)) {\n      utils.log.error('Invalid empty productId');\n    } else {\n      this._productId = productId;\n    }\n    return this;\n  };\n\n  /**\n   * Set a value for the quantity. Note revenue amount is calculated as price * quantity.\n   * @public\n   * @param {number} quantity - Integer value for the quantity. If not set, quantity defaults to 1.\n   * @return {Revenue} Returns the same Revenue object, allowing you to chain multiple method calls together.\n   * @example var revenue = new amplitude.Revenue().setProductId('productIdentifier').setPrice(10.99).setQuantity(5);\n   * amplitude.logRevenueV2(revenue);\n   */\n  Revenue.prototype.setQuantity = function setQuantity(quantity) {\n    if (type(quantity) !== 'number') {\n      utils.log.error('Unsupported type for quantity: ' + type(quantity) + ', expecting number');\n    } else {\n      this._quantity = parseInt(quantity);\n    }\n    return this;\n  };\n\n  /**\n   * Set a value for the price. This field is required for all revenue being logged.\n   * Note revenue amount is calculated as price * quantity.\n   * @public\n   * @param {number} price - Double value for the quantity.\n   * @return {Revenue} Returns the same Revenue object, allowing you to chain multiple method calls together.\n   * @example var revenue = new amplitude.Revenue().setProductId('productIdentifier').setPrice(10.99);\n   * amplitude.logRevenueV2(revenue);\n   */\n  Revenue.prototype.setPrice = function setPrice(price) {\n    if (type(price) !== 'number') {\n      utils.log.error('Unsupported type for price: ' + type(price) + ', expecting number');\n    } else {\n      this._price = price;\n    }\n    return this;\n  };\n\n  /**\n   * Set a value for the revenueType (for example purchase, cost, tax, refund, etc).\n   * @public\n   * @param {string} revenueType - RevenueType to designate.\n   * @return {Revenue} Returns the same Revenue object, allowing you to chain multiple method calls together.\n   * @example var revenue = new amplitude.Revenue().setProductId('productIdentifier').setPrice(10.99).setRevenueType('purchase');\n   * amplitude.logRevenueV2(revenue);\n   */\n  Revenue.prototype.setRevenueType = function setRevenueType(revenueType) {\n    if (type(revenueType) !== 'string') {\n      utils.log.error('Unsupported type for revenueType: ' + type(revenueType) + ', expecting string');\n    } else {\n      this._revenueType = revenueType;\n    }\n    return this;\n  };\n\n  /**\n   * Set event properties for the revenue event.\n   * @public\n   * @param {object} eventProperties - Revenue event properties to set.\n   * @return {Revenue} Returns the same Revenue object, allowing you to chain multiple method calls together.\n   * @example var event_properties = {'city': 'San Francisco'};\n   * var revenue = new amplitude.Revenue().setProductId('productIdentifier').setPrice(10.99).setEventProperties(event_properties);\n   * amplitude.logRevenueV2(revenue);\n  */\n  Revenue.prototype.setEventProperties = function setEventProperties(eventProperties) {\n    if (type(eventProperties) !== 'object') {\n      utils.log.error('Unsupported type for eventProperties: ' + type(eventProperties) + ', expecting object');\n    } else {\n      this._properties = utils.validateProperties(eventProperties);\n    }\n    return this;\n  };\n\n  /**\n   * @private\n   */\n  Revenue.prototype._isValidRevenue = function _isValidRevenue() {\n    if (type(this._price) !== 'number') {\n      utils.log.error('Invalid revenue, need to set price field');\n      return false;\n    }\n    return true;\n  };\n\n  /**\n   * @private\n   */\n  Revenue.prototype._toJSONObject = function _toJSONObject() {\n    var obj = type(this._properties) === 'object' ? this._properties : {};\n\n    if (this._productId !== null) {\n      obj[constants.REVENUE_PRODUCT_ID] = this._productId;\n    }\n    if (this._quantity !== null) {\n      obj[constants.REVENUE_QUANTITY] = this._quantity;\n    }\n    if (this._price !== null) {\n      obj[constants.REVENUE_PRICE] = this._price;\n    }\n    if (this._revenueType !== null) {\n      obj[constants.REVENUE_REVENUE_TYPE] = this._revenueType;\n    }\n    return obj;\n  };\n\n  var uaParser = createCommonjsModule(function (module, exports) {\n    /* jshint eqeqeq: false, forin: false */\n    /* global define */\n\n    /**\n     * UAParser.js v0.7.10\n     * Lightweight JavaScript-based User-Agent string parser\n     * https://github.com/faisalman/ua-parser-js\n     *\n     * Copyright  2012-2015 Faisal Salman <fyzlman@gmail.com>\n     * Dual licensed under GPLv2 & MIT\n     */\n\n    (function (window, undefined) {\n\n      'use strict';\n\n      //////////////\n      // Constants\n      /////////////\n\n\n      var LIBVERSION = '0.7.10',\n          EMPTY = '',\n          UNKNOWN = '?',\n          FUNC_TYPE = 'function',\n          UNDEF_TYPE = 'undefined',\n          OBJ_TYPE = 'object',\n          STR_TYPE = 'string',\n          MAJOR = 'major',\n          // deprecated\n      MODEL = 'model',\n          NAME = 'name',\n          TYPE = 'type',\n          VENDOR = 'vendor',\n          VERSION = 'version',\n          ARCHITECTURE = 'architecture',\n          CONSOLE = 'console',\n          MOBILE = 'mobile',\n          TABLET = 'tablet',\n          SMARTTV = 'smarttv',\n          WEARABLE = 'wearable',\n          EMBEDDED = 'embedded';\n\n      ///////////\n      // Helper\n      //////////\n\n\n      var util = {\n        extend: function extend(regexes, extensions) {\n          var margedRegexes = {};\n          for (var i in regexes) {\n            if (extensions[i] && extensions[i].length % 2 === 0) {\n              margedRegexes[i] = extensions[i].concat(regexes[i]);\n            } else {\n              margedRegexes[i] = regexes[i];\n            }\n          }\n          return margedRegexes;\n        },\n        has: function has(str1, str2) {\n          if (typeof str1 === \"string\") {\n            return str2.toLowerCase().indexOf(str1.toLowerCase()) !== -1;\n          } else {\n            return false;\n          }\n        },\n        lowerize: function lowerize(str) {\n          return str.toLowerCase();\n        },\n        major: function major(version) {\n          return (typeof version === 'undefined' ? 'undefined' : _typeof2(version)) === STR_TYPE ? version.split(\".\")[0] : undefined;\n        }\n      };\n\n      ///////////////\n      // Map helper\n      //////////////\n\n\n      var mapper = {\n\n        rgx: function rgx() {\n\n          var result,\n              i = 0,\n              j,\n              k,\n              p,\n              q,\n              matches,\n              match,\n              args = arguments;\n\n          // loop through all regexes maps\n          while (i < args.length && !matches) {\n\n            var regex = args[i],\n                // even sequence (0,2,4,..)\n            props = args[i + 1]; // odd sequence (1,3,5,..)\n\n            // construct object barebones\n            if ((typeof result === 'undefined' ? 'undefined' : _typeof2(result)) === UNDEF_TYPE) {\n              result = {};\n              for (p in props) {\n                if (props.hasOwnProperty(p)) {\n                  q = props[p];\n                  if ((typeof q === 'undefined' ? 'undefined' : _typeof2(q)) === OBJ_TYPE) {\n                    result[q[0]] = undefined;\n                  } else {\n                    result[q] = undefined;\n                  }\n                }\n              }\n            }\n\n            // try matching uastring with regexes\n            j = k = 0;\n            while (j < regex.length && !matches) {\n              matches = regex[j++].exec(this.getUA());\n              if (!!matches) {\n                for (p = 0; p < props.length; p++) {\n                  match = matches[++k];\n                  q = props[p];\n                  // check if given property is actually array\n                  if ((typeof q === 'undefined' ? 'undefined' : _typeof2(q)) === OBJ_TYPE && q.length > 0) {\n                    if (q.length == 2) {\n                      if (_typeof2(q[1]) == FUNC_TYPE) {\n                        // assign modified match\n                        result[q[0]] = q[1].call(this, match);\n                      } else {\n                        // assign given value, ignore regex match\n                        result[q[0]] = q[1];\n                      }\n                    } else if (q.length == 3) {\n                      // check whether function or regex\n                      if (_typeof2(q[1]) === FUNC_TYPE && !(q[1].exec && q[1].test)) {\n                        // call function (usually string mapper)\n                        result[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;\n                      } else {\n                        // sanitize match using given regex\n                        result[q[0]] = match ? match.replace(q[1], q[2]) : undefined;\n                      }\n                    } else if (q.length == 4) {\n                      result[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;\n                    }\n                  } else {\n                    result[q] = match ? match : undefined;\n                  }\n                }\n              }\n            }\n            i += 2;\n          }\n          return result;\n        },\n\n        str: function str(_str, map) {\n\n          for (var i in map) {\n            // check if array\n            if (_typeof2(map[i]) === OBJ_TYPE && map[i].length > 0) {\n              for (var j = 0; j < map[i].length; j++) {\n                if (util.has(map[i][j], _str)) {\n                  return i === UNKNOWN ? undefined : i;\n                }\n              }\n            } else if (util.has(map[i], _str)) {\n              return i === UNKNOWN ? undefined : i;\n            }\n          }\n          return _str;\n        }\n      };\n\n      ///////////////\n      // String map\n      //////////////\n\n\n      var maps = {\n\n        browser: {\n          oldsafari: {\n            version: {\n              '1.0': '/8',\n              '1.2': '/1',\n              '1.3': '/3',\n              '2.0': '/412',\n              '2.0.2': '/416',\n              '2.0.3': '/417',\n              '2.0.4': '/419',\n              '?': '/'\n            }\n          },\n          name: {\n            'Opera Mobile': 'Opera Mobi',\n            'IE Mobile': 'IEMobile'\n          }\n        },\n\n        device: {\n          amazon: {\n            model: {\n              'Fire Phone': ['SD', 'KF']\n            }\n          },\n          sprint: {\n            model: {\n              'Evo Shift 4G': '7373KT'\n            },\n            vendor: {\n              'HTC': 'APA',\n              'Sprint': 'Sprint'\n            }\n          }\n        },\n\n        os: {\n          windows: {\n            version: {\n              'ME': '4.90',\n              'NT 3.11': 'NT3.51',\n              'NT 4.0': 'NT4.0',\n              '2000': 'NT 5.0',\n              'XP': ['NT 5.1', 'NT 5.2'],\n              'Vista': 'NT 6.0',\n              '7': 'NT 6.1',\n              '8': 'NT 6.2',\n              '8.1': 'NT 6.3',\n              '10': ['NT 6.4', 'NT 10.0'],\n              'RT': 'ARM'\n            },\n            name: {\n              'Windows Phone': 'Windows Phone OS'\n            }\n          }\n        }\n      };\n\n      //////////////\n      // Regex map\n      /////////////\n\n\n      var regexes = {\n\n        browser: [[\n\n        // Presto based\n        /(opera\\smini)\\/([\\w\\.-]+)/i, // Opera Mini\n        /(opera\\s[mobiletab]+).+version\\/([\\w\\.-]+)/i, // Opera Mobi/Tablet\n        /(opera).+version\\/([\\w\\.]+)/i, // Opera > 9.80\n        /(opera)[\\/\\s]+([\\w\\.]+)/i // Opera < 9.80\n        ], [NAME, VERSION], [/(OPiOS)[\\/\\s]+([\\w\\.]+)/i // Opera mini on iphone >= 8.0\n        ], [[NAME, 'Opera Mini'], VERSION], [/\\s(opr)\\/([\\w\\.]+)/i // Opera Webkit\n        ], [[NAME, 'Opera'], VERSION], [\n\n        // Mixed\n        /(kindle)\\/([\\w\\.]+)/i, // Kindle\n        /(lunascape|maxthon|netfront|jasmine|blazer)[\\/\\s]?([\\w\\.]+)*/i,\n        // Lunascape/Maxthon/Netfront/Jasmine/Blazer\n\n        // Trident based\n        /(avant\\s|iemobile|slim|baidu)(?:browser)?[\\/\\s]?([\\w\\.]*)/i,\n        // Avant/IEMobile/SlimBrowser/Baidu\n        /(?:ms|\\()(ie)\\s([\\w\\.]+)/i, // Internet Explorer\n\n        // Webkit/KHTML based\n        /(rekonq)\\/([\\w\\.]+)*/i, // Rekonq\n        /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs)\\/([\\w\\.-]+)/i\n        // Chromium/Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS\n        ], [NAME, VERSION], [/(trident).+rv[:\\s]([\\w\\.]+).+like\\sgecko/i // IE11\n        ], [[NAME, 'IE'], VERSION], [/(edge)\\/((\\d+)?[\\w\\.]+)/i // Microsoft Edge\n        ], [NAME, VERSION], [/(yabrowser)\\/([\\w\\.]+)/i // Yandex\n        ], [[NAME, 'Yandex'], VERSION], [/(comodo_dragon)\\/([\\w\\.]+)/i // Comodo Dragon\n        ], [[NAME, /_/g, ' '], VERSION], [/((?:android.+)crmo|crios)\\/([\\w\\.]+)/i, /android.+(chrome)\\/([\\w\\.]+)\\s+(?:mobile\\s?safari)/i // Chrome for Android/iOS\n        ], [[NAME, 'Chrome Mobile'], VERSION], [/(chrome|omniweb|arora|[tizenoka]{5}\\s?browser)\\/v?([\\w\\.]+)/i,\n        // Chrome/OmniWeb/Arora/Tizen/Nokia\n        /(qqbrowser)[\\/\\s]?([\\w\\.]+)/i\n        // QQBrowser\n        ], [NAME, VERSION], [/(uc\\s?browser)[\\/\\s]?([\\w\\.]+)/i, /ucweb.+(ucbrowser)[\\/\\s]?([\\w\\.]+)/i, /JUC.+(ucweb)[\\/\\s]?([\\w\\.]+)/i\n        // UCBrowser\n        ], [[NAME, 'UCBrowser'], VERSION], [/(dolfin)\\/([\\w\\.]+)/i // Dolphin\n        ], [[NAME, 'Dolphin'], VERSION], [/XiaoMi\\/MiuiBrowser\\/([\\w\\.]+)/i // MIUI Browser\n        ], [VERSION, [NAME, 'MIUI Browser']], [/android.+version\\/([\\w\\.]+)\\s+(?:mobile\\s?safari|safari)/i // Android Browser\n        ], [VERSION, [NAME, 'Android Browser']], [/FBAV\\/([\\w\\.]+);/i // Facebook App for iOS\n        ], [VERSION, [NAME, 'Facebook']], [/fxios\\/([\\w\\.-]+)/i // Firefox for iOS\n        ], [VERSION, [NAME, 'Firefox']], [/version\\/([\\w\\.]+).+?mobile\\/\\w+\\s(safari)/i // Mobile Safari\n        ], [VERSION, [NAME, 'Mobile Safari']], [/version\\/([\\w\\.]+).+?(mobile\\s?safari|safari)/i // Safari & Safari Mobile\n        ], [VERSION, NAME], [/webkit.+?(mobile\\s?safari|safari)(\\/[\\w\\.]+)/i // Safari < 3.0\n        ], [NAME, [VERSION, mapper.str, maps.browser.oldsafari.version]], [/(konqueror)\\/([\\w\\.]+)/i, // Konqueror\n        /(webkit|khtml)\\/([\\w\\.]+)/i], [NAME, VERSION], [/(blackberry)\\\\s?\\/([\\w\\.]+)/i // Blackberry\n        ], [[NAME, \"BlackBerry\"], VERSION], [\n\n        // Gecko based\n        /(navigator|netscape)\\/([\\w\\.-]+)/i // Netscape\n        ], [[NAME, 'Netscape'], VERSION], [/(swiftfox)/i, // Swiftfox\n        /(icedragon|iceweasel|camino|chimera|fennec|maemo\\sbrowser|minimo|conkeror)[\\/\\s]?([\\w\\.\\+]+)/i,\n        // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror\n        /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix)\\/([\\w\\.-]+)/i,\n        // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix\n        /(mozilla)\\/([\\w\\.]+).+rv\\:.+gecko\\/\\d+/i, // Mozilla\n\n        // Other\n        /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\\/\\s]?([\\w\\.]+)/i,\n        // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir\n        /(links)\\s\\(([\\w\\.]+)/i, // Links\n        /(gobrowser)\\/?([\\w\\.]+)*/i, // GoBrowser\n        /(ice\\s?browser)\\/v?([\\w\\._]+)/i, // ICE Browser\n        /(mosaic)[\\/\\s]([\\w\\.]+)/i // Mosaic\n        ], [NAME, VERSION]\n\n        /* /////////////////////\n        // Media players BEGIN\n        ////////////////////////\n         , [\n         /(apple(?:coremedia|))\\/((\\d+)[\\w\\._]+)/i,                          // Generic Apple CoreMedia\n        /(coremedia) v((\\d+)[\\w\\._]+)/i\n        ], [NAME, VERSION], [\n         /(aqualung|lyssna|bsplayer)\\/((\\d+)?[\\w\\.-]+)/i                     // Aqualung/Lyssna/BSPlayer\n        ], [NAME, VERSION], [\n         /(ares|ossproxy)\\s((\\d+)[\\w\\.-]+)/i                                 // Ares/OSSProxy\n        ], [NAME, VERSION], [\n         /(audacious|audimusicstream|amarok|bass|core|dalvik|gnomemplayer|music on console|nsplayer|psp-internetradioplayer|videos)\\/((\\d+)[\\w\\.-]+)/i,\n                                                                            // Audacious/AudiMusicStream/Amarok/BASS/OpenCORE/Dalvik/GnomeMplayer/MoC\n                                                                            // NSPlayer/PSP-InternetRadioPlayer/Videos\n        /(clementine|music player daemon)\\s((\\d+)[\\w\\.-]+)/i,               // Clementine/MPD\n        /(lg player|nexplayer)\\s((\\d+)[\\d\\.]+)/i,\n        /player\\/(nexplayer|lg player)\\s((\\d+)[\\w\\.-]+)/i                   // NexPlayer/LG Player\n        ], [NAME, VERSION], [\n        /(nexplayer)\\s((\\d+)[\\w\\.-]+)/i                                     // Nexplayer\n        ], [NAME, VERSION], [\n         /(flrp)\\/((\\d+)[\\w\\.-]+)/i                                          // Flip Player\n        ], [[NAME, 'Flip Player'], VERSION], [\n         /(fstream|nativehost|queryseekspider|ia-archiver|facebookexternalhit)/i\n                                                                            // FStream/NativeHost/QuerySeekSpider/IA Archiver/facebookexternalhit\n        ], [NAME], [\n         /(gstreamer) souphttpsrc (?:\\([^\\)]+\\)){0,1} libsoup\\/((\\d+)[\\w\\.-]+)/i\n                                                                            // Gstreamer\n        ], [NAME, VERSION], [\n         /(htc streaming player)\\s[\\w_]+\\s\\/\\s((\\d+)[\\d\\.]+)/i,              // HTC Streaming Player\n        /(java|python-urllib|python-requests|wget|libcurl)\\/((\\d+)[\\w\\.-_]+)/i,\n                                                                            // Java/urllib/requests/wget/cURL\n        /(lavf)((\\d+)[\\d\\.]+)/i                                             // Lavf (FFMPEG)\n        ], [NAME, VERSION], [\n         /(htc_one_s)\\/((\\d+)[\\d\\.]+)/i                                      // HTC One S\n        ], [[NAME, /_/g, ' '], VERSION], [\n         /(mplayer)(?:\\s|\\/)(?:(?:sherpya-){0,1}svn)(?:-|\\s)(r\\d+(?:-\\d+[\\w\\.-]+){0,1})/i\n                                                                            // MPlayer SVN\n        ], [NAME, VERSION], [\n         /(mplayer)(?:\\s|\\/|[unkow-]+)((\\d+)[\\w\\.-]+)/i                      // MPlayer\n        ], [NAME, VERSION], [\n         /(mplayer)/i,                                                       // MPlayer (no other info)\n        /(yourmuze)/i,                                                      // YourMuze\n        /(media player classic|nero showtime)/i                             // Media Player Classic/Nero ShowTime\n        ], [NAME], [\n         /(nero (?:home|scout))\\/((\\d+)[\\w\\.-]+)/i                           // Nero Home/Nero Scout\n        ], [NAME, VERSION], [\n         /(nokia\\d+)\\/((\\d+)[\\w\\.-]+)/i                                      // Nokia\n        ], [NAME, VERSION], [\n         /\\s(songbird)\\/((\\d+)[\\w\\.-]+)/i                                    // Songbird/Philips-Songbird\n        ], [NAME, VERSION], [\n         /(winamp)3 version ((\\d+)[\\w\\.-]+)/i,                               // Winamp\n        /(winamp)\\s((\\d+)[\\w\\.-]+)/i,\n        /(winamp)mpeg\\/((\\d+)[\\w\\.-]+)/i\n        ], [NAME, VERSION], [\n         /(ocms-bot|tapinradio|tunein radio|unknown|winamp|inlight radio)/i  // OCMS-bot/tap in radio/tunein/unknown/winamp (no other info)\n                                                                            // inlight radio\n        ], [NAME], [\n         /(quicktime|rma|radioapp|radioclientapplication|soundtap|totem|stagefright|streamium)\\/((\\d+)[\\w\\.-]+)/i\n                                                                            // QuickTime/RealMedia/RadioApp/RadioClientApplication/\n                                                                            // SoundTap/Totem/Stagefright/Streamium\n        ], [NAME, VERSION], [\n         /(smp)((\\d+)[\\d\\.]+)/i                                              // SMP\n        ], [NAME, VERSION], [\n         /(vlc) media player - version ((\\d+)[\\w\\.]+)/i,                     // VLC Videolan\n        /(vlc)\\/((\\d+)[\\w\\.-]+)/i,\n        /(xbmc|gvfs|xine|xmms|irapp)\\/((\\d+)[\\w\\.-]+)/i,                    // XBMC/gvfs/Xine/XMMS/irapp\n        /(foobar2000)\\/((\\d+)[\\d\\.]+)/i,                                    // Foobar2000\n        /(itunes)\\/((\\d+)[\\d\\.]+)/i                                         // iTunes\n        ], [NAME, VERSION], [\n         /(wmplayer)\\/((\\d+)[\\w\\.-]+)/i,                                     // Windows Media Player\n        /(windows-media-player)\\/((\\d+)[\\w\\.-]+)/i\n        ], [[NAME, /-/g, ' '], VERSION], [\n         /windows\\/((\\d+)[\\w\\.-]+) upnp\\/[\\d\\.]+ dlnadoc\\/[\\d\\.]+ (home media server)/i\n                                                                            // Windows Media Server\n        ], [VERSION, [NAME, 'Windows']], [\n         /(com\\.riseupradioalarm)\\/((\\d+)[\\d\\.]*)/i                          // RiseUP Radio Alarm\n        ], [NAME, VERSION], [\n         /(rad.io)\\s((\\d+)[\\d\\.]+)/i,                                        // Rad.io\n        /(radio.(?:de|at|fr))\\s((\\d+)[\\d\\.]+)/i\n        ], [[NAME, 'rad.io'], VERSION]\n         //////////////////////\n        // Media players END\n        ////////////////////*/\n\n        ],\n\n        cpu: [[/(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\\)]/i // AMD64\n        ], [[ARCHITECTURE, 'amd64']], [/(ia32(?=;))/i // IA32 (quicktime)\n        ], [[ARCHITECTURE, util.lowerize]], [/((?:i[346]|x)86)[;\\)]/i // IA32\n        ], [[ARCHITECTURE, 'ia32']], [\n\n        // PocketPC mistakenly identified as PowerPC\n        /windows\\s(ce|mobile);\\sppc;/i], [[ARCHITECTURE, 'arm']], [/((?:ppc|powerpc)(?:64)?)(?:\\smac|;|\\))/i // PowerPC\n        ], [[ARCHITECTURE, /ower/, '', util.lowerize]], [/(sun4\\w)[;\\)]/i // SPARC\n        ], [[ARCHITECTURE, 'sparc']], [/((?:avr32|ia64(?=;))|68k(?=\\))|arm(?:64|(?=v\\d+;))|(?=atmel\\s)avr|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i\n        // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC\n        ], [[ARCHITECTURE, util.lowerize]]],\n\n        device: [[/\\((ipad|playbook);[\\w\\s\\);-]+(rim|apple)/i // iPad/PlayBook\n        ], [MODEL, VENDOR, [TYPE, TABLET]], [/applecoremedia\\/[\\w\\.]+ \\((ipad)/ // iPad\n        ], [MODEL, [VENDOR, 'Apple'], [TYPE, TABLET]], [/(apple\\s{0,1}tv)/i // Apple TV\n        ], [[MODEL, 'Apple TV'], [VENDOR, 'Apple']], [/(archos)\\s(gamepad2?)/i, // Archos\n        /(hp).+(touchpad)/i, // HP TouchPad\n        /(kindle)\\/([\\w\\.]+)/i, // Kindle\n        /\\s(nook)[\\w\\s]+build\\/(\\w+)/i, // Nook\n        /(dell)\\s(strea[kpr\\s\\d]*[\\dko])/i // Dell Streak\n        ], [VENDOR, MODEL, [TYPE, TABLET]], [/(kf[A-z]+)\\sbuild\\/[\\w\\.]+.*silk\\//i // Kindle Fire HD\n        ], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [/(sd|kf)[0349hijorstuw]+\\sbuild\\/[\\w\\.]+.*silk\\//i // Fire Phone\n        ], [[MODEL, mapper.str, maps.device.amazon.model], [VENDOR, 'Amazon'], [TYPE, MOBILE]], [/\\((ip[honed|\\s\\w*]+);.+(apple)/i // iPod/iPhone\n        ], [MODEL, VENDOR, [TYPE, MOBILE]], [/\\((ip[honed|\\s\\w*]+);/i // iPod/iPhone\n        ], [MODEL, [VENDOR, 'Apple'], [TYPE, MOBILE]], [/(blackberry)[\\s-]?(\\w+)/i, // BlackBerry\n        /(blackberry|benq|palm(?=\\-)|sonyericsson|acer|asus|dell|huawei|meizu|motorola|polytron)[\\s_-]?([\\w-]+)*/i,\n        // BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Huawei/Meizu/Motorola/Polytron\n        /(hp)\\s([\\w\\s]+\\w)/i, // HP iPAQ\n        /(asus)-?(\\w+)/i // Asus\n        ], [VENDOR, MODEL, [TYPE, MOBILE]], [/\\(bb10;\\s(\\w+)/i // BlackBerry 10\n        ], [MODEL, [VENDOR, 'BlackBerry'], [TYPE, MOBILE]], [\n        // Asus Tablets\n        /android.+(transfo[prime\\s]{4,10}\\s\\w+|eeepc|slider\\s\\w+|nexus 7)/i], [MODEL, [VENDOR, 'Asus'], [TYPE, TABLET]], [/(sony)\\s(tablet\\s[ps])\\sbuild\\//i, // Sony\n        /(sony)?(?:sgp.+)\\sbuild\\//i], [[VENDOR, 'Sony'], [MODEL, 'Xperia Tablet'], [TYPE, TABLET]], [/(?:sony)?(?:(?:(?:c|d)\\d{4})|(?:so[-l].+))\\sbuild\\//i], [[VENDOR, 'Sony'], [MODEL, 'Xperia Phone'], [TYPE, MOBILE]], [/\\s(ouya)\\s/i, // Ouya\n        /(nintendo)\\s([wids3u]+)/i // Nintendo\n        ], [VENDOR, MODEL, [TYPE, CONSOLE]], [/android.+;\\s(shield)\\sbuild/i // Nvidia\n        ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, CONSOLE]], [/(playstation\\s[34portablevi]+)/i // Playstation\n        ], [MODEL, [VENDOR, 'Sony'], [TYPE, CONSOLE]], [/(sprint\\s(\\w+))/i // Sprint Phones\n        ], [[VENDOR, mapper.str, maps.device.sprint.vendor], [MODEL, mapper.str, maps.device.sprint.model], [TYPE, MOBILE]], [/(lenovo)\\s?(S(?:5000|6000)+(?:[-][\\w+]))/i // Lenovo tablets\n        ], [VENDOR, MODEL, [TYPE, TABLET]], [/(htc)[;_\\s-]+([\\w\\s]+(?=\\))|\\w+)*/i, // HTC\n        /(zte)-(\\w+)*/i, // ZTE\n        /(alcatel|geeksphone|huawei|lenovo|nexian|panasonic|(?=;\\s)sony)[_\\s-]?([\\w-]+)*/i\n        // Alcatel/GeeksPhone/Huawei/Lenovo/Nexian/Panasonic/Sony\n        ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [/(nexus\\s9)/i // HTC Nexus 9\n        ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [/[\\s\\(;](xbox(?:\\sone)?)[\\s\\);]/i // Microsoft Xbox\n        ], [MODEL, [VENDOR, 'Microsoft'], [TYPE, CONSOLE]], [/(kin\\.[onetw]{3})/i // Microsoft Kin\n        ], [[MODEL, /\\./g, ' '], [VENDOR, 'Microsoft'], [TYPE, MOBILE]], [\n\n        // Motorola\n        /\\s(milestone|droid(?:[2-4x]|\\s(?:bionic|x2|pro|razr))?(:?\\s4g)?)[\\w\\s]+build\\//i, /mot[\\s-]?(\\w+)*/i, /(XT\\d{3,4}) build\\//i, /(nexus\\s[6])/i], [MODEL, [VENDOR, 'Motorola'], [TYPE, MOBILE]], [/android.+\\s(mz60\\d|xoom[\\s2]{0,2})\\sbuild\\//i], [MODEL, [VENDOR, 'Motorola'], [TYPE, TABLET]], [/android.+((sch-i[89]0\\d|shw-m380s|gt-p\\d{4}|gt-n8000|sgh-t8[56]9|nexus 10))/i, /((SM-T\\w+))/i], [[VENDOR, 'Samsung'], MODEL, [TYPE, TABLET]], [// Samsung\n        /((s[cgp]h-\\w+|gt-\\w+|galaxy\\snexus|sm-n900))/i, /(sam[sung]*)[\\s-]*(\\w+-?[\\w-]*)*/i, /sec-((sgh\\w+))/i], [[VENDOR, 'Samsung'], MODEL, [TYPE, MOBILE]], [/(samsung);smarttv/i], [VENDOR, MODEL, [TYPE, SMARTTV]], [/\\(dtv[\\);].+(aquos)/i // Sharp\n        ], [MODEL, [VENDOR, 'Sharp'], [TYPE, SMARTTV]], [/sie-(\\w+)*/i // Siemens\n        ], [MODEL, [VENDOR, 'Siemens'], [TYPE, MOBILE]], [/(maemo|nokia).*(n900|lumia\\s\\d+)/i, // Nokia\n        /(nokia)[\\s_-]?([\\w-]+)*/i], [[VENDOR, 'Nokia'], MODEL, [TYPE, MOBILE]], [/android\\s3\\.[\\s\\w;-]{10}(a\\d{3})/i // Acer\n        ], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [/android\\s3\\.[\\s\\w;-]{10}(lg?)-([06cv9]{3,4})/i // LG Tablet\n        ], [[VENDOR, 'LG'], MODEL, [TYPE, TABLET]], [/(lg) netcast\\.tv/i // LG SmartTV\n        ], [VENDOR, MODEL, [TYPE, SMARTTV]], [/(nexus\\s[45])/i, // LG\n        /lg[e;\\s\\/-]+(\\w+)*/i], [MODEL, [VENDOR, 'LG'], [TYPE, MOBILE]], [/android.+(ideatab[a-z0-9\\-\\s]+)/i // Lenovo\n        ], [MODEL, [VENDOR, 'Lenovo'], [TYPE, TABLET]], [/linux;.+((jolla));/i // Jolla\n        ], [VENDOR, MODEL, [TYPE, MOBILE]], [/((pebble))app\\/[\\d\\.]+\\s/i // Pebble\n        ], [VENDOR, MODEL, [TYPE, WEARABLE]], [/android.+;\\s(glass)\\s\\d/i // Google Glass\n        ], [MODEL, [VENDOR, 'Google'], [TYPE, WEARABLE]], [/android.+(\\w+)\\s+build\\/hm\\1/i, // Xiaomi Hongmi 'numeric' models\n        /android.+(hm[\\s\\-_]*note?[\\s_]*(?:\\d\\w)?)\\s+build/i, // Xiaomi Hongmi\n        /android.+(mi[\\s\\-_]*(?:one|one[\\s_]plus)?[\\s_]*(?:\\d\\w)?)\\s+build/i // Xiaomi Mi\n        ], [[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, MOBILE]], [/\\s(tablet)[;\\/\\s]/i, // Unidentifiable Tablet\n        /\\s(mobile)[;\\/\\s]/i // Unidentifiable Mobile\n        ], [[TYPE, util.lowerize], VENDOR, MODEL]\n\n        /*//////////////////////////\n        // TODO: move to string map\n        ////////////////////////////\n         /(C6603)/i                                                          // Sony Xperia Z C6603\n        ], [[MODEL, 'Xperia Z C6603'], [VENDOR, 'Sony'], [TYPE, MOBILE]], [\n        /(C6903)/i                                                          // Sony Xperia Z 1\n        ], [[MODEL, 'Xperia Z 1'], [VENDOR, 'Sony'], [TYPE, MOBILE]], [\n         /(SM-G900[F|H])/i                                                   // Samsung Galaxy S5\n        ], [[MODEL, 'Galaxy S5'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [\n        /(SM-G7102)/i                                                       // Samsung Galaxy Grand 2\n        ], [[MODEL, 'Galaxy Grand 2'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [\n        /(SM-G530H)/i                                                       // Samsung Galaxy Grand Prime\n        ], [[MODEL, 'Galaxy Grand Prime'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [\n        /(SM-G313HZ)/i                                                      // Samsung Galaxy V\n        ], [[MODEL, 'Galaxy V'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [\n        /(SM-T805)/i                                                        // Samsung Galaxy Tab S 10.5\n        ], [[MODEL, 'Galaxy Tab S 10.5'], [VENDOR, 'Samsung'], [TYPE, TABLET]], [\n        /(SM-G800F)/i                                                       // Samsung Galaxy S5 Mini\n        ], [[MODEL, 'Galaxy S5 Mini'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [\n        /(SM-T311)/i                                                        // Samsung Galaxy Tab 3 8.0\n        ], [[MODEL, 'Galaxy Tab 3 8.0'], [VENDOR, 'Samsung'], [TYPE, TABLET]], [\n         /(R1001)/i                                                          // Oppo R1001\n        ], [MODEL, [VENDOR, 'OPPO'], [TYPE, MOBILE]], [\n        /(X9006)/i                                                          // Oppo Find 7a\n        ], [[MODEL, 'Find 7a'], [VENDOR, 'Oppo'], [TYPE, MOBILE]], [\n        /(R2001)/i                                                          // Oppo YOYO R2001\n        ], [[MODEL, 'Yoyo R2001'], [VENDOR, 'Oppo'], [TYPE, MOBILE]], [\n        /(R815)/i                                                           // Oppo Clover R815\n        ], [[MODEL, 'Clover R815'], [VENDOR, 'Oppo'], [TYPE, MOBILE]], [\n         /(U707)/i                                                          // Oppo Find Way S\n        ], [[MODEL, 'Find Way S'], [VENDOR, 'Oppo'], [TYPE, MOBILE]], [\n         /(T3C)/i                                                            // Advan Vandroid T3C\n        ], [MODEL, [VENDOR, 'Advan'], [TYPE, TABLET]], [\n        /(ADVAN T1J\\+)/i                                                    // Advan Vandroid T1J+\n        ], [[MODEL, 'Vandroid T1J+'], [VENDOR, 'Advan'], [TYPE, TABLET]], [\n        /(ADVAN S4A)/i                                                      // Advan Vandroid S4A\n        ], [[MODEL, 'Vandroid S4A'], [VENDOR, 'Advan'], [TYPE, MOBILE]], [\n         /(V972M)/i                                                          // ZTE V972M\n        ], [MODEL, [VENDOR, 'ZTE'], [TYPE, MOBILE]], [\n         /(i-mobile)\\s(IQ\\s[\\d\\.]+)/i                                        // i-mobile IQ\n        ], [VENDOR, MODEL, [TYPE, MOBILE]], [\n        /(IQ6.3)/i                                                          // i-mobile IQ IQ 6.3\n        ], [[MODEL, 'IQ 6.3'], [VENDOR, 'i-mobile'], [TYPE, MOBILE]], [\n        /(i-mobile)\\s(i-style\\s[\\d\\.]+)/i                                   // i-mobile i-STYLE\n        ], [VENDOR, MODEL, [TYPE, MOBILE]], [\n        /(i-STYLE2.1)/i                                                     // i-mobile i-STYLE 2.1\n        ], [[MODEL, 'i-STYLE 2.1'], [VENDOR, 'i-mobile'], [TYPE, MOBILE]], [\n         /(mobiistar touch LAI 512)/i                                        // mobiistar touch LAI 512\n        ], [[MODEL, 'Touch LAI 512'], [VENDOR, 'mobiistar'], [TYPE, MOBILE]], [\n         /////////////\n        // END TODO\n        ///////////*/\n\n        ],\n\n        engine: [[/windows.+\\sedge\\/([\\w\\.]+)/i // EdgeHTML\n        ], [VERSION, [NAME, 'EdgeHTML']], [/(presto)\\/([\\w\\.]+)/i, // Presto\n        /(webkit|trident|netfront|netsurf|amaya|lynx|w3m)\\/([\\w\\.]+)/i, // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m\n        /(khtml|tasman|links)[\\/\\s]\\(?([\\w\\.]+)/i, // KHTML/Tasman/Links\n        /(icab)[\\/\\s]([23]\\.[\\d\\.]+)/i // iCab\n        ], [NAME, VERSION], [/rv\\:([\\w\\.]+).*(gecko)/i // Gecko\n        ], [VERSION, NAME]],\n\n        os: [[\n\n        // Windows based\n        /microsoft\\s(windows)\\s(vista|xp)/i // Windows (iTunes)\n        ], [NAME, VERSION], [/(windows)\\snt\\s6\\.2;\\s(arm)/i, // Windows RT\n        /(windows\\sphone(?:\\sos)*|windows\\smobile|windows)[\\s\\/]?([ntce\\d\\.\\s]+\\w)/i], [[NAME, mapper.str, maps.os.windows.name], [VERSION, mapper.str, maps.os.windows.version]], [/(win(?=3|9|n)|win\\s9x\\s)([nt\\d\\.]+)/i], [[NAME, 'Windows'], [VERSION, mapper.str, maps.os.windows.version]], [\n\n        // Mobile/Embedded OS\n        /\\((bb)(10);/i // BlackBerry 10\n        ], [[NAME, 'BlackBerry'], VERSION], [/(blackberry)\\w*\\/?([\\w\\.]+)*/i, // Blackberry\n        /(tizen)[\\/\\s]([\\w\\.]+)/i, // Tizen\n        /(android|webos|palm\\sos|qnx|bada|rim\\stablet\\sos|meego|contiki)[\\/\\s-]?([\\w\\.]+)*/i,\n        // Android/WebOS/Palm/QNX/Bada/RIM/MeeGo/Contiki\n        /linux;.+(sailfish);/i // Sailfish OS\n        ], [NAME, VERSION], [/(symbian\\s?o?s?|symbos|s60(?=;))[\\/\\s-]?([\\w\\.]+)*/i // Symbian\n        ], [[NAME, 'Symbian'], VERSION], [/\\((series40);/i // Series 40\n        ], [NAME], [/mozilla.+\\(mobile;.+gecko.+firefox/i // Firefox OS\n        ], [[NAME, 'Firefox OS'], VERSION], [\n\n        // Console\n        /(nintendo|playstation)\\s([wids34portablevu]+)/i, // Nintendo/Playstation\n\n        // GNU/Linux based\n        /(mint)[\\/\\s\\(]?(\\w+)*/i, // Mint\n        /(mageia|vectorlinux)[;\\s]/i, // Mageia/VectorLinux\n        /(joli|[kxln]?ubuntu|debian|[open]*suse|gentoo|(?=\\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\\/\\s-]?([\\w\\.-]+)*/i,\n        // Joli/Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware\n        // Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus\n        /(hurd|linux)\\s?([\\w\\.]+)*/i, // Hurd/Linux\n        /(gnu)\\s?([\\w\\.]+)*/i // GNU\n        ], [[NAME, 'Linux'], VERSION], [/(cros)\\s[\\w]+\\s([\\w\\.]+\\w)/i // Chromium OS\n        ], [[NAME, 'Chromium OS'], VERSION], [\n\n        // Solaris\n        /(sunos)\\s?([\\w\\.]+\\d)*/i // Solaris\n        ], [[NAME, 'Solaris'], VERSION], [\n\n        // BSD based\n        /\\s([frentopc-]{0,4}bsd|dragonfly)\\s?([\\w\\.]+)*/i // FreeBSD/NetBSD/OpenBSD/PC-BSD/DragonFly\n        ], [[NAME, 'Linux'], VERSION], [/(iphone)(?:.*os\\s*([\\w]+)*\\slike\\smac|;\\sopera)/i // iOS\n        ], [[NAME, 'iPhone'], [VERSION, /_/g, '.']], [/(ipad)(?:.*os\\s*([\\w]+)*\\slike\\smac|;\\sopera)/i // iOS\n        ], [[NAME, 'iPad'], [VERSION, /_/g, '.']], [/(ip[honead]+)(?:.*os\\s([\\w]+)*\\slike\\smac|;\\sopera)/i // iOS\n        ], [[NAME, 'iOS'], [VERSION, /_/g, '.']], [/(mac\\sos\\sx)\\s?([\\w\\s\\.]+\\w)*/i, /(macintosh|mac(?=_powerpc)\\s)/i // Mac OS\n        ], [[NAME, 'Mac'], [VERSION, /_/g, '.']], [\n\n        // Other\n        /((?:open)?solaris)[\\/\\s-]?([\\w\\.]+)*/i, // Solaris\n        /(haiku)\\s(\\w+)/i, // Haiku\n        /(aix)\\s((\\d)(?=\\.|\\)|\\s)[\\w\\.]*)*/i, // AIX\n        /(plan\\s9|minix|beos|os\\/2|amigaos|morphos|risc\\sos|openvms)/i,\n        // Plan9/Minix/BeOS/OS2/AmigaOS/MorphOS/RISCOS/OpenVMS\n        /(unix)\\s?([\\w\\.]+)*/i // UNIX\n        ], [NAME, VERSION]]\n      };\n\n      /////////////////\n      // Constructor\n      ////////////////\n\n\n      var UAParser = function UAParser(uastring, extensions) {\n\n        if (!(this instanceof UAParser)) {\n          return new UAParser(uastring, extensions).getResult();\n        }\n\n        var ua = uastring || (window && window.navigator && window.navigator.userAgent ? window.navigator.userAgent : EMPTY);\n        var rgxmap = extensions ? util.extend(regexes, extensions) : regexes;\n\n        this.getBrowser = function () {\n          var browser = mapper.rgx.apply(this, rgxmap.browser);\n          browser.major = util.major(browser.version);\n          return browser;\n        };\n        this.getCPU = function () {\n          return mapper.rgx.apply(this, rgxmap.cpu);\n        };\n        this.getDevice = function () {\n          return mapper.rgx.apply(this, rgxmap.device);\n        };\n        this.getEngine = function () {\n          return mapper.rgx.apply(this, rgxmap.engine);\n        };\n        this.getOS = function () {\n          return mapper.rgx.apply(this, rgxmap.os);\n        };\n        this.getResult = function () {\n          return {\n            ua: this.getUA(),\n            browser: this.getBrowser(),\n            engine: this.getEngine(),\n            os: this.getOS(),\n            device: this.getDevice(),\n            cpu: this.getCPU()\n          };\n        };\n        this.getUA = function () {\n          return ua;\n        };\n        this.setUA = function (uastring) {\n          ua = uastring;\n          return this;\n        };\n        return this;\n      };\n\n      UAParser.VERSION = LIBVERSION;\n      UAParser.BROWSER = {\n        NAME: NAME,\n        MAJOR: MAJOR, // deprecated\n        VERSION: VERSION\n      };\n      UAParser.CPU = {\n        ARCHITECTURE: ARCHITECTURE\n      };\n      UAParser.DEVICE = {\n        MODEL: MODEL,\n        VENDOR: VENDOR,\n        TYPE: TYPE,\n        CONSOLE: CONSOLE,\n        MOBILE: MOBILE,\n        SMARTTV: SMARTTV,\n        TABLET: TABLET,\n        WEARABLE: WEARABLE,\n        EMBEDDED: EMBEDDED\n      };\n      UAParser.ENGINE = {\n        NAME: NAME,\n        VERSION: VERSION\n      };\n      UAParser.OS = {\n        NAME: NAME,\n        VERSION: VERSION\n      };\n\n      ///////////\n      // Export\n      //////////\n\n\n      // check js environment\n      if ('object' !== UNDEF_TYPE) {\n        // nodejs env\n        if ('object' !== UNDEF_TYPE && module.exports) {\n          exports = module.exports = UAParser;\n        }\n        exports.UAParser = UAParser;\n      } else {\n        // requirejs env (optional)\n        if ((typeof undefined === 'undefined' ? 'undefined' : _typeof2(undefined)) === FUNC_TYPE && undefined.amd) {\n          undefined(\"ua-parser-js\", [], function () {\n            return UAParser;\n          });\n        } else {\n          // browser env\n          window.UAParser = UAParser;\n        }\n      }\n\n      // jQuery/Zepto specific (optional)\n      // Note:\n      //   In AMD env the global scope should be kept clean, but jQuery is an exception.\n      //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,\n      //   and we should catch that.\n      var $ = window.jQuery || window.Zepto;\n      if ((typeof $ === 'undefined' ? 'undefined' : _typeof2($)) !== UNDEF_TYPE) {\n        var parser = new UAParser();\n        $.ua = parser.getResult();\n        $.ua.get = function () {\n          return parser.getUA();\n        };\n        $.ua.set = function (uastring) {\n          parser.setUA(uastring);\n          var result = parser.getResult();\n          for (var prop in result) {\n            $.ua[prop] = result[prop];\n          }\n        };\n      }\n    })((typeof window === 'undefined' ? 'undefined' : _typeof2(window)) === 'object' ? window : commonjsGlobal);\n  });\n\n  /* jshint bitwise: false, laxbreak: true */\n\n  /**\n   * Source: [jed's gist]{@link https://gist.github.com/982883}.\n   * Returns a random v4 UUID of the form xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx,\n   * where each x is replaced with a random hexadecimal digit from 0 to f, and\n   * y is replaced with a random hexadecimal digit from 8 to b.\n   * Used to generate UUIDs for deviceIds.\n   * @private\n   */\n  var uuid$1 = function uuid(a) {\n    return a // if the placeholder was passed, return\n    ? ( // a random number from 0 to 15\n    a ^ // unless b is 8,\n    Math.random() // in which case\n    * 16 // a random number from\n    >> a / 4 // 8 to 11\n    ).toString(16) // in hexadecimal\n    : ( // or otherwise a concatenated string:\n    [1e7] + // 10000000 +\n    -1e3 + // -1000 +\n    -4e3 + // -4000 +\n    -8e3 + // -80000000 +\n    -1e11 // -100000000000,\n    ).replace( // replacing\n    /[018]/g, // zeroes, ones, and eights with\n    uuid // random hex digits\n    );\n  };\n\n  var version = '3.8.0';\n\n  var getLanguage = function getLanguage() {\n    return navigator && (navigator.languages && navigator.languages[0] || navigator.language || navigator.userLanguage) || undefined;\n  };\n\n  var language = {\n    language: getLanguage()\n  };\n\n  // default options\n  var DEFAULT_OPTIONS = {\n    apiEndpoint: 'api.amplitude.com',\n    cookieExpiration: 365 * 10,\n    cookieName: 'amplitude_id',\n    domain: '',\n    includeReferrer: false,\n    includeUtm: false,\n    language: language.language,\n    logLevel: 'WARN',\n    optOut: false,\n    platform: 'Web',\n    savedMaxCount: 1000,\n    saveEvents: true,\n    sessionTimeout: 30 * 60 * 1000,\n    unsentKey: 'amplitude_unsent',\n    unsentIdentifyKey: 'amplitude_unsent_identify',\n    uploadBatchSize: 100,\n    batchEvents: false,\n    eventUploadThreshold: 30,\n    eventUploadPeriodMillis: 30 * 1000, // 30s\n    forceHttps: false,\n    includeGclid: false,\n    saveParamsReferrerOncePerSession: true,\n    deviceIdFromUrlParam: false\n  };\n\n  /**\n   * AmplitudeClient SDK API - instance constructor.\n   * The Amplitude class handles creation of client instances, all you need to do is call amplitude.getInstance()\n   * @constructor AmplitudeClient\n   * @public\n   * @example var amplitudeClient = new AmplitudeClient();\n   */\n  var AmplitudeClient = function AmplitudeClient(instanceName) {\n    this._instanceName = utils.isEmptyString(instanceName) ? constants.DEFAULT_INSTANCE : instanceName.toLowerCase();\n    this._storageSuffix = this._instanceName === constants.DEFAULT_INSTANCE ? '' : '_' + this._instanceName;\n    this._unsentEvents = [];\n    this._unsentIdentifys = [];\n    this._ua = new uaParser(navigator.userAgent).getResult();\n    this.options = assign_1$1({}, DEFAULT_OPTIONS);\n    this.cookieStorage = new cookieStorage().getStorage();\n    this._q = []; // queue for proxied functions before script load\n    this._sending = false;\n    this._updateScheduled = false;\n\n    // event meta data\n    this._eventId = 0;\n    this._identifyId = 0;\n    this._lastEventTime = null;\n    this._newSession = false;\n    this._sequenceNumber = 0;\n    this._sessionId = null;\n\n    this._userAgent = navigator && navigator.userAgent || null;\n  };\n\n  AmplitudeClient.prototype.Identify = Identify;\n  AmplitudeClient.prototype.Revenue = Revenue;\n\n  /**\n   * Initializes the Amplitude Javascript SDK with your apiKey and any optional configurations.\n   * This is required before any other methods can be called.\n   * @public\n   * @param {string} apiKey - The API key for your app.\n   * @param {string} opt_userId - (optional) An identifier for this user.\n   * @param {object} opt_config - (optional) Configuration options.\n   * See [Readme]{@link https://github.com/amplitude/Amplitude-Javascript#configuration-options} for list of options and default values.\n   * @param {function} opt_callback - (optional) Provide a callback function to run after initialization is complete.\n   * @example amplitudeClient.init('API_KEY', 'USER_ID', {includeReferrer: true, includeUtm: true}, function() { alert('init complete'); });\n   */\n  AmplitudeClient.prototype.init = function init(apiKey, opt_userId, opt_config, opt_callback) {\n    if (type(apiKey) !== 'string' || utils.isEmptyString(apiKey)) {\n      utils.log.error('Invalid apiKey. Please re-initialize with a valid apiKey');\n      return;\n    }\n\n    try {\n      this.options.apiKey = apiKey;\n      _parseConfig(this.options, opt_config);\n      this.cookieStorage.options({\n        expirationDays: this.options.cookieExpiration,\n        domain: this.options.domain\n      });\n      this.options.domain = this.cookieStorage.options().domain;\n\n      if (this._instanceName === constants.DEFAULT_INSTANCE) {\n        _upgradeCookeData(this);\n      }\n      _loadCookieData(this);\n\n      // load deviceId and userId from input, or try to fetch existing value from cookie\n      this.options.deviceId = type(opt_config) === 'object' && type(opt_config.deviceId) === 'string' && !utils.isEmptyString(opt_config.deviceId) && opt_config.deviceId || this.options.deviceIdFromUrlParam && this._getDeviceIdFromUrlParam(this._getUrlParams()) || this.options.deviceId || uuid$1() + 'R';\n      this.options.userId = type(opt_userId) === 'string' && !utils.isEmptyString(opt_userId) && opt_userId || this.options.userId || null;\n\n      // load unsent events and identifies before any attempt to log new ones\n      if (this.options.saveEvents) {\n        this._unsentEvents = this._loadSavedUnsentEvents(this.options.unsentKey);\n        this._unsentIdentifys = this._loadSavedUnsentEvents(this.options.unsentIdentifyKey);\n\n        // validate event properties for unsent events\n        for (var i = 0; i < this._unsentEvents.length; i++) {\n          var eventProperties = this._unsentEvents[i].event_properties;\n          var groups = this._unsentEvents[i].groups;\n          this._unsentEvents[i].event_properties = utils.validateProperties(eventProperties);\n          this._unsentEvents[i].groups = utils.validateGroups(groups);\n        }\n\n        // validate user properties for unsent identifys\n        for (var j = 0; j < this._unsentIdentifys.length; j++) {\n          var userProperties = this._unsentIdentifys[j].user_properties;\n          var identifyGroups = this._unsentIdentifys[j].groups;\n          this._unsentIdentifys[j].user_properties = utils.validateProperties(userProperties);\n          this._unsentIdentifys[j].groups = utils.validateGroups(identifyGroups);\n        }\n      }\n\n      var now = new Date().getTime();\n      if (!this._sessionId || !this._lastEventTime || now - this._lastEventTime > this.options.sessionTimeout) {\n        this._newSession = true;\n        this._sessionId = now;\n\n        // only capture UTM params and referrer if new session\n        if (this.options.saveParamsReferrerOncePerSession) {\n          this._trackParamsAndReferrer();\n        }\n      }\n\n      if (!this.options.saveParamsReferrerOncePerSession) {\n        this._trackParamsAndReferrer();\n      }\n\n      this._lastEventTime = now;\n      _saveCookieData(this);\n\n      this._sendEventsIfReady(); // try sending unsent events\n    } catch (e) {\n      utils.log.error(e);\n    } finally {\n      if (type(opt_callback) === 'function') {\n        opt_callback(this);\n      }\n    }\n  };\n\n  /**\n   * @private\n   */\n  AmplitudeClient.prototype._trackParamsAndReferrer = function _trackParamsAndReferrer() {\n    if (this.options.includeUtm) {\n      this._initUtmData();\n    }\n    if (this.options.includeReferrer) {\n      this._saveReferrer(this._getReferrer());\n    }\n    if (this.options.includeGclid) {\n      this._saveGclid(this._getUrlParams());\n    }\n  };\n\n  /**\n   * Parse and validate user specified config values and overwrite existing option value\n   * DEFAULT_OPTIONS provides list of all config keys that are modifiable, as well as expected types for values\n   * @private\n   */\n  var _parseConfig = function _parseConfig(options, config) {\n    if (type(config) !== 'object') {\n      return;\n    }\n\n    // validates config value is defined, is the correct type, and some additional value sanity checks\n    var parseValidateAndLoad = function parseValidateAndLoad(key) {\n      if (!DEFAULT_OPTIONS.hasOwnProperty(key)) {\n        return; // skip bogus config values\n      }\n\n      var inputValue = config[key];\n      var expectedType = type(DEFAULT_OPTIONS[key]);\n      if (!utils.validateInput(inputValue, key + ' option', expectedType)) {\n        return;\n      }\n      if (expectedType === 'boolean') {\n        options[key] = !!inputValue;\n      } else if (expectedType === 'string' && !utils.isEmptyString(inputValue) || expectedType === 'number' && inputValue > 0) {\n        options[key] = inputValue;\n      }\n    };\n\n    for (var key in config) {\n      if (config.hasOwnProperty(key)) {\n        parseValidateAndLoad(key);\n      }\n    }\n  };\n\n  /**\n   * Run functions queued up by proxy loading snippet\n   * @private\n   */\n  AmplitudeClient.prototype.runQueuedFunctions = function () {\n    for (var i = 0; i < this._q.length; i++) {\n      var fn = this[this._q[i][0]];\n      if (type(fn) === 'function') {\n        fn.apply(this, this._q[i].slice(1));\n      }\n    }\n    this._q = []; // clear function queue after running\n  };\n\n  /**\n   * Check that the apiKey is set before calling a function. Logs a warning message if not set.\n   * @private\n   */\n  AmplitudeClient.prototype._apiKeySet = function _apiKeySet(methodName) {\n    if (utils.isEmptyString(this.options.apiKey)) {\n      utils.log.error('Invalid apiKey. Please set a valid apiKey with init() before calling ' + methodName);\n      return false;\n    }\n    return true;\n  };\n\n  /**\n   * Load saved events from localStorage. JSON deserializes event array. Handles case where string is corrupted.\n   * @private\n   */\n  AmplitudeClient.prototype._loadSavedUnsentEvents = function _loadSavedUnsentEvents(unsentKey) {\n    var savedUnsentEventsString = this._getFromStorage(localStorage$1, unsentKey);\n    if (utils.isEmptyString(savedUnsentEventsString)) {\n      return []; // new app, does not have any saved events\n    }\n\n    if (type(savedUnsentEventsString) === 'string') {\n      try {\n        var events = JSON.parse(savedUnsentEventsString);\n        if (type(events) === 'array') {\n          // handle case where JSON dumping of unsent events is corrupted\n          return events;\n        }\n      } catch (e) {}\n    }\n    utils.log.error('Unable to load ' + unsentKey + ' events. Restart with a new empty queue.');\n    return [];\n  };\n\n  /**\n   * Returns true if a new session was created during initialization, otherwise false.\n   * @public\n   * @return {boolean} Whether a new session was created during initialization.\n   */\n  AmplitudeClient.prototype.isNewSession = function isNewSession() {\n    return this._newSession;\n  };\n\n  /**\n   * Returns the id of the current session.\n   * @public\n   * @return {number} Id of the current session.\n   */\n  AmplitudeClient.prototype.getSessionId = function getSessionId() {\n    return this._sessionId;\n  };\n\n  /**\n   * Increments the eventId and returns it.\n   * @private\n   */\n  AmplitudeClient.prototype.nextEventId = function nextEventId() {\n    this._eventId++;\n    return this._eventId;\n  };\n\n  /**\n   * Increments the identifyId and returns it.\n   * @private\n   */\n  AmplitudeClient.prototype.nextIdentifyId = function nextIdentifyId() {\n    this._identifyId++;\n    return this._identifyId;\n  };\n\n  /**\n   * Increments the sequenceNumber and returns it.\n   * @private\n   */\n  AmplitudeClient.prototype.nextSequenceNumber = function nextSequenceNumber() {\n    this._sequenceNumber++;\n    return this._sequenceNumber;\n  };\n\n  /**\n   * Returns the total count of unsent events and identifys\n   * @private\n   */\n  AmplitudeClient.prototype._unsentCount = function _unsentCount() {\n    return this._unsentEvents.length + this._unsentIdentifys.length;\n  };\n\n  /**\n   * Send events if ready. Returns true if events are sent.\n   * @private\n   */\n  AmplitudeClient.prototype._sendEventsIfReady = function _sendEventsIfReady(callback) {\n    if (this._unsentCount() === 0) {\n      return false;\n    }\n\n    // if batching disabled, send any unsent events immediately\n    if (!this.options.batchEvents) {\n      this.sendEvents(callback);\n      return true;\n    }\n\n    // if batching enabled, check if min threshold met for batch size\n    if (this._unsentCount() >= this.options.eventUploadThreshold) {\n      this.sendEvents(callback);\n      return true;\n    }\n\n    // otherwise schedule an upload after 30s\n    if (!this._updateScheduled) {\n      // make sure we only schedule 1 upload\n      this._updateScheduled = true;\n      setTimeout(function () {\n        this._updateScheduled = false;\n        this.sendEvents();\n      }.bind(this), this.options.eventUploadPeriodMillis);\n    }\n\n    return false; // an upload was scheduled, no events were uploaded\n  };\n\n  /**\n   * Helper function to fetch values from storage\n   * Storage argument allows for localStoraoge and sessionStoraoge\n   * @private\n   */\n  AmplitudeClient.prototype._getFromStorage = function _getFromStorage(storage, key) {\n    return storage.getItem(key + this._storageSuffix);\n  };\n\n  /**\n   * Helper function to set values in storage\n   * Storage argument allows for localStoraoge and sessionStoraoge\n   * @private\n   */\n  AmplitudeClient.prototype._setInStorage = function _setInStorage(storage, key, value) {\n    storage.setItem(key + this._storageSuffix, value);\n  };\n\n  /**\n   * cookieData (deviceId, userId, optOut, sessionId, lastEventTime, eventId, identifyId, sequenceNumber)\n   * can be stored in many different places (localStorage, cookie, etc).\n   * Need to unify all sources into one place with a one-time upgrade/migration.\n   * @private\n   */\n  var _upgradeCookeData = function _upgradeCookeData(scope) {\n    // skip if migration already happened\n    var cookieData = scope.cookieStorage.get(scope.options.cookieName);\n    if (type(cookieData) === 'object' && cookieData.deviceId && cookieData.sessionId && cookieData.lastEventTime) {\n      return;\n    }\n\n    var _getAndRemoveFromLocalStorage = function _getAndRemoveFromLocalStorage(key) {\n      var value = localStorage$1.getItem(key);\n      localStorage$1.removeItem(key);\n      return value;\n    };\n\n    // in v2.6.0, deviceId, userId, optOut was migrated to localStorage with keys + first 6 char of apiKey\n    var apiKeySuffix = type(scope.options.apiKey) === 'string' && '_' + scope.options.apiKey.slice(0, 6) || '';\n    var localStorageDeviceId = _getAndRemoveFromLocalStorage(constants.DEVICE_ID + apiKeySuffix);\n    var localStorageUserId = _getAndRemoveFromLocalStorage(constants.USER_ID + apiKeySuffix);\n    var localStorageOptOut = _getAndRemoveFromLocalStorage(constants.OPT_OUT + apiKeySuffix);\n    if (localStorageOptOut !== null && localStorageOptOut !== undefined) {\n      localStorageOptOut = String(localStorageOptOut) === 'true'; // convert to boolean\n    }\n\n    // pre-v2.7.0 event and session meta-data was stored in localStorage. move to cookie for sub-domain support\n    var localStorageSessionId = parseInt(_getAndRemoveFromLocalStorage(constants.SESSION_ID));\n    var localStorageLastEventTime = parseInt(_getAndRemoveFromLocalStorage(constants.LAST_EVENT_TIME));\n    var localStorageEventId = parseInt(_getAndRemoveFromLocalStorage(constants.LAST_EVENT_ID));\n    var localStorageIdentifyId = parseInt(_getAndRemoveFromLocalStorage(constants.LAST_IDENTIFY_ID));\n    var localStorageSequenceNumber = parseInt(_getAndRemoveFromLocalStorage(constants.LAST_SEQUENCE_NUMBER));\n\n    var _getFromCookie = function _getFromCookie(key) {\n      return type(cookieData) === 'object' && cookieData[key];\n    };\n    scope.options.deviceId = _getFromCookie('deviceId') || localStorageDeviceId;\n    scope.options.userId = _getFromCookie('userId') || localStorageUserId;\n    scope._sessionId = _getFromCookie('sessionId') || localStorageSessionId || scope._sessionId;\n    scope._lastEventTime = _getFromCookie('lastEventTime') || localStorageLastEventTime || scope._lastEventTime;\n    scope._eventId = _getFromCookie('eventId') || localStorageEventId || scope._eventId;\n    scope._identifyId = _getFromCookie('identifyId') || localStorageIdentifyId || scope._identifyId;\n    scope._sequenceNumber = _getFromCookie('sequenceNumber') || localStorageSequenceNumber || scope._sequenceNumber;\n\n    // optOut is a little trickier since it is a boolean\n    scope.options.optOut = localStorageOptOut || false;\n    if (cookieData && cookieData.optOut !== undefined && cookieData.optOut !== null) {\n      scope.options.optOut = String(cookieData.optOut) === 'true';\n    }\n\n    _saveCookieData(scope);\n  };\n\n  /**\n   * Fetches deviceId, userId, event meta data from amplitude cookie\n   * @private\n   */\n  var _loadCookieData = function _loadCookieData(scope) {\n    var cookieData = scope.cookieStorage.get(scope.options.cookieName + scope._storageSuffix);\n    if (type(cookieData) === 'object') {\n      if (cookieData.deviceId) {\n        scope.options.deviceId = cookieData.deviceId;\n      }\n      if (cookieData.userId) {\n        scope.options.userId = cookieData.userId;\n      }\n      if (cookieData.optOut !== null && cookieData.optOut !== undefined) {\n        scope.options.optOut = cookieData.optOut;\n      }\n      if (cookieData.sessionId) {\n        scope._sessionId = parseInt(cookieData.sessionId);\n      }\n      if (cookieData.lastEventTime) {\n        scope._lastEventTime = parseInt(cookieData.lastEventTime);\n      }\n      if (cookieData.eventId) {\n        scope._eventId = parseInt(cookieData.eventId);\n      }\n      if (cookieData.identifyId) {\n        scope._identifyId = parseInt(cookieData.identifyId);\n      }\n      if (cookieData.sequenceNumber) {\n        scope._sequenceNumber = parseInt(cookieData.sequenceNumber);\n      }\n    }\n  };\n\n  /**\n   * Saves deviceId, userId, event meta data to amplitude cookie\n   * @private\n   */\n  var _saveCookieData = function _saveCookieData(scope) {\n    scope.cookieStorage.set(scope.options.cookieName + scope._storageSuffix, {\n      deviceId: scope.options.deviceId,\n      userId: scope.options.userId,\n      optOut: scope.options.optOut,\n      sessionId: scope._sessionId,\n      lastEventTime: scope._lastEventTime,\n      eventId: scope._eventId,\n      identifyId: scope._identifyId,\n      sequenceNumber: scope._sequenceNumber\n    });\n  };\n\n  /**\n   * Parse the utm properties out of cookies and query for adding to user properties.\n   * @private\n   */\n  AmplitudeClient.prototype._initUtmData = function _initUtmData(queryParams, cookieParams) {\n    queryParams = queryParams || this._getUrlParams();\n    cookieParams = cookieParams || this.cookieStorage.get('__utmz');\n    var utmProperties = getUtmData(cookieParams, queryParams);\n    _sendParamsReferrerUserProperties(this, utmProperties);\n  };\n\n  /**\n   * The calling function should determine when it is appropriate to send these user properties. This function\n   * will no longer contain any session storage checking logic.\n   * @private\n   */\n  var _sendParamsReferrerUserProperties = function _sendParamsReferrerUserProperties(scope, userProperties) {\n    if (type(userProperties) !== 'object' || Object.keys(userProperties).length === 0) {\n      return;\n    }\n\n    // setOnce the initial user properties\n    var identify = new Identify();\n    for (var key in userProperties) {\n      if (userProperties.hasOwnProperty(key)) {\n        identify.setOnce('initial_' + key, userProperties[key]);\n        identify.set(key, userProperties[key]);\n      }\n    }\n\n    scope.identify(identify);\n  };\n\n  /**\n   * @private\n   */\n  AmplitudeClient.prototype._getReferrer = function _getReferrer() {\n    return document.referrer;\n  };\n\n  /**\n   * @private\n   */\n  AmplitudeClient.prototype._getUrlParams = function _getUrlParams() {\n    return location.search;\n  };\n\n  /**\n   * Try to fetch Google Gclid from url params.\n   * @private\n   */\n  AmplitudeClient.prototype._saveGclid = function _saveGclid(urlParams) {\n    var gclid = utils.getQueryParam('gclid', urlParams);\n    if (utils.isEmptyString(gclid)) {\n      return;\n    }\n    var gclidProperties = { 'gclid': gclid };\n    _sendParamsReferrerUserProperties(this, gclidProperties);\n  };\n\n  /**\n   * Try to fetch Amplitude device id from url params.\n   * @private\n   */\n  AmplitudeClient.prototype._getDeviceIdFromUrlParam = function _getDeviceIdFromUrlParam(urlParams) {\n    return utils.getQueryParam(constants.AMP_DEVICE_ID_PARAM, urlParams);\n  };\n\n  /**\n   * Parse the domain from referrer info\n   * @private\n   */\n  AmplitudeClient.prototype._getReferringDomain = function _getReferringDomain(referrer) {\n    if (utils.isEmptyString(referrer)) {\n      return null;\n    }\n    var parts = referrer.split('/');\n    if (parts.length >= 3) {\n      return parts[2];\n    }\n    return null;\n  };\n\n  /**\n   * Fetch the referrer information, parse the domain and send.\n   * Since user properties are propagated on the server, only send once per session, don't need to send with every event\n   * @private\n   */\n  AmplitudeClient.prototype._saveReferrer = function _saveReferrer(referrer) {\n    if (utils.isEmptyString(referrer)) {\n      return;\n    }\n    var referrerInfo = {\n      'referrer': referrer,\n      'referring_domain': this._getReferringDomain(referrer)\n    };\n    _sendParamsReferrerUserProperties(this, referrerInfo);\n  };\n\n  /**\n   * Saves unsent events and identifies to localStorage. JSON stringifies event queues before saving.\n   * Note: this is called automatically every time events are logged, unless you explicitly set option saveEvents to false.\n   * @private\n   */\n  AmplitudeClient.prototype.saveEvents = function saveEvents() {\n    try {\n      this._setInStorage(localStorage$1, this.options.unsentKey, JSON.stringify(this._unsentEvents));\n    } catch (e) {}\n\n    try {\n      this._setInStorage(localStorage$1, this.options.unsentIdentifyKey, JSON.stringify(this._unsentIdentifys));\n    } catch (e) {}\n  };\n\n  /**\n   * Sets a customer domain for the amplitude cookie. Useful if you want to support cross-subdomain tracking.\n   * @public\n   * @param {string} domain to set.\n   * @example amplitudeClient.setDomain('.amplitude.com');\n   */\n  AmplitudeClient.prototype.setDomain = function setDomain(domain) {\n    if (!utils.validateInput(domain, 'domain', 'string')) {\n      return;\n    }\n\n    try {\n      this.cookieStorage.options({\n        domain: domain\n      });\n      this.options.domain = this.cookieStorage.options().domain;\n      _loadCookieData(this);\n      _saveCookieData(this);\n    } catch (e) {\n      utils.log.error(e);\n    }\n  };\n\n  /**\n   * Sets an identifier for the current user.\n   * @public\n   * @param {string} userId - identifier to set. Can be null.\n   * @example amplitudeClient.setUserId('joe@gmail.com');\n   */\n  AmplitudeClient.prototype.setUserId = function setUserId(userId) {\n    try {\n      this.options.userId = userId !== undefined && userId !== null && '' + userId || null;\n      _saveCookieData(this);\n    } catch (e) {\n      utils.log.error(e);\n    }\n  };\n\n  /**\n   * Add user to a group or groups. You need to specify a groupType and groupName(s).\n   * For example you can group people by their organization.\n   * In that case groupType is \"orgId\" and groupName would be the actual ID(s).\n   * groupName can be a string or an array of strings to indicate a user in multiple gruups.\n   * You can also call setGroup multiple times with different groupTypes to track multiple types of groups (up to 5 per app).\n   * Note: this will also set groupType: groupName as a user property.\n   * See the [SDK Readme]{@link https://github.com/amplitude/Amplitude-Javascript#setting-groups} for more information.\n   * @public\n   * @param {string} groupType - the group type (ex: orgId)\n   * @param {string|list} groupName - the name of the group (ex: 15), or a list of names of the groups\n   * @example amplitudeClient.setGroup('orgId', 15); // this adds the current user to orgId 15.\n   */\n  AmplitudeClient.prototype.setGroup = function (groupType, groupName) {\n    if (!this._apiKeySet('setGroup()') || !utils.validateInput(groupType, 'groupType', 'string') || utils.isEmptyString(groupType)) {\n      return;\n    }\n\n    var groups = {};\n    groups[groupType] = groupName;\n    var identify = new Identify().set(groupType, groupName);\n    this._logEvent(constants.IDENTIFY_EVENT, null, null, identify.userPropertiesOperations, groups, null, null);\n  };\n\n  /**\n   * Sets whether to opt current user out of tracking.\n   * @public\n   * @param {boolean} enable - if true then no events will be logged or sent.\n   * @example: amplitude.setOptOut(true);\n   */\n  AmplitudeClient.prototype.setOptOut = function setOptOut(enable) {\n    if (!utils.validateInput(enable, 'enable', 'boolean')) {\n      return;\n    }\n\n    try {\n      this.options.optOut = enable;\n      _saveCookieData(this);\n    } catch (e) {\n      utils.log.error(e);\n    }\n  };\n\n  AmplitudeClient.prototype.setSessionId = function setSessionId(sessionId) {\n    if (!utils.validateInput(sessionId, 'sessionId', 'number')) {\n      return;\n    }\n\n    try {\n      this._sessionId = sessionId;\n      _saveCookieData(this);\n    } catch (e) {\n      utils.log.error(e);\n    }\n  };\n\n  /**\n    * Regenerates a new random deviceId for current user. Note: this is not recommended unless you know what you\n    * are doing. This can be used in conjunction with `setUserId(null)` to anonymize users after they log out.\n    * With a null userId and a completely new deviceId, the current user would appear as a brand new user in dashboard.\n    * This uses src/uuid.js to regenerate the deviceId.\n    * @public\n    */\n  AmplitudeClient.prototype.regenerateDeviceId = function regenerateDeviceId() {\n    this.setDeviceId(uuid$1() + 'R');\n  };\n\n  /**\n    * Sets a custom deviceId for current user. Note: this is not recommended unless you know what you are doing\n    * (like if you have your own system for managing deviceIds). Make sure the deviceId you set is sufficiently unique\n    * (we recommend something like a UUID - see src/uuid.js for an example of how to generate) to prevent conflicts with other devices in our system.\n    * @public\n    * @param {string} deviceId - custom deviceId for current user.\n    * @example amplitudeClient.setDeviceId('45f0954f-eb79-4463-ac8a-233a6f45a8f0');\n    */\n  AmplitudeClient.prototype.setDeviceId = function setDeviceId(deviceId) {\n    if (!utils.validateInput(deviceId, 'deviceId', 'string')) {\n      return;\n    }\n\n    try {\n      if (!utils.isEmptyString(deviceId)) {\n        this.options.deviceId = '' + deviceId;\n        _saveCookieData(this);\n      }\n    } catch (e) {\n      utils.log.error(e);\n    }\n  };\n\n  /**\n   * Sets user properties for the current user.\n   * @public\n   * @param {object} - object with string keys and values for the user properties to set.\n   * @param {boolean} - DEPRECATED opt_replace: in earlier versions of the JS SDK the user properties object was kept in\n   * memory and replace = true would replace the object in memory. Now the properties are no longer stored in memory, so replace is deprecated.\n   * @example amplitudeClient.setUserProperties({'gender': 'female', 'sign_up_complete': true})\n   */\n  AmplitudeClient.prototype.setUserProperties = function setUserProperties(userProperties) {\n    if (!this._apiKeySet('setUserProperties()') || !utils.validateInput(userProperties, 'userProperties', 'object')) {\n      return;\n    }\n    // sanitize the userProperties dict before converting into identify\n    var sanitized = utils.truncate(utils.validateProperties(userProperties));\n    if (Object.keys(sanitized).length === 0) {\n      return;\n    }\n\n    // convert userProperties into an identify call\n    var identify = new Identify();\n    for (var property in sanitized) {\n      if (sanitized.hasOwnProperty(property)) {\n        identify.set(property, sanitized[property]);\n      }\n    }\n    this.identify(identify);\n  };\n\n  /**\n   * Clear all of the user properties for the current user. Note: clearing user properties is irreversible!\n   * @public\n   * @example amplitudeClient.clearUserProperties();\n   */\n  AmplitudeClient.prototype.clearUserProperties = function clearUserProperties() {\n    if (!this._apiKeySet('clearUserProperties()')) {\n      return;\n    }\n\n    var identify = new Identify();\n    identify.clearAll();\n    this.identify(identify);\n  };\n\n  /**\n   * Applies the proxied functions on the proxied object to an instance of the real object.\n   * Used to convert proxied Identify and Revenue objects.\n   * @private\n   */\n  var _convertProxyObjectToRealObject = function _convertProxyObjectToRealObject(instance, proxy) {\n    for (var i = 0; i < proxy._q.length; i++) {\n      var fn = instance[proxy._q[i][0]];\n      if (type(fn) === 'function') {\n        fn.apply(instance, proxy._q[i].slice(1));\n      }\n    }\n    return instance;\n  };\n\n  /**\n   * Send an identify call containing user property operations to Amplitude servers.\n   * See [Readme]{@link https://github.com/amplitude/Amplitude-Javascript#user-properties-and-user-property-operations}\n   * for more information on the Identify API and user property operations.\n   * @param {Identify} identify_obj - the Identify object containing the user property operations to send.\n   * @param {Amplitude~eventCallback} opt_callback - (optional) callback function to run when the identify event has been sent.\n   * Note: the server response code and response body from the identify event upload are passed to the callback function.\n   * @example\n   * var identify = new amplitude.Identify().set('colors', ['rose', 'gold']).add('karma', 1).setOnce('sign_up_date', '2016-03-31');\n   * amplitude.identify(identify);\n   */\n  AmplitudeClient.prototype.identify = function (identify_obj, opt_callback) {\n    if (!this._apiKeySet('identify()')) {\n      if (type(opt_callback) === 'function') {\n        opt_callback(0, 'No request sent');\n      }\n      return;\n    }\n\n    // if identify input is a proxied object created by the async loading snippet, convert it into an identify object\n    if (type(identify_obj) === 'object' && identify_obj.hasOwnProperty('_q')) {\n      identify_obj = _convertProxyObjectToRealObject(new Identify(), identify_obj);\n    }\n\n    if (identify_obj instanceof Identify) {\n      // only send if there are operations\n      if (Object.keys(identify_obj.userPropertiesOperations).length > 0) {\n        return this._logEvent(constants.IDENTIFY_EVENT, null, null, identify_obj.userPropertiesOperations, null, null, opt_callback);\n      }\n    } else {\n      utils.log.error('Invalid identify input type. Expected Identify object but saw ' + type(identify_obj));\n    }\n\n    if (type(opt_callback) === 'function') {\n      opt_callback(0, 'No request sent');\n    }\n  };\n\n  /**\n   * Set a versionName for your application.\n   * @public\n   * @param {string} versionName - The version to set for your application.\n   * @example amplitudeClient.setVersionName('1.12.3');\n   */\n  AmplitudeClient.prototype.setVersionName = function setVersionName(versionName) {\n    if (!utils.validateInput(versionName, 'versionName', 'string')) {\n      return;\n    }\n    this.options.versionName = versionName;\n  };\n\n  /**\n   * Private logEvent method. Keeps apiProperties from being publicly exposed.\n   * @private\n   */\n  AmplitudeClient.prototype._logEvent = function _logEvent(eventType, eventProperties, apiProperties, userProperties, groups, timestamp, callback) {\n    _loadCookieData(this); // reload cookie before each log event to sync event meta-data between windows and tabs\n    if (!eventType || this.options.optOut) {\n      if (type(callback) === 'function') {\n        callback(0, 'No request sent');\n      }\n      return;\n    }\n\n    try {\n      var eventId;\n      if (eventType === constants.IDENTIFY_EVENT) {\n        eventId = this.nextIdentifyId();\n      } else {\n        eventId = this.nextEventId();\n      }\n      var sequenceNumber = this.nextSequenceNumber();\n      var eventTime = type(timestamp) === 'number' ? timestamp : new Date().getTime();\n      if (!this._sessionId || !this._lastEventTime || eventTime - this._lastEventTime > this.options.sessionTimeout) {\n        this._sessionId = eventTime;\n      }\n      this._lastEventTime = eventTime;\n      _saveCookieData(this);\n\n      userProperties = userProperties || {};\n      apiProperties = apiProperties || {};\n      eventProperties = eventProperties || {};\n      groups = groups || {};\n      var event = {\n        device_id: this.options.deviceId,\n        user_id: this.options.userId,\n        timestamp: eventTime,\n        event_id: eventId,\n        session_id: this._sessionId || -1,\n        event_type: eventType,\n        version_name: this.options.versionName || null,\n        platform: this.options.platform,\n        os_name: this._ua.browser.name || null,\n        os_version: this._ua.browser.major || null,\n        device_model: this._ua.os.name || null,\n        language: this.options.language,\n        api_properties: apiProperties,\n        event_properties: utils.truncate(utils.validateProperties(eventProperties)),\n        user_properties: utils.truncate(utils.validateProperties(userProperties)),\n        uuid: uuid$1(),\n        library: {\n          name: 'amplitude-js',\n          version: version\n        },\n        sequence_number: sequenceNumber, // for ordering events and identifys\n        groups: utils.truncate(utils.validateGroups(groups)),\n        user_agent: this._userAgent\n        // country: null\n      };\n\n      if (eventType === constants.IDENTIFY_EVENT) {\n        this._unsentIdentifys.push(event);\n        this._limitEventsQueued(this._unsentIdentifys);\n      } else {\n        this._unsentEvents.push(event);\n        this._limitEventsQueued(this._unsentEvents);\n      }\n\n      if (this.options.saveEvents) {\n        this.saveEvents();\n      }\n\n      if (!this._sendEventsIfReady(callback) && type(callback) === 'function') {\n        callback(0, 'No request sent');\n      }\n\n      return eventId;\n    } catch (e) {\n      utils.log.error(e);\n    }\n  };\n\n  /**\n   * Remove old events from the beginning of the array if too many have accumulated. Default limit is 1000 events.\n   * @private\n   */\n  AmplitudeClient.prototype._limitEventsQueued = function _limitEventsQueued(queue) {\n    if (queue.length > this.options.savedMaxCount) {\n      queue.splice(0, queue.length - this.options.savedMaxCount);\n    }\n  };\n\n  /**\n   * This is the callback for logEvent and identify calls. It gets called after the event/identify is uploaded,\n   * and the server response code and response body from the upload request are passed to the callback function.\n   * @callback Amplitude~eventCallback\n   * @param {number} responseCode - Server response code for the event / identify upload request.\n   * @param {string} responseBody - Server response body for the event / identify upload request.\n   */\n\n  /**\n   * Log an event with eventType and eventProperties\n   * @public\n   * @param {string} eventType - name of event\n   * @param {object} eventProperties - (optional) an object with string keys and values for the event properties.\n   * @param {Amplitude~eventCallback} opt_callback - (optional) a callback function to run after the event is logged.\n   * Note: the server response code and response body from the event upload are passed to the callback function.\n   * @example amplitudeClient.logEvent('Clicked Homepage Button', {'finished_flow': false, 'clicks': 15});\n   */\n  AmplitudeClient.prototype.logEvent = function logEvent(eventType, eventProperties, opt_callback) {\n    return this.logEventWithTimestamp(eventType, eventProperties, null, opt_callback);\n  };\n\n  /**\n   * Log an event with eventType and eventProperties and a custom timestamp\n   * @public\n   * @param {string} eventType - name of event\n   * @param {object} eventProperties - (optional) an object with string keys and values for the event properties.\n   * @param {number} timesatmp - (optional) the custom timestamp as milliseconds since epoch.\n   * @param {Amplitude~eventCallback} opt_callback - (optional) a callback function to run after the event is logged.\n   * Note: the server response code and response body from the event upload are passed to the callback function.\n   * @example amplitudeClient.logEvent('Clicked Homepage Button', {'finished_flow': false, 'clicks': 15});\n   */\n  AmplitudeClient.prototype.logEventWithTimestamp = function logEvent(eventType, eventProperties, timestamp, opt_callback) {\n    if (!this._apiKeySet('logEvent()') || !utils.validateInput(eventType, 'eventType', 'string') || utils.isEmptyString(eventType)) {\n      if (type(opt_callback) === 'function') {\n        opt_callback(0, 'No request sent');\n      }\n      return -1;\n    }\n    return this._logEvent(eventType, eventProperties, null, null, null, timestamp, opt_callback);\n  };\n\n  /**\n   * Log an event with eventType, eventProperties, and groups. Use this to set event-level groups.\n   * Note: the group(s) set only apply for the specific event type being logged and does not persist on the user\n   * (unless you explicitly set it with setGroup).\n   * See the [SDK Readme]{@link https://github.com/amplitude/Amplitude-Javascript#setting-groups} for more information\n   * about groups and Count by Distinct on the Amplitude platform.\n   * @public\n   * @param {string} eventType - name of event\n   * @param {object} eventProperties - (optional) an object with string keys and values for the event properties.\n   * @param {object} groups - (optional) an object with string groupType: groupName values for the event being logged.\n   * groupName can be a string or an array of strings.\n   * @param {Amplitude~eventCallback} opt_callback - (optional) a callback function to run after the event is logged.\n   * Note: the server response code and response body from the event upload are passed to the callback function.\n   * @example amplitudeClient.logEventWithGroups('Clicked Button', null, {'orgId': 24});\n   */\n  AmplitudeClient.prototype.logEventWithGroups = function (eventType, eventProperties, groups, opt_callback) {\n    if (!this._apiKeySet('logEventWithGroup()') || !utils.validateInput(eventType, 'eventType', 'string')) {\n      if (type(opt_callback) === 'function') {\n        opt_callback(0, 'No request sent');\n      }\n      return -1;\n    }\n    return this._logEvent(eventType, eventProperties, null, null, groups, null, opt_callback);\n  };\n\n  /**\n   * Test that n is a number or a numeric value.\n   * @private\n   */\n  var _isNumber = function _isNumber(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  };\n\n  /**\n   * Log revenue with Revenue interface. The new revenue interface allows for more revenue fields like\n   * revenueType and event properties.\n   * See [Readme]{@link https://github.com/amplitude/Amplitude-Javascript#tracking-revenue}\n   * for more information on the Revenue interface and logging revenue.\n   * @public\n   * @param {Revenue} revenue_obj - the revenue object containing the revenue data being logged.\n   * @example var revenue = new amplitude.Revenue().setProductId('productIdentifier').setPrice(10.99);\n   * amplitude.logRevenueV2(revenue);\n   */\n  AmplitudeClient.prototype.logRevenueV2 = function logRevenueV2(revenue_obj) {\n    if (!this._apiKeySet('logRevenueV2()')) {\n      return;\n    }\n\n    // if revenue input is a proxied object created by the async loading snippet, convert it into an revenue object\n    if (type(revenue_obj) === 'object' && revenue_obj.hasOwnProperty('_q')) {\n      revenue_obj = _convertProxyObjectToRealObject(new Revenue(), revenue_obj);\n    }\n\n    if (revenue_obj instanceof Revenue) {\n      // only send if revenue is valid\n      if (revenue_obj && revenue_obj._isValidRevenue()) {\n        return this.logEvent(constants.REVENUE_EVENT, revenue_obj._toJSONObject());\n      }\n    } else {\n      utils.log.error('Invalid revenue input type. Expected Revenue object but saw ' + type(revenue_obj));\n    }\n  };\n\n  /**\n   * Log revenue event with a price, quantity, and product identifier. DEPRECATED - use logRevenueV2\n   * @public\n   * @deprecated\n   * @param {number} price - price of revenue event\n   * @param {number} quantity - (optional) quantity of products in revenue event. If no quantity specified default to 1.\n   * @param {string} product - (optional) product identifier\n   * @example amplitudeClient.logRevenue(3.99, 1, 'product_1234');\n   */\n  AmplitudeClient.prototype.logRevenue = function logRevenue(price, quantity, product) {\n    // Test that the parameters are of the right type.\n    if (!this._apiKeySet('logRevenue()') || !_isNumber(price) || quantity !== undefined && !_isNumber(quantity)) {\n      // utils.log('Price and quantity arguments to logRevenue must be numbers');\n      return -1;\n    }\n\n    return this._logEvent(constants.REVENUE_EVENT, {}, {\n      productId: product,\n      special: 'revenue_amount',\n      quantity: quantity || 1,\n      price: price\n    }, null, null, null, null);\n  };\n\n  /**\n   * Remove events in storage with event ids up to and including maxEventId.\n   * @private\n   */\n  AmplitudeClient.prototype.removeEvents = function removeEvents(maxEventId, maxIdentifyId) {\n    _removeEvents(this, '_unsentEvents', maxEventId);\n    _removeEvents(this, '_unsentIdentifys', maxIdentifyId);\n  };\n\n  /**\n   * Helper function to remove events up to maxId from a single queue.\n   * Does a true filter in case events get out of order or old events are removed.\n   * @private\n   */\n  var _removeEvents = function _removeEvents(scope, eventQueue, maxId) {\n    if (maxId < 0) {\n      return;\n    }\n\n    var filteredEvents = [];\n    for (var i = 0; i < scope[eventQueue].length || 0; i++) {\n      if (scope[eventQueue][i].event_id > maxId) {\n        filteredEvents.push(scope[eventQueue][i]);\n      }\n    }\n    scope[eventQueue] = filteredEvents;\n  };\n\n  /**\n   * Send unsent events. Note: this is called automatically after events are logged if option batchEvents is false.\n   * If batchEvents is true, then events are only sent when batch criterias are met.\n   * @private\n   * @param {Amplitude~eventCallback} callback - (optional) callback to run after events are sent.\n   * Note the server response code and response body are passed to the callback as input arguments.\n   */\n  AmplitudeClient.prototype.sendEvents = function sendEvents(callback) {\n    if (!this._apiKeySet('sendEvents()') || this._sending || this.options.optOut || this._unsentCount() === 0) {\n      if (type(callback) === 'function') {\n        callback(0, 'No request sent');\n      }\n      return;\n    }\n\n    this._sending = true;\n    var protocol = this.options.forceHttps ? 'https' : 'https:' === window.location.protocol ? 'https' : 'http';\n    var url = protocol + '://' + this.options.apiEndpoint + '/';\n\n    // fetch events to send\n    var numEvents = Math.min(this._unsentCount(), this.options.uploadBatchSize);\n    var mergedEvents = this._mergeEventsAndIdentifys(numEvents);\n    var maxEventId = mergedEvents.maxEventId;\n    var maxIdentifyId = mergedEvents.maxIdentifyId;\n    var events = JSON.stringify(mergedEvents.eventsToSend);\n    var uploadTime = new Date().getTime();\n\n    var data = {\n      client: this.options.apiKey,\n      e: events,\n      v: constants.API_VERSION,\n      upload_time: uploadTime,\n      checksum: md5(constants.API_VERSION + this.options.apiKey + events + uploadTime)\n    };\n\n    var scope = this;\n    new Request(url, data).send(function (status, response) {\n      scope._sending = false;\n      try {\n        if (status === 200 && response === 'success') {\n          scope.removeEvents(maxEventId, maxIdentifyId);\n\n          // Update the event cache after the removal of sent events.\n          if (scope.options.saveEvents) {\n            scope.saveEvents();\n          }\n\n          // Send more events if any queued during previous send.\n          if (!scope._sendEventsIfReady(callback) && type(callback) === 'function') {\n            callback(status, response);\n          }\n\n          // handle payload too large\n        } else if (status === 413) {\n          // utils.log('request too large');\n          // Can't even get this one massive event through. Drop it, even if it is an identify.\n          if (scope.options.uploadBatchSize === 1) {\n            scope.removeEvents(maxEventId, maxIdentifyId);\n          }\n\n          // The server complained about the length of the request. Backoff and try again.\n          scope.options.uploadBatchSize = Math.ceil(numEvents / 2);\n          scope.sendEvents(callback);\n        } else if (type(callback) === 'function') {\n          // If server turns something like a 400\n          callback(status, response);\n        }\n      } catch (e) {\n        // utils.log('failed upload');\n      }\n    });\n  };\n\n  /**\n   * Merge unsent events and identifys together in sequential order based on their sequence number, for uploading.\n   * @private\n   */\n  AmplitudeClient.prototype._mergeEventsAndIdentifys = function _mergeEventsAndIdentifys(numEvents) {\n    // coalesce events from both queues\n    var eventsToSend = [];\n    var eventIndex = 0;\n    var maxEventId = -1;\n    var identifyIndex = 0;\n    var maxIdentifyId = -1;\n\n    while (eventsToSend.length < numEvents) {\n      var event;\n      var noIdentifys = identifyIndex >= this._unsentIdentifys.length;\n      var noEvents = eventIndex >= this._unsentEvents.length;\n\n      // case 0: no events or identifys left\n      // note this should not happen, this means we have less events and identifys than expected\n      if (noEvents && noIdentifys) {\n        utils.log.error('Merging Events and Identifys, less events and identifys than expected');\n        break;\n      }\n\n      // case 1: no identifys - grab from events\n      else if (noIdentifys) {\n          event = this._unsentEvents[eventIndex++];\n          maxEventId = event.event_id;\n\n          // case 2: no events - grab from identifys\n        } else if (noEvents) {\n          event = this._unsentIdentifys[identifyIndex++];\n          maxIdentifyId = event.event_id;\n\n          // case 3: need to compare sequence numbers\n        } else {\n          // events logged before v2.5.0 won't have a sequence number, put those first\n          if (!('sequence_number' in this._unsentEvents[eventIndex]) || this._unsentEvents[eventIndex].sequence_number < this._unsentIdentifys[identifyIndex].sequence_number) {\n            event = this._unsentEvents[eventIndex++];\n            maxEventId = event.event_id;\n          } else {\n            event = this._unsentIdentifys[identifyIndex++];\n            maxIdentifyId = event.event_id;\n          }\n        }\n\n      eventsToSend.push(event);\n    }\n\n    return {\n      eventsToSend: eventsToSend,\n      maxEventId: maxEventId,\n      maxIdentifyId: maxIdentifyId\n    };\n  };\n\n  /**\n   * Set global user properties. Note this is deprecated, and we recommend using setUserProperties\n   * @public\n   * @deprecated\n   */\n  AmplitudeClient.prototype.setGlobalUserProperties = function setGlobalUserProperties(userProperties) {\n    this.setUserProperties(userProperties);\n  };\n\n  /**\n   * Get the current version of Amplitude's Javascript SDK.\n   * @public\n   * @returns {number} version number\n   * @example var amplitudeVersion = amplitude.__VERSION__;\n   */\n  AmplitudeClient.prototype.__VERSION__ = version;\n\n  /**\n   * Amplitude SDK API - instance manager.\n   * Function calls directly on amplitude have been deprecated. Please call methods on the default shared instance: amplitude.getInstance() instead.\n   * See [Readme]{@link https://github.com/amplitude/Amplitude-Javascript#300-update-and-logging-events-to-multiple-amplitude-apps} for more information about this change.\n   * @constructor Amplitude\n   * @public\n   * @example var amplitude = new Amplitude();\n   */\n  var Amplitude = function Amplitude() {\n    this.options = assign_1$1({}, DEFAULT_OPTIONS);\n    this._q = [];\n    this._instances = {}; // mapping of instance names to instances\n  };\n\n  Amplitude.prototype.Identify = Identify;\n  Amplitude.prototype.Revenue = Revenue;\n\n  Amplitude.prototype.getInstance = function getInstance(instance) {\n    instance = utils.isEmptyString(instance) ? constants.DEFAULT_INSTANCE : instance.toLowerCase();\n    var client = this._instances[instance];\n    if (client === undefined) {\n      client = new AmplitudeClient(instance);\n      this._instances[instance] = client;\n    }\n    return client;\n  };\n\n  /**\n   * Initializes the Amplitude Javascript SDK with your apiKey and any optional configurations.\n   * This is required before any other methods can be called.\n   * @public\n   * @param {string} apiKey - The API key for your app.\n   * @param {string} opt_userId - (optional) An identifier for this user.\n   * @param {object} opt_config - (optional) Configuration options.\n   * See [Readme]{@link https://github.com/amplitude/Amplitude-Javascript#configuration-options} for list of options and default values.\n   * @param {function} opt_callback - (optional) Provide a callback function to run after initialization is complete.\n   * @deprecated Please use amplitude.getInstance().init(apiKey, opt_userId, opt_config, opt_callback);\n   * @example amplitude.init('API_KEY', 'USER_ID', {includeReferrer: true, includeUtm: true}, function() { alert('init complete'); });\n   */\n  Amplitude.prototype.init = function init(apiKey, opt_userId, opt_config, opt_callback) {\n    this.getInstance().init(apiKey, opt_userId, opt_config, function (instance) {\n      // make options such as deviceId available for callback functions\n      this.options = instance.options;\n      if (type(opt_callback) === 'function') {\n        opt_callback(instance);\n      }\n    }.bind(this));\n  };\n\n  /**\n   * Run functions queued up by proxy loading snippet\n   * @private\n   */\n  Amplitude.prototype.runQueuedFunctions = function () {\n    // run queued up old versions of functions\n    for (var i = 0; i < this._q.length; i++) {\n      var fn = this[this._q[i][0]];\n      if (type(fn) === 'function') {\n        fn.apply(this, this._q[i].slice(1));\n      }\n    }\n    this._q = []; // clear function queue after running\n\n    // run queued up functions on instances\n    for (var instance in this._instances) {\n      if (this._instances.hasOwnProperty(instance)) {\n        this._instances[instance].runQueuedFunctions();\n      }\n    }\n  };\n\n  /**\n   * Returns true if a new session was created during initialization, otherwise false.\n   * @public\n   * @return {boolean} Whether a new session was created during initialization.\n   * @deprecated Please use amplitude.getInstance().isNewSession();\n   */\n  Amplitude.prototype.isNewSession = function isNewSession() {\n    return this.getInstance().isNewSession();\n  };\n\n  /**\n   * Returns the id of the current session.\n   * @public\n   * @return {number} Id of the current session.\n   * @deprecated Please use amplitude.getInstance().getSessionId();\n   */\n  Amplitude.prototype.getSessionId = function getSessionId() {\n    return this.getInstance().getSessionId();\n  };\n\n  /**\n   * Increments the eventId and returns it.\n   * @private\n   */\n  Amplitude.prototype.nextEventId = function nextEventId() {\n    return this.getInstance().nextEventId();\n  };\n\n  /**\n   * Increments the identifyId and returns it.\n   * @private\n   */\n  Amplitude.prototype.nextIdentifyId = function nextIdentifyId() {\n    return this.getInstance().nextIdentifyId();\n  };\n\n  /**\n   * Increments the sequenceNumber and returns it.\n   * @private\n   */\n  Amplitude.prototype.nextSequenceNumber = function nextSequenceNumber() {\n    return this.getInstance().nextSequenceNumber();\n  };\n\n  /**\n   * Saves unsent events and identifies to localStorage. JSON stringifies event queues before saving.\n   * Note: this is called automatically every time events are logged, unless you explicitly set option saveEvents to false.\n   * @private\n   */\n  Amplitude.prototype.saveEvents = function saveEvents() {\n    this.getInstance().saveEvents();\n  };\n\n  /**\n   * Sets a customer domain for the amplitude cookie. Useful if you want to support cross-subdomain tracking.\n   * @public\n   * @param {string} domain to set.\n   * @deprecated Please use amplitude.getInstance().setDomain(domain);\n   * @example amplitude.setDomain('.amplitude.com');\n   */\n  Amplitude.prototype.setDomain = function setDomain(domain) {\n    this.getInstance().setDomain(domain);\n  };\n\n  /**\n   * Sets an identifier for the current user.\n   * @public\n   * @param {string} userId - identifier to set. Can be null.\n   * @deprecated Please use amplitude.getInstance().setUserId(userId);\n   * @example amplitude.setUserId('joe@gmail.com');\n   */\n  Amplitude.prototype.setUserId = function setUserId(userId) {\n    this.getInstance().setUserId(userId);\n  };\n\n  /**\n   * Add user to a group or groups. You need to specify a groupType and groupName(s).\n   * For example you can group people by their organization.\n   * In that case groupType is \"orgId\" and groupName would be the actual ID(s).\n   * groupName can be a string or an array of strings to indicate a user in multiple gruups.\n   * You can also call setGroup multiple times with different groupTypes to track multiple types of groups (up to 5 per app).\n   * Note: this will also set groupType: groupName as a user property.\n   * See the [SDK Readme]{@link https://github.com/amplitude/Amplitude-Javascript#setting-groups} for more information.\n   * @public\n   * @param {string} groupType - the group type (ex: orgId)\n   * @param {string|list} groupName - the name of the group (ex: 15), or a list of names of the groups\n   * @deprecated Please use amplitude.getInstance().setGroup(groupType, groupName);\n   * @example amplitude.setGroup('orgId', 15); // this adds the current user to orgId 15.\n   */\n  Amplitude.prototype.setGroup = function (groupType, groupName) {\n    this.getInstance().setGroup(groupType, groupName);\n  };\n\n  /**\n   * Sets whether to opt current user out of tracking.\n   * @public\n   * @param {boolean} enable - if true then no events will be logged or sent.\n   * @deprecated Please use amplitude.getInstance().setOptOut(enable);\n   * @example: amplitude.setOptOut(true);\n   */\n  Amplitude.prototype.setOptOut = function setOptOut(enable) {\n    this.getInstance().setOptOut(enable);\n  };\n\n  /**\n    * Regenerates a new random deviceId for current user. Note: this is not recommended unless you know what you\n    * are doing. This can be used in conjunction with `setUserId(null)` to anonymize users after they log out.\n    * With a null userId and a completely new deviceId, the current user would appear as a brand new user in dashboard.\n    * This uses src/uuid.js to regenerate the deviceId.\n    * @public\n    * @deprecated Please use amplitude.getInstance().regenerateDeviceId();\n    */\n  Amplitude.prototype.regenerateDeviceId = function regenerateDeviceId() {\n    this.getInstance().regenerateDeviceId();\n  };\n\n  /**\n    * Sets a custom deviceId for current user. Note: this is not recommended unless you know what you are doing\n    * (like if you have your own system for managing deviceIds). Make sure the deviceId you set is sufficiently unique\n    * (we recommend something like a UUID - see src/uuid.js for an example of how to generate) to prevent conflicts with other devices in our system.\n    * @public\n    * @param {string} deviceId - custom deviceId for current user.\n    * @deprecated Please use amplitude.getInstance().setDeviceId(deviceId);\n    * @example amplitude.setDeviceId('45f0954f-eb79-4463-ac8a-233a6f45a8f0');\n    */\n  Amplitude.prototype.setDeviceId = function setDeviceId(deviceId) {\n    this.getInstance().setDeviceId(deviceId);\n  };\n\n  /**\n   * Sets user properties for the current user.\n   * @public\n   * @param {object} - object with string keys and values for the user properties to set.\n   * @param {boolean} - DEPRECATED opt_replace: in earlier versions of the JS SDK the user properties object was kept in\n   * memory and replace = true would replace the object in memory. Now the properties are no longer stored in memory, so replace is deprecated.\n   * @deprecated Please use amplitude.getInstance.setUserProperties(userProperties);\n   * @example amplitude.setUserProperties({'gender': 'female', 'sign_up_complete': true})\n   */\n  Amplitude.prototype.setUserProperties = function setUserProperties(userProperties) {\n    this.getInstance().setUserProperties(userProperties);\n  };\n\n  /**\n   * Clear all of the user properties for the current user. Note: clearing user properties is irreversible!\n   * @public\n   * @deprecated Please use amplitude.getInstance().clearUserProperties();\n   * @example amplitude.clearUserProperties();\n   */\n  Amplitude.prototype.clearUserProperties = function clearUserProperties() {\n    this.getInstance().clearUserProperties();\n  };\n\n  /**\n   * Send an identify call containing user property operations to Amplitude servers.\n   * See [Readme]{@link https://github.com/amplitude/Amplitude-Javascript#user-properties-and-user-property-operations}\n   * for more information on the Identify API and user property operations.\n   * @param {Identify} identify_obj - the Identify object containing the user property operations to send.\n   * @param {Amplitude~eventCallback} opt_callback - (optional) callback function to run when the identify event has been sent.\n   * Note: the server response code and response body from the identify event upload are passed to the callback function.\n   * @deprecated Please use amplitude.getInstance().identify(identify);\n   * @example\n   * var identify = new amplitude.Identify().set('colors', ['rose', 'gold']).add('karma', 1).setOnce('sign_up_date', '2016-03-31');\n   * amplitude.identify(identify);\n   */\n  Amplitude.prototype.identify = function (identify_obj, opt_callback) {\n    this.getInstance().identify(identify_obj, opt_callback);\n  };\n\n  /**\n   * Set a versionName for your application.\n   * @public\n   * @param {string} versionName - The version to set for your application.\n   * @deprecated Please use amplitude.getInstance().setVersionName(versionName);\n   * @example amplitude.setVersionName('1.12.3');\n   */\n  Amplitude.prototype.setVersionName = function setVersionName(versionName) {\n    this.getInstance().setVersionName(versionName);\n  };\n\n  /**\n   * This is the callback for logEvent and identify calls. It gets called after the event/identify is uploaded,\n   * and the server response code and response body from the upload request are passed to the callback function.\n   * @callback Amplitude~eventCallback\n   * @param {number} responseCode - Server response code for the event / identify upload request.\n   * @param {string} responseBody - Server response body for the event / identify upload request.\n   */\n\n  /**\n   * Log an event with eventType and eventProperties\n   * @public\n   * @param {string} eventType - name of event\n   * @param {object} eventProperties - (optional) an object with string keys and values for the event properties.\n   * @param {Amplitude~eventCallback} opt_callback - (optional) a callback function to run after the event is logged.\n   * Note: the server response code and response body from the event upload are passed to the callback function.\n   * @deprecated Please use amplitude.getInstance().logEvent(eventType, eventProperties, opt_callback);\n   * @example amplitude.logEvent('Clicked Homepage Button', {'finished_flow': false, 'clicks': 15});\n   */\n  Amplitude.prototype.logEvent = function logEvent(eventType, eventProperties, opt_callback) {\n    return this.getInstance().logEvent(eventType, eventProperties, opt_callback);\n  };\n\n  /**\n   * Log an event with eventType, eventProperties, and groups. Use this to set event-level groups.\n   * Note: the group(s) set only apply for the specific event type being logged and does not persist on the user\n   * (unless you explicitly set it with setGroup).\n   * See the [SDK Readme]{@link https://github.com/amplitude/Amplitude-Javascript#setting-groups} for more information\n   * about groups and Count by Distinct on the Amplitude platform.\n   * @public\n   * @param {string} eventType - name of event\n   * @param {object} eventProperties - (optional) an object with string keys and values for the event properties.\n   * @param {object} groups - (optional) an object with string groupType: groupName values for the event being logged.\n   * groupName can be a string or an array of strings.\n   * @param {Amplitude~eventCallback} opt_callback - (optional) a callback function to run after the event is logged.\n   * Note: the server response code and response body from the event upload are passed to the callback function.\n   * Deprecated Please use amplitude.getInstance().logEventWithGroups(eventType, eventProperties, groups, opt_callback);\n   * @example amplitude.logEventWithGroups('Clicked Button', null, {'orgId': 24});\n   */\n  Amplitude.prototype.logEventWithGroups = function (eventType, eventProperties, groups, opt_callback) {\n    return this.getInstance().logEventWithGroups(eventType, eventProperties, groups, opt_callback);\n  };\n\n  /**\n   * Log revenue with Revenue interface. The new revenue interface allows for more revenue fields like\n   * revenueType and event properties.\n   * See [Readme]{@link https://github.com/amplitude/Amplitude-Javascript#tracking-revenue}\n   * for more information on the Revenue interface and logging revenue.\n   * @public\n   * @param {Revenue} revenue_obj - the revenue object containing the revenue data being logged.\n   * @deprecated Please use amplitude.getInstance().logRevenueV2(revenue_obj);\n   * @example var revenue = new amplitude.Revenue().setProductId('productIdentifier').setPrice(10.99);\n   * amplitude.logRevenueV2(revenue);\n   */\n  Amplitude.prototype.logRevenueV2 = function logRevenueV2(revenue_obj) {\n    return this.getInstance().logRevenueV2(revenue_obj);\n  };\n\n  /**\n   * Log revenue event with a price, quantity, and product identifier. DEPRECATED - use logRevenueV2\n   * @public\n   * @param {number} price - price of revenue event\n   * @param {number} quantity - (optional) quantity of products in revenue event. If no quantity specified default to 1.\n   * @param {string} product - (optional) product identifier\n   * @deprecated Please use amplitude.getInstance().logRevenueV2(revenue_obj);\n   * @example amplitude.logRevenue(3.99, 1, 'product_1234');\n   */\n  Amplitude.prototype.logRevenue = function logRevenue(price, quantity, product) {\n    return this.getInstance().logRevenue(price, quantity, product);\n  };\n\n  /**\n   * Remove events in storage with event ids up to and including maxEventId.\n   * @private\n   */\n  Amplitude.prototype.removeEvents = function removeEvents(maxEventId, maxIdentifyId) {\n    this.getInstance().removeEvents(maxEventId, maxIdentifyId);\n  };\n\n  /**\n   * Send unsent events. Note: this is called automatically after events are logged if option batchEvents is false.\n   * If batchEvents is true, then events are only sent when batch criterias are met.\n   * @private\n   * @param {Amplitude~eventCallback} callback - (optional) callback to run after events are sent.\n   * Note the server response code and response body are passed to the callback as input arguments.\n   */\n  Amplitude.prototype.sendEvents = function sendEvents(callback) {\n    this.getInstance().sendEvents(callback);\n  };\n\n  /**\n   * Set global user properties. Note this is deprecated, and we recommend using setUserProperties\n   * @public\n   * @deprecated\n   */\n  Amplitude.prototype.setGlobalUserProperties = function setGlobalUserProperties(userProperties) {\n    this.getInstance().setUserProperties(userProperties);\n  };\n\n  /**\n   * Get the current version of Amplitude's Javascript SDK.\n   * @public\n   * @returns {number} version number\n   * @example var amplitudeVersion = amplitude.__VERSION__;\n   */\n  Amplitude.prototype.__VERSION__ = version;\n\n  /* jshint expr:true */\n  var old = window.amplitude || {};\n  var newInstance = new Amplitude();\n  newInstance._q = old._q || [];\n  for (var instance in old._iq) {\n    // migrate each instance's queue\n    if (old._iq.hasOwnProperty(instance)) {\n      newInstance.getInstance(instance)._q = old._iq[instance]._q || [];\n    }\n  }\n\n  return newInstance;\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../webpack/buildin/global.js */ 9), __webpack_require__(/*! ./../node-libs-browser/node_modules/process/browser.js */ 6), __webpack_require__(/*! ./../buffer/index.js */ 45).Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvYW1wbGl0dWRlLWpzL2FtcGxpdHVkZS5qcz8yOGVmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJpSUFBQTs7QUFFQSxxR0FBcUcsbUJBQW1CLEVBQUUsbUJBQW1CLDhIQUE4SDs7QUFFM1E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0EscUJBQXFCLFlBQVksRUFBRTtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSwrQkFBK0IsaURBQWlEO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0RBQW9EO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw4QkFBOEI7QUFDM0U7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSw2QkFBNkI7QUFDakcsMkVBQTJFLGlDQUFpQztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGdCQUFnQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekUsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQSxxREFBcUQsTUFBTTtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsMkRBQTJELDBFQUEwRSxNQUFNLDBCQUEwQixPQUFPO0FBQzVLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLG9FQUFvRSxnQkFBZ0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsMkJBQTJCO0FBQ2hHO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6Qyw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELEtBQUs7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGtCQUFrQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJGQUEyRjtBQUN2SCx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUdBQWlHO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsaUdBQWlHO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsVUFBVTtBQUN2RDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGNBQWM7QUFDbkM7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCLGFBQWEsT0FBTztBQUNwQixjQUFjLE1BQU07QUFDcEIsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUIsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLDhCQUE4QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0IsaUNBQWlDO0FBQ2pDLGtDQUFrQztBQUNsQyxpQ0FBaUM7O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxhQUFhO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMscUNBQXFDO0FBQ3JDLDJDQUEyQztBQUMzQyxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLGNBQWM7QUFDM0IsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsMEJBQTBCO0FBQ3ZDO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLDBCQUEwQjtBQUN2QztBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBLDJCQUEyQiwrQkFBK0IsRUFBRTtBQUM1RCxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsMEJBQTBCO0FBQ3ZDO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsU0FBUztBQUN2QjtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsRUFBRTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixhQUFhLEVBQUU7QUFDZixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CLGFBQWEsT0FBTyxXQUFXO0FBQy9CLGFBQWEsU0FBUztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsZUFBZSxFQUFFO0FBQ2pCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLEVBQUU7QUFDZixhQUFhLE1BQU07QUFDbkIsZUFBZSxFQUFFO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBLGFBQWEsU0FBUyxHQUFHLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLE9BQU87QUFDcEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixhQUFhLE9BQU87QUFDcEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixhQUFhLEVBQUU7QUFDZixhQUFhLEVBQUU7QUFDZixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQixFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFVBQVU7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5RUFBeUU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxRQUFRO0FBQ3RCLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1CQUFtQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsRUFBRTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxJQUFJO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxJQUFJLGtDQUFrQyxJQUFJO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseURBQXlEO0FBQ3pELGlEQUFpRDtBQUNqRCxnRUFBZ0U7QUFDaEU7O0FBRUE7QUFDQSw4QkFBOEIsTUFBTSxrRUFBa0U7QUFDdEcsb0VBQW9FO0FBQ3BFLDBEQUEwRCw4QkFBOEIsZ0RBQWdEO0FBQ3hJO0FBQ0E7O0FBRUEscUNBQXFDLFFBQVE7QUFDN0M7QUFDQSxrRUFBa0UsSUFBSTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVIQUF1SDtBQUN2SCxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0Esb0NBQW9DLEtBQUs7QUFDekMsZ0lBQWdJLEVBQUU7QUFDbEk7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQSw2REFBNkQsdUJBQXVCO0FBQ3BGLDRFQUE0RSxFQUFFO0FBQzlFOztBQUVBO0FBQ0Esc0hBQXNILElBQUksNkdBQTZHLElBQUkseUdBQXlHLEVBQUU7QUFDdFYsNEtBQTRLLHlEQUF5RDtBQUNyTztBQUNBO0FBQ0EscUdBQXFHLEdBQUcsR0FBRyxLQUFLLEVBQUU7QUFDbEgsMEVBQTBFLEdBQUcsR0FBRyxlQUFlLElBQUk7QUFDbkc7QUFDQTtBQUNBLGNBQWM7QUFDZCxnRUFBZ0UsWUFBWTtBQUM1RTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkYscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsNERBQTREO0FBQzVELHdEQUF3RDtBQUN4RCx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixJQUFJO0FBQzVCLGdGQUFnRjtBQUNoRiw0RkFBNEY7QUFDNUYsZ0dBQWdHO0FBQ2hHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDs7QUFFQTtBQUNBLDBCQUEwQixxQ0FBcUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsa0JBQWtCLDhFQUE4RTtBQUNoRyxhQUFhLFNBQVM7QUFDdEIsMERBQTBELHdDQUF3QyxjQUFjLHdCQUF3QixFQUFFO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLCtCQUErQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLGtDQUFrQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQ0FBZ0M7QUFDaEMsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVFQUF1RTtBQUNqRztBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFlBQVk7QUFDekIsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsaURBQWlELDZDQUE2QztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLHdCQUF3QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLHdCQUF3QjtBQUNyQztBQUNBLG1FQUFtRSxxQ0FBcUM7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSx3QkFBd0I7QUFDckM7QUFDQSxtRUFBbUUscUNBQXFDO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVFQUF1RTtBQUNqRztBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQztBQUNBLDBFQUEwRSxZQUFZO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsbUNBQW1DO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpSEFBaUg7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGtCQUFrQiw4RUFBOEU7QUFDaEcsYUFBYSxTQUFTO0FBQ3RCO0FBQ0Esb0RBQW9ELHdDQUF3QyxjQUFjLHdCQUF3QixFQUFFO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1RUFBdUU7QUFDakc7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSwyQ0FBMkMsNkNBQTZDO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7QUFDQSw2REFBNkQscUNBQXFDO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVFQUF1RTtBQUNqRztBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQztBQUNBO0FBQ0Esb0VBQW9FLFlBQVk7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLEUiLCJmaWxlIjoiNDQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mMiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YyKGV4cG9ydHMpKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6IHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6IGdsb2JhbC5hbXBsaXR1ZGUgPSBmYWN0b3J5KCk7XG59KSh1bmRlZmluZWQsIGZ1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xuICAgIHJldHVybiBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbiAgfVxuXG4gIHZhciBqc29uMyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAvKiEgSlNPTiB2My4zLjIgfCBodHRwOi8vYmVzdGllanMuZ2l0aHViLmlvL2pzb24zIHwgQ29weXJpZ2h0IDIwMTItMjAxNCwgS2l0IENhbWJyaWRnZSB8IGh0dHA6Ly9raXQubWl0LWxpY2Vuc2Uub3JnICovXG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIERldGVjdCB0aGUgYGRlZmluZWAgZnVuY3Rpb24gZXhwb3NlZCBieSBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuIFRoZVxuICAgICAgLy8gc3RyaWN0IGBkZWZpbmVgIGNoZWNrIGlzIG5lY2Vzc2FyeSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGByLmpzYC5cbiAgICAgIHZhciBpc0xvYWRlciA9IHR5cGVvZiB1bmRlZmluZWQgPT09IFwiZnVuY3Rpb25cIiAmJiB1bmRlZmluZWQuYW1kO1xuXG4gICAgICAvLyBBIHNldCBvZiB0eXBlcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIG9iamVjdHMgZnJvbSBwcmltaXRpdmVzLlxuICAgICAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgICAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgICAgIFwib2JqZWN0XCI6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIC8vIERldGVjdCB0aGUgYGV4cG9ydHNgIG9iamVjdCBleHBvc2VkIGJ5IENvbW1vbkpTIGltcGxlbWVudGF0aW9ucy5cbiAgICAgIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzWydvYmplY3QnXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgICAgIC8vIFVzZSB0aGUgYGdsb2JhbGAgb2JqZWN0IGV4cG9zZWQgYnkgTm9kZSAoaW5jbHVkaW5nIEJyb3dzZXJpZnkgdmlhXG4gICAgICAvLyBgaW5zZXJ0LW1vZHVsZS1nbG9iYWxzYCksIE5hcndoYWwsIGFuZCBSaW5nbyBhcyB0aGUgZGVmYXVsdCBjb250ZXh0LFxuICAgICAgLy8gYW5kIHRoZSBgd2luZG93YCBvYmplY3QgaW4gYnJvd3NlcnMuIFJoaW5vIGV4cG9ydHMgYSBgZ2xvYmFsYCBmdW5jdGlvblxuICAgICAgLy8gaW5zdGVhZC5cbiAgICAgIHZhciByb290ID0gb2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YyKHdpbmRvdyldICYmIHdpbmRvdyB8fCB0aGlzLFxuICAgICAgICAgIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBvYmplY3RUeXBlc1snb2JqZWN0J10gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgKHR5cGVvZiBjb21tb25qc0dsb2JhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YyKGNvbW1vbmpzR2xvYmFsKSkgPT0gXCJvYmplY3RcIiAmJiBjb21tb25qc0dsb2JhbDtcblxuICAgICAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWxbXCJnbG9iYWxcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcIndpbmRvd1wiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wic2VsZlwiXSA9PT0gZnJlZUdsb2JhbCkpIHtcbiAgICAgICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gICAgICB9XG5cbiAgICAgIC8vIFB1YmxpYzogSW5pdGlhbGl6ZXMgSlNPTiAzIHVzaW5nIHRoZSBnaXZlbiBgY29udGV4dGAgb2JqZWN0LCBhdHRhY2hpbmcgdGhlXG4gICAgICAvLyBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBmdW5jdGlvbnMgdG8gdGhlIHNwZWNpZmllZCBgZXhwb3J0c2Agb2JqZWN0LlxuICAgICAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQsIGV4cG9ydHMpIHtcbiAgICAgICAgY29udGV4dCB8fCAoY29udGV4dCA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG4gICAgICAgIGV4cG9ydHMgfHwgKGV4cG9ydHMgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuXG4gICAgICAgIC8vIE5hdGl2ZSBjb25zdHJ1Y3RvciBhbGlhc2VzLlxuICAgICAgICB2YXIgTnVtYmVyID0gY29udGV4dFtcIk51bWJlclwiXSB8fCByb290W1wiTnVtYmVyXCJdLFxuICAgICAgICAgICAgU3RyaW5nID0gY29udGV4dFtcIlN0cmluZ1wiXSB8fCByb290W1wiU3RyaW5nXCJdLFxuICAgICAgICAgICAgT2JqZWN0ID0gY29udGV4dFtcIk9iamVjdFwiXSB8fCByb290W1wiT2JqZWN0XCJdLFxuICAgICAgICAgICAgRGF0ZSA9IGNvbnRleHRbXCJEYXRlXCJdIHx8IHJvb3RbXCJEYXRlXCJdLFxuICAgICAgICAgICAgU3ludGF4RXJyb3IgPSBjb250ZXh0W1wiU3ludGF4RXJyb3JcIl0gfHwgcm9vdFtcIlN5bnRheEVycm9yXCJdLFxuICAgICAgICAgICAgVHlwZUVycm9yID0gY29udGV4dFtcIlR5cGVFcnJvclwiXSB8fCByb290W1wiVHlwZUVycm9yXCJdLFxuICAgICAgICAgICAgTWF0aCA9IGNvbnRleHRbXCJNYXRoXCJdIHx8IHJvb3RbXCJNYXRoXCJdLFxuICAgICAgICAgICAgbmF0aXZlSlNPTiA9IGNvbnRleHRbXCJKU09OXCJdIHx8IHJvb3RbXCJKU09OXCJdO1xuXG4gICAgICAgIC8vIERlbGVnYXRlIHRvIHRoZSBuYXRpdmUgYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgaW1wbGVtZW50YXRpb25zLlxuICAgICAgICBpZiAoKHR5cGVvZiBuYXRpdmVKU09OID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZjIobmF0aXZlSlNPTikpID09IFwib2JqZWN0XCIgJiYgbmF0aXZlSlNPTikge1xuICAgICAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gbmF0aXZlSlNPTi5zdHJpbmdpZnk7XG4gICAgICAgICAgZXhwb3J0cy5wYXJzZSA9IG5hdGl2ZUpTT04ucGFyc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZW5pZW5jZSBhbGlhc2VzLlxuICAgICAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgICAgICAgZ2V0Q2xhc3MgPSBvYmplY3RQcm90by50b1N0cmluZyxcbiAgICAgICAgICAgIF9pc1Byb3BlcnR5LFxuICAgICAgICAgICAgX2ZvckVhY2gsXG4gICAgICAgICAgICB1bmRlZjtcblxuICAgICAgICAvLyBUZXN0IHRoZSBgRGF0ZSNnZXRVVEMqYCBtZXRob2RzLiBCYXNlZCBvbiB3b3JrIGJ5IEBZYWZmbGUuXG4gICAgICAgIHZhciBpc0V4dGVuZGVkID0gbmV3IERhdGUoLTM1MDk4MjczMzQ1NzMyOTIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoZSBgZ2V0VVRDRnVsbFllYXJgLCBgTW9udGhgLCBhbmQgYERhdGVgIG1ldGhvZHMgcmV0dXJuIG5vbnNlbnNpY2FsXG4gICAgICAgICAgLy8gcmVzdWx0cyBmb3IgY2VydGFpbiBkYXRlcyBpbiBPcGVyYSA+PSAxMC41My5cbiAgICAgICAgICBpc0V4dGVuZGVkID0gaXNFeHRlbmRlZC5nZXRVVENGdWxsWWVhcigpID09IC0xMDkyNTIgJiYgaXNFeHRlbmRlZC5nZXRVVENNb250aCgpID09PSAwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDRGF0ZSgpID09PSAxICYmXG4gICAgICAgICAgLy8gU2FmYXJpIDwgMi4wLjIgc3RvcmVzIHRoZSBpbnRlcm5hbCBtaWxsaXNlY29uZCB0aW1lIHZhbHVlIGNvcnJlY3RseSxcbiAgICAgICAgICAvLyBidXQgY2xpcHMgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgZGF0ZSBtZXRob2RzIHRvIHRoZSByYW5nZSBvZlxuICAgICAgICAgIC8vIHNpZ25lZCAzMi1iaXQgaW50ZWdlcnMgKFstMiAqKiAzMSwgMiAqKiAzMSAtIDFdKS5cbiAgICAgICAgICBpc0V4dGVuZGVkLmdldFVUQ0hvdXJzKCkgPT0gMTAgJiYgaXNFeHRlbmRlZC5nZXRVVENNaW51dGVzKCkgPT0gMzcgJiYgaXNFeHRlbmRlZC5nZXRVVENTZWNvbmRzKCkgPT0gNiAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbGxpc2Vjb25kcygpID09IDcwODtcbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuXG4gICAgICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdGl2ZSBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG4gICAgICAgIC8vIGltcGxlbWVudGF0aW9ucyBhcmUgc3BlYy1jb21wbGlhbnQuIEJhc2VkIG9uIHdvcmsgYnkgS2VuIFNueWRlci5cbiAgICAgICAgZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgICAgICAgICBpZiAoaGFzW25hbWVdICE9PSB1bmRlZikge1xuICAgICAgICAgICAgLy8gUmV0dXJuIGNhY2hlZCBmZWF0dXJlIHRlc3QgcmVzdWx0LlxuICAgICAgICAgICAgcmV0dXJuIGhhc1tuYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGlzU3VwcG9ydGVkO1xuICAgICAgICAgIGlmIChuYW1lID09IFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpIHtcbiAgICAgICAgICAgIC8vIElFIDw9IDcgZG9lc24ndCBzdXBwb3J0IGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyB1c2luZyBzcXVhcmVcbiAgICAgICAgICAgIC8vIGJyYWNrZXQgbm90YXRpb24uIElFIDggb25seSBzdXBwb3J0cyB0aGlzIGZvciBwcmltaXRpdmVzLlxuICAgICAgICAgICAgaXNTdXBwb3J0ZWQgPSBcImFcIlswXSAhPSBcImFcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIC8vIEluZGljYXRlcyB3aGV0aGVyIGJvdGggYEpTT04uc3RyaW5naWZ5YCBhbmQgYEpTT04ucGFyc2VgIGFyZVxuICAgICAgICAgICAgLy8gc3VwcG9ydGVkLlxuICAgICAgICAgICAgaXNTdXBwb3J0ZWQgPSBoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSAmJiBoYXMoXCJqc29uLXBhcnNlXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUsXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZCA9ICd7XCJhXCI6WzEsdHJ1ZSxmYWxzZSxudWxsLFwiXFxcXHUwMDAwXFxcXGJcXFxcblxcXFxmXFxcXHJcXFxcdFwiXX0nO1xuICAgICAgICAgICAgLy8gVGVzdCBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXN0cmluZ2lmeVwiKSB7XG4gICAgICAgICAgICAgIHZhciBzdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSxcbiAgICAgICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9IHR5cGVvZiBzdHJpbmdpZnkgPT0gXCJmdW5jdGlvblwiICYmIGlzRXh0ZW5kZWQ7XG4gICAgICAgICAgICAgIGlmIChzdHJpbmdpZnlTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBBIHRlc3QgZnVuY3Rpb24gb2JqZWN0IHdpdGggYSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kLlxuICAgICAgICAgICAgICAgICh2YWx1ZSA9IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfSkudG9KU09OID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9XG4gICAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDMuMWIxIGFuZCBiMiBzZXJpYWxpemUgc3RyaW5nLCBudW1iZXIsIGFuZCBib29sZWFuXG4gICAgICAgICAgICAgICAgICAvLyBwcmltaXRpdmVzIGFzIG9iamVjdCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgwKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiwgYW5kIEpTT04gMiBzZXJpYWxpemUgd3JhcHBlZCBwcmltaXRpdmVzIGFzIG9iamVjdFxuICAgICAgICAgICAgICAgICAgLy8gbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IE51bWJlcigpKSA9PT0gXCIwXCIgJiYgc3RyaW5naWZ5KG5ldyBTdHJpbmcoKSkgPT0gJ1wiXCInICYmXG4gICAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgdmFsdWUgaXMgYG51bGxgLCBgdW5kZWZpbmVkYCwgb3JcbiAgICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IGRlZmluZSBhIGNhbm9uaWNhbCBKU09OIHJlcHJlc2VudGF0aW9uICh0aGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBgdG9KU09OYCBwcm9wZXJ0aWVzIGFzIHdlbGwsICp1bmxlc3MqIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgICAgLy8gd2l0aGluIGFuIG9iamVjdCBvciBhcnJheSkuXG4gICAgICAgICAgICAgICAgICBzdHJpbmdpZnkoZ2V0Q2xhc3MpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgICAgLy8gSUUgOCBzZXJpYWxpemVzIGB1bmRlZmluZWRgIGFzIGBcInVuZGVmaW5lZFwiYC4gU2FmYXJpIDw9IDUuMS43IGFuZFxuICAgICAgICAgICAgICAgICAgLy8gRkYgMy4xYjMgcGFzcyB0aGlzIHRlc3QuXG4gICAgICAgICAgICAgICAgICBzdHJpbmdpZnkodW5kZWYpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS43IGFuZCBGRiAzLjFiMyB0aHJvdyBgRXJyb3JgcyBhbmQgYFR5cGVFcnJvcmBzLFxuICAgICAgICAgICAgICAgICAgLy8gcmVzcGVjdGl2ZWx5LCBpZiB0aGUgdmFsdWUgaXMgb21pdHRlZCBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlcixcbiAgICAgICAgICAgICAgICAgIC8vIHN0cmluZywgYXJyYXksIG9iamVjdCwgQm9vbGVhbiwgb3IgYG51bGxgIGxpdGVyYWwuIFRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzIGFzIHdlbGwsIHVubGVzcyB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAgIC8vIGluc2lkZSBvYmplY3Qgb3IgYXJyYXkgbGl0ZXJhbHMuIFlVSSAzLjAuMGIxIGlnbm9yZXMgY3VzdG9tIGB0b0pTT05gXG4gICAgICAgICAgICAgICAgICAvLyBtZXRob2RzIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgICAgc3RyaW5naWZ5KHZhbHVlKSA9PT0gXCIxXCIgJiYgc3RyaW5naWZ5KFt2YWx1ZV0pID09IFwiWzFdXCIgJiZcbiAgICAgICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBzZXJpYWxpemVzIGBbdW5kZWZpbmVkXWAgYXMgYFwiW11cImAgaW5zdGVhZCBvZlxuICAgICAgICAgICAgICAgICAgLy8gYFwiW251bGxdXCJgLlxuICAgICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZl0pID09IFwiW251bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAgIC8vIFlVSSAzLjAuMGIxIGZhaWxzIHRvIHNlcmlhbGl6ZSBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCkgPT0gXCJudWxsXCIgJiZcbiAgICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIGhhbHRzIHNlcmlhbGl6YXRpb24gaWYgYW4gYXJyYXkgY29udGFpbnMgYSBmdW5jdGlvbjpcbiAgICAgICAgICAgICAgICAgIC8vIGBbMSwgdHJ1ZSwgZ2V0Q2xhc3MsIDFdYCBzZXJpYWxpemVzIGFzIFwiWzEsdHJ1ZSxdLFwiLiBGRiAzLjFiM1xuICAgICAgICAgICAgICAgICAgLy8gZWxpZGVzIG5vbi1KU09OIHZhbHVlcyBmcm9tIG9iamVjdHMgYW5kIGFycmF5cywgdW5sZXNzIHRoZXlcbiAgICAgICAgICAgICAgICAgIC8vIGRlZmluZSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcy5cbiAgICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWYsIGdldENsYXNzLCBudWxsXSkgPT0gXCJbbnVsbCxudWxsLG51bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBzZXJpYWxpemF0aW9uIHRlc3QuIEZGIDMuMWIxIHVzZXMgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgICAgICAgICAvLyB3aGVyZSBjaGFyYWN0ZXIgZXNjYXBlIGNvZGVzIGFyZSBleHBlY3RlZCAoZS5nLiwgYFxcYmAgPT4gYFxcdTAwMDhgKS5cbiAgICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh7IFwiYVwiOiBbdmFsdWUsIHRydWUsIGZhbHNlLCBudWxsLCBcIlxceDAwXFxiXFxuXFxmXFxyXFx0XCJdIH0pID09IHNlcmlhbGl6ZWQgJiZcbiAgICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxIGFuZCBiMiBpZ25vcmUgdGhlIGBmaWx0ZXJgIGFuZCBgd2lkdGhgIGFyZ3VtZW50cy5cbiAgICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsLCB2YWx1ZSkgPT09IFwiMVwiICYmIHN0cmluZ2lmeShbMSwgMl0sIG51bGwsIDEpID09IFwiW1xcbiAxLFxcbiAyXFxuXVwiICYmXG4gICAgICAgICAgICAgICAgICAvLyBKU09OIDIsIFByb3RvdHlwZSA8PSAxLjcsIGFuZCBvbGRlciBXZWJLaXQgYnVpbGRzIGluY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgICAvLyBzZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMuXG4gICAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTguNjRlMTUpKSA9PSAnXCItMjcxODIxLTA0LTIwVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBtaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoOC42NGUxNSkpID09ICdcIisyNzU3NjAtMDktMTNUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveCA8PSAxMS4wIGluY29ycmVjdGx5IHNlcmlhbGl6ZXMgeWVhcnMgcHJpb3IgdG8gMCBhcyBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCB5ZWFycyBpbnN0ZWFkIG9mIHNpeC1kaWdpdCB5ZWFycy4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtNjIxOTg3NTUyZTUpKSA9PSAnXCItMDAwMDAxLTAxLTAxVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNSBhbmQgT3BlcmEgPj0gMTAuNTMgaW5jb3JyZWN0bHkgc2VyaWFsaXplIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgbGVzcyB0aGFuIDEwMDAuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTEpKSA9PSAnXCIxOTY5LTEyLTMxVDIzOjU5OjU5Ljk5OVpcIic7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaXNTdXBwb3J0ZWQgPSBzdHJpbmdpZnlTdXBwb3J0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUZXN0IGBKU09OLnBhcnNlYC5cbiAgICAgICAgICAgIGlmIChuYW1lID09IFwianNvbi1wYXJzZVwiKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJzZSA9IGV4cG9ydHMucGFyc2U7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyc2UgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhIGJhcmUgbGl0ZXJhbCBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgICAgICAgIC8vIENvbmZvcm1pbmcgaW1wbGVtZW50YXRpb25zIHNob3VsZCBhbHNvIGNvZXJjZSB0aGUgaW5pdGlhbCBhcmd1bWVudCB0b1xuICAgICAgICAgICAgICAgICAgLy8gYSBzdHJpbmcgcHJpb3IgdG8gcGFyc2luZy5cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZShcIjBcIikgPT09IDAgJiYgIXBhcnNlKGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaW1wbGUgcGFyc2luZyB0ZXN0LlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlKHNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VTdXBwb3J0ZWQgPSB2YWx1ZVtcImFcIl0ubGVuZ3RoID09IDUgJiYgdmFsdWVbXCJhXCJdWzBdID09PSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS4yIGFuZCBGRiAzLjFiMSBhbGxvdyB1bmVzY2FwZWQgdGFicyBpbiBzdHJpbmdzLlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSAhcGFyc2UoJ1wiXFx0XCInKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAgYW5kIDQuMC4xIGFsbG93IGxlYWRpbmcgYCtgIHNpZ25zIGFuZCBsZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY2ltYWwgcG9pbnRzLiBGRiA0LjAsIDQuMC4xLCBhbmQgSUUgOS0xMCBhbHNvIGFsbG93XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNlcnRhaW4gb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIwMVwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAsIDQuMC4xLCBhbmQgUmhpbm8gMS43UjMtUjQgYWxsb3cgdHJhaWxpbmcgZGVjaW1hbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludHMuIFRoZXNlIGVudmlyb25tZW50cywgYWxvbmcgd2l0aCBGRiAzLjFiMSBhbmQgMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyBhbGxvdyB0cmFpbGluZyBjb21tYXMgaW4gSlNPTiBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIxLlwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlzU3VwcG9ydGVkID0gcGFyc2VTdXBwb3J0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBoYXNbbmFtZV0gPSAhIWlzU3VwcG9ydGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoYXMoXCJqc29uXCIpKSB7XG4gICAgICAgICAgLy8gQ29tbW9uIGBbW0NsYXNzXV1gIG5hbWUgYWxpYXNlcy5cbiAgICAgICAgICB2YXIgZnVuY3Rpb25DbGFzcyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIixcbiAgICAgICAgICAgICAgZGF0ZUNsYXNzID0gXCJbb2JqZWN0IERhdGVdXCIsXG4gICAgICAgICAgICAgIG51bWJlckNsYXNzID0gXCJbb2JqZWN0IE51bWJlcl1cIixcbiAgICAgICAgICAgICAgc3RyaW5nQ2xhc3MgPSBcIltvYmplY3QgU3RyaW5nXVwiLFxuICAgICAgICAgICAgICBhcnJheUNsYXNzID0gXCJbb2JqZWN0IEFycmF5XVwiLFxuICAgICAgICAgICAgICBib29sZWFuQ2xhc3MgPSBcIltvYmplY3QgQm9vbGVhbl1cIjtcblxuICAgICAgICAgIC8vIERldGVjdCBpbmNvbXBsZXRlIHN1cHBvcnQgZm9yIGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyBieSBpbmRleC5cbiAgICAgICAgICB2YXIgY2hhckluZGV4QnVnZ3kgPSBoYXMoXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIik7XG5cbiAgICAgICAgICAvLyBEZWZpbmUgYWRkaXRpb25hbCB1dGlsaXR5IG1ldGhvZHMgaWYgdGhlIGBEYXRlYCBtZXRob2RzIGFyZSBidWdneS5cbiAgICAgICAgICBpZiAoIWlzRXh0ZW5kZWQpIHtcbiAgICAgICAgICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgICAgICAgICAvLyBBIG1hcHBpbmcgYmV0d2VlbiB0aGUgbW9udGhzIG9mIHRoZSB5ZWFyIGFuZCB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlblxuICAgICAgICAgICAgLy8gSmFudWFyeSAxc3QgYW5kIHRoZSBmaXJzdCBvZiB0aGUgcmVzcGVjdGl2ZSBtb250aC5cbiAgICAgICAgICAgIHZhciBNb250aHMgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzRdO1xuICAgICAgICAgICAgLy8gSW50ZXJuYWw6IENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW4gdGhlIFVuaXggZXBvY2ggYW5kIHRoZVxuICAgICAgICAgICAgLy8gZmlyc3QgZGF5IG9mIHRoZSBnaXZlbiBtb250aC5cbiAgICAgICAgICAgIHZhciBnZXREYXkgPSBmdW5jdGlvbiBnZXREYXkoeWVhciwgbW9udGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE1vbnRoc1ttb250aF0gKyAzNjUgKiAoeWVhciAtIDE5NzApICsgZmxvb3IoKHllYXIgLSAxOTY5ICsgKG1vbnRoID0gKyhtb250aCA+IDEpKSkgLyA0KSAtIGZsb29yKCh5ZWFyIC0gMTkwMSArIG1vbnRoKSAvIDEwMCkgKyBmbG9vcigoeWVhciAtIDE2MDEgKyBtb250aCkgLyA0MDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyBpZiBhIHByb3BlcnR5IGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIHRoZSBnaXZlblxuICAgICAgICAgIC8vIG9iamVjdC4gRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgbWV0aG9kLlxuICAgICAgICAgIGlmICghKF9pc1Byb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHkpKSB7XG4gICAgICAgICAgICBfaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIGlzUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSxcbiAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgICBpZiAoKG1lbWJlcnMuX19wcm90b19fID0gbnVsbCwgbWVtYmVycy5fX3Byb3RvX18gPSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlICpwcm90byogcHJvcGVydHkgY2Fubm90IGJlIHNldCBtdWx0aXBsZSB0aW1lcyBpbiByZWNlbnRcbiAgICAgICAgICAgICAgICAvLyB2ZXJzaW9ucyBvZiBGaXJlZm94IGFuZCBTZWFNb25rZXkuXG4gICAgICAgICAgICAgICAgXCJ0b1N0cmluZ1wiOiAxXG4gICAgICAgICAgICAgIH0sIG1lbWJlcnMpLnRvU3RyaW5nICE9IGdldENsYXNzKSB7XG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC4zIGRvZXNuJ3QgaW1wbGVtZW50IGBPYmplY3QjaGFzT3duUHJvcGVydHlgLCBidXRcbiAgICAgICAgICAgICAgICAvLyBzdXBwb3J0cyB0aGUgbXV0YWJsZSAqcHJvdG8qIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIF9pc1Byb3BlcnR5ID0gZnVuY3Rpb24gaXNQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBhbmQgYnJlYWsgdGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbiAoc2VlIHNlY3Rpb24gOC42LjJcbiAgICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBFUyA1LjEgc3BlYykuIFRoZSBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb24gcHJldmVudHMgYW5cbiAgICAgICAgICAgICAgICAgIC8vIHVuc2FmZSB0cmFuc2Zvcm1hdGlvbiBieSB0aGUgQ2xvc3VyZSBDb21waWxlci5cbiAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHRoaXMuX19wcm90b19fLFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHByb3BlcnR5IGluICh0aGlzLl9fcHJvdG9fXyA9IG51bGwsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBvcmlnaW5hbDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIGEgcmVmZXJlbmNlIHRvIHRoZSB0b3AtbGV2ZWwgYE9iamVjdGAgY29uc3RydWN0b3IuXG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3IgPSBtZW1iZXJzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSB0byBzaW11bGF0ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpblxuICAgICAgICAgICAgICAgIC8vIG90aGVyIGVudmlyb25tZW50cy5cbiAgICAgICAgICAgICAgICBfaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIGlzUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAodGhpcy5jb25zdHJ1Y3RvciB8fCBjb25zdHJ1Y3RvcikucHJvdG90eXBlO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5IGluIHRoaXMgJiYgIShwcm9wZXJ0eSBpbiBwYXJlbnQgJiYgdGhpc1twcm9wZXJ0eV0gPT09IHBhcmVudFtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbWVtYmVycyA9IG51bGw7XG4gICAgICAgICAgICAgIHJldHVybiBfaXNQcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSW50ZXJuYWw6IE5vcm1hbGl6ZXMgdGhlIGBmb3IuLi5pbmAgaXRlcmF0aW9uIGFsZ29yaXRobSBhY3Jvc3NcbiAgICAgICAgICAvLyBlbnZpcm9ubWVudHMuIEVhY2ggZW51bWVyYXRlZCBrZXkgaXMgeWllbGRlZCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uXG4gICAgICAgICAgX2ZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gMCxcbiAgICAgICAgICAgICAgICBQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIG1lbWJlcnMsXG4gICAgICAgICAgICAgICAgcHJvcGVydHk7XG5cbiAgICAgICAgICAgIC8vIFRlc3RzIGZvciBidWdzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgYGZvci4uLmluYCBhbGdvcml0aG0uIFRoZVxuICAgICAgICAgICAgLy8gYHZhbHVlT2ZgIHByb3BlcnR5IGluaGVyaXRzIHRoZSBub24tZW51bWVyYWJsZSBmbGFnIGZyb21cbiAgICAgICAgICAgIC8vIGBPYmplY3QucHJvdG90eXBlYCBpbiBvbGRlciB2ZXJzaW9ucyBvZiBJRSwgTmV0c2NhcGUsIGFuZCBNb3ppbGxhLlxuICAgICAgICAgICAgKFByb3BlcnRpZXMgPSBmdW5jdGlvbiBQcm9wZXJ0aWVzKCkge1xuICAgICAgICAgICAgICB0aGlzLnZhbHVlT2YgPSAwO1xuICAgICAgICAgICAgfSkucHJvdG90eXBlLnZhbHVlT2YgPSAwO1xuXG4gICAgICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcm9wZXJ0aWVzYCBjbGFzcy5cbiAgICAgICAgICAgIG1lbWJlcnMgPSBuZXcgUHJvcGVydGllcygpO1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBtZW1iZXJzKSB7XG4gICAgICAgICAgICAgIC8vIElnbm9yZSBhbGwgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgICAgIGlmIChfaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUHJvcGVydGllcyA9IG1lbWJlcnMgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGl0ZXJhdGlvbiBhbGdvcml0aG0uXG4gICAgICAgICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgICAgICAgLy8gQSBsaXN0IG9mIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgICAgICBtZW1iZXJzID0gW1widmFsdWVPZlwiLCBcInRvU3RyaW5nXCIsIFwidG9Mb2NhbGVTdHJpbmdcIiwgXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLCBcImlzUHJvdG90eXBlT2ZcIiwgXCJoYXNPd25Qcm9wZXJ0eVwiLCBcImNvbnN0cnVjdG9yXCJdO1xuICAgICAgICAgICAgICAvLyBJRSA8PSA4LCBNb3ppbGxhIDEuMCwgYW5kIE5ldHNjYXBlIDYuMiBpZ25vcmUgc2hhZG93ZWQgbm9uLWVudW1lcmFibGVcbiAgICAgICAgICAgICAgLy8gcHJvcGVydGllcy5cbiAgICAgICAgICAgICAgX2ZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBoYXNQcm9wZXJ0eSA9ICFpc0Z1bmN0aW9uICYmIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgIT0gXCJmdW5jdGlvblwiICYmIG9iamVjdFR5cGVzW190eXBlb2YyKG9iamVjdC5oYXNPd25Qcm9wZXJ0eSldICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSB8fCBfaXNQcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgLy8gR2Vja28gPD0gMS4wIGVudW1lcmF0ZXMgdGhlIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB1bmRlclxuICAgICAgICAgICAgICAgICAgLy8gY2VydGFpbiBjb25kaXRpb25zOyBJRSBkb2VzIG5vdC5cbiAgICAgICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggbm9uLWVudW1lcmFibGUgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgZm9yIChsZW5ndGggPSBtZW1iZXJzLmxlbmd0aDsgcHJvcGVydHkgPSBtZW1iZXJzWy0tbGVuZ3RoXTsgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiBjYWxsYmFjayhwcm9wZXJ0eSkpIHt9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNpemUgPT0gMikge1xuICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjQgZW51bWVyYXRlcyBzaGFkb3dlZCBwcm9wZXJ0aWVzIHR3aWNlLlxuICAgICAgICAgICAgICBfZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2gob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNldCBvZiBpdGVyYXRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sXG4gICAgICAgICAgICAgICAgICAgIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk7XG4gICAgICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIGVhY2ggcHJvcGVydHkgbmFtZSB0byBwcmV2ZW50IGRvdWJsZSBlbnVtZXJhdGlvbi4gVGhlXG4gICAgICAgICAgICAgICAgICAvLyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgaXMgbm90IGVudW1lcmF0ZWQgZHVlIHRvIGNyb3NzLVxuICAgICAgICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiAhX2lzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkgJiYgKG1lbWJlcnNbcHJvcGVydHldID0gMSkgJiYgX2lzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gTm8gYnVncyBkZXRlY3RlZDsgdXNlIHRoZSBzdGFuZGFyZCBgZm9yLi4uaW5gIGFsZ29yaXRobS5cbiAgICAgICAgICAgICAgX2ZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgaXNDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBfaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmICEoaXNDb25zdHJ1Y3RvciA9IHByb3BlcnR5ID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgZHVlIHRvXG4gICAgICAgICAgICAgICAgLy8gY3Jvc3MtZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgICAgIGlmIChpc0NvbnN0cnVjdG9yIHx8IF9pc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSA9IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2ZvckVhY2gob2JqZWN0LCBjYWxsYmFjayk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIFB1YmxpYzogU2VyaWFsaXplcyBhIEphdmFTY3JpcHQgYHZhbHVlYCBhcyBhIEpTT04gc3RyaW5nLiBUaGUgb3B0aW9uYWxcbiAgICAgICAgICAvLyBgZmlsdGVyYCBhcmd1bWVudCBtYXkgc3BlY2lmeSBlaXRoZXIgYSBmdW5jdGlvbiB0aGF0IGFsdGVycyBob3cgb2JqZWN0IGFuZFxuICAgICAgICAgIC8vIGFycmF5IG1lbWJlcnMgYXJlIHNlcmlhbGl6ZWQsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIG51bWJlcnMgdGhhdFxuICAgICAgICAgIC8vIGluZGljYXRlcyB3aGljaCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgb3B0aW9uYWwgYHdpZHRoYFxuICAgICAgICAgIC8vIGFyZ3VtZW50IG1heSBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuICAgICAgICAgIC8vIGxldmVsIG9mIHRoZSBvdXRwdXQuXG4gICAgICAgICAgaWYgKCFoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSkge1xuICAgICAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy5cbiAgICAgICAgICAgIHZhciBFc2NhcGVzID0ge1xuICAgICAgICAgICAgICA5MjogXCJcXFxcXFxcXFwiLFxuICAgICAgICAgICAgICAzNDogJ1xcXFxcIicsXG4gICAgICAgICAgICAgIDg6IFwiXFxcXGJcIixcbiAgICAgICAgICAgICAgMTI6IFwiXFxcXGZcIixcbiAgICAgICAgICAgICAgMTA6IFwiXFxcXG5cIixcbiAgICAgICAgICAgICAgMTM6IFwiXFxcXHJcIixcbiAgICAgICAgICAgICAgOTogXCJcXFxcdFwiXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBJbnRlcm5hbDogQ29udmVydHMgYHZhbHVlYCBpbnRvIGEgemVyby1wYWRkZWQgc3RyaW5nIHN1Y2ggdGhhdCBpdHNcbiAgICAgICAgICAgIC8vIGxlbmd0aCBpcyBhdCBsZWFzdCBlcXVhbCB0byBgd2lkdGhgLiBUaGUgYHdpZHRoYCBtdXN0IGJlIDw9IDYuXG4gICAgICAgICAgICB2YXIgbGVhZGluZ1plcm9lcyA9IFwiMDAwMDAwXCI7XG4gICAgICAgICAgICB2YXIgdG9QYWRkZWRTdHJpbmcgPSBmdW5jdGlvbiB0b1BhZGRlZFN0cmluZyh3aWR0aCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgLy8gVGhlIGB8fCAwYCBleHByZXNzaW9uIGlzIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpblxuICAgICAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgd2hlcmUgYDAgPT0gLTBgLCBidXQgYFN0cmluZygtMCkgIT09IFwiMFwiYC5cbiAgICAgICAgICAgICAgcmV0dXJuIChsZWFkaW5nWmVyb2VzICsgKHZhbHVlIHx8IDApKS5zbGljZSgtd2lkdGgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gSW50ZXJuYWw6IERvdWJsZS1xdW90ZXMgYSBzdHJpbmcgYHZhbHVlYCwgcmVwbGFjaW5nIGFsbCBBU0NJSSBjb250cm9sXG4gICAgICAgICAgICAvLyBjaGFyYWN0ZXJzIChjaGFyYWN0ZXJzIHdpdGggY29kZSB1bml0IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDMxKSB3aXRoXG4gICAgICAgICAgICAvLyB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAgICAgLy8gYFF1b3RlKHZhbHVlKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgICAgIHZhciB1bmljb2RlUHJlZml4ID0gJ1xcXFx1MDAnO1xuICAgICAgICAgICAgdmFyIHF1b3RlID0gZnVuY3Rpb24gcXVvdGUodmFsdWUpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICdcIicsXG4gICAgICAgICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICB1c2VDaGFySW5kZXggPSAhY2hhckluZGV4QnVnZ3kgfHwgbGVuZ3RoID4gMTA7XG4gICAgICAgICAgICAgIHZhciBzeW1ib2xzID0gdXNlQ2hhckluZGV4ICYmIChjaGFySW5kZXhCdWdneSA/IHZhbHVlLnNwbGl0KFwiXCIpIDogdmFsdWUpO1xuICAgICAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgY29udHJvbCBjaGFyYWN0ZXIsIGFwcGVuZCBpdHMgVW5pY29kZSBvclxuICAgICAgICAgICAgICAgIC8vIHNob3J0aGFuZCBlc2NhcGUgc2VxdWVuY2U7IG90aGVyd2lzZSwgYXBwZW5kIHRoZSBjaGFyYWN0ZXIgYXMtaXMuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSA4OmNhc2UgOTpjYXNlIDEwOmNhc2UgMTI6Y2FzZSAxMzpjYXNlIDM0OmNhc2UgOTI6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBFc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1bmljb2RlUHJlZml4ICsgdG9QYWRkZWRTdHJpbmcoMiwgY2hhckNvZGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdXNlQ2hhckluZGV4ID8gc3ltYm9sc1tpbmRleF0gOiB2YWx1ZS5jaGFyQXQoaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ1wiJztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSBzZXJpYWxpemVzIGFuIG9iamVjdC4gSW1wbGVtZW50cyB0aGVcbiAgICAgICAgICAgIC8vIGBTdHIoa2V5LCBob2xkZXIpYCwgYEpPKHZhbHVlKWAsIGFuZCBgSkEodmFsdWUpYCBvcGVyYXRpb25zLlxuICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZShwcm9wZXJ0eSwgb2JqZWN0LCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSwgY2xhc3NOYW1lLCB5ZWFyLCBtb250aCwgZGF0ZSwgdGltZSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgcmVzdWx0cywgZWxlbWVudCwgaW5kZXgsIGxlbmd0aCwgcHJlZml4LCByZXN1bHQ7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gTmVjZXNzYXJ5IGZvciBob3N0IG9iamVjdCBzdXBwb3J0LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YyKHZhbHVlKSkgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gZGF0ZUNsYXNzICYmICFfaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGF0ZXMgYXJlIHNlcmlhbGl6ZWQgYWNjb3JkaW5nIHRvIHRoZSBgRGF0ZSN0b0pTT05gIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuOS41LjQ0LiBTZWUgc2VjdGlvbiAxNS45LjEuMTVcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBJU08gODYwMSBkYXRlIHRpbWUgc3RyaW5nIGZvcm1hdC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdldERheSkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IGNvbXB1dGUgdGhlIHllYXIsIG1vbnRoLCBkYXRlLCBob3VycywgbWludXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGlmIHRoZSBgZ2V0VVRDKmAgbWV0aG9kcyBhcmVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBidWdneS4gQWRhcHRlZCBmcm9tIEBZYWZmbGUncyBgZGF0ZS1zaGltYCBwcm9qZWN0LlxuICAgICAgICAgICAgICAgICAgICAgIGRhdGUgPSBmbG9vcih2YWx1ZSAvIDg2NGU1KTtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHllYXIgPSBmbG9vcihkYXRlIC8gMzY1LjI0MjUpICsgMTk3MCAtIDE7IGdldERheSh5ZWFyICsgMSwgMCkgPD0gZGF0ZTsgeWVhcisrKSB7fVxuICAgICAgICAgICAgICAgICAgICAgIGZvciAobW9udGggPSBmbG9vcigoZGF0ZSAtIGdldERheSh5ZWFyLCAwKSkgLyAzMC40Mik7IGdldERheSh5ZWFyLCBtb250aCArIDEpIDw9IGRhdGU7IG1vbnRoKyspIHt9XG4gICAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IDEgKyBkYXRlIC0gZ2V0RGF5KHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYHRpbWVgIHZhbHVlIHNwZWNpZmllcyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheSAoc2VlIEVTXG4gICAgICAgICAgICAgICAgICAgICAgLy8gNS4xIHNlY3Rpb24gMTUuOS4xLjIpLiBUaGUgZm9ybXVsYSBgKEEgJSBCICsgQikgJSBCYCBpcyB1c2VkXG4gICAgICAgICAgICAgICAgICAgICAgLy8gdG8gY29tcHV0ZSBgQSBtb2R1bG8gQmAsIGFzIHRoZSBgJWAgb3BlcmF0b3IgZG9lcyBub3RcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjb3JyZXNwb25kIHRvIHRoZSBgbW9kdWxvYCBvcGVyYXRpb24gZm9yIG5lZ2F0aXZlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgdGltZSA9ICh2YWx1ZSAlIDg2NGU1ICsgODY0ZTUpICUgODY0ZTU7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGFyZSBvYnRhaW5lZCBieVxuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY29tcG9zaW5nIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5LiBTZWUgc2VjdGlvbiAxNS45LjEuMTAuXG4gICAgICAgICAgICAgICAgICAgICAgaG91cnMgPSBmbG9vcih0aW1lIC8gMzZlNSkgJSAyNDtcbiAgICAgICAgICAgICAgICAgICAgICBtaW51dGVzID0gZmxvb3IodGltZSAvIDZlNCkgJSA2MDtcbiAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRzID0gZmxvb3IodGltZSAvIDFlMykgJSA2MDtcbiAgICAgICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB0aW1lICUgMWUzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHllYXIgPSB2YWx1ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgICAgICAgIG1vbnRoID0gdmFsdWUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICBkYXRlID0gdmFsdWUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgIGhvdXJzID0gdmFsdWUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICBtaW51dGVzID0gdmFsdWUuZ2V0VVRDTWludXRlcygpO1xuICAgICAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSB2YWx1ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdmFsdWUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIGV4dGVuZGVkIHllYXJzIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAoeWVhciA8PSAwIHx8IHllYXIgPj0gMWU0ID8gKHllYXIgPCAwID8gXCItXCIgOiBcIitcIikgKyB0b1BhZGRlZFN0cmluZyg2LCB5ZWFyIDwgMCA/IC15ZWFyIDogeWVhcikgOiB0b1BhZGRlZFN0cmluZyg0LCB5ZWFyKSkgKyBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1vbnRoICsgMSkgKyBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIGRhdGUpICtcbiAgICAgICAgICAgICAgICAgICAgLy8gTW9udGhzLCBkYXRlcywgaG91cnMsIG1pbnV0ZXMsIGFuZCBzZWNvbmRzIHNob3VsZCBoYXZlIHR3b1xuICAgICAgICAgICAgICAgICAgICAvLyBkaWdpdHM7IG1pbGxpc2Vjb25kcyBzaG91bGQgaGF2ZSB0aHJlZS5cbiAgICAgICAgICAgICAgICAgICAgXCJUXCIgKyB0b1BhZGRlZFN0cmluZygyLCBob3VycykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1pbnV0ZXMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBzZWNvbmRzKSArXG4gICAgICAgICAgICAgICAgICAgIC8vIE1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNS4wLCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgICAgICBcIi5cIiArIHRvUGFkZGVkU3RyaW5nKDMsIG1pbGxpc2Vjb25kcykgKyBcIlpcIjtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT0gXCJmdW5jdGlvblwiICYmIChjbGFzc05hbWUgIT0gbnVtYmVyQ2xhc3MgJiYgY2xhc3NOYW1lICE9IHN0cmluZ0NsYXNzICYmIGNsYXNzTmFtZSAhPSBhcnJheUNsYXNzIHx8IF9pc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSkge1xuICAgICAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIGFkZHMgbm9uLXN0YW5kYXJkIGB0b0pTT05gIG1ldGhvZHMgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAvLyBgTnVtYmVyYCwgYFN0cmluZ2AsIGBEYXRlYCwgYW5kIGBBcnJheWAgcHJvdG90eXBlcy4gSlNPTiAzXG4gICAgICAgICAgICAgICAgICAvLyBpZ25vcmVzIGFsbCBgdG9KU09OYCBtZXRob2RzIG9uIHRoZXNlIG9iamVjdHMgdW5sZXNzIHRoZXkgYXJlXG4gICAgICAgICAgICAgICAgICAvLyBkZWZpbmVkIGRpcmVjdGx5IG9uIGFuIGluc3RhbmNlLlxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04ocHJvcGVydHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhIHJlcGxhY2VtZW50IGZ1bmN0aW9uIHdhcyBwcm92aWRlZCwgY2FsbCBpdCB0byBvYnRhaW4gdGhlIHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gZm9yIHNlcmlhbGl6YXRpb24uXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5jYWxsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYm9vbGVhbkNsYXNzKSB7XG4gICAgICAgICAgICAgICAgLy8gQm9vbGVhbnMgYXJlIHJlcHJlc2VudGVkIGxpdGVyYWxseS5cbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gYEluZmluaXR5YCBhbmQgYE5hTmAgYXJlIHNlcmlhbGl6ZWQgYXNcbiAgICAgICAgICAgICAgICAvLyBgXCJudWxsXCJgLlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwID8gXCJcIiArIHZhbHVlIDogXCJudWxsXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgLy8gU3RyaW5ncyBhcmUgZG91YmxlLXF1b3RlZCBhbmQgZXNjYXBlZC5cbiAgICAgICAgICAgICAgICByZXR1cm4gcXVvdGUoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgICAgICBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YyKHZhbHVlKSkgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhpcyBpcyBhIGxpbmVhciBzZWFyY2g7IHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAgICAgLy8gaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mIHVuaXF1ZSBuZXN0ZWQgb2JqZWN0cy5cbiAgICAgICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHN0YWNrLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoc3RhY2tbbGVuZ3RoXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3ljbGljIHN0cnVjdHVyZXMgY2Fubm90IGJlIHNlcmlhbGl6ZWQgYnkgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbCBhbmQgaW5kZW50IG9uZSBhZGRpdGlvbmFsIGxldmVsLlxuICAgICAgICAgICAgICAgIHByZWZpeCA9IGluZGVudGF0aW9uO1xuICAgICAgICAgICAgICAgIGluZGVudGF0aW9uICs9IHdoaXRlc3BhY2U7XG4gICAgICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgYXJyYXkgZWxlbWVudHMuXG4gICAgICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gc2VyaWFsaXplKGluZGV4LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50ID09PSB1bmRlZiA/IFwibnVsbFwiIDogZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/IHdoaXRlc3BhY2UgPyBcIltcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwiXVwiIDogXCJbXCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJdXCIgOiBcIltdXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3QgbWVtYmVycy4gTWVtYmVycyBhcmUgc2VsZWN0ZWQgZnJvbVxuICAgICAgICAgICAgICAgICAgLy8gZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcywgb3IgdGhlIG9iamVjdFxuICAgICAgICAgICAgICAgICAgLy8gaXRzZWxmLlxuICAgICAgICAgICAgICAgICAgX2ZvckVhY2gocHJvcGVydGllcyB8fCB2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2VyaWFsaXplKHByb3BlcnR5LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB1bmRlZikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zOiBcIklmIGBnYXBgIHt3aGl0ZXNwYWNlfVxuICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCBsZXQgYG1lbWJlcmAge3F1b3RlKHByb3BlcnR5KSArIFwiOlwifVxuICAgICAgICAgICAgICAgICAgICAgIC8vIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIGBtZW1iZXJgIGFuZCB0aGUgYHNwYWNlYCBjaGFyYWN0ZXIuXCJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgXCJgc3BhY2VgIGNoYXJhY3RlclwiIHJlZmVycyB0byB0aGUgbGl0ZXJhbCBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYXJhY3Rlciwgbm90IHRoZSBgc3BhY2VgIHt3aWR0aH0gYXJndW1lbnQgcHJvdmlkZWQgdG9cbiAgICAgICAgICAgICAgICAgICAgICAvLyBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIiArICh3aGl0ZXNwYWNlID8gXCIgXCIgOiBcIlwiKSArIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gd2hpdGVzcGFjZSA/IFwie1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJ9XCIgOiBcIntcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIn1cIiA6IFwie31cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvYmplY3QgZnJvbSB0aGUgdHJhdmVyc2VkIG9iamVjdCBzdGFjay5cbiAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnN0cmluZ2lmeWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAoc291cmNlLCBmaWx0ZXIsIHdpZHRoKSB7XG4gICAgICAgICAgICAgIHZhciB3aGl0ZXNwYWNlLCBjYWxsYmFjaywgcHJvcGVydGllcywgY2xhc3NOYW1lO1xuICAgICAgICAgICAgICBpZiAob2JqZWN0VHlwZXNbdHlwZW9mIGZpbHRlciA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YyKGZpbHRlcildICYmIGZpbHRlcikge1xuICAgICAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbChmaWx0ZXIpKSA9PSBmdW5jdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZpbHRlcjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBwcm9wZXJ0eSBuYW1lcyBhcnJheSBpbnRvIGEgbWFrZXNoaWZ0IHNldC5cbiAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZmlsdGVyLmxlbmd0aCwgdmFsdWU7IGluZGV4IDwgbGVuZ3RoOyB2YWx1ZSA9IGZpbHRlcltpbmRleCsrXSwgKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpLCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSAmJiAocHJvcGVydGllc1t2YWx1ZV0gPSAxKSkge31cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHdpZHRoKSkgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGB3aWR0aGAgdG8gYW4gaW50ZWdlciBhbmQgY3JlYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmdcbiAgICAgICAgICAgICAgICAgIC8vIGB3aWR0aGAgbnVtYmVyIG9mIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICBpZiAoKHdpZHRoIC09IHdpZHRoICUgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAod2hpdGVzcGFjZSA9IFwiXCIsIHdpZHRoID4gMTAgJiYgKHdpZHRoID0gMTApOyB3aGl0ZXNwYWNlLmxlbmd0aCA8IHdpZHRoOyB3aGl0ZXNwYWNlICs9IFwiIFwiKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlID0gd2lkdGgubGVuZ3RoIDw9IDEwID8gd2lkdGggOiB3aWR0aC5zbGljZSgwLCAxMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiBkaXNjYXJkcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlbXB0eSBzdHJpbmcga2V5c1xuICAgICAgICAgICAgICAvLyAoYFwiXCJgKSBvbmx5IGlmIHRoZXkgYXJlIHVzZWQgZGlyZWN0bHkgd2l0aGluIGFuIG9iamVjdCBtZW1iZXIgbGlzdFxuICAgICAgICAgICAgICAvLyAoZS5nLiwgYCEoXCJcIiBpbiB7IFwiXCI6IDF9KWApLlxuICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKFwiXCIsICh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHNvdXJjZSwgdmFsdWUpLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgXCJcIiwgW10pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBQdWJsaWM6IFBhcnNlcyBhIEpTT04gc291cmNlIHN0cmluZy5cbiAgICAgICAgICBpZiAoIWhhcyhcImpzb24tcGFyc2VcIikpIHtcbiAgICAgICAgICAgIHZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4gICAgICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIHVuZXNjYXBlZFxuICAgICAgICAgICAgLy8gZXF1aXZhbGVudHMuXG4gICAgICAgICAgICB2YXIgVW5lc2NhcGVzID0ge1xuICAgICAgICAgICAgICA5MjogXCJcXFxcXCIsXG4gICAgICAgICAgICAgIDM0OiAnXCInLFxuICAgICAgICAgICAgICA0NzogXCIvXCIsXG4gICAgICAgICAgICAgIDk4OiBcIlxcYlwiLFxuICAgICAgICAgICAgICAxMTY6IFwiXFx0XCIsXG4gICAgICAgICAgICAgIDExMDogXCJcXG5cIixcbiAgICAgICAgICAgICAgMTAyOiBcIlxcZlwiLFxuICAgICAgICAgICAgICAxMTQ6IFwiXFxyXCJcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEludGVybmFsOiBTdG9yZXMgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgICAgIHZhciBJbmRleCwgU291cmNlO1xuXG4gICAgICAgICAgICAvLyBJbnRlcm5hbDogUmVzZXRzIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHRocm93cyBhIGBTeW50YXhFcnJvcmAuXG4gICAgICAgICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgICAgICB0aHJvdyBTeW50YXhFcnJvcigpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gSW50ZXJuYWw6IFJldHVybnMgdGhlIG5leHQgdG9rZW4sIG9yIGBcIiRcImAgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZFxuICAgICAgICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgc291cmNlIHN0cmluZy4gQSB0b2tlbiBtYXkgYmUgYSBzdHJpbmcsIG51bWJlciwgYG51bGxgXG4gICAgICAgICAgICAvLyBsaXRlcmFsLCBvciBCb29sZWFuIGxpdGVyYWwuXG4gICAgICAgICAgICB2YXIgbGV4ID0gZnVuY3Rpb24gbGV4KCkge1xuICAgICAgICAgICAgICB2YXIgc291cmNlID0gU291cmNlLFxuICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgYmVnaW4sXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkLFxuICAgICAgICAgICAgICAgICAgY2hhckNvZGU7XG4gICAgICAgICAgICAgIHdoaWxlIChJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgOTpjYXNlIDEwOmNhc2UgMTM6Y2FzZSAzMjpcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIHRva2VucywgaW5jbHVkaW5nIHRhYnMsIGNhcnJpYWdlIHJldHVybnMsIGxpbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gZmVlZHMsIGFuZCBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTIzOmNhc2UgMTI1OmNhc2UgOTE6Y2FzZSA5MzpjYXNlIDU4OmNhc2UgNDQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGEgcHVuY3R1YXRvciB0b2tlbiAoYHtgLCBgfWAsIGBbYCwgYF1gLCBgOmAsIG9yIGAsYCkgYXRcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2hhckluZGV4QnVnZ3kgPyBzb3VyY2UuY2hhckF0KEluZGV4KSA6IHNvdXJjZVtJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIGBcImAgZGVsaW1pdHMgYSBKU09OIHN0cmluZzsgYWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlZ2luIHBhcnNpbmcgdGhlIHN0cmluZy4gU3RyaW5nIHRva2VucyBhcmUgcHJlZml4ZWQgd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VudGluZWwgYEBgIGNoYXJhY3RlciB0byBkaXN0aW5ndWlzaCB0aGVtIGZyb20gcHVuY3R1YXRvcnMgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIGVuZC1vZi1zdHJpbmcgdG9rZW5zLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhbHVlID0gXCJAXCIsIEluZGV4Kys7IEluZGV4IDwgbGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVbmVzY2FwZWQgQVNDSUkgY29udHJvbCBjaGFyYWN0ZXJzICh0aG9zZSB3aXRoIGEgY29kZSB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXNzIHRoYW4gdGhlIHNwYWNlIGNoYXJhY3RlcikgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPT0gOTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgcmV2ZXJzZSBzb2xpZHVzIChgXFxgKSBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGFuIGVzY2FwZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRyb2wgY2hhcmFjdGVyIChpbmNsdWRpbmcgYFwiYCwgYFxcYCwgYW5kIGAvYCkgb3IgVW5pY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5MjpjYXNlIDM0OmNhc2UgNDc6Y2FzZSA5ODpjYXNlIDExNjpjYXNlIDExMDpjYXNlIDEwMjpjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gVW5lc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBgXFx1YCBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCB2YWxpZGF0ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IGNvZGUgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleCArIDQ7IEluZGV4IDwgcG9zaXRpb247IEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSB2YWxpZCBzZXF1ZW5jZSBjb21wcmlzZXMgZm91ciBoZXhkaWdpdHMgKGNhc2UtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlbnNpdGl2ZSkgdGhhdCBmb3JtIGEgc2luZ2xlIGhleGFkZWNpbWFsIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcgfHwgY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTAyIHx8IGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDcwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGZyb21DaGFyQ29kZShcIjB4XCIgKyBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFuIHVuZXNjYXBlZCBkb3VibGUtcXVvdGUgY2hhcmFjdGVyIG1hcmtzIHRoZSBlbmQgb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiBjYXNlIHdoZXJlIGEgc3RyaW5nIGlzIHZhbGlkLlxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJDb2RlID49IDMyICYmIGNoYXJDb2RlICE9IDkyICYmIGNoYXJDb2RlICE9IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHN0cmluZyBhcy1pcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kIHJldHVybiB0aGUgcmV2aXZlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVW50ZXJtaW5hdGVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIG51bWJlcnMgYW5kIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHBhc3QgdGhlIG5lZ2F0aXZlIHNpZ24sIGlmIG9uZSBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nykge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgemVyb2VzIGFyZSBpbnRlcnByZXRlZCBhcyBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDggJiYgKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXggKyAxKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIG9jdGFsIGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBpbnRlZ2VyIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgSW5kZXggPCBsZW5ndGggJiYgKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IEluZGV4KyspIHt9XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRmxvYXRzIGNhbm5vdCBjb250YWluIGEgbGVhZGluZyBkZWNpbWFsIHBvaW50OyBob3dldmVyLCB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSBpcyBhbHJlYWR5IGFjY291bnRlZCBmb3IgYnkgdGhlIHBhcnNlci5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDQ2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZGVjaW1hbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspIHt9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCB0cmFpbGluZyBkZWNpbWFsLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgZXhwb25lbnRzLiBUaGUgYGVgIGRlbm90aW5nIHRoZSBleHBvbmVudCBpc1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UtaW5zZW5zaXRpdmUuXG4gICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDEwMSB8fCBjaGFyQ29kZSA9PSA2OSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNraXAgcGFzdCB0aGUgc2lnbiBmb2xsb3dpbmcgdGhlIGV4cG9uZW50LCBpZiBvbmUgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0MyB8fCBjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGV4cG9uZW50aWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspIHt9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBlbXB0eSBleHBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIC8vIENvZXJjZSB0aGUgcGFyc2VkIHZhbHVlIHRvIGEgSmF2YVNjcmlwdCBudW1iZXIuXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICtzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBIG5lZ2F0aXZlIHNpZ24gbWF5IG9ubHkgcHJlY2VkZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTaWduZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGB0cnVlYCwgYGZhbHNlYCwgYW5kIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcInRydWVcIikge1xuICAgICAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDUpID09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcIm51bGxcIikge1xuICAgICAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVW5yZWNvZ25pemVkIHRva2VuLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNlbnRpbmVsIGAkYCBjaGFyYWN0ZXIgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgICAgICAgIC8vIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLlxuICAgICAgICAgICAgICByZXR1cm4gXCIkXCI7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBJbnRlcm5hbDogUGFyc2VzIGEgSlNPTiBgdmFsdWVgIHRva2VuLlxuICAgICAgICAgICAgdmFyIGdldCA9IGZ1bmN0aW9uIGdldCh2YWx1ZSkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0cywgaGFzTWVtYmVycztcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiJFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQuXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pID09IFwiQFwiKSB7XG4gICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIG9iamVjdCBhbmQgYXJyYXkgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiW1wiKSB7XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIGFycmF5LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBhcnJheS5cbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBzcXVhcmUgYnJhY2tldCBtYXJrcyB0aGUgZW5kIG9mIHRoZSBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYXJyYXkgbGl0ZXJhbCBjb250YWlucyBlbGVtZW50cywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdGluZyB0aGUgcHJldmlvdXMgZWxlbWVudCBmcm9tIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBuZXh0LlxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggYXJyYXkgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEVsaXNpb25zIGFuZCBsZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZ2V0KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IFwie1wiKSB7XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIG9iamVjdCwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIGN1cmx5IGJyYWNlIG1hcmtzIHRoZSBlbmQgb2YgdGhlIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGxpdGVyYWwgY29udGFpbnMgbWVtYmVycywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdG9yLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIG9iamVjdCBtZW1iZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZCwgb2JqZWN0IHByb3BlcnR5IG5hbWVzIG11c3QgYmVcbiAgICAgICAgICAgICAgICAgICAgLy8gZG91YmxlLXF1b3RlZCBzdHJpbmdzLCBhbmQgYSBgOmAgbXVzdCBzZXBhcmF0ZSBlYWNoIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgIC8vIG5hbWUgYW5kIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIgfHwgdHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIgfHwgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pICE9IFwiQFwiIHx8IGxleCgpICE9IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW3ZhbHVlLnNsaWNlKDEpXSA9IGdldChsZXgoKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0b2tlbiBlbmNvdW50ZXJlZC5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEludGVybmFsOiBVcGRhdGVzIGEgdHJhdmVyc2VkIG9iamVjdCBtZW1iZXIuXG4gICAgICAgICAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gd2Fsayhzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSB1bmRlZikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNvdXJjZVtwcm9wZXJ0eV0gPSBlbGVtZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgdHJhdmVyc2VzIGEgcGFyc2VkIEpTT04gb2JqZWN0LCBpbnZva2luZyB0aGVcbiAgICAgICAgICAgIC8vIGBjYWxsYmFja2AgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgICAgICAvLyBgV2Fsayhob2xkZXIsIG5hbWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICAgICAgdmFyIHdhbGsgPSBmdW5jdGlvbiB3YWxrKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0sXG4gICAgICAgICAgICAgICAgICBsZW5ndGg7XG4gICAgICAgICAgICAgIGlmICgodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZjIodmFsdWUpKSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gYGZvckVhY2hgIGNhbid0IGJlIHVzZWQgdG8gdHJhdmVyc2UgYW4gYXJyYXkgaW4gT3BlcmEgPD0gOC41NFxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgaXRzIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGltcGxlbWVudGF0aW9uIHJldHVybnMgYGZhbHNlYFxuICAgICAgICAgICAgICAgIC8vIGZvciBhcnJheSBpbmRpY2VzIChlLmcuLCBgIVsxLCAyLCAzXS5oYXNPd25Qcm9wZXJ0eShcIjBcIilgKS5cbiAgICAgICAgICAgICAgICBpZiAoZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAgICAgZm9yIChsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIGxlbmd0aCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBfZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzb3VyY2UsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnBhcnNlYC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgICAgICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCwgdmFsdWU7XG4gICAgICAgICAgICAgIEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgU291cmNlID0gXCJcIiArIHNvdXJjZTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAgICAgLy8gSWYgYSBKU09OIHN0cmluZyBjb250YWlucyBtdWx0aXBsZSB0b2tlbnMsIGl0IGlzIGludmFsaWQuXG4gICAgICAgICAgICAgIGlmIChsZXgoKSAhPSBcIiRcIikge1xuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgZ2V0Q2xhc3MuY2FsbChjYWxsYmFjaykgPT0gZnVuY3Rpb25DbGFzcyA/IHdhbGsoKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gcmVzdWx0LCB2YWx1ZSksIFwiXCIsIGNhbGxiYWNrKSA6IHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXhwb3J0c1tcInJ1bkluQ29udGV4dFwiXSA9IHJ1bkluQ29udGV4dDtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHM7XG4gICAgICB9XG5cbiAgICAgIGlmIChmcmVlRXhwb3J0cyAmJiAhaXNMb2FkZXIpIHtcbiAgICAgICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBlbnZpcm9ubWVudHMuXG4gICAgICAgIHJ1bkluQ29udGV4dChyb290LCBmcmVlRXhwb3J0cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFeHBvcnQgZm9yIHdlYiBicm93c2VycyBhbmQgSmF2YVNjcmlwdCBlbmdpbmVzLlxuICAgICAgICB2YXIgbmF0aXZlSlNPTiA9IHJvb3QuSlNPTixcbiAgICAgICAgICAgIHByZXZpb3VzSlNPTiA9IHJvb3RbXCJKU09OM1wiXSxcbiAgICAgICAgICAgIGlzUmVzdG9yZWQgPSBmYWxzZTtcblxuICAgICAgICB2YXIgSlNPTjMgPSBydW5JbkNvbnRleHQocm9vdCwgcm9vdFtcIkpTT04zXCJdID0ge1xuICAgICAgICAgIC8vIFB1YmxpYzogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBnbG9iYWwgYEpTT05gIG9iamVjdCBhbmRcbiAgICAgICAgICAvLyByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgSlNPTjNgIG9iamVjdC5cbiAgICAgICAgICBcIm5vQ29uZmxpY3RcIjogZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgICAgICAgIGlmICghaXNSZXN0b3JlZCkge1xuICAgICAgICAgICAgICBpc1Jlc3RvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcm9vdC5KU09OID0gbmF0aXZlSlNPTjtcbiAgICAgICAgICAgICAgcm9vdFtcIkpTT04zXCJdID0gcHJldmlvdXNKU09OO1xuICAgICAgICAgICAgICBuYXRpdmVKU09OID0gcHJldmlvdXNKU09OID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBKU09OMztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJvb3QuSlNPTiA9IHtcbiAgICAgICAgICBcInBhcnNlXCI6IEpTT04zLnBhcnNlLFxuICAgICAgICAgIFwic3RyaW5naWZ5XCI6IEpTT04zLnN0cmluZ2lmeVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBFeHBvcnQgZm9yIGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy5cbiAgICAgIGlmIChpc0xvYWRlcikge1xuICAgICAgICB1bmRlZmluZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBKU09OMztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkuY2FsbChjb21tb25qc0dsb2JhbCk7XG4gIH0pO1xuXG4gIHZhciBjb25zdGFudHMgPSB7XG4gICAgREVGQVVMVF9JTlNUQU5DRTogJyRkZWZhdWx0X2luc3RhbmNlJyxcbiAgICBBUElfVkVSU0lPTjogMixcbiAgICBNQVhfU1RSSU5HX0xFTkdUSDogNDA5NixcbiAgICBNQVhfUFJPUEVSVFlfS0VZUzogMTAwMCxcbiAgICBJREVOVElGWV9FVkVOVDogJyRpZGVudGlmeScsXG5cbiAgICAvLyBsb2NhbFN0b3JhZ2VLZXlzXG4gICAgTEFTVF9FVkVOVF9JRDogJ2FtcGxpdHVkZV9sYXN0RXZlbnRJZCcsXG4gICAgTEFTVF9FVkVOVF9USU1FOiAnYW1wbGl0dWRlX2xhc3RFdmVudFRpbWUnLFxuICAgIExBU1RfSURFTlRJRllfSUQ6ICdhbXBsaXR1ZGVfbGFzdElkZW50aWZ5SWQnLFxuICAgIExBU1RfU0VRVUVOQ0VfTlVNQkVSOiAnYW1wbGl0dWRlX2xhc3RTZXF1ZW5jZU51bWJlcicsXG4gICAgU0VTU0lPTl9JRDogJ2FtcGxpdHVkZV9zZXNzaW9uSWQnLFxuXG4gICAgLy8gVXNlZCBpbiBjb29raWUgYXMgd2VsbFxuICAgIERFVklDRV9JRDogJ2FtcGxpdHVkZV9kZXZpY2VJZCcsXG4gICAgT1BUX09VVDogJ2FtcGxpdHVkZV9vcHRPdXQnLFxuICAgIFVTRVJfSUQ6ICdhbXBsaXR1ZGVfdXNlcklkJyxcblxuICAgIENPT0tJRV9URVNUOiAnYW1wbGl0dWRlX2Nvb2tpZV90ZXN0JyxcblxuICAgIC8vIHJldmVudWUga2V5c1xuICAgIFJFVkVOVUVfRVZFTlQ6ICdyZXZlbnVlX2Ftb3VudCcsXG4gICAgUkVWRU5VRV9QUk9EVUNUX0lEOiAnJHByb2R1Y3RJZCcsXG4gICAgUkVWRU5VRV9RVUFOVElUWTogJyRxdWFudGl0eScsXG4gICAgUkVWRU5VRV9QUklDRTogJyRwcmljZScsXG4gICAgUkVWRU5VRV9SRVZFTlVFX1RZUEU6ICckcmV2ZW51ZVR5cGUnLFxuXG4gICAgQU1QX0RFVklDRV9JRF9QQVJBTTogJ2FtcF9kZXZpY2VfaWQnIC8vIHVybCBwYXJhbVxuICB9O1xuXG4gIC8qIGpzaGludCBiaXR3aXNlOiBmYWxzZSAqL1xuXG4gIC8qXG4gICAqIFVURi04IGVuY29kZXIvZGVjb2RlclxuICAgKiBodHRwOi8vd3d3LndlYnRvb2xraXQuaW5mby9cbiAgICovXG4gIHZhciBVVEY4ID0ge1xuICAgIGVuY29kZTogZnVuY3Rpb24gZW5jb2RlKHMpIHtcbiAgICAgIHZhciB1dGZ0ZXh0ID0gJyc7XG5cbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgcy5sZW5ndGg7IG4rKykge1xuICAgICAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChuKTtcblxuICAgICAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgICAgIHV0ZnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgfSBlbHNlIGlmIChjID4gMTI3ICYmIGMgPCAyMDQ4KSB7XG4gICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMgPj4gNiB8IDE5Mik7XG4gICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMgJiA2MyB8IDEyOCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMgPj4gMTIgfCAyMjQpO1xuICAgICAgICAgIHV0ZnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjID4+IDYgJiA2MyB8IDEyOCk7XG4gICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMgJiA2MyB8IDEyOCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1dGZ0ZXh0O1xuICAgIH0sXG5cbiAgICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZSh1dGZ0ZXh0KSB7XG4gICAgICB2YXIgcyA9ICcnO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGMgPSAwLFxuICAgICAgICAgIGMxID0gMCxcbiAgICAgICAgICBjMiA9IDA7XG5cbiAgICAgIHdoaWxlIChpIDwgdXRmdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgYyA9IHV0ZnRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPiAxOTEgJiYgYyA8IDIyNCkge1xuICAgICAgICAgIGMxID0gdXRmdGV4dC5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiAzMSkgPDwgNiB8IGMxICYgNjMpO1xuICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjMSA9IHV0ZnRleHQuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgICAgYzIgPSB1dGZ0ZXh0LmNoYXJDb2RlQXQoaSArIDIpO1xuICAgICAgICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDE1KSA8PCAxMiB8IChjMSAmIDYzKSA8PCA2IHwgYzIgJiA2Myk7XG4gICAgICAgICAgaSArPSAzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcztcbiAgICB9XG4gIH07XG5cbiAgLyoganNoaW50IGJpdHdpc2U6IGZhbHNlICovXG4gIC8qIGdsb2JhbCBlc2NhcGUsIHVuZXNjYXBlICovXG5cbiAgLypcbiAgICogQmFzZTY0IGVuY29kZXIvZGVjb2RlclxuICAgKiBodHRwOi8vd3d3LndlYnRvb2xraXQuaW5mby9cbiAgICovXG4gIHZhciBCYXNlNjQgPSB7XG4gICAgX2tleVN0cjogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JyxcblxuICAgIGVuY29kZTogZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAod2luZG93LmJ0b2EgJiYgd2luZG93LmF0b2IpIHtcbiAgICAgICAgICByZXR1cm4gd2luZG93LmJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0KSkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vbG9nKGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEJhc2U2NC5fZW5jb2RlKGlucHV0KTtcbiAgICB9LFxuXG4gICAgX2VuY29kZTogZnVuY3Rpb24gX2VuY29kZShpbnB1dCkge1xuICAgICAgdmFyIG91dHB1dCA9ICcnO1xuICAgICAgdmFyIGNocjEsIGNocjIsIGNocjMsIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIGlucHV0ID0gVVRGOC5lbmNvZGUoaW5wdXQpO1xuXG4gICAgICB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICBjaHIxID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBjaHIyID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBjaHIzID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xuXG4gICAgICAgIGVuYzEgPSBjaHIxID4+IDI7XG4gICAgICAgIGVuYzIgPSAoY2hyMSAmIDMpIDw8IDQgfCBjaHIyID4+IDQ7XG4gICAgICAgIGVuYzMgPSAoY2hyMiAmIDE1KSA8PCAyIHwgY2hyMyA+PiA2O1xuICAgICAgICBlbmM0ID0gY2hyMyAmIDYzO1xuXG4gICAgICAgIGlmIChpc05hTihjaHIyKSkge1xuICAgICAgICAgIGVuYzMgPSBlbmM0ID0gNjQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOYU4oY2hyMykpIHtcbiAgICAgICAgICBlbmM0ID0gNjQ7XG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXQgPSBvdXRwdXQgKyBCYXNlNjQuX2tleVN0ci5jaGFyQXQoZW5jMSkgKyBCYXNlNjQuX2tleVN0ci5jaGFyQXQoZW5jMikgKyBCYXNlNjQuX2tleVN0ci5jaGFyQXQoZW5jMykgKyBCYXNlNjQuX2tleVN0ci5jaGFyQXQoZW5jNCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0sXG5cbiAgICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHdpbmRvdy5idG9hICYmIHdpbmRvdy5hdG9iKSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUod2luZG93LmF0b2IoaW5wdXQpKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy9sb2coZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQmFzZTY0Ll9kZWNvZGUoaW5wdXQpO1xuICAgIH0sXG5cbiAgICBfZGVjb2RlOiBmdW5jdGlvbiBfZGVjb2RlKGlucHV0KSB7XG4gICAgICB2YXIgb3V0cHV0ID0gJyc7XG4gICAgICB2YXIgY2hyMSwgY2hyMiwgY2hyMztcbiAgICAgIHZhciBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0O1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLCAnJyk7XG5cbiAgICAgIHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIGVuYzEgPSBCYXNlNjQuX2tleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jMiA9IEJhc2U2NC5fa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICAgICAgICBlbmMzID0gQmFzZTY0Ll9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzQgPSBCYXNlNjQuX2tleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcblxuICAgICAgICBjaHIxID0gZW5jMSA8PCAyIHwgZW5jMiA+PiA0O1xuICAgICAgICBjaHIyID0gKGVuYzIgJiAxNSkgPDwgNCB8IGVuYzMgPj4gMjtcbiAgICAgICAgY2hyMyA9IChlbmMzICYgMykgPDwgNiB8IGVuYzQ7XG5cbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0ICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaHIxKTtcblxuICAgICAgICBpZiAoZW5jMyAhPT0gNjQpIHtcbiAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmM0ICE9PSA2NCkge1xuICAgICAgICAgIG91dHB1dCA9IG91dHB1dCArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG91dHB1dCA9IFVURjguZGVjb2RlKG91dHB1dCk7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgfTtcblxuICB2YXIgY29tcG9uZW50VXJsID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBnaXZlbiBgdXJsYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICB2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgIGEuaHJlZiA9IHVybDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhyZWY6IGEuaHJlZixcbiAgICAgICAgaG9zdDogYS5ob3N0IHx8IGxvY2F0aW9uLmhvc3QsXG4gICAgICAgIHBvcnQ6ICcwJyA9PT0gYS5wb3J0IHx8ICcnID09PSBhLnBvcnQgPyBwb3J0KGEucHJvdG9jb2wpIDogYS5wb3J0LFxuICAgICAgICBoYXNoOiBhLmhhc2gsXG4gICAgICAgIGhvc3RuYW1lOiBhLmhvc3RuYW1lIHx8IGxvY2F0aW9uLmhvc3RuYW1lLFxuICAgICAgICBwYXRobmFtZTogYS5wYXRobmFtZS5jaGFyQXQoMCkgIT0gJy8nID8gJy8nICsgYS5wYXRobmFtZSA6IGEucGF0aG5hbWUsXG4gICAgICAgIHByb3RvY29sOiAhYS5wcm90b2NvbCB8fCAnOicgPT0gYS5wcm90b2NvbCA/IGxvY2F0aW9uLnByb3RvY29sIDogYS5wcm90b2NvbCxcbiAgICAgICAgc2VhcmNoOiBhLnNlYXJjaCxcbiAgICAgICAgcXVlcnk6IGEuc2VhcmNoLnNsaWNlKDEpXG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBgdXJsYCBpcyBhYnNvbHV0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBleHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICByZXR1cm4gMCA9PSB1cmwuaW5kZXhPZignLy8nKSB8fCAhIX51cmwuaW5kZXhPZignOi8vJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGB1cmxgIGlzIHJlbGF0aXZlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIGV4cG9ydHMuaXNSZWxhdGl2ZSA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgIHJldHVybiAhZXhwb3J0cy5pc0Fic29sdXRlKHVybCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGB1cmxgIGlzIGNyb3NzIGRvbWFpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBleHBvcnRzLmlzQ3Jvc3NEb21haW4gPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICB1cmwgPSBleHBvcnRzLnBhcnNlKHVybCk7XG4gICAgICB2YXIgbG9jYXRpb24gPSBleHBvcnRzLnBhcnNlKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgIHJldHVybiB1cmwuaG9zdG5hbWUgIT09IGxvY2F0aW9uLmhvc3RuYW1lIHx8IHVybC5wb3J0ICE9PSBsb2NhdGlvbi5wb3J0IHx8IHVybC5wcm90b2NvbCAhPT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBkZWZhdWx0IHBvcnQgZm9yIGBwcm90b2NvbGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHByb3RvY29sXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBvcnQocHJvdG9jb2wpIHtcbiAgICAgIHN3aXRjaCAocHJvdG9jb2wpIHtcbiAgICAgICAgY2FzZSAnaHR0cDonOlxuICAgICAgICAgIHJldHVybiA4MDtcbiAgICAgICAgY2FzZSAnaHR0cHM6JzpcbiAgICAgICAgICByZXR1cm4gNDQzO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBsb2NhdGlvbi5wb3J0O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEhlbHBlcnMuXG4gICAqL1xuXG4gIHZhciBzID0gMTAwMDtcbiAgdmFyIG0gPSBzICogNjA7XG4gIHZhciBoID0gbSAqIDYwO1xuICB2YXIgZCA9IGggKiAyNDtcbiAgdmFyIHkgPSBkICogMzY1LjI1O1xuXG4gIC8qKlxuICAgKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICAgKlxuICAgKiBPcHRpb25zOlxuICAgKlxuICAgKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAgICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgdmFyIG1zID0gZnVuY3Rpb24gbXModmFsLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZjIodmFsKTtcbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBwYXJzZSQxKHZhbCk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICsgSlNPTi5zdHJpbmdpZnkodmFsKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBmdW5jdGlvbiBwYXJzZSQxKHN0cikge1xuICAgIHN0ciA9IFN0cmluZyhzdHIpO1xuICAgIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoc3RyKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gICAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3llYXJzJzpcbiAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgY2FzZSAneXJzJzpcbiAgICAgIGNhc2UgJ3lyJzpcbiAgICAgIGNhc2UgJ3knOlxuICAgICAgICByZXR1cm4gbiAqIHk7XG4gICAgICBjYXNlICdkYXlzJzpcbiAgICAgIGNhc2UgJ2RheSc6XG4gICAgICBjYXNlICdkJzpcbiAgICAgICAgcmV0dXJuIG4gKiBkO1xuICAgICAgY2FzZSAnaG91cnMnOlxuICAgICAgY2FzZSAnaG91cic6XG4gICAgICBjYXNlICdocnMnOlxuICAgICAgY2FzZSAnaHInOlxuICAgICAgY2FzZSAnaCc6XG4gICAgICAgIHJldHVybiBuICogaDtcbiAgICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgIGNhc2UgJ21pbnMnOlxuICAgICAgY2FzZSAnbWluJzpcbiAgICAgIGNhc2UgJ20nOlxuICAgICAgICByZXR1cm4gbiAqIG07XG4gICAgICBjYXNlICdzZWNvbmRzJzpcbiAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICBjYXNlICdzZWNzJzpcbiAgICAgIGNhc2UgJ3NlYyc6XG4gICAgICBjYXNlICdzJzpcbiAgICAgICAgcmV0dXJuIG4gKiBzO1xuICAgICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgIGNhc2UgJ21zZWNzJzpcbiAgICAgIGNhc2UgJ21zZWMnOlxuICAgICAgY2FzZSAnbXMnOlxuICAgICAgICByZXR1cm4gbjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gICAgaWYgKG1zID49IGQpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gICAgfVxuICAgIGlmIChtcyA+PSBoKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICAgIH1cbiAgICBpZiAobXMgPj0gbSkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgICB9XG4gICAgaWYgKG1zID49IHMpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gICAgfVxuICAgIHJldHVybiBtcyArICdtcyc7XG4gIH1cblxuICAvKipcbiAgICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBmdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpIHx8IHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fCBwbHVyYWwobXMsIG0sICdtaW51dGUnKSB8fCBwbHVyYWwobXMsIHMsICdzZWNvbmQnKSB8fCBtcyArICcgbXMnO1xuICB9XG5cbiAgLyoqXG4gICAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICAgKi9cblxuICBmdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgICBpZiAobXMgPCBuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtcyA8IG4gKiAxLjUpIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xuICB9XG5cbiAgdmFyIGRlYnVnJDEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICAgICAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gICAgICpcbiAgICAgKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gICAgICovXG5cbiAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnWydkZWZhdWx0J10gPSBjcmVhdGVEZWJ1ZztcbiAgICBleHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbiAgICBleHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuICAgIGV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuICAgIGV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgZXhwb3J0cy5odW1hbml6ZSA9IG1zO1xuXG4gICAgLyoqXG4gICAgICogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICAgICAqL1xuICAgIGV4cG9ydHMuaW5zdGFuY2VzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAgICAgKi9cblxuICAgIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgICBleHBvcnRzLnNraXBzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gICAgICpcbiAgICAgKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gICAgICovXG5cbiAgICBleHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBhIGNvbG9yLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgICAgIHZhciBoYXNoID0gMCxcbiAgICAgICAgICBpO1xuXG4gICAgICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cbiAgICAgIHZhciBwcmV2VGltZTtcblxuICAgICAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgICAgIC8vIGRpc2FibGVkP1xuICAgICAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHJldHVybjtcblxuICAgICAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgICAgIHZhciBtcyQkMSA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgICAgIHNlbGYuZGlmZiA9IG1zJCQxO1xuICAgICAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICAgICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICAgICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgICAgIC8vIHR1cm4gdGhlIGBhcmd1bWVudHNgIGludG8gYSBwcm9wZXIgQXJyYXlcbiAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cblxuICAgICAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICAgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uIChtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGluZGV4LS07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcbiAgICAgICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICAgICAgdmFyIGxvZ0ZuID0gZGVidWcubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgICBkZWJ1Zy5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gICAgICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICAgICAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuICAgICAgZGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cbiAgICAgIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuaW5pdCkge1xuICAgICAgICBleHBvcnRzLmluaXQoZGVidWcpO1xuICAgICAgfVxuXG4gICAgICBleHBvcnRzLmluc3RhbmNlcy5wdXNoKGRlYnVnKTtcblxuICAgICAgcmV0dXJuIGRlYnVnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB2YXIgaW5kZXggPSBleHBvcnRzLmluc3RhbmNlcy5pbmRleE9mKHRoaXMpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBleHBvcnRzLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gICAgICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgICAgIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgICAgIGV4cG9ydHMuc2tpcHMgPSBbXTtcblxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICAgICAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgICAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICAgICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBleHBvcnRzLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBleHBvcnRzLmluc3RhbmNlc1tpXTtcbiAgICAgICAgaW5zdGFuY2UuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChpbnN0YW5jZS5uYW1lc3BhY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICAgICAqXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgICBleHBvcnRzLmVuYWJsZSgnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgICAgIGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpLCBsZW47XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29lcmNlIGB2YWxgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gICAgICogQHJldHVybiB7TWl4ZWR9XG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGJyb3dzZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICAgICAqXG4gICAgICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICAgICAqL1xuXG4gICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGVidWckMTtcbiAgICBleHBvcnRzLmxvZyA9IGxvZztcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuICAgIGV4cG9ydHMuc2F2ZSA9IHNhdmU7XG4gICAgZXhwb3J0cy5sb2FkID0gbG9hZDtcbiAgICBleHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbiAgICBleHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZSA/IGNocm9tZS5zdG9yYWdlLmxvY2FsIDogbG9jYWxzdG9yYWdlKCk7XG5cbiAgICAvKipcbiAgICAgKiBDb2xvcnMuXG4gICAgICovXG5cbiAgICBleHBvcnRzLmNvbG9ycyA9IFsnIzAwMDBDQycsICcjMDAwMEZGJywgJyMwMDMzQ0MnLCAnIzAwMzNGRicsICcjMDA2NkNDJywgJyMwMDY2RkYnLCAnIzAwOTlDQycsICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJywgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLCAnIzMzOTlGRicsICcjMzNDQzAwJywgJyMzM0NDMzMnLCAnIzMzQ0M2NicsICcjMzNDQzk5JywgJyMzM0NDQ0MnLCAnIzMzQ0NGRicsICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJywgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLCAnI0NDMDA2NicsICcjQ0MwMDk5JywgJyNDQzAwQ0MnLCAnI0NDMDBGRicsICcjQ0MzMzAwJywgJyNDQzMzMzMnLCAnI0NDMzM2NicsICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJywgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLCAnI0ZGMDBGRicsICcjRkYzMzAwJywgJyNGRjMzMzMnLCAnI0ZGMzM2NicsICcjRkYzMzk5JywgJyNGRjMzQ0MnLCAnI0ZGMzNGRicsICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMyddO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAgICAgKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAgICAgKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAgICAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAgICAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgICAgIC8vIGV4cGxpY2l0bHlcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG4gICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAgICAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgICAgIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UgfHxcbiAgICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8IHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkgfHxcbiAgICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxIHx8XG4gICAgICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gICAgICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gICAgICovXG5cbiAgICBleHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gICAgICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgICAgIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKSArIHRoaXMubmFtZXNwYWNlICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArIGFyZ3NbMF0gKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gICAgICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xuXG4gICAgICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gICAgICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuICAgICAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgICAgIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgICAgIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBsYXN0QyA9IDA7XG4gICAgICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gICAgICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAgICAgKlxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBsb2coKSB7XG4gICAgICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAgICAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgICAgIHJldHVybiAnb2JqZWN0JyA9PT0gKHR5cGVvZiBjb25zb2xlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZjIoY29uc29sZSkpICYmIGNvbnNvbGUubG9nICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBsb2FkKCkge1xuICAgICAgdmFyIHI7XG4gICAgICB0cnkge1xuICAgICAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICAgICAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAgICAgKi9cblxuICAgIGV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbiAgICAvKipcbiAgICAgKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAgICAgKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICAgICAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAgICovXG5cbiAgdmFyIGRlYnVnID0gYnJvd3NlcignY29va2llJyk7XG5cbiAgLyoqXG4gICAqIFNldCBvciBnZXQgY29va2llIGBuYW1lYCB3aXRoIGB2YWx1ZWAgYW5kIGBvcHRpb25zYCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtNaXhlZH1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgdmFyIGNvbXBvbmVudENvb2tpZSA9IGZ1bmN0aW9uIGNvbXBvbmVudENvb2tpZShuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAzOlxuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gc2V0JDEobmFtZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gZ2V0JDEobmFtZSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYWxsKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgY29va2llIGBuYW1lYCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHNldCQxKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIHN0ciA9IGVuY29kZShuYW1lKSArICc9JyArIGVuY29kZSh2YWx1ZSk7XG5cbiAgICBpZiAobnVsbCA9PSB2YWx1ZSkgb3B0aW9ucy5tYXhhZ2UgPSAtMTtcblxuICAgIGlmIChvcHRpb25zLm1heGFnZSkge1xuICAgICAgb3B0aW9ucy5leHBpcmVzID0gbmV3IERhdGUoK25ldyBEYXRlKCkgKyBvcHRpb25zLm1heGFnZSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucGF0aCkgc3RyICs9ICc7IHBhdGg9JyArIG9wdGlvbnMucGF0aDtcbiAgICBpZiAob3B0aW9ucy5kb21haW4pIHN0ciArPSAnOyBkb21haW49JyArIG9wdGlvbnMuZG9tYWluO1xuICAgIGlmIChvcHRpb25zLmV4cGlyZXMpIHN0ciArPSAnOyBleHBpcmVzPScgKyBvcHRpb25zLmV4cGlyZXMudG9VVENTdHJpbmcoKTtcbiAgICBpZiAob3B0aW9ucy5zZWN1cmUpIHN0ciArPSAnOyBzZWN1cmUnO1xuXG4gICAgZG9jdW1lbnQuY29va2llID0gc3RyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbGwgY29va2llcy5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgZnVuY3Rpb24gYWxsKCkge1xuICAgIHZhciBzdHI7XG4gICAgdHJ5IHtcbiAgICAgIHN0ciA9IGRvY3VtZW50LmNvb2tpZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIuc3RhY2sgfHwgZXJyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlKHN0cik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNvb2tpZSBgbmFtZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldCQxKG5hbWUpIHtcbiAgICByZXR1cm4gYWxsKClbbmFtZV07XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgY29va2llIGBzdHJgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICAgIHZhciBvYmogPSB7fTtcbiAgICB2YXIgcGFpcnMgPSBzdHIuc3BsaXQoLyAqOyAqLyk7XG4gICAgdmFyIHBhaXI7XG4gICAgaWYgKCcnID09IHBhaXJzWzBdKSByZXR1cm4gb2JqO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHBhaXIgPSBwYWlyc1tpXS5zcGxpdCgnPScpO1xuICAgICAgb2JqW2RlY29kZShwYWlyWzBdKV0gPSBkZWNvZGUocGFpclsxXSk7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlLlxuICAgKi9cblxuICBmdW5jdGlvbiBlbmNvZGUodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcoJ2Vycm9yIGBlbmNvZGUoJW8pYCAtICVvJywgdmFsdWUsIGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGRlY29kZSh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZygnZXJyb3IgYGRlY29kZSglbylgIC0gJW8nLCB2YWx1ZSwgZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxpYiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICAgICAqL1xuXG4gICAgdmFyIHBhcnNlID0gY29tcG9uZW50VXJsLnBhcnNlO1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0b3AgZG9tYWluLlxuICAgICAqXG4gICAgICogVGhlIGZ1bmN0aW9uIGNvbnN0cnVjdHMgdGhlIGxldmVscyBvZiBkb21haW4gYW5kIGF0dGVtcHRzIHRvIHNldCBhIGdsb2JhbFxuICAgICAqIGNvb2tpZSBvbiBlYWNoIG9uZSB3aGVuIGl0IHN1Y2NlZWRzIGl0IHJldHVybnMgdGhlIHRvcCBsZXZlbCBkb21haW4uXG4gICAgICpcbiAgICAgKiBUaGUgbWV0aG9kIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nIHdoZW4gdGhlIGhvc3RuYW1lIGlzIGFuIGlwIG9yIGBsb2NhbGhvc3RgLlxuICAgICAqXG4gICAgICogRXhhbXBsZSBsZXZlbHM6XG4gICAgICpcbiAgICAgKiAgICAgIGRvbWFpbi5sZXZlbHMoJ2h0dHA6Ly93d3cuZ29vZ2xlLmNvLnVrJyk7XG4gICAgICogICAgICAvLyA9PiBbXCJjby51a1wiLCBcImdvb2dsZS5jby51a1wiLCBcInd3dy5nb29nbGUuY28udWtcIl1cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgICAgIGRvbWFpbignaHR0cDovL2xvY2FsaG9zdDozMDAwL2JheicpO1xuICAgICAqICAgICAgLy8gPT4gJydcbiAgICAgKiAgICAgIGRvbWFpbignaHR0cDovL2RldjozMDAwL2JheicpO1xuICAgICAqICAgICAgLy8gPT4gJydcbiAgICAgKiAgICAgIGRvbWFpbignaHR0cDovLzEyNy4wLjAuMTozMDAwL2JheicpO1xuICAgICAqICAgICAgLy8gPT4gJydcbiAgICAgKiAgICAgIGRvbWFpbignaHR0cDovL3NlZ21lbnQuaW8vYmF6Jyk7XG4gICAgICogICAgICAvLyA9PiAnc2VnbWVudC5pbydcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb21haW4odXJsKSB7XG4gICAgICB2YXIgY29va2llJCQxID0gZXhwb3J0cy5jb29raWU7XG4gICAgICB2YXIgbGV2ZWxzID0gZXhwb3J0cy5sZXZlbHModXJsKTtcblxuICAgICAgLy8gTG9va3VwIHRoZSByZWFsIHRvcCBsZXZlbCBvbmUuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY25hbWUgPSAnX190bGRfXyc7XG4gICAgICAgIHZhciBkb21haW4gPSBsZXZlbHNbaV07XG4gICAgICAgIHZhciBvcHRzID0geyBkb21haW46ICcuJyArIGRvbWFpbiB9O1xuXG4gICAgICAgIGNvb2tpZSQkMShjbmFtZSwgMSwgb3B0cyk7XG4gICAgICAgIGlmIChjb29raWUkJDEoY25hbWUpKSB7XG4gICAgICAgICAgY29va2llJCQxKGNuYW1lLCBudWxsLCBvcHRzKTtcbiAgICAgICAgICByZXR1cm4gZG9tYWluO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMZXZlbHMgcmV0dXJucyBhbGwgbGV2ZWxzIG9mIHRoZSBnaXZlbiB1cmwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBkb21haW4ubGV2ZWxzID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgdmFyIGhvc3QgPSBwYXJzZSh1cmwpLmhvc3RuYW1lO1xuICAgICAgdmFyIHBhcnRzID0gaG9zdC5zcGxpdCgnLicpO1xuICAgICAgdmFyIGxhc3QgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBsZXZlbHMgPSBbXTtcblxuICAgICAgLy8gSXAgYWRkcmVzcy5cbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDQgJiYgbGFzdCA9PT0gcGFyc2VJbnQobGFzdCwgMTApKSB7XG4gICAgICAgIHJldHVybiBsZXZlbHM7XG4gICAgICB9XG5cbiAgICAgIC8vIExvY2FsaG9zdC5cbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPD0gMSkge1xuICAgICAgICByZXR1cm4gbGV2ZWxzO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgbGV2ZWxzLlxuICAgICAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDI7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGxldmVscy5wdXNoKHBhcnRzLnNsaWNlKGkpLmpvaW4oJy4nKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsZXZlbHM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4cG9zZSBjb29raWUgb24gZG9tYWluLlxuICAgICAqL1xuICAgIGRvbWFpbi5jb29raWUgPSBjb21wb25lbnRDb29raWU7XG5cbiAgICAvKlxuICAgICAqIEV4cG9ydHMuXG4gICAgICovXG5cbiAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBkb21haW47XG4gIH0pO1xuXG4gIHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIF90eXBlb2YyKFN5bWJvbC5pdGVyYXRvcikgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mMihvYmopO1xuICB9IDogZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZjIob2JqKTtcbiAgfTtcblxuICAvKipcbiAgICogdG9TdHJpbmcgcmVmLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHR5cGUgb2YgYHZhbGAuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHZhciB0eXBlID0gZnVuY3Rpb24gdHlwZSh2YWwpIHtcbiAgICBzd2l0Y2ggKHRvU3RyaW5nLmNhbGwodmFsKSkge1xuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICBjYXNlICdbb2JqZWN0IEFyZ3VtZW50c10nOlxuICAgICAgICByZXR1cm4gJ2FyZ3VtZW50cyc7XG4gICAgICBjYXNlICdbb2JqZWN0IEFycmF5XSc6XG4gICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgICAgY2FzZSAnW29iamVjdCBFcnJvcl0nOlxuICAgICAgICByZXR1cm4gJ2Vycm9yJztcbiAgICB9XG5cbiAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICB9XG4gICAgaWYgKHZhbCAhPT0gdmFsKSB7XG4gICAgICByZXR1cm4gJ25hbic7XG4gICAgfVxuICAgIGlmICh2YWwgJiYgdmFsLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICByZXR1cm4gJ2VsZW1lbnQnO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgICAgcmV0dXJuICdidWZmZXInO1xuICAgIH1cblxuICAgIHZhbCA9IHZhbC52YWx1ZU9mID8gdmFsLnZhbHVlT2YoKSA6IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZi5hcHBseSh2YWwpO1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpO1xuICB9O1xuXG4gIHZhciBsb2dMZXZlbCA9ICdXQVJOJztcblxuICB2YXIgbG9nTGV2ZWxzID0ge1xuICAgIERJU0FCTEU6IDAsXG4gICAgRVJST1I6IDEsXG4gICAgV0FSTjogMixcbiAgICBJTkZPOiAzXG4gIH07XG5cbiAgdmFyIHNldExvZ0xldmVsID0gZnVuY3Rpb24gc2V0TG9nTGV2ZWwobG9nTGV2ZWxOYW1lKSB7XG4gICAgbG9nTGV2ZWwgPSBsb2dMZXZlbHNbbG9nTGV2ZWxOYW1lXSB8fCBsb2dMZXZlbDtcbiAgfTtcblxuICB2YXIgZ2V0TG9nTGV2ZWwgPSBmdW5jdGlvbiBnZXRMb2dMZXZlbCgpIHtcbiAgICByZXR1cm4gbG9nTGV2ZWw7XG4gIH07XG5cbiAgdmFyIGxvZyA9IHtcbiAgICBlcnJvcjogZnVuY3Rpb24gZXJyb3Iocykge1xuICAgICAgaWYgKGxvZ0xldmVsID49IGxvZ0xldmVscy5FUlJPUikge1xuICAgICAgICBfbG9nKHMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB3YXJuOiBmdW5jdGlvbiB3YXJuKHMpIHtcbiAgICAgIGlmIChsb2dMZXZlbCA+PSBsb2dMZXZlbHMuV0FSTikge1xuICAgICAgICBfbG9nKHMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBpbmZvOiBmdW5jdGlvbiBpbmZvKHMpIHtcbiAgICAgIGlmIChsb2dMZXZlbCA+PSBsb2dMZXZlbHMuSU5GTykge1xuICAgICAgICBfbG9nKHMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgX2xvZyA9IGZ1bmN0aW9uIF9sb2cocykge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnW0FtcGxpdHVkZV0gJyArIHMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGNvbnNvbGUgbG9nZ2luZyBub3QgYXZhaWxhYmxlXG4gICAgfVxuICB9O1xuXG4gIHZhciBpc0VtcHR5U3RyaW5nID0gZnVuY3Rpb24gaXNFbXB0eVN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gIXN0ciB8fCBzdHIubGVuZ3RoID09PSAwO1xuICB9O1xuXG4gIHZhciBzZXNzaW9uU3RvcmFnZUVuYWJsZWQgPSBmdW5jdGlvbiBzZXNzaW9uU3RvcmFnZUVuYWJsZWQoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh3aW5kb3cuc2Vzc2lvblN0b3JhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge30gLy8gc2Vzc2lvblN0b3JhZ2UgZGlzYWJsZWRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLy8gdHJ1bmNhdGUgc3RyaW5nIHZhbHVlcyBpbiBldmVudCBhbmQgdXNlciBwcm9wZXJ0aWVzIHNvIHRoYXQgcmVxdWVzdCBzaXplIGRvZXMgbm90IGdldCB0b28gbGFyZ2VcbiAgdmFyIHRydW5jYXRlID0gZnVuY3Rpb24gdHJ1bmNhdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZSh2YWx1ZSkgPT09ICdhcnJheScpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWVbaV0gPSB0cnVuY2F0ZSh2YWx1ZVtpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlKHZhbHVlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHZhbHVlW2tleV0gPSB0cnVuY2F0ZSh2YWx1ZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IF90cnVuY2F0ZVZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgdmFyIF90cnVuY2F0ZVZhbHVlID0gZnVuY3Rpb24gX3RydW5jYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZSh2YWx1ZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID4gY29uc3RhbnRzLk1BWF9TVFJJTkdfTEVOR1RIID8gdmFsdWUuc3Vic3RyaW5nKDAsIGNvbnN0YW50cy5NQVhfU1RSSU5HX0xFTkdUSCkgOiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIHZhciB2YWxpZGF0ZUlucHV0ID0gZnVuY3Rpb24gdmFsaWRhdGVJbnB1dChpbnB1dCwgbmFtZSwgZXhwZWN0ZWRUeXBlKSB7XG4gICAgaWYgKHR5cGUoaW5wdXQpICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgIGxvZy5lcnJvcignSW52YWxpZCAnICsgbmFtZSArICcgaW5wdXQgdHlwZS4gRXhwZWN0ZWQgJyArIGV4cGVjdGVkVHlwZSArICcgYnV0IHJlY2VpdmVkICcgKyB0eXBlKGlucHV0KSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIGRvIHNvbWUgYmFzaWMgc2FuaXRpemF0aW9uIGFuZCB0eXBlIGNoZWNraW5nLCBhbHNvIGNhdGNoIHByb3BlcnR5IGRpY3RzIHdpdGggbW9yZSB0aGFuIDEwMDAga2V5L3ZhbHVlIHBhaXJzXG4gIHZhciB2YWxpZGF0ZVByb3BlcnRpZXMgPSBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMocHJvcGVydGllcykge1xuICAgIHZhciBwcm9wc1R5cGUgPSB0eXBlKHByb3BlcnRpZXMpO1xuICAgIGlmIChwcm9wc1R5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICBsb2cuZXJyb3IoJ0Vycm9yOiBpbnZhbGlkIHByb3BlcnRpZXMgZm9ybWF0LiBFeHBlY3RpbmcgSmF2YXNjcmlwdCBvYmplY3QsIHJlY2VpdmVkICcgKyBwcm9wc1R5cGUgKyAnLCBpZ25vcmluZycpO1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIGlmIChPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5sZW5ndGggPiBjb25zdGFudHMuTUFYX1BST1BFUlRZX0tFWVMpIHtcbiAgICAgIGxvZy5lcnJvcignRXJyb3I6IHRvbyBtYW55IHByb3BlcnRpZXMgKG1vcmUgdGhhbiAxMDAwKSwgaWdub3JpbmcnKTtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICB2YXIgY29weSA9IHt9OyAvLyBjcmVhdGUgYSBjb3B5IHdpdGggYWxsIG9mIHRoZSB2YWxpZCBwcm9wZXJ0aWVzXG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gcHJvcGVydGllcykge1xuICAgICAgaWYgKCFwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWRhdGUga2V5XG4gICAgICB2YXIga2V5ID0gcHJvcGVydHk7XG4gICAgICB2YXIga2V5VHlwZSA9IHR5cGUoa2V5KTtcbiAgICAgIGlmIChrZXlUeXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICBrZXkgPSBTdHJpbmcoa2V5KTtcbiAgICAgICAgbG9nLndhcm4oJ1dBUk5JTkc6IE5vbi1zdHJpbmcgcHJvcGVydHkga2V5LCByZWNlaXZlZCB0eXBlICcgKyBrZXlUeXBlICsgJywgY29lcmNpbmcgdG8gc3RyaW5nIFwiJyArIGtleSArICdcIicpO1xuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZGF0ZSB2YWx1ZVxuICAgICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wZXJ0eVZhbHVlKGtleSwgcHJvcGVydGllc1twcm9wZXJ0eV0pO1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29weVtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xuICB9O1xuXG4gIHZhciBpbnZhbGlkVmFsdWVUeXBlcyA9IFsnbnVsbCcsICduYW4nLCAndW5kZWZpbmVkJywgJ2Z1bmN0aW9uJywgJ2FyZ3VtZW50cycsICdyZWdleHAnLCAnZWxlbWVudCddO1xuXG4gIHZhciB2YWxpZGF0ZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5VmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgIHZhciB2YWx1ZVR5cGUgPSB0eXBlKHZhbHVlKTtcbiAgICBpZiAoaW52YWxpZFZhbHVlVHlwZXMuaW5kZXhPZih2YWx1ZVR5cGUpICE9PSAtMSkge1xuICAgICAgbG9nLndhcm4oJ1dBUk5JTkc6IFByb3BlcnR5IGtleSBcIicgKyBrZXkgKyAnXCIgd2l0aCBpbnZhbGlkIHZhbHVlIHR5cGUgJyArIHZhbHVlVHlwZSArICcsIGlnbm9yaW5nJyk7XG4gICAgICB2YWx1ZSA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgIGxvZy53YXJuKCdXQVJOSU5HOiBQcm9wZXJ0eSBrZXkgXCInICsga2V5ICsgJ1wiIHdpdGggdmFsdWUgdHlwZSBlcnJvciwgY29lcmNpbmcgdG8gJyArIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgLy8gY2hlY2sgZm9yIG5lc3RlZCBhcnJheXMgb3Igb2JqZWN0c1xuICAgICAgdmFyIGFycmF5Q29weSA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHZhbHVlW2ldO1xuICAgICAgICB2YXIgZWxlbVR5cGUgPSB0eXBlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbVR5cGUgPT09ICdhcnJheScgfHwgZWxlbVR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgbG9nLndhcm4oJ1dBUk5JTkc6IENhbm5vdCBoYXZlICcgKyBlbGVtVHlwZSArICcgbmVzdGVkIGluIGFuIGFycmF5IHByb3BlcnR5IHZhbHVlLCBza2lwcGluZycpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5Q29weS5wdXNoKHZhbGlkYXRlUHJvcGVydHlWYWx1ZShrZXksIGVsZW1lbnQpKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gYXJyYXlDb3B5O1xuICAgIH0gZWxzZSBpZiAodmFsdWVUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFsdWUgPSB2YWxpZGF0ZVByb3BlcnRpZXModmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlR3JvdXBzID0gZnVuY3Rpb24gdmFsaWRhdGVHcm91cHMoZ3JvdXBzKSB7XG4gICAgdmFyIGdyb3Vwc1R5cGUgPSB0eXBlKGdyb3Vwcyk7XG4gICAgaWYgKGdyb3Vwc1R5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICBsb2cuZXJyb3IoJ0Vycm9yOiBpbnZhbGlkIGdyb3VwcyBmb3JtYXQuIEV4cGVjdGluZyBKYXZhc2NyaXB0IG9iamVjdCwgcmVjZWl2ZWQgJyArIGdyb3Vwc1R5cGUgKyAnLCBpZ25vcmluZycpO1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIHZhciBjb3B5ID0ge307IC8vIGNyZWF0ZSBhIGNvcHkgd2l0aCBhbGwgb2YgdGhlIHZhbGlkIHByb3BlcnRpZXNcbiAgICBmb3IgKHZhciBncm91cCBpbiBncm91cHMpIHtcbiAgICAgIGlmICghZ3JvdXBzLmhhc093blByb3BlcnR5KGdyb3VwKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWRhdGUga2V5XG4gICAgICB2YXIga2V5ID0gZ3JvdXA7XG4gICAgICB2YXIga2V5VHlwZSA9IHR5cGUoa2V5KTtcbiAgICAgIGlmIChrZXlUeXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICBrZXkgPSBTdHJpbmcoa2V5KTtcbiAgICAgICAgbG9nLndhcm4oJ1dBUk5JTkc6IE5vbi1zdHJpbmcgZ3JvdXBUeXBlLCByZWNlaXZlZCB0eXBlICcgKyBrZXlUeXBlICsgJywgY29lcmNpbmcgdG8gc3RyaW5nIFwiJyArIGtleSArICdcIicpO1xuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZGF0ZSB2YWx1ZVxuICAgICAgdmFyIHZhbHVlID0gdmFsaWRhdGVHcm91cE5hbWUoa2V5LCBncm91cHNbZ3JvdXBdKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvcHlba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbiAgfTtcblxuICB2YXIgdmFsaWRhdGVHcm91cE5hbWUgPSBmdW5jdGlvbiB2YWxpZGF0ZUdyb3VwTmFtZShrZXksIGdyb3VwTmFtZSkge1xuICAgIHZhciBncm91cE5hbWVUeXBlID0gdHlwZShncm91cE5hbWUpO1xuICAgIGlmIChncm91cE5hbWVUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGdyb3VwTmFtZTtcbiAgICB9XG4gICAgaWYgKGdyb3VwTmFtZVR5cGUgPT09ICdkYXRlJyB8fCBncm91cE5hbWVUeXBlID09PSAnbnVtYmVyJyB8fCBncm91cE5hbWVUeXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIGdyb3VwTmFtZSA9IFN0cmluZyhncm91cE5hbWUpO1xuICAgICAgbG9nLndhcm4oJ1dBUk5JTkc6IE5vbi1zdHJpbmcgZ3JvdXBOYW1lLCByZWNlaXZlZCB0eXBlICcgKyBncm91cE5hbWVUeXBlICsgJywgY29lcmNpbmcgdG8gc3RyaW5nIFwiJyArIGdyb3VwTmFtZSArICdcIicpO1xuICAgICAgcmV0dXJuIGdyb3VwTmFtZTtcbiAgICB9XG4gICAgaWYgKGdyb3VwTmFtZVR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgIC8vIGNoZWNrIGZvciBuZXN0ZWQgYXJyYXlzIG9yIG9iamVjdHNcbiAgICAgIHZhciBhcnJheUNvcHkgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBOYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gZ3JvdXBOYW1lW2ldO1xuICAgICAgICB2YXIgZWxlbVR5cGUgPSB0eXBlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbVR5cGUgPT09ICdhcnJheScgfHwgZWxlbVR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgbG9nLndhcm4oJ1dBUk5JTkc6IFNraXBwaW5nIG5lc3RlZCAnICsgZWxlbVR5cGUgKyAnIGluIGFycmF5IGdyb3VwTmFtZScpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1UeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGFycmF5Q29weS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1UeXBlID09PSAnZGF0ZScgfHwgZWxlbVR5cGUgPT09ICdudW1iZXInIHx8IGVsZW1UeXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBlbGVtZW50ID0gU3RyaW5nKGVsZW1lbnQpO1xuICAgICAgICAgIGxvZy53YXJuKCdXQVJOSU5HOiBOb24tc3RyaW5nIGdyb3VwTmFtZSwgcmVjZWl2ZWQgdHlwZSAnICsgZWxlbVR5cGUgKyAnLCBjb2VyY2luZyB0byBzdHJpbmcgXCInICsgZWxlbWVudCArICdcIicpO1xuICAgICAgICAgIGFycmF5Q29weS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlDb3B5O1xuICAgIH1cbiAgICBsb2cud2FybignV0FSTklORzogTm9uLXN0cmluZyBncm91cE5hbWUsIHJlY2VpdmVkIHR5cGUgJyArIGdyb3VwTmFtZVR5cGUgKyAnLiBQbGVhc2UgdXNlIHN0cmluZ3Mgb3IgYXJyYXkgb2Ygc3RyaW5ncyBmb3IgZ3JvdXBOYW1lJyk7XG4gIH07XG5cbiAgLy8gcGFyc2VzIHRoZSB2YWx1ZSBvZiBhIHVybCBwYXJhbSAoZm9yIGV4YW1wbGUgP2djbGlkPTEyMzQmLi4uKVxuICB2YXIgZ2V0UXVlcnlQYXJhbSA9IGZ1bmN0aW9uIGdldFF1ZXJ5UGFyYW0obmFtZSwgcXVlcnkpIHtcbiAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC9bXFxbXS8sIFwiXFxcXFtcIikucmVwbGFjZSgvW1xcXV0vLCBcIlxcXFxdXCIpO1xuICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoXCJbXFxcXD8mXVwiICsgbmFtZSArIFwiPShbXiYjXSopXCIpO1xuICAgIHZhciByZXN1bHRzID0gcmVnZXguZXhlYyhxdWVyeSk7XG4gICAgcmV0dXJuIHJlc3VsdHMgPT09IG51bGwgPyB1bmRlZmluZWQgOiBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0c1sxXS5yZXBsYWNlKC9cXCsvZywgXCIgXCIpKTtcbiAgfTtcblxuICB2YXIgdXRpbHMgPSB7XG4gICAgc2V0TG9nTGV2ZWw6IHNldExvZ0xldmVsLFxuICAgIGdldExvZ0xldmVsOiBnZXRMb2dMZXZlbCxcbiAgICBsb2c6IGxvZyxcbiAgICBpc0VtcHR5U3RyaW5nOiBpc0VtcHR5U3RyaW5nLFxuICAgIGdldFF1ZXJ5UGFyYW06IGdldFF1ZXJ5UGFyYW0sXG4gICAgc2Vzc2lvblN0b3JhZ2VFbmFibGVkOiBzZXNzaW9uU3RvcmFnZUVuYWJsZWQsXG4gICAgdHJ1bmNhdGU6IHRydW5jYXRlLFxuICAgIHZhbGlkYXRlR3JvdXBzOiB2YWxpZGF0ZUdyb3VwcyxcbiAgICB2YWxpZGF0ZUlucHV0OiB2YWxpZGF0ZUlucHV0LFxuICAgIHZhbGlkYXRlUHJvcGVydGllczogdmFsaWRhdGVQcm9wZXJ0aWVzXG4gIH07XG5cbiAgLypcbiAgICogQ29va2llIGRhdGFcbiAgICovXG5cbiAgdmFyIF9vcHRpb25zID0ge1xuICAgIGV4cGlyYXRpb25EYXlzOiB1bmRlZmluZWQsXG4gICAgZG9tYWluOiB1bmRlZmluZWRcbiAgfTtcblxuICB2YXIgcmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBfb3B0aW9ucyA9IHtcbiAgICAgIGV4cGlyYXRpb25EYXlzOiB1bmRlZmluZWQsXG4gICAgICBkb21haW46IHVuZGVmaW5lZFxuICAgIH07XG4gIH07XG5cbiAgdmFyIG9wdGlvbnMgPSBmdW5jdGlvbiBvcHRpb25zKG9wdHMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIF9vcHRpb25zO1xuICAgIH1cblxuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgX29wdGlvbnMuZXhwaXJhdGlvbkRheXMgPSBvcHRzLmV4cGlyYXRpb25EYXlzO1xuXG4gICAgdmFyIGRvbWFpbiA9ICF1dGlscy5pc0VtcHR5U3RyaW5nKG9wdHMuZG9tYWluKSA/IG9wdHMuZG9tYWluIDogJy4nICsgbGliKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICB2YXIgdG9rZW4gPSBNYXRoLnJhbmRvbSgpO1xuICAgIF9vcHRpb25zLmRvbWFpbiA9IGRvbWFpbjtcbiAgICBzZXQoJ2FtcGxpdHVkZV90ZXN0JywgdG9rZW4pO1xuICAgIHZhciBzdG9yZWQgPSBnZXQoJ2FtcGxpdHVkZV90ZXN0Jyk7XG4gICAgaWYgKCFzdG9yZWQgfHwgc3RvcmVkICE9PSB0b2tlbikge1xuICAgICAgZG9tYWluID0gbnVsbDtcbiAgICB9XG4gICAgcmVtb3ZlKCdhbXBsaXR1ZGVfdGVzdCcpO1xuICAgIF9vcHRpb25zLmRvbWFpbiA9IGRvbWFpbjtcbiAgfTtcblxuICB2YXIgX2RvbWFpblNwZWNpZmljID0gZnVuY3Rpb24gX2RvbWFpblNwZWNpZmljKG5hbWUpIHtcbiAgICAvLyBkaWZmZXJlbnRpYXRlIGJldHdlZW4gY29va2llcyBvbiBkaWZmZXJlbnQgZG9tYWluc1xuICAgIHZhciBzdWZmaXggPSAnJztcbiAgICBpZiAoX29wdGlvbnMuZG9tYWluKSB7XG4gICAgICBzdWZmaXggPSBfb3B0aW9ucy5kb21haW4uY2hhckF0KDApID09PSAnLicgPyBfb3B0aW9ucy5kb21haW4uc3Vic3RyaW5nKDEpIDogX29wdGlvbnMuZG9tYWluO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZSArIHN1ZmZpeDtcbiAgfTtcblxuICB2YXIgZ2V0ID0gZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIG5hbWVFcSA9IF9kb21haW5TcGVjaWZpYyhuYW1lKSArICc9JztcbiAgICAgIHZhciBjYSA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpO1xuICAgICAgdmFyIHZhbHVlID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBjYVtpXTtcbiAgICAgICAgd2hpbGUgKGMuY2hhckF0KDApID09PSAnICcpIHtcbiAgICAgICAgICBjID0gYy5zdWJzdHJpbmcoMSwgYy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjLmluZGV4T2YobmFtZUVxKSA9PT0gMCkge1xuICAgICAgICAgIHZhbHVlID0gYy5zdWJzdHJpbmcobmFtZUVxLmxlbmd0aCwgYy5sZW5ndGgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShCYXNlNjQuZGVjb2RlKHZhbHVlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHNldCA9IGZ1bmN0aW9uIHNldChuYW1lLCB2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICBfc2V0KF9kb21haW5TcGVjaWZpYyhuYW1lKSwgQmFzZTY0LmVuY29kZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpLCBfb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHZhciBfc2V0ID0gZnVuY3Rpb24gX3NldChuYW1lLCB2YWx1ZSwgb3B0cykge1xuICAgIHZhciBleHBpcmVzID0gdmFsdWUgIT09IG51bGwgPyBvcHRzLmV4cGlyYXRpb25EYXlzIDogLTE7XG4gICAgaWYgKGV4cGlyZXMpIHtcbiAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIGV4cGlyZXMgKiAyNCAqIDYwICogNjAgKiAxMDAwKTtcbiAgICAgIGV4cGlyZXMgPSBkYXRlO1xuICAgIH1cbiAgICB2YXIgc3RyID0gbmFtZSArICc9JyArIHZhbHVlO1xuICAgIGlmIChleHBpcmVzKSB7XG4gICAgICBzdHIgKz0gJzsgZXhwaXJlcz0nICsgZXhwaXJlcy50b1VUQ1N0cmluZygpO1xuICAgIH1cbiAgICBzdHIgKz0gJzsgcGF0aD0vJztcbiAgICBpZiAob3B0cy5kb21haW4pIHtcbiAgICAgIHN0ciArPSAnOyBkb21haW49JyArIG9wdHMuZG9tYWluO1xuICAgIH1cbiAgICBkb2N1bWVudC5jb29raWUgPSBzdHI7XG4gIH07XG5cbiAgdmFyIHJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgIF9zZXQoX2RvbWFpblNwZWNpZmljKG5hbWUpLCBudWxsLCBfb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHZhciBDb29raWUgPSB7XG4gICAgcmVzZXQ6IHJlc2V0LFxuICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgZ2V0OiBnZXQsXG4gICAgc2V0OiBzZXQsXG4gICAgcmVtb3ZlOiByZW1vdmVcblxuICB9O1xuXG4gIC8qIGpzaGludCAtVzAyMCwgdW51c2VkOiBmYWxzZSwgbm9lbXB0eTogZmFsc2UsIGJvc3M6IHRydWUgKi9cblxuICAvKlxuICAgKiBJbXBsZW1lbnQgbG9jYWxTdG9yYWdlIHRvIHN1cHBvcnQgRmlyZWZveCAyLTMgYW5kIElFIDUtN1xuICAgKi9cbiAgdmFyIGxvY2FsU3RvcmFnZTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgLy8gdGVzdCB0aGF0IFdpbmRvdy5sb2NhbFN0b3JhZ2UgaXMgYXZhaWxhYmxlIGFuZCB3b3Jrc1xuICBmdW5jdGlvbiB3aW5kb3dMb2NhbFN0b3JhZ2VBdmFpbGFibGUoKSB7XG4gICAgdmFyIHVpZCA9IG5ldyBEYXRlKCk7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKHVpZCwgdWlkKTtcbiAgICAgIHJlc3VsdCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSh1aWQpID09PSBTdHJpbmcodWlkKTtcbiAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh1aWQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBsb2NhbFN0b3JhZ2Ugbm90IGF2YWlsYWJsZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAod2luZG93TG9jYWxTdG9yYWdlQXZhaWxhYmxlKCkpIHtcbiAgICBsb2NhbFN0b3JhZ2UgPSB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGVsc2UgaWYgKHdpbmRvdy5nbG9iYWxTdG9yYWdlKSB7XG4gICAgLy8gRmlyZWZveCAyLTMgdXNlIGdsb2JhbFN0b3JhZ2VcbiAgICAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9tL3N0b3JhZ2UjZ2xvYmFsU3RvcmFnZVxuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2UgPSB3aW5kb3cuZ2xvYmFsU3RvcmFnZVt3aW5kb3cubG9jYXRpb24uaG9zdG5hbWVdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBiYWQgaGFwcGVuZWQuLi5cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSUUgNS03IHVzZSB1c2VyRGF0YVxuICAgIC8vIFNlZSBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzE0MjQodj12cy44NSkuYXNweFxuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgYXR0cktleSA9ICdsb2NhbFN0b3JhZ2UnO1xuICAgIGRpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICBpZiAoZGl2LmFkZEJlaGF2aW9yKSB7XG4gICAgICBkaXYuYWRkQmVoYXZpb3IoJyNkZWZhdWx0I3VzZXJkYXRhJyk7XG4gICAgICBsb2NhbFN0b3JhZ2UgPSB7XG4gICAgICAgIGxlbmd0aDogMCxcbiAgICAgICAgc2V0SXRlbTogZnVuY3Rpb24gc2V0SXRlbShrLCB2KSB7XG4gICAgICAgICAgZGl2LmxvYWQoYXR0cktleSk7XG4gICAgICAgICAgaWYgKCFkaXYuZ2V0QXR0cmlidXRlKGspKSB7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKGssIHYpO1xuICAgICAgICAgIGRpdi5zYXZlKGF0dHJLZXkpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRJdGVtOiBmdW5jdGlvbiBnZXRJdGVtKGspIHtcbiAgICAgICAgICBkaXYubG9hZChhdHRyS2V5KTtcbiAgICAgICAgICByZXR1cm4gZGl2LmdldEF0dHJpYnV0ZShrKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlSXRlbTogZnVuY3Rpb24gcmVtb3ZlSXRlbShrKSB7XG4gICAgICAgICAgZGl2LmxvYWQoYXR0cktleSk7XG4gICAgICAgICAgaWYgKGRpdi5nZXRBdHRyaWJ1dGUoaykpIHtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgICAgICAgfVxuICAgICAgICAgIGRpdi5yZW1vdmVBdHRyaWJ1dGUoayk7XG4gICAgICAgICAgZGl2LnNhdmUoYXR0cktleSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgICBkaXYubG9hZChhdHRyS2V5KTtcbiAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgdmFyIGF0dHI7XG4gICAgICAgICAgd2hpbGUgKGF0dHIgPSBkaXYuWE1MRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmF0dHJpYnV0ZXNbaSsrXSkge1xuICAgICAgICAgICAgZGl2LnJlbW92ZUF0dHJpYnV0ZShhdHRyLm5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkaXYuc2F2ZShhdHRyS2V5KTtcbiAgICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGtleTogZnVuY3Rpb24ga2V5KGspIHtcbiAgICAgICAgICBkaXYubG9hZChhdHRyS2V5KTtcbiAgICAgICAgICByZXR1cm4gZGl2LlhNTERvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hdHRyaWJ1dGVzW2tdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZGl2LmxvYWQoYXR0cktleSk7XG4gICAgICBsb2NhbFN0b3JhZ2UubGVuZ3RoID0gZGl2LlhNTERvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hdHRyaWJ1dGVzLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm90aGluZyB3ZSBjYW4gZG8gLi4uICovXG4gICAgfVxuICB9XG4gIGlmICghbG9jYWxTdG9yYWdlKSB7XG4gICAgbG9jYWxTdG9yYWdlID0ge1xuICAgICAgbGVuZ3RoOiAwLFxuICAgICAgc2V0SXRlbTogZnVuY3Rpb24gc2V0SXRlbShrLCB2KSB7fSxcbiAgICAgIGdldEl0ZW06IGZ1bmN0aW9uIGdldEl0ZW0oaykge30sXG4gICAgICByZW1vdmVJdGVtOiBmdW5jdGlvbiByZW1vdmVJdGVtKGspIHt9LFxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge30sXG4gICAgICBrZXk6IGZ1bmN0aW9uIGtleShrKSB7fVxuICAgIH07XG4gIH1cblxuICB2YXIgbG9jYWxTdG9yYWdlJDEgPSBsb2NhbFN0b3JhZ2U7XG5cbiAgLyoganNoaW50IC1XMDIwLCB1bnVzZWQ6IGZhbHNlLCBub2VtcHR5OiBmYWxzZSwgYm9zczogdHJ1ZSAqL1xuXG4gIC8qXG4gICAqIEFic3RyYWN0aW9uIGxheWVyIGZvciBjb29raWUgc3RvcmFnZS5cbiAgICogVXNlcyBjb29raWUgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgZmFsbGJhY2sgdG8gbG9jYWxzdG9yYWdlLlxuICAgKi9cblxuICB2YXIgY29va2llU3RvcmFnZSA9IGZ1bmN0aW9uIGNvb2tpZVN0b3JhZ2UoKSB7XG4gICAgdGhpcy5zdG9yYWdlID0gbnVsbDtcbiAgfTtcblxuICAvLyB0ZXN0IHRoYXQgY29va2llcyBhcmUgZW5hYmxlZCAtIG5hdmlnYXRvci5jb29raWVzRW5hYmxlZCB5aWVsZHMgZmFsc2UgcG9zaXRpdmVzIGluIElFLCBuZWVkIHRvIHRlc3QgZGlyZWN0bHlcbiAgY29va2llU3RvcmFnZS5wcm90b3R5cGUuX2Nvb2tpZXNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB1aWQgPSBTdHJpbmcobmV3IERhdGUoKSk7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgQ29va2llLnNldChjb25zdGFudHMuQ09PS0lFX1RFU1QsIHVpZCk7XG4gICAgICByZXN1bHQgPSBDb29raWUuZ2V0KGNvbnN0YW50cy5DT09LSUVfVEVTVCkgPT09IHVpZDtcbiAgICAgIENvb2tpZS5yZW1vdmUoY29uc3RhbnRzLkNPT0tJRV9URVNUKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gY29va2llcyBhcmUgbm90IGVuYWJsZWRcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIGNvb2tpZVN0b3JhZ2UucHJvdG90eXBlLmdldFN0b3JhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc3RvcmFnZSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY29va2llc0VuYWJsZWQoKSkge1xuICAgICAgdGhpcy5zdG9yYWdlID0gQ29va2llO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBjb29raWVzIGRpc2FibGVkLCBmYWxsYmFjayB0byBsb2NhbHN0b3JhZ2VcbiAgICAgIC8vIG5vdGU6IGxvY2Fsc3RvcmFnZSBkb2VzIG5vdCBwZXJzaXN0IGFjcm9zcyBzdWJkb21haW5zXG4gICAgICB2YXIga2V5UHJlZml4ID0gJ2FtcF9jb29raWVzdG9yZV8nO1xuICAgICAgdGhpcy5zdG9yYWdlID0ge1xuICAgICAgICBfb3B0aW9uczoge1xuICAgICAgICAgIGV4cGlyYXRpb25EYXlzOiB1bmRlZmluZWQsXG4gICAgICAgICAgZG9tYWluOiB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgIHRoaXMuX29wdGlvbnMgPSB7XG4gICAgICAgICAgICBleHBpcmF0aW9uRGF5czogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZG9tYWluOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBvcHRpb25zOiBmdW5jdGlvbiBvcHRpb25zKG9wdHMpIHtcbiAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICAgIHRoaXMuX29wdGlvbnMuZXhwaXJhdGlvbkRheXMgPSBvcHRzLmV4cGlyYXRpb25EYXlzIHx8IHRoaXMuX29wdGlvbnMuZXhwaXJhdGlvbkRheXM7XG4gICAgICAgICAgLy8gbG9jYWxTdG9yYWdlIGlzIHNwZWNpZmljIHRvIHN1YmRvbWFpbnNcbiAgICAgICAgICB0aGlzLl9vcHRpb25zLmRvbWFpbiA9IG9wdHMuZG9tYWluIHx8IHRoaXMuX29wdGlvbnMuZG9tYWluIHx8IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UkMS5nZXRJdGVtKGtleVByZWZpeCArIG5hbWUpKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UkMS5zZXRJdGVtKGtleVByZWZpeCArIG5hbWUsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UkMS5yZW1vdmVJdGVtKGtleVByZWZpeCArIG5hbWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZTtcbiAgfTtcblxuICB2YXIgZ2V0VXRtRGF0YSA9IGZ1bmN0aW9uIGdldFV0bURhdGEocmF3Q29va2llLCBxdWVyeSkge1xuICAgIC8vIFRyYW5zbGF0ZSB0aGUgdXRteiBjb29raWUgZm9ybWF0IGludG8gdXJsIHF1ZXJ5IHN0cmluZyBmb3JtYXQuXG4gICAgdmFyIGNvb2tpZSA9IHJhd0Nvb2tpZSA/ICc/JyArIHJhd0Nvb2tpZS5zcGxpdCgnLicpLnNsaWNlKC0xKVswXS5yZXBsYWNlKC9cXHwvZywgJyYnKSA6ICcnO1xuXG4gICAgdmFyIGZldGNoUGFyYW0gPSBmdW5jdGlvbiBmZXRjaFBhcmFtKHF1ZXJ5TmFtZSwgcXVlcnksIGNvb2tpZU5hbWUsIGNvb2tpZSkge1xuICAgICAgcmV0dXJuIHV0aWxzLmdldFF1ZXJ5UGFyYW0ocXVlcnlOYW1lLCBxdWVyeSkgfHwgdXRpbHMuZ2V0UXVlcnlQYXJhbShjb29raWVOYW1lLCBjb29raWUpO1xuICAgIH07XG5cbiAgICB2YXIgdXRtU291cmNlID0gZmV0Y2hQYXJhbSgndXRtX3NvdXJjZScsIHF1ZXJ5LCAndXRtY3NyJywgY29va2llKTtcbiAgICB2YXIgdXRtTWVkaXVtID0gZmV0Y2hQYXJhbSgndXRtX21lZGl1bScsIHF1ZXJ5LCAndXRtY21kJywgY29va2llKTtcbiAgICB2YXIgdXRtQ2FtcGFpZ24gPSBmZXRjaFBhcmFtKCd1dG1fY2FtcGFpZ24nLCBxdWVyeSwgJ3V0bWNjbicsIGNvb2tpZSk7XG4gICAgdmFyIHV0bVRlcm0gPSBmZXRjaFBhcmFtKCd1dG1fdGVybScsIHF1ZXJ5LCAndXRtY3RyJywgY29va2llKTtcbiAgICB2YXIgdXRtQ29udGVudCA9IGZldGNoUGFyYW0oJ3V0bV9jb250ZW50JywgcXVlcnksICd1dG1jY3QnLCBjb29raWUpO1xuXG4gICAgdmFyIHV0bURhdGEgPSB7fTtcbiAgICB2YXIgYWRkSWZOb3ROdWxsID0gZnVuY3Rpb24gYWRkSWZOb3ROdWxsKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICghdXRpbHMuaXNFbXB0eVN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdXRtRGF0YVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGFkZElmTm90TnVsbCgndXRtX3NvdXJjZScsIHV0bVNvdXJjZSk7XG4gICAgYWRkSWZOb3ROdWxsKCd1dG1fbWVkaXVtJywgdXRtTWVkaXVtKTtcbiAgICBhZGRJZk5vdE51bGwoJ3V0bV9jYW1wYWlnbicsIHV0bUNhbXBhaWduKTtcbiAgICBhZGRJZk5vdE51bGwoJ3V0bV90ZXJtJywgdXRtVGVybSk7XG4gICAgYWRkSWZOb3ROdWxsKCd1dG1fY29udGVudCcsIHV0bUNvbnRlbnQpO1xuXG4gICAgcmV0dXJuIHV0bURhdGE7XG4gIH07XG5cbiAgLypcbiAgICogV3JhcHBlciBmb3IgYSB1c2VyIHByb3BlcnRpZXMgSlNPTiBvYmplY3QgdGhhdCBzdXBwb3J0cyBvcGVyYXRpb25zLlxuICAgKiBOb3RlOiBpZiBhIHVzZXIgcHJvcGVydHkgaXMgdXNlZCBpbiBtdWx0aXBsZSBvcGVyYXRpb25zIG9uIHRoZSBzYW1lIElkZW50aWZ5IG9iamVjdCxcbiAgICogb25seSB0aGUgZmlyc3Qgb3BlcmF0aW9uIHdpbGwgYmUgc2F2ZWQsIGFuZCB0aGUgcmVzdCB3aWxsIGJlIGlnbm9yZWQuXG4gICAqL1xuXG4gIHZhciBBTVBfT1BfQUREID0gJyRhZGQnO1xuICB2YXIgQU1QX09QX0FQUEVORCA9ICckYXBwZW5kJztcbiAgdmFyIEFNUF9PUF9DTEVBUl9BTEwgPSAnJGNsZWFyQWxsJztcbiAgdmFyIEFNUF9PUF9QUkVQRU5EID0gJyRwcmVwZW5kJztcbiAgdmFyIEFNUF9PUF9TRVQgPSAnJHNldCc7XG4gIHZhciBBTVBfT1BfU0VUX09OQ0UgPSAnJHNldE9uY2UnO1xuICB2YXIgQU1QX09QX1VOU0VUID0gJyR1bnNldCc7XG5cbiAgLyoqXG4gICAqIElkZW50aWZ5IEFQSSAtIGluc3RhbmNlIGNvbnN0cnVjdG9yLiBJZGVudGlmeSBvYmplY3RzIGFyZSBhIHdyYXBwZXIgZm9yIHVzZXIgcHJvcGVydHkgb3BlcmF0aW9ucy5cbiAgICogRWFjaCBtZXRob2QgYWRkcyBhIHVzZXIgcHJvcGVydHkgb3BlcmF0aW9uIHRvIHRoZSBJZGVudGlmeSBvYmplY3QsIGFuZCByZXR1cm5zIHRoZSBzYW1lIElkZW50aWZ5IG9iamVjdCxcbiAgICogYWxsb3dpbmcgeW91IHRvIGNoYWluIG11bHRpcGxlIG1ldGhvZCBjYWxscyB0b2dldGhlci5cbiAgICogTm90ZTogaWYgdGhlIHNhbWUgdXNlciBwcm9wZXJ0eSBpcyB1c2VkIGluIG11bHRpcGxlIG9wZXJhdGlvbnMgb24gYSBzaW5nbGUgSWRlbnRpZnkgb2JqZWN0LFxuICAgKiBvbmx5IHRoZSBmaXJzdCBvcGVyYXRpb24gb24gdGhhdCBwcm9wZXJ0eSB3aWxsIGJlIHNhdmVkLCBhbmQgdGhlIHJlc3Qgd2lsbCBiZSBpZ25vcmVkLlxuICAgKiBTZWUgW1JlYWRtZV17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FtcGxpdHVkZS9BbXBsaXR1ZGUtSmF2YXNjcmlwdCN1c2VyLXByb3BlcnRpZXMtYW5kLXVzZXItcHJvcGVydHktb3BlcmF0aW9uc31cbiAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlIElkZW50aWZ5IEFQSSBhbmQgdXNlciBwcm9wZXJ0eSBvcGVyYXRpb25zLlxuICAgKiBAY29uc3RydWN0b3IgSWRlbnRpZnlcbiAgICogQHB1YmxpY1xuICAgKiBAZXhhbXBsZSB2YXIgaWRlbnRpZnkgPSBuZXcgYW1wbGl0dWRlLklkZW50aWZ5KCk7XG4gICAqL1xuICB2YXIgSWRlbnRpZnkgPSBmdW5jdGlvbiBJZGVudGlmeSgpIHtcbiAgICB0aGlzLnVzZXJQcm9wZXJ0aWVzT3BlcmF0aW9ucyA9IHt9O1xuICAgIHRoaXMucHJvcGVydGllcyA9IFtdOyAvLyBrZWVwIHRyYWNrIG9mIGtleXMgdGhhdCBoYXZlIGJlZW4gYWRkZWRcbiAgfTtcblxuICAvKipcbiAgICogSW5jcmVtZW50IGEgdXNlciBwcm9wZXJ0eSBieSBhIGdpdmVuIHZhbHVlIChjYW4gYWxzbyBiZSBuZWdhdGl2ZSB0byBkZWNyZW1lbnQpLlxuICAgKiBJZiB0aGUgdXNlciBwcm9wZXJ0eSBkb2VzIG5vdCBoYXZlIGEgdmFsdWUgc2V0IHlldCwgaXQgd2lsbCBiZSBpbml0aWFsaXplZCB0byAwIGJlZm9yZSBiZWluZyBpbmNyZW1lbnRlZC5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSBUaGUgdXNlciBwcm9wZXJ0eSBrZXkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWUgLSBUaGUgYW1vdW50IGJ5IHdoaWNoIHRvIGluY3JlbWVudCB0aGUgdXNlciBwcm9wZXJ0eS4gQWxsb3dzIG51bWJlcnMgYXMgc3RyaW5ncyAoZXg6ICcxMjMnKS5cbiAgICogQHJldHVybiB7SWRlbnRpZnl9IFJldHVybnMgdGhlIHNhbWUgSWRlbnRpZnkgb2JqZWN0LCBhbGxvd2luZyB5b3UgdG8gY2hhaW4gbXVsdGlwbGUgbWV0aG9kIGNhbGxzIHRvZ2V0aGVyLlxuICAgKiBAZXhhbXBsZSB2YXIgaWRlbnRpZnkgPSBuZXcgYW1wbGl0dWRlLklkZW50aWZ5KCkuYWRkKCdrYXJtYScsIDEpLmFkZCgnZnJpZW5kcycsIDEpO1xuICAgKiBhbXBsaXR1ZGUuaWRlbnRpZnkoaWRlbnRpZnkpOyAvLyBzZW5kIHRoZSBJZGVudGlmeSBjYWxsXG4gICAqL1xuICBJZGVudGlmeS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIGlmICh0eXBlKHZhbHVlKSA9PT0gJ251bWJlcicgfHwgdHlwZSh2YWx1ZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9hZGRPcGVyYXRpb24oQU1QX09QX0FERCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXRpbHMubG9nLmVycm9yKCdVbnN1cHBvcnRlZCB0eXBlIGZvciB2YWx1ZTogJyArIHR5cGUodmFsdWUpICsgJywgZXhwZWN0aW5nIG51bWJlciBvciBzdHJpbmcnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBhIHZhbHVlIG9yIHZhbHVlcyB0byBhIHVzZXIgcHJvcGVydHkuXG4gICAqIElmIHRoZSB1c2VyIHByb3BlcnR5IGRvZXMgbm90IGhhdmUgYSB2YWx1ZSBzZXQgeWV0LFxuICAgKiBpdCB3aWxsIGJlIGluaXRpYWxpemVkIHRvIGFuIGVtcHR5IGxpc3QgYmVmb3JlIHRoZSBuZXcgdmFsdWVzIGFyZSBhcHBlbmRlZC5cbiAgICogSWYgdGhlIHVzZXIgcHJvcGVydHkgaGFzIGFuIGV4aXN0aW5nIHZhbHVlIGFuZCBpdCBpcyBub3QgYSBsaXN0LFxuICAgKiB0aGUgZXhpc3RpbmcgdmFsdWUgd2lsbCBiZSBjb252ZXJ0ZWQgaW50byBhIGxpc3Qgd2l0aCB0aGUgbmV3IHZhbHVlcyBhcHBlbmRlZC5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSBUaGUgdXNlciBwcm9wZXJ0eSBrZXkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xsaXN0fG9iamVjdH0gdmFsdWUgLSBBIHZhbHVlIG9yIHZhbHVlcyB0byBhcHBlbmQuXG4gICAqIFZhbHVlcyBjYW4gYmUgbnVtYmVycywgc3RyaW5ncywgbGlzdHMsIG9yIG9iamVjdCAoa2V5OnZhbHVlIGRpY3Qgd2lsbCBiZSBmbGF0dGVuZWQpLlxuICAgKiBAcmV0dXJuIHtJZGVudGlmeX0gUmV0dXJucyB0aGUgc2FtZSBJZGVudGlmeSBvYmplY3QsIGFsbG93aW5nIHlvdSB0byBjaGFpbiBtdWx0aXBsZSBtZXRob2QgY2FsbHMgdG9nZXRoZXIuXG4gICAqIEBleGFtcGxlIHZhciBpZGVudGlmeSA9IG5ldyBhbXBsaXR1ZGUuSWRlbnRpZnkoKS5hcHBlbmQoJ2FiLXRlc3RzJywgJ25ldy11c2VyLXRlc3RzJyk7XG4gICAqIGlkZW50aWZ5LmFwcGVuZCgnc29tZV9saXN0JywgWzEsIDIsIDMsIDQsICd2YWx1ZXMnXSk7XG4gICAqIGFtcGxpdHVkZS5pZGVudGlmeShpZGVudGlmeSk7IC8vIHNlbmQgdGhlIElkZW50aWZ5IGNhbGxcbiAgICovXG4gIElkZW50aWZ5LnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAocHJvcGVydHksIHZhbHVlKSB7XG4gICAgdGhpcy5fYWRkT3BlcmF0aW9uKEFNUF9PUF9BUFBFTkQsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCB1c2VyIHByb3BlcnRpZXMgZm9yIHRoZSBjdXJyZW50IHVzZXIuXG4gICAqIFNESyB1c2VyIHNob3VsZCBpbnN0ZWFkIGNhbGwgYW1wbGl0dWRlLmNsZWFyVXNlclByb3BlcnRpZXMoKSBpbnN0ZWFkIG9mIHVzaW5nIHRoaXMuXG4gICAqICRjbGVhckFsbCBuZWVkcyB0byBiZSBzZW50IG9uIGl0cyBvd24gSWRlbnRpZnkgb2JqZWN0LiBJZiB0aGVyZSBhcmUgYWxyZWFkeSBvdGhlciBvcGVyYXRpb25zLCB0aGVuIGRvbid0IGFkZCAkY2xlYXJBbGwuXG4gICAqIElmICRjbGVhckFsbCBhbHJlYWR5IGluIGFuIElkZW50aWZ5IG9iamVjdCwgZG9uJ3QgYWxsb3cgb3RoZXIgb3BlcmF0aW9ucyB0byBiZSBhZGRlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIElkZW50aWZ5LnByb3RvdHlwZS5jbGVhckFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy51c2VyUHJvcGVydGllc09wZXJhdGlvbnMpLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICghdGhpcy51c2VyUHJvcGVydGllc09wZXJhdGlvbnMuaGFzT3duUHJvcGVydHkoQU1QX09QX0NMRUFSX0FMTCkpIHtcbiAgICAgICAgdXRpbHMubG9nLmVycm9yKCdOZWVkIHRvIHNlbmQgJGNsZWFyQWxsIG9uIGl0cyBvd24gSWRlbnRpZnkgb2JqZWN0IHdpdGhvdXQgYW55IG90aGVyIG9wZXJhdGlvbnMsIHNraXBwaW5nICRjbGVhckFsbCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMudXNlclByb3BlcnRpZXNPcGVyYXRpb25zW0FNUF9PUF9DTEVBUl9BTExdID0gJy0nO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcmVwZW5kIGEgdmFsdWUgb3IgdmFsdWVzIHRvIGEgdXNlciBwcm9wZXJ0eS5cbiAgICogUHJlcGVuZCBtZWFucyBpbnNlcnRpbmcgdGhlIHZhbHVlIG9yIHZhbHVlcyBhdCB0aGUgZnJvbnQgb2YgYSBsaXN0LlxuICAgKiBJZiB0aGUgdXNlciBwcm9wZXJ0eSBkb2VzIG5vdCBoYXZlIGEgdmFsdWUgc2V0IHlldCxcbiAgICogaXQgd2lsbCBiZSBpbml0aWFsaXplZCB0byBhbiBlbXB0eSBsaXN0IGJlZm9yZSB0aGUgbmV3IHZhbHVlcyBhcmUgcHJlcGVuZGVkLlxuICAgKiBJZiB0aGUgdXNlciBwcm9wZXJ0eSBoYXMgYW4gZXhpc3RpbmcgdmFsdWUgYW5kIGl0IGlzIG5vdCBhIGxpc3QsXG4gICAqIHRoZSBleGlzdGluZyB2YWx1ZSB3aWxsIGJlIGNvbnZlcnRlZCBpbnRvIGEgbGlzdCB3aXRoIHRoZSBuZXcgdmFsdWVzIHByZXBlbmRlZC5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSBUaGUgdXNlciBwcm9wZXJ0eSBrZXkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xsaXN0fG9iamVjdH0gdmFsdWUgLSBBIHZhbHVlIG9yIHZhbHVlcyB0byBwcmVwZW5kLlxuICAgKiBWYWx1ZXMgY2FuIGJlIG51bWJlcnMsIHN0cmluZ3MsIGxpc3RzLCBvciBvYmplY3QgKGtleTp2YWx1ZSBkaWN0IHdpbGwgYmUgZmxhdHRlbmVkKS5cbiAgICogQHJldHVybiB7SWRlbnRpZnl9IFJldHVybnMgdGhlIHNhbWUgSWRlbnRpZnkgb2JqZWN0LCBhbGxvd2luZyB5b3UgdG8gY2hhaW4gbXVsdGlwbGUgbWV0aG9kIGNhbGxzIHRvZ2V0aGVyLlxuICAgKiBAZXhhbXBsZSB2YXIgaWRlbnRpZnkgPSBuZXcgYW1wbGl0dWRlLklkZW50aWZ5KCkucHJlcGVuZCgnYWItdGVzdHMnLCAnbmV3LXVzZXItdGVzdHMnKTtcbiAgICogaWRlbnRpZnkucHJlcGVuZCgnc29tZV9saXN0JywgWzEsIDIsIDMsIDQsICd2YWx1ZXMnXSk7XG4gICAqIGFtcGxpdHVkZS5pZGVudGlmeShpZGVudGlmeSk7IC8vIHNlbmQgdGhlIElkZW50aWZ5IGNhbGxcbiAgICovXG4gIElkZW50aWZ5LnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gKHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIHRoaXMuX2FkZE9wZXJhdGlvbihBTVBfT1BfUFJFUEVORCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgb2YgYSBnaXZlbiB1c2VyIHByb3BlcnR5LiBJZiBhIHZhbHVlIGFscmVhZHkgZXhpc3RzLCBpdCB3aWxsIGJlIG92ZXJ3cml0ZW4gd2l0aCB0aGUgbmV3IHZhbHVlLlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIFRoZSB1c2VyIHByb3BlcnR5IGtleS5cbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfGxpc3R8b2JqZWN0fSB2YWx1ZSAtIEEgdmFsdWUgb3IgdmFsdWVzIHRvIHNldC5cbiAgICogVmFsdWVzIGNhbiBiZSBudW1iZXJzLCBzdHJpbmdzLCBsaXN0cywgb3Igb2JqZWN0IChrZXk6dmFsdWUgZGljdCB3aWxsIGJlIGZsYXR0ZW5lZCkuXG4gICAqIEByZXR1cm4ge0lkZW50aWZ5fSBSZXR1cm5zIHRoZSBzYW1lIElkZW50aWZ5IG9iamVjdCwgYWxsb3dpbmcgeW91IHRvIGNoYWluIG11bHRpcGxlIG1ldGhvZCBjYWxscyB0b2dldGhlci5cbiAgICogQGV4YW1wbGUgdmFyIGlkZW50aWZ5ID0gbmV3IGFtcGxpdHVkZS5JZGVudGlmeSgpLnNldCgndXNlcl90eXBlJywgJ2JldGEnKTtcbiAgICogaWRlbnRpZnkuc2V0KCduYW1lJywgeydmaXJzdCc6ICdKb2huJywgJ2xhc3QnOiAnRG9lJ30pOyAvLyBkaWN0IGlzIGZsYXR0ZW5lZCBhbmQgYmVjb21lcyBuYW1lLmZpcnN0OiBKb2huLCBuYW1lLmxhc3Q6IERvZVxuICAgKiBhbXBsaXR1ZGUuaWRlbnRpZnkoaWRlbnRpZnkpOyAvLyBzZW5kIHRoZSBJZGVudGlmeSBjYWxsXG4gICAqL1xuICBJZGVudGlmeS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIHRoaXMuX2FkZE9wZXJhdGlvbihBTVBfT1BfU0VULCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIGdpdmVuIHVzZXIgcHJvcGVydHkgb25seSBvbmNlLiBTdWJzZXF1ZW50IHNldE9uY2Ugb3BlcmF0aW9ucyBvbiB0aGF0IHVzZXIgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkO1xuICAgKiBob3dldmVyLCB0aGF0IHVzZXIgcHJvcGVydHkgY2FuIHN0aWxsIGJlIG1vZGlmaWVkIHRocm91Z2ggYW55IG9mIHRoZSBvdGhlciBvcGVyYXRpb25zLlxuICAgKiBVc2VmdWwgZm9yIGNhcHR1cmluZyBwcm9wZXJ0aWVzIHN1Y2ggYXMgJ2luaXRpYWxfc2lnbnVwX2RhdGUnLCAnaW5pdGlhbF9yZWZlcnJlcicsIGV0Yy5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSBUaGUgdXNlciBwcm9wZXJ0eSBrZXkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xsaXN0fG9iamVjdH0gdmFsdWUgLSBBIHZhbHVlIG9yIHZhbHVlcyB0byBzZXQgb25jZS5cbiAgICogVmFsdWVzIGNhbiBiZSBudW1iZXJzLCBzdHJpbmdzLCBsaXN0cywgb3Igb2JqZWN0IChrZXk6dmFsdWUgZGljdCB3aWxsIGJlIGZsYXR0ZW5lZCkuXG4gICAqIEByZXR1cm4ge0lkZW50aWZ5fSBSZXR1cm5zIHRoZSBzYW1lIElkZW50aWZ5IG9iamVjdCwgYWxsb3dpbmcgeW91IHRvIGNoYWluIG11bHRpcGxlIG1ldGhvZCBjYWxscyB0b2dldGhlci5cbiAgICogQGV4YW1wbGUgdmFyIGlkZW50aWZ5ID0gbmV3IGFtcGxpdHVkZS5JZGVudGlmeSgpLnNldE9uY2UoJ3NpZ25fdXBfZGF0ZScsICcyMDE2LTA0LTAxJyk7XG4gICAqIGFtcGxpdHVkZS5pZGVudGlmeShpZGVudGlmeSk7IC8vIHNlbmQgdGhlIElkZW50aWZ5IGNhbGxcbiAgICovXG4gIElkZW50aWZ5LnByb3RvdHlwZS5zZXRPbmNlID0gZnVuY3Rpb24gKHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIHRoaXMuX2FkZE9wZXJhdGlvbihBTVBfT1BfU0VUX09OQ0UsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVuc2V0IGFuZCByZW1vdmUgYSB1c2VyIHByb3BlcnR5LiBUaGlzIHVzZXIgcHJvcGVydHkgd2lsbCBubyBsb25nZXIgc2hvdyB1cCBpbiBhIHVzZXIncyBwcm9maWxlLlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIFRoZSB1c2VyIHByb3BlcnR5IGtleS5cbiAgICogQHJldHVybiB7SWRlbnRpZnl9IFJldHVybnMgdGhlIHNhbWUgSWRlbnRpZnkgb2JqZWN0LCBhbGxvd2luZyB5b3UgdG8gY2hhaW4gbXVsdGlwbGUgbWV0aG9kIGNhbGxzIHRvZ2V0aGVyLlxuICAgKiBAZXhhbXBsZSB2YXIgaWRlbnRpZnkgPSBuZXcgYW1wbGl0dWRlLklkZW50aWZ5KCkudW5zZXQoJ3VzZXJfdHlwZScpLnVuc2V0KCdhZ2UnKTtcbiAgICogYW1wbGl0dWRlLmlkZW50aWZ5KGlkZW50aWZ5KTsgLy8gc2VuZCB0aGUgSWRlbnRpZnkgY2FsbFxuICAgKi9cbiAgSWRlbnRpZnkucHJvdG90eXBlLnVuc2V0ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgdGhpcy5fYWRkT3BlcmF0aW9uKEFNUF9PUF9VTlNFVCwgcHJvcGVydHksICctJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGFkZHMgb3BlcmF0aW9uIHRvIHRoZSBJZGVudGlmeSdzIG9iamVjdFxuICAgKiBIYW5kbGUncyBmaWx0ZXJpbmcgb2YgZHVwbGljYXRlIHVzZXIgcHJvcGVydHkga2V5cywgYW5kIGZpbHRlcmluZyBmb3IgY2xlYXJBbGwuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJZGVudGlmeS5wcm90b3R5cGUuX2FkZE9wZXJhdGlvbiA9IGZ1bmN0aW9uIChvcGVyYXRpb24sIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIC8vIGNoZWNrIHRoYXQgdGhlIGlkZW50aWZ5IGRvZXNuJ3QgYWxyZWFkeSBjb250YWluIGEgY2xlYXJBbGxcbiAgICBpZiAodGhpcy51c2VyUHJvcGVydGllc09wZXJhdGlvbnMuaGFzT3duUHJvcGVydHkoQU1QX09QX0NMRUFSX0FMTCkpIHtcbiAgICAgIHV0aWxzLmxvZy5lcnJvcignVGhpcyBpZGVudGlmeSBhbHJlYWR5IGNvbnRhaW5zIGEgJGNsZWFyQWxsIG9wZXJhdGlvbiwgc2tpcHBpbmcgb3BlcmF0aW9uICcgKyBvcGVyYXRpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIHRoYXQgcHJvcGVydHkgd2Fzbid0IGFscmVhZHkgdXNlZCBpbiB0aGlzIElkZW50aWZ5XG4gICAgaWYgKHRoaXMucHJvcGVydGllcy5pbmRleE9mKHByb3BlcnR5KSAhPT0gLTEpIHtcbiAgICAgIHV0aWxzLmxvZy5lcnJvcignVXNlciBwcm9wZXJ0eSBcIicgKyBwcm9wZXJ0eSArICdcIiBhbHJlYWR5IHVzZWQgaW4gdGhpcyBpZGVudGlmeSwgc2tpcHBpbmcgb3BlcmF0aW9uICcgKyBvcGVyYXRpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy51c2VyUHJvcGVydGllc09wZXJhdGlvbnMuaGFzT3duUHJvcGVydHkob3BlcmF0aW9uKSkge1xuICAgICAgdGhpcy51c2VyUHJvcGVydGllc09wZXJhdGlvbnNbb3BlcmF0aW9uXSA9IHt9O1xuICAgIH1cbiAgICB0aGlzLnVzZXJQcm9wZXJ0aWVzT3BlcmF0aW9uc1tvcGVyYXRpb25dW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIHRoaXMucHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgfTtcblxuICB2YXIgbWQ1ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgIC8qXG4gICAgICogSmF2YVNjcmlwdCBNRDVcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9KYXZhU2NyaXB0LU1ENVxuICAgICAqXG4gICAgICogQ29weXJpZ2h0IDIwMTEsIFNlYmFzdGlhbiBUc2NoYW5cbiAgICAgKiBodHRwczovL2JsdWVpbXAubmV0XG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gICAgICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAgICAgKlxuICAgICAqIEJhc2VkIG9uXG4gICAgICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBSU0EgRGF0YSBTZWN1cml0eSwgSW5jLiBNRDUgTWVzc2FnZVxuICAgICAqIERpZ2VzdCBBbGdvcml0aG0sIGFzIGRlZmluZWQgaW4gUkZDIDEzMjEuXG4gICAgICogVmVyc2lvbiAyLjIgQ29weXJpZ2h0IChDKSBQYXVsIEpvaG5zdG9uIDE5OTkgLSAyMDA5XG4gICAgICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICAgICAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICAgICAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBtb3JlIGluZm8uXG4gICAgICovXG5cbiAgICAvKiBnbG9iYWwgZGVmaW5lICovXG5cbiAgICAoZnVuY3Rpb24gKCQpIHtcbiAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgLypcbiAgICAgICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICAgICAgKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICAgICAgKi9cblxuICAgICAgZnVuY3Rpb24gc2FmZUFkZCh4LCB5KSB7XG4gICAgICAgIHZhciBsc3cgPSAoeCAmIDB4ZmZmZikgKyAoeSAmIDB4ZmZmZik7XG4gICAgICAgIHZhciBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcbiAgICAgICAgcmV0dXJuIG1zdyA8PCAxNiB8IGxzdyAmIDB4ZmZmZjtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGJpdFJvdGF0ZUxlZnQobnVtLCBjbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bSA8PCBjbnQgfCBudW0gPj4+IDMyIC0gY250O1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgKiBUaGVzZSBmdW5jdGlvbnMgaW1wbGVtZW50IHRoZSBmb3VyIGJhc2ljIG9wZXJhdGlvbnMgdGhlIGFsZ29yaXRobSB1c2VzLlxuICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIG1kNWNtbihxLCBhLCBiLCB4LCBzLCB0KSB7XG4gICAgICAgIHJldHVybiBzYWZlQWRkKGJpdFJvdGF0ZUxlZnQoc2FmZUFkZChzYWZlQWRkKGEsIHEpLCBzYWZlQWRkKHgsIHQpKSwgcyksIGIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbWQ1ZmYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgICAgICByZXR1cm4gbWQ1Y21uKGIgJiBjIHwgfmIgJiBkLCBhLCBiLCB4LCBzLCB0KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG1kNWdnKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICAgICAgcmV0dXJuIG1kNWNtbihiICYgZCB8IGMgJiB+ZCwgYSwgYiwgeCwgcywgdCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBtZDVoaChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgICAgIHJldHVybiBtZDVjbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG1kNWlpKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICAgICAgcmV0dXJuIG1kNWNtbihjIF4gKGIgfCB+ZCksIGEsIGIsIHgsIHMsIHQpO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoLlxuICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGJpbmxNRDUoeCwgbGVuKSB7XG4gICAgICAgIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gICAgICAgIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgbGVuICUgMzI7XG4gICAgICAgIHhbKGxlbiArIDY0ID4+PiA5IDw8IDQpICsgMTRdID0gbGVuO1xuXG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgb2xkYTtcbiAgICAgICAgdmFyIG9sZGI7XG4gICAgICAgIHZhciBvbGRjO1xuICAgICAgICB2YXIgb2xkZDtcbiAgICAgICAgdmFyIGEgPSAxNzMyNTg0MTkzO1xuICAgICAgICB2YXIgYiA9IC0yNzE3MzM4Nzk7XG4gICAgICAgIHZhciBjID0gLTE3MzI1ODQxOTQ7XG4gICAgICAgIHZhciBkID0gMjcxNzMzODc4O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNikge1xuICAgICAgICAgIG9sZGEgPSBhO1xuICAgICAgICAgIG9sZGIgPSBiO1xuICAgICAgICAgIG9sZGMgPSBjO1xuICAgICAgICAgIG9sZGQgPSBkO1xuXG4gICAgICAgICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaV0sIDcsIC02ODA4NzY5MzYpO1xuICAgICAgICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xuICAgICAgICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAyXSwgMTcsIDYwNjEwNTgxOSk7XG4gICAgICAgICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xuICAgICAgICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNywgLTE3NjQxODg5Nyk7XG4gICAgICAgICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDVdLCAxMiwgMTIwMDA4MDQyNik7XG4gICAgICAgICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xuICAgICAgICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyA3XSwgMjIsIC00NTcwNTk4Myk7XG4gICAgICAgICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA3LCAxNzcwMDM1NDE2KTtcbiAgICAgICAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgOV0sIDEyLCAtMTk1ODQxNDQxNyk7XG4gICAgICAgICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTcsIC00MjA2Myk7XG4gICAgICAgICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDExXSwgMjIsIC0xOTkwNDA0MTYyKTtcbiAgICAgICAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA3LCAxODA0NjAzNjgyKTtcbiAgICAgICAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgMTNdLCAxMiwgLTQwMzQxMTAxKTtcbiAgICAgICAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNywgLTE1MDIwMDIyOTApO1xuICAgICAgICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAxNV0sIDIyLCAxMjM2NTM1MzI5KTtcblxuICAgICAgICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyAxXSwgNSwgLTE2NTc5NjUxMCk7XG4gICAgICAgICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDZdLCA5LCAtMTA2OTUwMTYzMik7XG4gICAgICAgICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDExXSwgMTQsIDY0MzcxNzcxMyk7XG4gICAgICAgICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaV0sIDIwLCAtMzczODk3MzAyKTtcbiAgICAgICAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgNV0sIDUsIC03MDE1NTg2OTEpO1xuICAgICAgICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAxMF0sIDksIDM4MDE2MDgzKTtcbiAgICAgICAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XG4gICAgICAgICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDRdLCAyMCwgLTQwNTUzNzg0OCk7XG4gICAgICAgICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDldLCA1LCA1Njg0NDY0MzgpO1xuICAgICAgICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAxNF0sIDksIC0xMDE5ODAzNjkwKTtcbiAgICAgICAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgM10sIDE0LCAtMTg3MzYzOTYxKTtcbiAgICAgICAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgOF0sIDIwLCAxMTYzNTMxNTAxKTtcbiAgICAgICAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgMTNdLCA1LCAtMTQ0NDY4MTQ2Nyk7XG4gICAgICAgICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDJdLCA5LCAtNTE0MDM3ODQpO1xuICAgICAgICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyA3XSwgMTQsIDE3MzUzMjg0NzMpO1xuICAgICAgICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyAxMl0sIDIwLCAtMTkyNjYwNzczNCk7XG5cbiAgICAgICAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgNV0sIDQsIC0zNzg1NTgpO1xuICAgICAgICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyA4XSwgMTEsIC0yMDIyNTc0NDYzKTtcbiAgICAgICAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgMTFdLCAxNiwgMTgzOTAzMDU2Mik7XG4gICAgICAgICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDE0XSwgMjMsIC0zNTMwOTU1Nik7XG4gICAgICAgICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDFdLCA0LCAtMTUzMDk5MjA2MCk7XG4gICAgICAgICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDRdLCAxMSwgMTI3Mjg5MzM1Myk7XG4gICAgICAgICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDddLCAxNiwgLTE1NTQ5NzYzMik7XG4gICAgICAgICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDEwXSwgMjMsIC0xMDk0NzMwNjQwKTtcbiAgICAgICAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgMTNdLCA0LCA2ODEyNzkxNzQpO1xuICAgICAgICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2ldLCAxMSwgLTM1ODUzNzIyMik7XG4gICAgICAgICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDNdLCAxNiwgLTcyMjUyMTk3OSk7XG4gICAgICAgICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDZdLCAyMywgNzYwMjkxODkpO1xuICAgICAgICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyA5XSwgNCwgLTY0MDM2NDQ4Nyk7XG4gICAgICAgICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDEyXSwgMTEsIC00MjE4MTU4MzUpO1xuICAgICAgICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAxNV0sIDE2LCA1MzA3NDI1MjApO1xuICAgICAgICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAyXSwgMjMsIC05OTUzMzg2NTEpO1xuXG4gICAgICAgICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaV0sIDYsIC0xOTg2MzA4NDQpO1xuICAgICAgICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyA3XSwgMTAsIDExMjY4OTE0MTUpO1xuICAgICAgICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XG4gICAgICAgICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDVdLCAyMSwgLTU3NDM0MDU1KTtcbiAgICAgICAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA2LCAxNzAwNDg1NTcxKTtcbiAgICAgICAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgM10sIDEwLCAtMTg5NDk4NjYwNik7XG4gICAgICAgICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTUsIC0xMDUxNTIzKTtcbiAgICAgICAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG4gICAgICAgICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA2LCAxODczMzEzMzU5KTtcbiAgICAgICAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgMTVdLCAxMCwgLTMwNjExNzQ0KTtcbiAgICAgICAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XG4gICAgICAgICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDEzXSwgMjEsIDEzMDkxNTE2NDkpO1xuICAgICAgICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNiwgLTE0NTUyMzA3MCk7XG4gICAgICAgICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDExXSwgMTAsIC0xMTIwMjEwMzc5KTtcbiAgICAgICAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMl0sIDE1LCA3MTg3ODcyNTkpO1xuICAgICAgICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xuXG4gICAgICAgICAgYSA9IHNhZmVBZGQoYSwgb2xkYSk7XG4gICAgICAgICAgYiA9IHNhZmVBZGQoYiwgb2xkYik7XG4gICAgICAgICAgYyA9IHNhZmVBZGQoYywgb2xkYyk7XG4gICAgICAgICAgZCA9IHNhZmVBZGQoZCwgb2xkZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFthLCBiLCBjLCBkXTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICogQ29udmVydCBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzIHRvIGEgc3RyaW5nXG4gICAgICAqL1xuICAgICAgZnVuY3Rpb24gYmlubDJyc3RyKGlucHV0KSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gJyc7XG4gICAgICAgIHZhciBsZW5ndGgzMiA9IGlucHV0Lmxlbmd0aCAqIDMyO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMzI7IGkgKz0gOCkge1xuICAgICAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGlucHV0W2kgPj4gNV0gPj4+IGkgJSAzMiAmIDB4ZmYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAqIENvbnZlcnQgYSByYXcgc3RyaW5nIHRvIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHNcbiAgICAgICogQ2hhcmFjdGVycyA+MjU1IGhhdmUgdGhlaXIgaGlnaC1ieXRlIHNpbGVudGx5IGlnbm9yZWQuXG4gICAgICAqL1xuICAgICAgZnVuY3Rpb24gcnN0cjJiaW5sKGlucHV0KSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICAgIG91dHB1dFsoaW5wdXQubGVuZ3RoID4+IDIpIC0gMV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvdXRwdXQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBvdXRwdXRbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW5ndGg4ID0gaW5wdXQubGVuZ3RoICogODtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDg7IGkgKz0gOCkge1xuICAgICAgICAgIG91dHB1dFtpID4+IDVdIHw9IChpbnB1dC5jaGFyQ29kZUF0KGkgLyA4KSAmIDB4ZmYpIDw8IGkgJSAzMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhIHJhdyBzdHJpbmdcbiAgICAgICovXG4gICAgICBmdW5jdGlvbiByc3RyTUQ1KHMpIHtcbiAgICAgICAgcmV0dXJuIGJpbmwycnN0cihiaW5sTUQ1KHJzdHIyYmlubChzKSwgcy5sZW5ndGggKiA4KSk7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAqIENhbGN1bGF0ZSB0aGUgSE1BQy1NRDUsIG9mIGEga2V5IGFuZCBzb21lIGRhdGEgKHJhdyBzdHJpbmdzKVxuICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHJzdHJITUFDTUQ1KGtleSwgZGF0YSkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGJrZXkgPSByc3RyMmJpbmwoa2V5KTtcbiAgICAgICAgdmFyIGlwYWQgPSBbXTtcbiAgICAgICAgdmFyIG9wYWQgPSBbXTtcbiAgICAgICAgdmFyIGhhc2g7XG4gICAgICAgIGlwYWRbMTVdID0gb3BhZFsxNV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChia2V5Lmxlbmd0aCA+IDE2KSB7XG4gICAgICAgICAgYmtleSA9IGJpbmxNRDUoYmtleSwga2V5Lmxlbmd0aCAqIDgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSArPSAxKSB7XG4gICAgICAgICAgaXBhZFtpXSA9IGJrZXlbaV0gXiAweDM2MzYzNjM2O1xuICAgICAgICAgIG9wYWRbaV0gPSBia2V5W2ldIF4gMHg1YzVjNWM1YztcbiAgICAgICAgfVxuICAgICAgICBoYXNoID0gYmlubE1ENShpcGFkLmNvbmNhdChyc3RyMmJpbmwoZGF0YSkpLCA1MTIgKyBkYXRhLmxlbmd0aCAqIDgpO1xuICAgICAgICByZXR1cm4gYmlubDJyc3RyKGJpbmxNRDUob3BhZC5jb25jYXQoaGFzaCksIDUxMiArIDEyOCkpO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgKiBDb252ZXJ0IGEgcmF3IHN0cmluZyB0byBhIGhleCBzdHJpbmdcbiAgICAgICovXG4gICAgICBmdW5jdGlvbiByc3RyMmhleChpbnB1dCkge1xuICAgICAgICB2YXIgaGV4VGFiID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xuICAgICAgICB2YXIgb3V0cHV0ID0gJyc7XG4gICAgICAgIHZhciB4O1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgeCA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgb3V0cHV0ICs9IGhleFRhYi5jaGFyQXQoeCA+Pj4gNCAmIDB4MGYpICsgaGV4VGFiLmNoYXJBdCh4ICYgMHgwZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICogRW5jb2RlIGEgc3RyaW5nIGFzIHV0Zi04XG4gICAgICAqL1xuICAgICAgZnVuY3Rpb24gc3RyMnJzdHJVVEY4KGlucHV0KSB7XG4gICAgICAgIHJldHVybiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoaW5wdXQpKTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICogVGFrZSBzdHJpbmcgYXJndW1lbnRzIGFuZCByZXR1cm4gZWl0aGVyIHJhdyBvciBoZXggZW5jb2RlZCBzdHJpbmdzXG4gICAgICAqL1xuICAgICAgZnVuY3Rpb24gcmF3TUQ1KHMpIHtcbiAgICAgICAgcmV0dXJuIHJzdHJNRDUoc3RyMnJzdHJVVEY4KHMpKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGhleE1ENShzKSB7XG4gICAgICAgIHJldHVybiByc3RyMmhleChyYXdNRDUocykpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmF3SE1BQ01ENShrLCBkKSB7XG4gICAgICAgIHJldHVybiByc3RySE1BQ01ENShzdHIycnN0clVURjgoayksIHN0cjJyc3RyVVRGOChkKSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBoZXhITUFDTUQ1KGssIGQpIHtcbiAgICAgICAgcmV0dXJuIHJzdHIyaGV4KHJhd0hNQUNNRDUoaywgZCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtZDUoc3RyaW5nLCBrZXksIHJhdykge1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgIGlmICghcmF3KSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4TUQ1KHN0cmluZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByYXdNRDUoc3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJhdykge1xuICAgICAgICAgIHJldHVybiBoZXhITUFDTUQ1KGtleSwgc3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmF3SE1BQ01ENShrZXksIHN0cmluZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdW5kZWZpbmVkID09PSAnZnVuY3Rpb24nICYmIHVuZGVmaW5lZC5hbWQpIHtcbiAgICAgICAgdW5kZWZpbmVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbWQ1O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gbWQ1O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJC5tZDUgPSBtZDU7XG4gICAgICB9XG4gICAgfSkoY29tbW9uanNHbG9iYWwpO1xuICB9KTtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xuICB2YXIgZnJlZUdsb2JhbCA9ICh0eXBlb2YgY29tbW9uanNHbG9iYWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mMihjb21tb25qc0dsb2JhbCkpID09ICdvYmplY3QnICYmIGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGNvbW1vbmpzR2xvYmFsO1xuXG4gIHZhciBfZnJlZUdsb2JhbCA9IGZyZWVHbG9iYWw7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbiAgdmFyIGZyZWVTZWxmID0gKHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZjIoc2VsZikpID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4gIC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xuICB2YXIgcm9vdCA9IF9mcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbiAgdmFyIF9yb290ID0gcm9vdDtcblxuICAvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIFN5bWJvbCQxID0gX3Jvb3QuU3ltYm9sO1xuXG4gIHZhciBfU3ltYm9sID0gU3ltYm9sJDE7XG5cbiAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICB2YXIgb2JqZWN0UHJvdG8kMyA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gIHZhciBoYXNPd25Qcm9wZXJ0eSQzID0gb2JqZWN0UHJvdG8kMy5oYXNPd25Qcm9wZXJ0eTtcblxuICAvKipcbiAgICogVXNlZCB0byByZXNvbHZlIHRoZVxuICAgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICogb2YgdmFsdWVzLlxuICAgKi9cbiAgdmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8kMy50b1N0cmluZztcblxuICAvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIHN5bVRvU3RyaW5nVGFnJDEgPSBfU3ltYm9sID8gX1N5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gICAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkkMy5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyQxKSxcbiAgICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWckMV07XG5cbiAgICB0cnkge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWckMV0gPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgaWYgKHVubWFza2VkKSB7XG4gICAgICBpZiAoaXNPd24pIHtcbiAgICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWckMV0gPSB0YWc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWckMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgX2dldFJhd1RhZyA9IGdldFJhd1RhZztcblxuICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gIHZhciBvYmplY3RQcm90byQ0ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAvKipcbiAgICogVXNlZCB0byByZXNvbHZlIHRoZVxuICAgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICogb2YgdmFsdWVzLlxuICAgKi9cbiAgdmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nJDEgPSBvYmplY3RQcm90byQ0LnRvU3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nJDEuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICB2YXIgX29iamVjdFRvU3RyaW5nID0gb2JqZWN0VG9TdHJpbmc7XG5cbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuICB2YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJztcbiAgdmFyIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4gIC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuICB2YXIgc3ltVG9TdHJpbmdUYWcgPSBfU3ltYm9sID8gX1N5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgICB9XG4gICAgcmV0dXJuIHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkgPyBfZ2V0UmF3VGFnKHZhbHVlKSA6IF9vYmplY3RUb1N0cmluZyh2YWx1ZSk7XG4gIH1cblxuICB2YXIgX2Jhc2VHZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAgICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICAgKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc09iamVjdCh7fSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0KG51bGwpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YyKHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xuICB9XG5cbiAgdmFyIGlzT2JqZWN0XzEgPSBpc09iamVjdDtcblxuICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG4gIHZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJztcbiAgdmFyIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICB2YXIgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcbiAgdmFyIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzRnVuY3Rpb24oXyk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0XzEodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAgIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICAgIHZhciB0YWcgPSBfYmFzZUdldFRhZyh2YWx1ZSk7XG4gICAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbiAgfVxuXG4gIHZhciBpc0Z1bmN0aW9uXzEgPSBpc0Z1bmN0aW9uO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbiAgdmFyIGNvcmVKc0RhdGEgPSBfcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbiAgdmFyIF9jb3JlSnNEYXRhID0gY29yZUpzRGF0YTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xuICB2YXIgbWFza1NyY0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhfY29yZUpzRGF0YSAmJiBfY29yZUpzRGF0YS5rZXlzICYmIF9jb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICAgIHJldHVybiB1aWQgPyAnU3ltYm9sKHNyYylfMS4nICsgdWlkIDogJyc7XG4gIH0oKTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICAgIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgbWFza1NyY0tleSBpbiBmdW5jO1xuICB9XG5cbiAgdmFyIF9pc01hc2tlZCA9IGlzTWFza2VkO1xuXG4gIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIGZ1bmNQcm90byQxID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4gIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbiAgdmFyIGZ1bmNUb1N0cmluZyQxID0gZnVuY1Byb3RvJDEudG9TdHJpbmc7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICAgKi9cbiAgZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICAgIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmdW5jVG9TdHJpbmckMS5jYWxsKGZ1bmMpO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmdW5jICsgJyc7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgX3RvU291cmNlID0gdG9Tb3VyY2U7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAgICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gICAqL1xuICB2YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbiAgdmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbiAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICB2YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuICB2YXIgb2JqZWN0UHJvdG8kMiA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xuICB2YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4gIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuICB2YXIgaGFzT3duUHJvcGVydHkkMiA9IG9iamVjdFByb3RvJDIuaGFzT3duUHJvcGVydHk7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbiAgdmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICsgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkkMikucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKS5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJyk7XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdF8xKHZhbHVlKSB8fCBfaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbl8xKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChfdG9Tb3VyY2UodmFsdWUpKTtcbiAgfVxuXG4gIHZhciBfYmFzZUlzTmF0aXZlID0gYmFzZUlzTmF0aXZlO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9XG5cbiAgdmFyIF9nZXRWYWx1ZSA9IGdldFZhbHVlO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAqL1xuICBmdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgICB2YXIgdmFsdWUgPSBfZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICAgIHJldHVybiBfYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIF9nZXROYXRpdmUgPSBnZXROYXRpdmU7XG5cbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgZnVuYyA9IF9nZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9KCk7XG5cbiAgdmFyIF9kZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5O1xuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICAgKiB2YWx1ZSBjaGVja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBfZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIF9iYXNlQXNzaWduVmFsdWUgPSBiYXNlQXNzaWduVmFsdWU7XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGFcbiAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDQuMC4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICAgKlxuICAgKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmVxKCdhJywgJ2EnKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmVxKE5hTiwgTmFOKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKi9cbiAgZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG5cbiAgdmFyIGVxXzEgPSBlcTtcblxuICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gIHZhciBvYmplY3RQcm90byQxID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbiAgdmFyIGhhc093blByb3BlcnR5JDEgPSBvYmplY3RQcm90byQxLmhhc093blByb3BlcnR5O1xuXG4gIC8qKlxuICAgKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICovXG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICAgIGlmICghKGhhc093blByb3BlcnR5JDEuY2FsbChvYmplY3QsIGtleSkgJiYgZXFfMShvYmpWYWx1ZSwgdmFsdWUpKSB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgIF9iYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgX2Fzc2lnblZhbHVlID0gYXNzaWduVmFsdWU7XG5cbiAgLyoqXG4gICAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAqL1xuICBmdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICAgIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gICAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgICBpZiAoaXNOZXcpIHtcbiAgICAgICAgX2Jhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2Fzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICB2YXIgX2NvcHlPYmplY3QgPSBjb3B5T2JqZWN0O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IFV0aWxcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgKlxuICAgKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gICAqIC8vID0+IHRydWVcbiAgICovXG4gIGZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgdmFyIGlkZW50aXR5XzEgPSBpZGVudGl0eTtcblxuICAvKipcbiAgICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9XG5cbiAgdmFyIF9hcHBseSA9IGFwcGx5O1xuXG4gIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbiAgdmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICAgIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyBmdW5jLmxlbmd0aCAtIDEgOiBzdGFydCwgMCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICAgIH1cbiAgICAgIGluZGV4ID0gLTE7XG4gICAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgICAgfVxuICAgICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgICByZXR1cm4gX2FwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBfb3ZlclJlc3QgPSBvdmVyUmVzdDtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAyLjQuMFxuICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICAgKlxuICAgKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAgICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gICAqXG4gICAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuICBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBjb25zdGFudF8xID0gY29uc3RhbnQ7XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgKi9cbiAgdmFyIGJhc2VTZXRUb1N0cmluZyA9ICFfZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eV8xIDogZnVuY3Rpb24gKGZ1bmMsIHN0cmluZykge1xuICAgIHJldHVybiBfZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICAgJ3ZhbHVlJzogY29uc3RhbnRfMShzdHJpbmcpLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBfYmFzZVNldFRvU3RyaW5nID0gYmFzZVNldFRvU3RyaW5nO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbiAgdmFyIEhPVF9DT1VOVCA9IDgwMDtcbiAgdmFyIEhPVF9TUEFOID0gMTY7XG5cbiAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuICB2YXIgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICAgKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAgICogbWlsbGlzZWNvbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICAgIHZhciBjb3VudCA9IDAsXG4gICAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvdW50ID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIF9zaG9ydE91dCA9IHNob3J0T3V0O1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAqL1xuICB2YXIgc2V0VG9TdHJpbmcgPSBfc2hvcnRPdXQoX2Jhc2VTZXRUb1N0cmluZyk7XG5cbiAgdmFyIF9zZXRUb1N0cmluZyA9IHNldFRvU3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICAgIHJldHVybiBfc2V0VG9TdHJpbmcoX292ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eV8xKSwgZnVuYyArICcnKTtcbiAgfVxuXG4gIHZhciBfYmFzZVJlc3QgPSBiYXNlUmVzdDtcblxuICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbiAgdmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICAgKlxuICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc0xlbmd0aCgzKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogXy5pc0xlbmd0aCgnMycpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbiAgfVxuXG4gIHZhciBpc0xlbmd0aF8xID0gaXNMZW5ndGg7XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAgICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICAgKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuICBmdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoXzEodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbl8xKHZhbHVlKTtcbiAgfVxuXG4gIHZhciBpc0FycmF5TGlrZV8xID0gaXNBcnJheUxpa2U7XG5cbiAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG4gIHZhciBNQVhfU0FGRV9JTlRFR0VSJDEgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIkMSA6IGxlbmd0aDtcbiAgICByZXR1cm4gISFsZW5ndGggJiYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aDtcbiAgfVxuXG4gIHZhciBfaXNJbmRleCA9IGlzSW5kZXg7XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAgICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAgICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gICAqICBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgIGlmICghaXNPYmplY3RfMShvYmplY3QpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZjIoaW5kZXgpO1xuICAgIGlmICh0eXBlID09ICdudW1iZXInID8gaXNBcnJheUxpa2VfMShvYmplY3QpICYmIF9pc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSA6IHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KSB7XG4gICAgICByZXR1cm4gZXFfMShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBfaXNJdGVyYXRlZUNhbGwgPSBpc0l0ZXJhdGVlQ2FsbDtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgICByZXR1cm4gX2Jhc2VSZXN0KGZ1bmN0aW9uIChvYmplY3QsIHNvdXJjZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICBjdXN0b21pemVyID0gYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGd1YXJkICYmIF9pc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIF9jcmVhdGVBc3NpZ25lciA9IGNyZWF0ZUFzc2lnbmVyO1xuXG4gIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIG9iamVjdFByb3RvJDUgPSBPYmplY3QucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gICAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgICAgcHJvdG8gPSB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlIHx8IG9iamVjdFByb3RvJDU7XG5cbiAgICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xuICB9XG5cbiAgdmFyIF9pc1Byb3RvdHlwZSA9IGlzUHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gICAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgX2Jhc2VUaW1lcyA9IGJhc2VUaW1lcztcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gICAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YyKHZhbHVlKSkgPT0gJ29iamVjdCc7XG4gIH1cblxuICB2YXIgaXNPYmplY3RMaWtlXzEgPSBpc09iamVjdExpa2U7XG5cbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuICB2YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgICByZXR1cm4gaXNPYmplY3RMaWtlXzEodmFsdWUpICYmIF9iYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xuICB9XG5cbiAgdmFyIF9iYXNlSXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHM7XG5cbiAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICB2YXIgb2JqZWN0UHJvdG8kNyA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gIHZhciBoYXNPd25Qcm9wZXJ0eSQ1ID0gb2JqZWN0UHJvdG8kNy5oYXNPd25Qcm9wZXJ0eTtcblxuICAvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8kNy5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuICB2YXIgaXNBcmd1bWVudHMgPSBfYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzO1xuICB9KCkpID8gX2Jhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBpc09iamVjdExpa2VfMSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkkNS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiYgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbiAgfTtcblxuICB2YXIgaXNBcmd1bWVudHNfMSA9IGlzQXJndW1lbnRzO1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzQXJyYXkoJ2FiYycpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuICB2YXIgaXNBcnJheV8xID0gaXNBcnJheTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSA0LjEzLjBcbiAgICogQGNhdGVnb3J5IFV0aWxcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gICAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gICAqL1xuICBmdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHN0dWJGYWxzZV8xID0gc3R1YkZhbHNlO1xuXG4gIHZhciBpc0J1ZmZlcl8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAgIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG4gICAgdmFyIGZyZWVFeHBvcnRzID0gJ29iamVjdCcgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gICAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xuICAgIHZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgJ29iamVjdCcgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4gICAgLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbiAgICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuICAgIC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gX3Jvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4gICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuICAgIHZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlXzE7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuICB9KTtcblxuICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG4gIHZhciBhcmdzVGFnJDEgPSAnW29iamVjdCBBcmd1bWVudHNdJztcbiAgdmFyIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJztcbiAgdmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXSc7XG4gIHZhciBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nO1xuICB2YXIgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nO1xuICB2YXIgZnVuY1RhZyQxID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgdmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nO1xuICB2YXIgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXSc7XG4gIHZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcbiAgdmFyIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nO1xuICB2YXIgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG4gIHZhciBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJztcbiAgdmFyIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbiAgdmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbiAgdmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcbiAgdmFyIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJztcbiAgdmFyIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJztcbiAgdmFyIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJztcbiAgdmFyIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nO1xuICB2YXIgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XSc7XG4gIHZhciB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJztcbiAgdmFyIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSc7XG4gIHZhciB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nO1xuICB2YXIgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG4gIHZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xuICB0eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuICB0eXBlZEFycmF5VGFnc1thcmdzVGFnJDFdID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWckMV0gPSB0eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID0gdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPSB0eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBpc09iamVjdExpa2VfMSh2YWx1ZSkgJiYgaXNMZW5ndGhfMSh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbX2Jhc2VHZXRUYWcodmFsdWUpXTtcbiAgfVxuXG4gIHZhciBfYmFzZUlzVHlwZWRBcnJheSA9IGJhc2VJc1R5cGVkQXJyYXk7XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIF9iYXNlVW5hcnkgPSBiYXNlVW5hcnk7XG5cbiAgdmFyIF9ub2RlVXRpbCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xuICAgIHZhciBmcmVlRXhwb3J0cyA9ICdvYmplY3QnID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAgIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbiAgICB2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmICdvYmplY3QnID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuICAgIC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG4gICAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbiAgICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbiAgICB2YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIF9mcmVlR2xvYmFsLnByb2Nlc3M7XG5cbiAgICAvKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbiAgICB2YXIgbm9kZVV0aWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH0oKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gbm9kZVV0aWw7XG4gIH0pO1xuXG4gIC8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG4gIHZhciBub2RlSXNUeXBlZEFycmF5ID0gX25vZGVVdGlsICYmIF9ub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMy4wLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIHZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gX2Jhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IF9iYXNlSXNUeXBlZEFycmF5O1xuXG4gIHZhciBpc1R5cGVkQXJyYXlfMSA9IGlzVHlwZWRBcnJheTtcblxuICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gIHZhciBvYmplY3RQcm90byQ2ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbiAgdmFyIGhhc093blByb3BlcnR5JDQgPSBvYmplY3RQcm90byQ2Lmhhc093blByb3BlcnR5O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgICB2YXIgaXNBcnIgPSBpc0FycmF5XzEodmFsdWUpLFxuICAgICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50c18xKHZhbHVlKSxcbiAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcl8xKHZhbHVlKSxcbiAgICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheV8xKHZhbHVlKSxcbiAgICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IF9iYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5JDQuY2FsbCh2YWx1ZSwga2V5KSkgJiYgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSB8fFxuICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSB8fFxuICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgX2lzSW5kZXgoa2V5LCBsZW5ndGgpKSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBfYXJyYXlMaWtlS2V5cyA9IGFycmF5TGlrZUtleXM7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBfb3ZlckFyZyA9IG92ZXJBcmc7XG5cbiAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuICB2YXIgbmF0aXZlS2V5cyA9IF9vdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG4gIHZhciBfbmF0aXZlS2V5cyA9IG5hdGl2ZUtleXM7XG5cbiAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICB2YXIgb2JqZWN0UHJvdG8kOCA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gIHZhciBoYXNPd25Qcm9wZXJ0eSQ2ID0gb2JqZWN0UHJvdG8kOC5oYXNPd25Qcm9wZXJ0eTtcblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgICBpZiAoIV9pc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgICByZXR1cm4gX25hdGl2ZUtleXMob2JqZWN0KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5JDYuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBfYmFzZUtleXMgPSBiYXNlS2V5cztcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAqXG4gICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gICAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICogICB0aGlzLmEgPSAxO1xuICAgKiAgIHRoaXMuYiA9IDI7XG4gICAqIH1cbiAgICpcbiAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICpcbiAgICogXy5rZXlzKG5ldyBGb28pO1xuICAgKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAqXG4gICAqIF8ua2V5cygnaGknKTtcbiAgICogLy8gPT4gWycwJywgJzEnXVxuICAgKi9cbiAgZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICByZXR1cm4gaXNBcnJheUxpa2VfMShvYmplY3QpID8gX2FycmF5TGlrZUtleXMob2JqZWN0KSA6IF9iYXNlS2V5cyhvYmplY3QpO1xuICB9XG5cbiAgdmFyIGtleXNfMSA9IGtleXM7XG5cbiAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4gIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvKipcbiAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGVcbiAgICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAqIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAgICpcbiAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAgYW5kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICogW2BPYmplY3QuYXNzaWduYF0oaHR0cHM6Ly9tZG4uaW8vT2JqZWN0L2Fzc2lnbikuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDAuMTAuMFxuICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAqIEBzZWUgXy5hc3NpZ25JblxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAqICAgdGhpcy5hID0gMTtcbiAgICogfVxuICAgKlxuICAgKiBmdW5jdGlvbiBCYXIoKSB7XG4gICAqICAgdGhpcy5jID0gMztcbiAgICogfVxuICAgKlxuICAgKiBGb28ucHJvdG90eXBlLmIgPSAyO1xuICAgKiBCYXIucHJvdG90eXBlLmQgPSA0O1xuICAgKlxuICAgKiBfLmFzc2lnbih7ICdhJzogMCB9LCBuZXcgRm9vLCBuZXcgQmFyKTtcbiAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAqL1xuICB2YXIgYXNzaWduID0gX2NyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uIChvYmplY3QsIHNvdXJjZSkge1xuICAgIGlmIChfaXNQcm90b3R5cGUoc291cmNlKSB8fCBpc0FycmF5TGlrZV8xKHNvdXJjZSkpIHtcbiAgICAgIF9jb3B5T2JqZWN0KHNvdXJjZSwga2V5c18xKHNvdXJjZSksIG9iamVjdCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICBfYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBhc3NpZ25fMSQxID0gYXNzaWduO1xuXG4gIC8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuICAvL1xuICAvLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICAvLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4gIC8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICAvLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gIC8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbiAgLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4gIC8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAvL1xuICAvLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICAvLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgLy9cbiAgLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICAvLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIC8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbiAgLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4gIC8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuICAvLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4gIC8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuICAvLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4gIC8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuICBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eSQ3KG9iaiwgcHJvcCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbiAgfVxuICB2YXIgaXNBcnJheSQyID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcbiAgZnVuY3Rpb24gc3RyaW5naWZ5UHJpbWl0aXZlKHYpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiB2ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZjIodikpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHJldHVybiB2O1xuXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdpZnkob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gICAgc2VwID0gc2VwIHx8ICcmJztcbiAgICBlcSA9IGVxIHx8ICc9JztcbiAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICBvYmogPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKCh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZjIob2JqKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24gKGspIHtcbiAgICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgICAgaWYgKGlzQXJyYXkkMihvYmpba10pKSB7XG4gICAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgICAgfVxuICAgICAgfSkuam9pbihzZXApO1xuICAgIH1cblxuICAgIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcCh4cywgZikge1xuICAgIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIHZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZSQyKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gICAgc2VwID0gc2VwIHx8ICcmJztcbiAgICBlcSA9IGVxIHx8ICc9JztcbiAgICB2YXIgb2JqID0ge307XG5cbiAgICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgICAgbGVuID0gbWF4S2V5cztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAgICBrc3RyLFxuICAgICAgICAgIHZzdHIsXG4gICAgICAgICAgayxcbiAgICAgICAgICB2O1xuXG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtzdHIgPSB4O1xuICAgICAgICB2c3RyID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgICBpZiAoIWhhc093blByb3BlcnR5JDcob2JqLCBrKSkge1xuICAgICAgICBvYmpba10gPSB2O1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5JDIob2JqW2tdKSkge1xuICAgICAgICBvYmpba10ucHVzaCh2KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgdmFyIHF1ZXJ5c3RyaW5nID0ge1xuICAgIGVuY29kZTogc3RyaW5naWZ5LFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5LFxuICAgIGRlY29kZTogcGFyc2UkMixcbiAgICBwYXJzZTogcGFyc2UkMlxuICB9O1xuXG4gIC8qXG4gICAqIFNpbXBsZSBBSkFYIHJlcXVlc3Qgb2JqZWN0XG4gICAqL1xuICB2YXIgUmVxdWVzdCA9IGZ1bmN0aW9uIFJlcXVlc3QodXJsLCBkYXRhKSB7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5kYXRhID0gZGF0YSB8fCB7fTtcbiAgfTtcblxuICBSZXF1ZXN0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIGlzSUUgPSB3aW5kb3cuWERvbWFpblJlcXVlc3QgPyB0cnVlIDogZmFsc2U7XG4gICAgaWYgKGlzSUUpIHtcbiAgICAgIHZhciB4ZHIgPSBuZXcgd2luZG93LlhEb21haW5SZXF1ZXN0KCk7XG4gICAgICB4ZHIub3BlbignUE9TVCcsIHRoaXMudXJsLCB0cnVlKTtcbiAgICAgIHhkci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKDIwMCwgeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgICB9O1xuICAgICAgeGRyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHN0YXR1cyBjb2RlIG5vdCBhdmFpbGFibGUgZnJvbSB4ZHIsIHRyeSBzdHJpbmcgbWF0Y2hpbmcgb24gcmVzcG9uc2VUZXh0XG4gICAgICAgIGlmICh4ZHIucmVzcG9uc2VUZXh0ID09PSAnUmVxdWVzdCBFbnRpdHkgVG9vIExhcmdlJykge1xuICAgICAgICAgIGNhbGxiYWNrKDQxMywgeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2soNTAwLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHhkci5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIHhkci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge307XG4gICAgICB4ZHIuc2VuZChxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5kYXRhKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHhoci5vcGVuKCdQT1NUJywgdGhpcy51cmwsIHRydWUpO1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgY2FsbGJhY2soeGhyLnN0YXR1cywgeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOCcpO1xuICAgICAgeGhyLnNlbmQocXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMuZGF0YSkpO1xuICAgIH1cbiAgICAvL2xvZygnc2VudCByZXF1ZXN0IHRvICcgKyB0aGlzLnVybCArICcgd2l0aCBkYXRhICcgKyBkZWNvZGVVUklDb21wb25lbnQocXVlcnlTdHJpbmcodGhpcy5kYXRhKSkpO1xuICB9O1xuXG4gIC8qXG4gICAqIFdyYXBwZXIgZm9yIGxvZ2dpbmcgUmV2ZW51ZSBkYXRhLiBSZXZlbnVlIG9iamVjdHMgZ2V0IHBhc3NlZCB0byBhbXBsaXR1ZGUubG9nUmV2ZW51ZVYyIHRvIHNlbmQgdG8gQW1wbGl0dWRlIHNlcnZlcnMuXG4gICAqIE5vdGU6IHByaWNlIGlzIHRoZSBvbmx5IHJlcXVpcmVkIGZpZWxkLiBJZiBxdWFudGl0eSBpcyBub3Qgc3BlY2lmaWVkLCB0aGVuIGRlZmF1bHRzIHRvIDEuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXZlbnVlIEFQSSAtIGluc3RhbmNlIGNvbnN0cnVjdG9yLiBSZXZlbnVlIG9iamVjdHMgYXJlIGEgd3JhcHBlciBmb3IgcmV2ZW51ZSBkYXRhLlxuICAgKiBFYWNoIG1ldGhvZCB1cGRhdGVzIGEgcmV2ZW51ZSBwcm9wZXJ0eSBpbiB0aGUgUmV2ZW51ZSBvYmplY3QsIGFuZCByZXR1cm5zIHRoZSBzYW1lIFJldmVudWUgb2JqZWN0LFxuICAgKiBhbGxvd2luZyB5b3UgdG8gY2hhaW4gbXVsdGlwbGUgbWV0aG9kIGNhbGxzIHRvZ2V0aGVyLlxuICAgKiBOb3RlOiBwcmljZSBpcyBhIHJlcXVpcmVkIGZpZWxkIHRvIGxvZyByZXZlbnVlIGV2ZW50cy5cbiAgICogSWYgcXVhbnRpdHkgaXMgbm90IHNwZWNpZmllZCB0aGVuIGRlZmF1bHRzIHRvIDEuXG4gICAqIFNlZSBbUmVhZG1lXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vYW1wbGl0dWRlL0FtcGxpdHVkZS1KYXZhc2NyaXB0I3RyYWNraW5nLXJldmVudWV9IGZvciBtb3JlIGluZm9ybWF0aW9uXG4gICAqIGFib3V0IGxvZ2dpbmcgUmV2ZW51ZS5cbiAgICogQGNvbnN0cnVjdG9yIFJldmVudWVcbiAgICogQHB1YmxpY1xuICAgKiBAZXhhbXBsZSB2YXIgcmV2ZW51ZSA9IG5ldyBhbXBsaXR1ZGUuUmV2ZW51ZSgpO1xuICAgKi9cbiAgdmFyIFJldmVudWUgPSBmdW5jdGlvbiBSZXZlbnVlKCkge1xuICAgIC8vIHJlcXVpcmVkIGZpZWxkc1xuICAgIHRoaXMuX3ByaWNlID0gbnVsbDtcblxuICAgIC8vIG9wdGlvbmFsIGZpZWxkc1xuICAgIHRoaXMuX3Byb2R1Y3RJZCA9IG51bGw7XG4gICAgdGhpcy5fcXVhbnRpdHkgPSAxO1xuICAgIHRoaXMuX3JldmVudWVUeXBlID0gbnVsbDtcbiAgICB0aGlzLl9wcm9wZXJ0aWVzID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGEgdmFsdWUgZm9yIHRoZSBwcm9kdWN0IGlkZW50aWZlci5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvZHVjdElkIC0gVGhlIHZhbHVlIGZvciB0aGUgcHJvZHVjdCBpZGVudGlmaWVyLiBFbXB0eSBhbmQgaW52YWxpZCBzdHJpbmdzIGFyZSBpZ25vcmVkLlxuICAgKiBAcmV0dXJuIHtSZXZlbnVlfSBSZXR1cm5zIHRoZSBzYW1lIFJldmVudWUgb2JqZWN0LCBhbGxvd2luZyB5b3UgdG8gY2hhaW4gbXVsdGlwbGUgbWV0aG9kIGNhbGxzIHRvZ2V0aGVyLlxuICAgKiBAZXhhbXBsZSB2YXIgcmV2ZW51ZSA9IG5ldyBhbXBsaXR1ZGUuUmV2ZW51ZSgpLnNldFByb2R1Y3RJZCgncHJvZHVjdElkZW50aWZpZXInKS5zZXRQcmljZSgxMC45OSk7XG4gICAqIGFtcGxpdHVkZS5sb2dSZXZlbnVlVjIocmV2ZW51ZSk7XG4gICAqL1xuICBSZXZlbnVlLnByb3RvdHlwZS5zZXRQcm9kdWN0SWQgPSBmdW5jdGlvbiBzZXRQcm9kdWN0SWQocHJvZHVjdElkKSB7XG4gICAgaWYgKHR5cGUocHJvZHVjdElkKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHV0aWxzLmxvZy5lcnJvcignVW5zdXBwb3J0ZWQgdHlwZSBmb3IgcHJvZHVjdElkOiAnICsgdHlwZShwcm9kdWN0SWQpICsgJywgZXhwZWN0aW5nIHN0cmluZycpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNFbXB0eVN0cmluZyhwcm9kdWN0SWQpKSB7XG4gICAgICB1dGlscy5sb2cuZXJyb3IoJ0ludmFsaWQgZW1wdHkgcHJvZHVjdElkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Byb2R1Y3RJZCA9IHByb2R1Y3RJZDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhIHZhbHVlIGZvciB0aGUgcXVhbnRpdHkuIE5vdGUgcmV2ZW51ZSBhbW91bnQgaXMgY2FsY3VsYXRlZCBhcyBwcmljZSAqIHF1YW50aXR5LlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBxdWFudGl0eSAtIEludGVnZXIgdmFsdWUgZm9yIHRoZSBxdWFudGl0eS4gSWYgbm90IHNldCwgcXVhbnRpdHkgZGVmYXVsdHMgdG8gMS5cbiAgICogQHJldHVybiB7UmV2ZW51ZX0gUmV0dXJucyB0aGUgc2FtZSBSZXZlbnVlIG9iamVjdCwgYWxsb3dpbmcgeW91IHRvIGNoYWluIG11bHRpcGxlIG1ldGhvZCBjYWxscyB0b2dldGhlci5cbiAgICogQGV4YW1wbGUgdmFyIHJldmVudWUgPSBuZXcgYW1wbGl0dWRlLlJldmVudWUoKS5zZXRQcm9kdWN0SWQoJ3Byb2R1Y3RJZGVudGlmaWVyJykuc2V0UHJpY2UoMTAuOTkpLnNldFF1YW50aXR5KDUpO1xuICAgKiBhbXBsaXR1ZGUubG9nUmV2ZW51ZVYyKHJldmVudWUpO1xuICAgKi9cbiAgUmV2ZW51ZS5wcm90b3R5cGUuc2V0UXVhbnRpdHkgPSBmdW5jdGlvbiBzZXRRdWFudGl0eShxdWFudGl0eSkge1xuICAgIGlmICh0eXBlKHF1YW50aXR5KSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHV0aWxzLmxvZy5lcnJvcignVW5zdXBwb3J0ZWQgdHlwZSBmb3IgcXVhbnRpdHk6ICcgKyB0eXBlKHF1YW50aXR5KSArICcsIGV4cGVjdGluZyBudW1iZXInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcXVhbnRpdHkgPSBwYXJzZUludChxdWFudGl0eSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYSB2YWx1ZSBmb3IgdGhlIHByaWNlLiBUaGlzIGZpZWxkIGlzIHJlcXVpcmVkIGZvciBhbGwgcmV2ZW51ZSBiZWluZyBsb2dnZWQuXG4gICAqIE5vdGUgcmV2ZW51ZSBhbW91bnQgaXMgY2FsY3VsYXRlZCBhcyBwcmljZSAqIHF1YW50aXR5LlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwcmljZSAtIERvdWJsZSB2YWx1ZSBmb3IgdGhlIHF1YW50aXR5LlxuICAgKiBAcmV0dXJuIHtSZXZlbnVlfSBSZXR1cm5zIHRoZSBzYW1lIFJldmVudWUgb2JqZWN0LCBhbGxvd2luZyB5b3UgdG8gY2hhaW4gbXVsdGlwbGUgbWV0aG9kIGNhbGxzIHRvZ2V0aGVyLlxuICAgKiBAZXhhbXBsZSB2YXIgcmV2ZW51ZSA9IG5ldyBhbXBsaXR1ZGUuUmV2ZW51ZSgpLnNldFByb2R1Y3RJZCgncHJvZHVjdElkZW50aWZpZXInKS5zZXRQcmljZSgxMC45OSk7XG4gICAqIGFtcGxpdHVkZS5sb2dSZXZlbnVlVjIocmV2ZW51ZSk7XG4gICAqL1xuICBSZXZlbnVlLnByb3RvdHlwZS5zZXRQcmljZSA9IGZ1bmN0aW9uIHNldFByaWNlKHByaWNlKSB7XG4gICAgaWYgKHR5cGUocHJpY2UpICE9PSAnbnVtYmVyJykge1xuICAgICAgdXRpbHMubG9nLmVycm9yKCdVbnN1cHBvcnRlZCB0eXBlIGZvciBwcmljZTogJyArIHR5cGUocHJpY2UpICsgJywgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wcmljZSA9IHByaWNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGEgdmFsdWUgZm9yIHRoZSByZXZlbnVlVHlwZSAoZm9yIGV4YW1wbGUgcHVyY2hhc2UsIGNvc3QsIHRheCwgcmVmdW5kLCBldGMpLlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZXZlbnVlVHlwZSAtIFJldmVudWVUeXBlIHRvIGRlc2lnbmF0ZS5cbiAgICogQHJldHVybiB7UmV2ZW51ZX0gUmV0dXJucyB0aGUgc2FtZSBSZXZlbnVlIG9iamVjdCwgYWxsb3dpbmcgeW91IHRvIGNoYWluIG11bHRpcGxlIG1ldGhvZCBjYWxscyB0b2dldGhlci5cbiAgICogQGV4YW1wbGUgdmFyIHJldmVudWUgPSBuZXcgYW1wbGl0dWRlLlJldmVudWUoKS5zZXRQcm9kdWN0SWQoJ3Byb2R1Y3RJZGVudGlmaWVyJykuc2V0UHJpY2UoMTAuOTkpLnNldFJldmVudWVUeXBlKCdwdXJjaGFzZScpO1xuICAgKiBhbXBsaXR1ZGUubG9nUmV2ZW51ZVYyKHJldmVudWUpO1xuICAgKi9cbiAgUmV2ZW51ZS5wcm90b3R5cGUuc2V0UmV2ZW51ZVR5cGUgPSBmdW5jdGlvbiBzZXRSZXZlbnVlVHlwZShyZXZlbnVlVHlwZSkge1xuICAgIGlmICh0eXBlKHJldmVudWVUeXBlKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHV0aWxzLmxvZy5lcnJvcignVW5zdXBwb3J0ZWQgdHlwZSBmb3IgcmV2ZW51ZVR5cGU6ICcgKyB0eXBlKHJldmVudWVUeXBlKSArICcsIGV4cGVjdGluZyBzdHJpbmcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmV2ZW51ZVR5cGUgPSByZXZlbnVlVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBldmVudCBwcm9wZXJ0aWVzIGZvciB0aGUgcmV2ZW51ZSBldmVudC5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnRQcm9wZXJ0aWVzIC0gUmV2ZW51ZSBldmVudCBwcm9wZXJ0aWVzIHRvIHNldC5cbiAgICogQHJldHVybiB7UmV2ZW51ZX0gUmV0dXJucyB0aGUgc2FtZSBSZXZlbnVlIG9iamVjdCwgYWxsb3dpbmcgeW91IHRvIGNoYWluIG11bHRpcGxlIG1ldGhvZCBjYWxscyB0b2dldGhlci5cbiAgICogQGV4YW1wbGUgdmFyIGV2ZW50X3Byb3BlcnRpZXMgPSB7J2NpdHknOiAnU2FuIEZyYW5jaXNjbyd9O1xuICAgKiB2YXIgcmV2ZW51ZSA9IG5ldyBhbXBsaXR1ZGUuUmV2ZW51ZSgpLnNldFByb2R1Y3RJZCgncHJvZHVjdElkZW50aWZpZXInKS5zZXRQcmljZSgxMC45OSkuc2V0RXZlbnRQcm9wZXJ0aWVzKGV2ZW50X3Byb3BlcnRpZXMpO1xuICAgKiBhbXBsaXR1ZGUubG9nUmV2ZW51ZVYyKHJldmVudWUpO1xuICAqL1xuICBSZXZlbnVlLnByb3RvdHlwZS5zZXRFdmVudFByb3BlcnRpZXMgPSBmdW5jdGlvbiBzZXRFdmVudFByb3BlcnRpZXMoZXZlbnRQcm9wZXJ0aWVzKSB7XG4gICAgaWYgKHR5cGUoZXZlbnRQcm9wZXJ0aWVzKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHV0aWxzLmxvZy5lcnJvcignVW5zdXBwb3J0ZWQgdHlwZSBmb3IgZXZlbnRQcm9wZXJ0aWVzOiAnICsgdHlwZShldmVudFByb3BlcnRpZXMpICsgJywgZXhwZWN0aW5nIG9iamVjdCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gdXRpbHMudmFsaWRhdGVQcm9wZXJ0aWVzKGV2ZW50UHJvcGVydGllcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUmV2ZW51ZS5wcm90b3R5cGUuX2lzVmFsaWRSZXZlbnVlID0gZnVuY3Rpb24gX2lzVmFsaWRSZXZlbnVlKCkge1xuICAgIGlmICh0eXBlKHRoaXMuX3ByaWNlKSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHV0aWxzLmxvZy5lcnJvcignSW52YWxpZCByZXZlbnVlLCBuZWVkIHRvIHNldCBwcmljZSBmaWVsZCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJldmVudWUucHJvdG90eXBlLl90b0pTT05PYmplY3QgPSBmdW5jdGlvbiBfdG9KU09OT2JqZWN0KCkge1xuICAgIHZhciBvYmogPSB0eXBlKHRoaXMuX3Byb3BlcnRpZXMpID09PSAnb2JqZWN0JyA/IHRoaXMuX3Byb3BlcnRpZXMgOiB7fTtcblxuICAgIGlmICh0aGlzLl9wcm9kdWN0SWQgIT09IG51bGwpIHtcbiAgICAgIG9ialtjb25zdGFudHMuUkVWRU5VRV9QUk9EVUNUX0lEXSA9IHRoaXMuX3Byb2R1Y3RJZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3F1YW50aXR5ICE9PSBudWxsKSB7XG4gICAgICBvYmpbY29uc3RhbnRzLlJFVkVOVUVfUVVBTlRJVFldID0gdGhpcy5fcXVhbnRpdHk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9wcmljZSAhPT0gbnVsbCkge1xuICAgICAgb2JqW2NvbnN0YW50cy5SRVZFTlVFX1BSSUNFXSA9IHRoaXMuX3ByaWNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcmV2ZW51ZVR5cGUgIT09IG51bGwpIHtcbiAgICAgIG9ialtjb25zdGFudHMuUkVWRU5VRV9SRVZFTlVFX1RZUEVdID0gdGhpcy5fcmV2ZW51ZVR5cGU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgdmFyIHVhUGFyc2VyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAgIC8qIGpzaGludCBlcWVxZXE6IGZhbHNlLCBmb3JpbjogZmFsc2UgKi9cbiAgICAvKiBnbG9iYWwgZGVmaW5lICovXG5cbiAgICAvKipcbiAgICAgKiBVQVBhcnNlci5qcyB2MC43LjEwXG4gICAgICogTGlnaHR3ZWlnaHQgSmF2YVNjcmlwdC1iYXNlZCBVc2VyLUFnZW50IHN0cmluZyBwYXJzZXJcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vZmFpc2FsbWFuL3VhLXBhcnNlci1qc1xuICAgICAqXG4gICAgICogQ29weXJpZ2h0IMKpIDIwMTItMjAxNSBGYWlzYWwgU2FsbWFuIDxmeXpsbWFuQGdtYWlsLmNvbT5cbiAgICAgKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIEdQTHYyICYgTUlUXG4gICAgICovXG5cbiAgICAoZnVuY3Rpb24gKHdpbmRvdywgdW5kZWZpbmVkKSB7XG5cbiAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgLy8vLy8vLy8vLy8vLy9cbiAgICAgIC8vIENvbnN0YW50c1xuICAgICAgLy8vLy8vLy8vLy8vL1xuXG5cbiAgICAgIHZhciBMSUJWRVJTSU9OID0gJzAuNy4xMCcsXG4gICAgICAgICAgRU1QVFkgPSAnJyxcbiAgICAgICAgICBVTktOT1dOID0gJz8nLFxuICAgICAgICAgIEZVTkNfVFlQRSA9ICdmdW5jdGlvbicsXG4gICAgICAgICAgVU5ERUZfVFlQRSA9ICd1bmRlZmluZWQnLFxuICAgICAgICAgIE9CSl9UWVBFID0gJ29iamVjdCcsXG4gICAgICAgICAgU1RSX1RZUEUgPSAnc3RyaW5nJyxcbiAgICAgICAgICBNQUpPUiA9ICdtYWpvcicsXG4gICAgICAgICAgLy8gZGVwcmVjYXRlZFxuICAgICAgTU9ERUwgPSAnbW9kZWwnLFxuICAgICAgICAgIE5BTUUgPSAnbmFtZScsXG4gICAgICAgICAgVFlQRSA9ICd0eXBlJyxcbiAgICAgICAgICBWRU5ET1IgPSAndmVuZG9yJyxcbiAgICAgICAgICBWRVJTSU9OID0gJ3ZlcnNpb24nLFxuICAgICAgICAgIEFSQ0hJVEVDVFVSRSA9ICdhcmNoaXRlY3R1cmUnLFxuICAgICAgICAgIENPTlNPTEUgPSAnY29uc29sZScsXG4gICAgICAgICAgTU9CSUxFID0gJ21vYmlsZScsXG4gICAgICAgICAgVEFCTEVUID0gJ3RhYmxldCcsXG4gICAgICAgICAgU01BUlRUViA9ICdzbWFydHR2JyxcbiAgICAgICAgICBXRUFSQUJMRSA9ICd3ZWFyYWJsZScsXG4gICAgICAgICAgRU1CRURERUQgPSAnZW1iZWRkZWQnO1xuXG4gICAgICAvLy8vLy8vLy8vL1xuICAgICAgLy8gSGVscGVyXG4gICAgICAvLy8vLy8vLy8vXG5cblxuICAgICAgdmFyIHV0aWwgPSB7XG4gICAgICAgIGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKHJlZ2V4ZXMsIGV4dGVuc2lvbnMpIHtcbiAgICAgICAgICB2YXIgbWFyZ2VkUmVnZXhlcyA9IHt9O1xuICAgICAgICAgIGZvciAodmFyIGkgaW4gcmVnZXhlcykge1xuICAgICAgICAgICAgaWYgKGV4dGVuc2lvbnNbaV0gJiYgZXh0ZW5zaW9uc1tpXS5sZW5ndGggJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgIG1hcmdlZFJlZ2V4ZXNbaV0gPSBleHRlbnNpb25zW2ldLmNvbmNhdChyZWdleGVzW2ldKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hcmdlZFJlZ2V4ZXNbaV0gPSByZWdleGVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWFyZ2VkUmVnZXhlcztcbiAgICAgICAgfSxcbiAgICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoc3RyMSwgc3RyMikge1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RyMSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHN0cjIudG9Mb3dlckNhc2UoKS5pbmRleE9mKHN0cjEudG9Mb3dlckNhc2UoKSkgIT09IC0xO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsb3dlcml6ZTogZnVuY3Rpb24gbG93ZXJpemUoc3RyKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9LFxuICAgICAgICBtYWpvcjogZnVuY3Rpb24gbWFqb3IodmVyc2lvbikge1xuICAgICAgICAgIHJldHVybiAodHlwZW9mIHZlcnNpb24gPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mMih2ZXJzaW9uKSkgPT09IFNUUl9UWVBFID8gdmVyc2lvbi5zcGxpdChcIi5cIilbMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vLy8vLy8vLy8vLy8vL1xuICAgICAgLy8gTWFwIGhlbHBlclxuICAgICAgLy8vLy8vLy8vLy8vLy9cblxuXG4gICAgICB2YXIgbWFwcGVyID0ge1xuXG4gICAgICAgIHJneDogZnVuY3Rpb24gcmd4KCkge1xuXG4gICAgICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgIGosXG4gICAgICAgICAgICAgIGssXG4gICAgICAgICAgICAgIHAsXG4gICAgICAgICAgICAgIHEsXG4gICAgICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGFsbCByZWdleGVzIG1hcHNcbiAgICAgICAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoICYmICFtYXRjaGVzKSB7XG5cbiAgICAgICAgICAgIHZhciByZWdleCA9IGFyZ3NbaV0sXG4gICAgICAgICAgICAgICAgLy8gZXZlbiBzZXF1ZW5jZSAoMCwyLDQsLi4pXG4gICAgICAgICAgICBwcm9wcyA9IGFyZ3NbaSArIDFdOyAvLyBvZGQgc2VxdWVuY2UgKDEsMyw1LC4uKVxuXG4gICAgICAgICAgICAvLyBjb25zdHJ1Y3Qgb2JqZWN0IGJhcmVib25lc1xuICAgICAgICAgICAgaWYgKCh0eXBlb2YgcmVzdWx0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZjIocmVzdWx0KSkgPT09IFVOREVGX1RZUEUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0ge307XG4gICAgICAgICAgICAgIGZvciAocCBpbiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgICAgICAgICAgcSA9IHByb3BzW3BdO1xuICAgICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YgcSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YyKHEpKSA9PT0gT0JKX1RZUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3FbMF1dID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3FdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0cnkgbWF0Y2hpbmcgdWFzdHJpbmcgd2l0aCByZWdleGVzXG4gICAgICAgICAgICBqID0gayA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaiA8IHJlZ2V4Lmxlbmd0aCAmJiAhbWF0Y2hlcykge1xuICAgICAgICAgICAgICBtYXRjaGVzID0gcmVnZXhbaisrXS5leGVjKHRoaXMuZ2V0VUEoKSk7XG4gICAgICAgICAgICAgIGlmICghIW1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHAgPSAwOyBwIDwgcHJvcHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoID0gbWF0Y2hlc1srK2tdO1xuICAgICAgICAgICAgICAgICAgcSA9IHByb3BzW3BdO1xuICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZ2l2ZW4gcHJvcGVydHkgaXMgYWN0dWFsbHkgYXJyYXlcbiAgICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIHEgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mMihxKSkgPT09IE9CSl9UWVBFICYmIHEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocS5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChfdHlwZW9mMihxWzFdKSA9PSBGVU5DX1RZUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzc2lnbiBtb2RpZmllZCBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3FbMF1dID0gcVsxXS5jYWxsKHRoaXMsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXNzaWduIGdpdmVuIHZhbHVlLCBpZ25vcmUgcmVnZXggbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtxWzBdXSA9IHFbMV07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHEubGVuZ3RoID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB3aGV0aGVyIGZ1bmN0aW9uIG9yIHJlZ2V4XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKF90eXBlb2YyKHFbMV0pID09PSBGVU5DX1RZUEUgJiYgIShxWzFdLmV4ZWMgJiYgcVsxXS50ZXN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCBmdW5jdGlvbiAodXN1YWxseSBzdHJpbmcgbWFwcGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3FbMF1dID0gbWF0Y2ggPyBxWzFdLmNhbGwodGhpcywgbWF0Y2gsIHFbMl0pIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzYW5pdGl6ZSBtYXRjaCB1c2luZyBnaXZlbiByZWdleFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3FbMF1dID0gbWF0Y2ggPyBtYXRjaC5yZXBsYWNlKHFbMV0sIHFbMl0pIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChxLmxlbmd0aCA9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3FbMF1dID0gbWF0Y2ggPyBxWzNdLmNhbGwodGhpcywgbWF0Y2gucmVwbGFjZShxWzFdLCBxWzJdKSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtxXSA9IG1hdGNoID8gbWF0Y2ggOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RyOiBmdW5jdGlvbiBzdHIoX3N0ciwgbWFwKSB7XG5cbiAgICAgICAgICBmb3IgKHZhciBpIGluIG1hcCkge1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgYXJyYXlcbiAgICAgICAgICAgIGlmIChfdHlwZW9mMihtYXBbaV0pID09PSBPQkpfVFlQRSAmJiBtYXBbaV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hcFtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmICh1dGlsLmhhcyhtYXBbaV1bal0sIF9zdHIpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaSA9PT0gVU5LTk9XTiA/IHVuZGVmaW5lZCA6IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHV0aWwuaGFzKG1hcFtpXSwgX3N0cikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGkgPT09IFVOS05PV04gPyB1bmRlZmluZWQgOiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3N0cjtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8vLy8vLy8vLy8vLy8vXG4gICAgICAvLyBTdHJpbmcgbWFwXG4gICAgICAvLy8vLy8vLy8vLy8vL1xuXG5cbiAgICAgIHZhciBtYXBzID0ge1xuXG4gICAgICAgIGJyb3dzZXI6IHtcbiAgICAgICAgICBvbGRzYWZhcmk6IHtcbiAgICAgICAgICAgIHZlcnNpb246IHtcbiAgICAgICAgICAgICAgJzEuMCc6ICcvOCcsXG4gICAgICAgICAgICAgICcxLjInOiAnLzEnLFxuICAgICAgICAgICAgICAnMS4zJzogJy8zJyxcbiAgICAgICAgICAgICAgJzIuMCc6ICcvNDEyJyxcbiAgICAgICAgICAgICAgJzIuMC4yJzogJy80MTYnLFxuICAgICAgICAgICAgICAnMi4wLjMnOiAnLzQxNycsXG4gICAgICAgICAgICAgICcyLjAuNCc6ICcvNDE5JyxcbiAgICAgICAgICAgICAgJz8nOiAnLydcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgICdPcGVyYSBNb2JpbGUnOiAnT3BlcmEgTW9iaScsXG4gICAgICAgICAgICAnSUUgTW9iaWxlJzogJ0lFTW9iaWxlJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkZXZpY2U6IHtcbiAgICAgICAgICBhbWF6b246IHtcbiAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICdGaXJlIFBob25lJzogWydTRCcsICdLRiddXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzcHJpbnQ6IHtcbiAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICdFdm8gU2hpZnQgNEcnOiAnNzM3M0tUJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZlbmRvcjoge1xuICAgICAgICAgICAgICAnSFRDJzogJ0FQQScsXG4gICAgICAgICAgICAgICdTcHJpbnQnOiAnU3ByaW50J1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvczoge1xuICAgICAgICAgIHdpbmRvd3M6IHtcbiAgICAgICAgICAgIHZlcnNpb246IHtcbiAgICAgICAgICAgICAgJ01FJzogJzQuOTAnLFxuICAgICAgICAgICAgICAnTlQgMy4xMSc6ICdOVDMuNTEnLFxuICAgICAgICAgICAgICAnTlQgNC4wJzogJ05UNC4wJyxcbiAgICAgICAgICAgICAgJzIwMDAnOiAnTlQgNS4wJyxcbiAgICAgICAgICAgICAgJ1hQJzogWydOVCA1LjEnLCAnTlQgNS4yJ10sXG4gICAgICAgICAgICAgICdWaXN0YSc6ICdOVCA2LjAnLFxuICAgICAgICAgICAgICAnNyc6ICdOVCA2LjEnLFxuICAgICAgICAgICAgICAnOCc6ICdOVCA2LjInLFxuICAgICAgICAgICAgICAnOC4xJzogJ05UIDYuMycsXG4gICAgICAgICAgICAgICcxMCc6IFsnTlQgNi40JywgJ05UIDEwLjAnXSxcbiAgICAgICAgICAgICAgJ1JUJzogJ0FSTSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICdXaW5kb3dzIFBob25lJzogJ1dpbmRvd3MgUGhvbmUgT1MnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLy8vLy8vLy8vLy8vL1xuICAgICAgLy8gUmVnZXggbWFwXG4gICAgICAvLy8vLy8vLy8vLy8vXG5cblxuICAgICAgdmFyIHJlZ2V4ZXMgPSB7XG5cbiAgICAgICAgYnJvd3NlcjogW1tcblxuICAgICAgICAvLyBQcmVzdG8gYmFzZWRcbiAgICAgICAgLyhvcGVyYVxcc21pbmkpXFwvKFtcXHdcXC4tXSspL2ksIC8vIE9wZXJhIE1pbmlcbiAgICAgICAgLyhvcGVyYVxcc1ttb2JpbGV0YWJdKykuK3ZlcnNpb25cXC8oW1xcd1xcLi1dKykvaSwgLy8gT3BlcmEgTW9iaS9UYWJsZXRcbiAgICAgICAgLyhvcGVyYSkuK3ZlcnNpb25cXC8oW1xcd1xcLl0rKS9pLCAvLyBPcGVyYSA+IDkuODBcbiAgICAgICAgLyhvcGVyYSlbXFwvXFxzXSsoW1xcd1xcLl0rKS9pIC8vIE9wZXJhIDwgOS44MFxuICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFsvKE9QaU9TKVtcXC9cXHNdKyhbXFx3XFwuXSspL2kgLy8gT3BlcmEgbWluaSBvbiBpcGhvbmUgPj0gOC4wXG4gICAgICAgIF0sIFtbTkFNRSwgJ09wZXJhIE1pbmknXSwgVkVSU0lPTl0sIFsvXFxzKG9wcilcXC8oW1xcd1xcLl0rKS9pIC8vIE9wZXJhIFdlYmtpdFxuICAgICAgICBdLCBbW05BTUUsICdPcGVyYSddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgIC8vIE1peGVkXG4gICAgICAgIC8oa2luZGxlKVxcLyhbXFx3XFwuXSspL2ksIC8vIEtpbmRsZVxuICAgICAgICAvKGx1bmFzY2FwZXxtYXh0aG9ufG5ldGZyb250fGphc21pbmV8YmxhemVyKVtcXC9cXHNdPyhbXFx3XFwuXSspKi9pLFxuICAgICAgICAvLyBMdW5hc2NhcGUvTWF4dGhvbi9OZXRmcm9udC9KYXNtaW5lL0JsYXplclxuXG4gICAgICAgIC8vIFRyaWRlbnQgYmFzZWRcbiAgICAgICAgLyhhdmFudFxcc3xpZW1vYmlsZXxzbGltfGJhaWR1KSg/OmJyb3dzZXIpP1tcXC9cXHNdPyhbXFx3XFwuXSopL2ksXG4gICAgICAgIC8vIEF2YW50L0lFTW9iaWxlL1NsaW1Ccm93c2VyL0JhaWR1XG4gICAgICAgIC8oPzptc3xcXCgpKGllKVxccyhbXFx3XFwuXSspL2ksIC8vIEludGVybmV0IEV4cGxvcmVyXG5cbiAgICAgICAgLy8gV2Via2l0L0tIVE1MIGJhc2VkXG4gICAgICAgIC8ocmVrb25xKVxcLyhbXFx3XFwuXSspKi9pLCAvLyBSZWtvbnFcbiAgICAgICAgLyhjaHJvbWl1bXxmbG9ja3xyb2NrbWVsdHxtaWRvcml8ZXBpcGhhbnl8c2lsa3xza3lmaXJlfG92aWJyb3dzZXJ8Ym9sdHxpcm9ufHZpdmFsZGl8aXJpZGl1bXxwaGFudG9tanMpXFwvKFtcXHdcXC4tXSspL2lcbiAgICAgICAgLy8gQ2hyb21pdW0vRmxvY2svUm9ja01lbHQvTWlkb3JpL0VwaXBoYW55L1NpbGsvU2t5ZmlyZS9Cb2x0L0lyb24vSXJpZGl1bS9QaGFudG9tSlNcbiAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbLyh0cmlkZW50KS4rcnZbOlxcc10oW1xcd1xcLl0rKS4rbGlrZVxcc2dlY2tvL2kgLy8gSUUxMVxuICAgICAgICBdLCBbW05BTUUsICdJRSddLCBWRVJTSU9OXSwgWy8oZWRnZSlcXC8oKFxcZCspP1tcXHdcXC5dKykvaSAvLyBNaWNyb3NvZnQgRWRnZVxuICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFsvKHlhYnJvd3NlcilcXC8oW1xcd1xcLl0rKS9pIC8vIFlhbmRleFxuICAgICAgICBdLCBbW05BTUUsICdZYW5kZXgnXSwgVkVSU0lPTl0sIFsvKGNvbW9kb19kcmFnb24pXFwvKFtcXHdcXC5dKykvaSAvLyBDb21vZG8gRHJhZ29uXG4gICAgICAgIF0sIFtbTkFNRSwgL18vZywgJyAnXSwgVkVSU0lPTl0sIFsvKCg/OmFuZHJvaWQuKyljcm1vfGNyaW9zKVxcLyhbXFx3XFwuXSspL2ksIC9hbmRyb2lkLisoY2hyb21lKVxcLyhbXFx3XFwuXSspXFxzKyg/Om1vYmlsZVxccz9zYWZhcmkpL2kgLy8gQ2hyb21lIGZvciBBbmRyb2lkL2lPU1xuICAgICAgICBdLCBbW05BTUUsICdDaHJvbWUgTW9iaWxlJ10sIFZFUlNJT05dLCBbLyhjaHJvbWV8b21uaXdlYnxhcm9yYXxbdGl6ZW5va2FdezV9XFxzP2Jyb3dzZXIpXFwvdj8oW1xcd1xcLl0rKS9pLFxuICAgICAgICAvLyBDaHJvbWUvT21uaVdlYi9Bcm9yYS9UaXplbi9Ob2tpYVxuICAgICAgICAvKHFxYnJvd3NlcilbXFwvXFxzXT8oW1xcd1xcLl0rKS9pXG4gICAgICAgIC8vIFFRQnJvd3NlclxuICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFsvKHVjXFxzP2Jyb3dzZXIpW1xcL1xcc10/KFtcXHdcXC5dKykvaSwgL3Vjd2ViLisodWNicm93c2VyKVtcXC9cXHNdPyhbXFx3XFwuXSspL2ksIC9KVUMuKyh1Y3dlYilbXFwvXFxzXT8oW1xcd1xcLl0rKS9pXG4gICAgICAgIC8vIFVDQnJvd3NlclxuICAgICAgICBdLCBbW05BTUUsICdVQ0Jyb3dzZXInXSwgVkVSU0lPTl0sIFsvKGRvbGZpbilcXC8oW1xcd1xcLl0rKS9pIC8vIERvbHBoaW5cbiAgICAgICAgXSwgW1tOQU1FLCAnRG9scGhpbiddLCBWRVJTSU9OXSwgWy9YaWFvTWlcXC9NaXVpQnJvd3NlclxcLyhbXFx3XFwuXSspL2kgLy8gTUlVSSBCcm93c2VyXG4gICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ01JVUkgQnJvd3NlciddXSwgWy9hbmRyb2lkLit2ZXJzaW9uXFwvKFtcXHdcXC5dKylcXHMrKD86bW9iaWxlXFxzP3NhZmFyaXxzYWZhcmkpL2kgLy8gQW5kcm9pZCBCcm93c2VyXG4gICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0FuZHJvaWQgQnJvd3NlciddXSwgWy9GQkFWXFwvKFtcXHdcXC5dKyk7L2kgLy8gRmFjZWJvb2sgQXBwIGZvciBpT1NcbiAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnRmFjZWJvb2snXV0sIFsvZnhpb3NcXC8oW1xcd1xcLi1dKykvaSAvLyBGaXJlZm94IGZvciBpT1NcbiAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnRmlyZWZveCddXSwgWy92ZXJzaW9uXFwvKFtcXHdcXC5dKykuKz9tb2JpbGVcXC9cXHcrXFxzKHNhZmFyaSkvaSAvLyBNb2JpbGUgU2FmYXJpXG4gICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ01vYmlsZSBTYWZhcmknXV0sIFsvdmVyc2lvblxcLyhbXFx3XFwuXSspLis/KG1vYmlsZVxccz9zYWZhcml8c2FmYXJpKS9pIC8vIFNhZmFyaSAmIFNhZmFyaSBNb2JpbGVcbiAgICAgICAgXSwgW1ZFUlNJT04sIE5BTUVdLCBbL3dlYmtpdC4rPyhtb2JpbGVcXHM/c2FmYXJpfHNhZmFyaSkoXFwvW1xcd1xcLl0rKS9pIC8vIFNhZmFyaSA8IDMuMFxuICAgICAgICBdLCBbTkFNRSwgW1ZFUlNJT04sIG1hcHBlci5zdHIsIG1hcHMuYnJvd3Nlci5vbGRzYWZhcmkudmVyc2lvbl1dLCBbLyhrb25xdWVyb3IpXFwvKFtcXHdcXC5dKykvaSwgLy8gS29ucXVlcm9yXG4gICAgICAgIC8od2Via2l0fGtodG1sKVxcLyhbXFx3XFwuXSspL2ldLCBbTkFNRSwgVkVSU0lPTl0sIFsvKGJsYWNrYmVycnkpXFxcXHM/XFwvKFtcXHdcXC5dKykvaSAvLyBCbGFja2JlcnJ5XG4gICAgICAgIF0sIFtbTkFNRSwgXCJCbGFja0JlcnJ5XCJdLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgIC8vIEdlY2tvIGJhc2VkXG4gICAgICAgIC8obmF2aWdhdG9yfG5ldHNjYXBlKVxcLyhbXFx3XFwuLV0rKS9pIC8vIE5ldHNjYXBlXG4gICAgICAgIF0sIFtbTkFNRSwgJ05ldHNjYXBlJ10sIFZFUlNJT05dLCBbLyhzd2lmdGZveCkvaSwgLy8gU3dpZnRmb3hcbiAgICAgICAgLyhpY2VkcmFnb258aWNld2Vhc2VsfGNhbWlub3xjaGltZXJhfGZlbm5lY3xtYWVtb1xcc2Jyb3dzZXJ8bWluaW1vfGNvbmtlcm9yKVtcXC9cXHNdPyhbXFx3XFwuXFwrXSspL2ksXG4gICAgICAgIC8vIEljZURyYWdvbi9JY2V3ZWFzZWwvQ2FtaW5vL0NoaW1lcmEvRmVubmVjL01hZW1vL01pbmltby9Db25rZXJvclxuICAgICAgICAvKGZpcmVmb3h8c2VhbW9ua2V5fGstbWVsZW9ufGljZWNhdHxpY2VhcGV8ZmlyZWJpcmR8cGhvZW5peClcXC8oW1xcd1xcLi1dKykvaSxcbiAgICAgICAgLy8gRmlyZWZveC9TZWFNb25rZXkvSy1NZWxlb24vSWNlQ2F0L0ljZUFwZS9GaXJlYmlyZC9QaG9lbml4XG4gICAgICAgIC8obW96aWxsYSlcXC8oW1xcd1xcLl0rKS4rcnZcXDouK2dlY2tvXFwvXFxkKy9pLCAvLyBNb3ppbGxhXG5cbiAgICAgICAgLy8gT3RoZXJcbiAgICAgICAgLyhwb2xhcmlzfGx5bnh8ZGlsbG98aWNhYnxkb3Jpc3xhbWF5YXx3M218bmV0c3VyZnxzbGVpcG5pcilbXFwvXFxzXT8oW1xcd1xcLl0rKS9pLFxuICAgICAgICAvLyBQb2xhcmlzL0x5bngvRGlsbG8vaUNhYi9Eb3Jpcy9BbWF5YS93M20vTmV0U3VyZi9TbGVpcG5pclxuICAgICAgICAvKGxpbmtzKVxcc1xcKChbXFx3XFwuXSspL2ksIC8vIExpbmtzXG4gICAgICAgIC8oZ29icm93c2VyKVxcLz8oW1xcd1xcLl0rKSovaSwgLy8gR29Ccm93c2VyXG4gICAgICAgIC8oaWNlXFxzP2Jyb3dzZXIpXFwvdj8oW1xcd1xcLl9dKykvaSwgLy8gSUNFIEJyb3dzZXJcbiAgICAgICAgLyhtb3NhaWMpW1xcL1xcc10oW1xcd1xcLl0rKS9pIC8vIE1vc2FpY1xuICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl1cblxuICAgICAgICAvKiAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgLy8gTWVkaWEgcGxheWVycyBCRUdJTlxuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICwgW1xuICAgICAgICAgLyhhcHBsZSg/OmNvcmVtZWRpYXwpKVxcLygoXFxkKylbXFx3XFwuX10rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2VuZXJpYyBBcHBsZSBDb3JlTWVkaWFcbiAgICAgICAgLyhjb3JlbWVkaWEpIHYoKFxcZCspW1xcd1xcLl9dKykvaVxuICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcbiAgICAgICAgIC8oYXF1YWx1bmd8bHlzc25hfGJzcGxheWVyKVxcLygoXFxkKyk/W1xcd1xcLi1dKykvaSAgICAgICAgICAgICAgICAgICAgIC8vIEFxdWFsdW5nL0x5c3NuYS9CU1BsYXllclxuICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcbiAgICAgICAgIC8oYXJlc3xvc3Nwcm94eSlcXHMoKFxcZCspW1xcd1xcLi1dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFyZXMvT1NTUHJveHlcbiAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG4gICAgICAgICAvKGF1ZGFjaW91c3xhdWRpbXVzaWNzdHJlYW18YW1hcm9rfGJhc3N8Y29yZXxkYWx2aWt8Z25vbWVtcGxheWVyfG11c2ljIG9uIGNvbnNvbGV8bnNwbGF5ZXJ8cHNwLWludGVybmV0cmFkaW9wbGF5ZXJ8dmlkZW9zKVxcLygoXFxkKylbXFx3XFwuLV0rKS9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF1ZGFjaW91cy9BdWRpTXVzaWNTdHJlYW0vQW1hcm9rL0JBU1MvT3BlbkNPUkUvRGFsdmlrL0dub21lTXBsYXllci9Nb0NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOU1BsYXllci9QU1AtSW50ZXJuZXRSYWRpb1BsYXllci9WaWRlb3NcbiAgICAgICAgLyhjbGVtZW50aW5lfG11c2ljIHBsYXllciBkYWVtb24pXFxzKChcXGQrKVtcXHdcXC4tXSspL2ksICAgICAgICAgICAgICAgLy8gQ2xlbWVudGluZS9NUERcbiAgICAgICAgLyhsZyBwbGF5ZXJ8bmV4cGxheWVyKVxccygoXFxkKylbXFxkXFwuXSspL2ksXG4gICAgICAgIC9wbGF5ZXJcXC8obmV4cGxheWVyfGxnIHBsYXllcilcXHMoKFxcZCspW1xcd1xcLi1dKykvaSAgICAgICAgICAgICAgICAgICAvLyBOZXhQbGF5ZXIvTEcgUGxheWVyXG4gICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuICAgICAgICAvKG5leHBsYXllcilcXHMoKFxcZCspW1xcd1xcLi1dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXhwbGF5ZXJcbiAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG4gICAgICAgICAvKGZscnApXFwvKChcXGQrKVtcXHdcXC4tXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGbGlwIFBsYXllclxuICAgICAgICBdLCBbW05BTUUsICdGbGlwIFBsYXllciddLCBWRVJTSU9OXSwgW1xuICAgICAgICAgLyhmc3RyZWFtfG5hdGl2ZWhvc3R8cXVlcnlzZWVrc3BpZGVyfGlhLWFyY2hpdmVyfGZhY2Vib29rZXh0ZXJuYWxoaXQpL2lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGU3RyZWFtL05hdGl2ZUhvc3QvUXVlcnlTZWVrU3BpZGVyL0lBIEFyY2hpdmVyL2ZhY2Vib29rZXh0ZXJuYWxoaXRcbiAgICAgICAgXSwgW05BTUVdLCBbXG4gICAgICAgICAvKGdzdHJlYW1lcikgc291cGh0dHBzcmMgKD86XFwoW15cXCldK1xcKSl7MCwxfSBsaWJzb3VwXFwvKChcXGQrKVtcXHdcXC4tXSspL2lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHc3RyZWFtZXJcbiAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG4gICAgICAgICAvKGh0YyBzdHJlYW1pbmcgcGxheWVyKVxcc1tcXHdfXStcXHNcXC9cXHMoKFxcZCspW1xcZFxcLl0rKS9pLCAgICAgICAgICAgICAgLy8gSFRDIFN0cmVhbWluZyBQbGF5ZXJcbiAgICAgICAgLyhqYXZhfHB5dGhvbi11cmxsaWJ8cHl0aG9uLXJlcXVlc3RzfHdnZXR8bGliY3VybClcXC8oKFxcZCspW1xcd1xcLi1fXSspL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSmF2YS91cmxsaWIvcmVxdWVzdHMvd2dldC9jVVJMXG4gICAgICAgIC8obGF2ZikoKFxcZCspW1xcZFxcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGF2ZiAoRkZNUEVHKVxuICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcbiAgICAgICAgIC8oaHRjX29uZV9zKVxcLygoXFxkKylbXFxkXFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhUQyBPbmUgU1xuICAgICAgICBdLCBbW05BTUUsIC9fL2csICcgJ10sIFZFUlNJT05dLCBbXG4gICAgICAgICAvKG1wbGF5ZXIpKD86XFxzfFxcLykoPzooPzpzaGVycHlhLSl7MCwxfXN2bikoPzotfFxccykoclxcZCsoPzotXFxkK1tcXHdcXC4tXSspezAsMX0pL2lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNUGxheWVyIFNWTlxuICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcbiAgICAgICAgIC8obXBsYXllcikoPzpcXHN8XFwvfFt1bmtvdy1dKykoKFxcZCspW1xcd1xcLi1dKykvaSAgICAgICAgICAgICAgICAgICAgICAvLyBNUGxheWVyXG4gICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuICAgICAgICAgLyhtcGxheWVyKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNUGxheWVyIChubyBvdGhlciBpbmZvKVxuICAgICAgICAvKHlvdXJtdXplKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFlvdXJNdXplXG4gICAgICAgIC8obWVkaWEgcGxheWVyIGNsYXNzaWN8bmVybyBzaG93dGltZSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWVkaWEgUGxheWVyIENsYXNzaWMvTmVybyBTaG93VGltZVxuICAgICAgICBdLCBbTkFNRV0sIFtcbiAgICAgICAgIC8obmVybyAoPzpob21lfHNjb3V0KSlcXC8oKFxcZCspW1xcd1xcLi1dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5lcm8gSG9tZS9OZXJvIFNjb3V0XG4gICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuICAgICAgICAgLyhub2tpYVxcZCspXFwvKChcXGQrKVtcXHdcXC4tXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5va2lhXG4gICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuICAgICAgICAgL1xccyhzb25nYmlyZClcXC8oKFxcZCspW1xcd1xcLi1dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbmdiaXJkL1BoaWxpcHMtU29uZ2JpcmRcbiAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG4gICAgICAgICAvKHdpbmFtcCkzIHZlcnNpb24gKChcXGQrKVtcXHdcXC4tXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdpbmFtcFxuICAgICAgICAvKHdpbmFtcClcXHMoKFxcZCspW1xcd1xcLi1dKykvaSxcbiAgICAgICAgLyh3aW5hbXApbXBlZ1xcLygoXFxkKylbXFx3XFwuLV0rKS9pXG4gICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuICAgICAgICAgLyhvY21zLWJvdHx0YXBpbnJhZGlvfHR1bmVpbiByYWRpb3x1bmtub3dufHdpbmFtcHxpbmxpZ2h0IHJhZGlvKS9pICAvLyBPQ01TLWJvdC90YXAgaW4gcmFkaW8vdHVuZWluL3Vua25vd24vd2luYW1wIChubyBvdGhlciBpbmZvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlubGlnaHQgcmFkaW9cbiAgICAgICAgXSwgW05BTUVdLCBbXG4gICAgICAgICAvKHF1aWNrdGltZXxybWF8cmFkaW9hcHB8cmFkaW9jbGllbnRhcHBsaWNhdGlvbnxzb3VuZHRhcHx0b3RlbXxzdGFnZWZyaWdodHxzdHJlYW1pdW0pXFwvKChcXGQrKVtcXHdcXC4tXSspL2lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBRdWlja1RpbWUvUmVhbE1lZGlhL1JhZGlvQXBwL1JhZGlvQ2xpZW50QXBwbGljYXRpb24vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU291bmRUYXAvVG90ZW0vU3RhZ2VmcmlnaHQvU3RyZWFtaXVtXG4gICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuICAgICAgICAgLyhzbXApKChcXGQrKVtcXGRcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTTVBcbiAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG4gICAgICAgICAvKHZsYykgbWVkaWEgcGxheWVyIC0gdmVyc2lvbiAoKFxcZCspW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgIC8vIFZMQyBWaWRlb2xhblxuICAgICAgICAvKHZsYylcXC8oKFxcZCspW1xcd1xcLi1dKykvaSxcbiAgICAgICAgLyh4Ym1jfGd2ZnN8eGluZXx4bW1zfGlyYXBwKVxcLygoXFxkKylbXFx3XFwuLV0rKS9pLCAgICAgICAgICAgICAgICAgICAgLy8gWEJNQy9ndmZzL1hpbmUvWE1NUy9pcmFwcFxuICAgICAgICAvKGZvb2JhcjIwMDApXFwvKChcXGQrKVtcXGRcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGb29iYXIyMDAwXG4gICAgICAgIC8oaXR1bmVzKVxcLygoXFxkKylbXFxkXFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlUdW5lc1xuICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcbiAgICAgICAgIC8od21wbGF5ZXIpXFwvKChcXGQrKVtcXHdcXC4tXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdpbmRvd3MgTWVkaWEgUGxheWVyXG4gICAgICAgIC8od2luZG93cy1tZWRpYS1wbGF5ZXIpXFwvKChcXGQrKVtcXHdcXC4tXSspL2lcbiAgICAgICAgXSwgW1tOQU1FLCAvLS9nLCAnICddLCBWRVJTSU9OXSwgW1xuICAgICAgICAgL3dpbmRvd3NcXC8oKFxcZCspW1xcd1xcLi1dKykgdXBucFxcL1tcXGRcXC5dKyBkbG5hZG9jXFwvW1xcZFxcLl0rIChob21lIG1lZGlhIHNlcnZlcikvaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdpbmRvd3MgTWVkaWEgU2VydmVyXG4gICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ1dpbmRvd3MnXV0sIFtcbiAgICAgICAgIC8oY29tXFwucmlzZXVwcmFkaW9hbGFybSlcXC8oKFxcZCspW1xcZFxcLl0qKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSaXNlVVAgUmFkaW8gQWxhcm1cbiAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG4gICAgICAgICAvKHJhZC5pbylcXHMoKFxcZCspW1xcZFxcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSYWQuaW9cbiAgICAgICAgLyhyYWRpby4oPzpkZXxhdHxmcikpXFxzKChcXGQrKVtcXGRcXC5dKykvaVxuICAgICAgICBdLCBbW05BTUUsICdyYWQuaW8nXSwgVkVSU0lPTl1cbiAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgLy8gTWVkaWEgcGxheWVycyBFTkRcbiAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8qL1xuXG4gICAgICAgIF0sXG5cbiAgICAgICAgY3B1OiBbWy8oPzooYW1kfHgoPzooPzo4Nnw2NClbXy1dKT98d293fHdpbik2NClbO1xcKV0vaSAvLyBBTUQ2NFxuICAgICAgICBdLCBbW0FSQ0hJVEVDVFVSRSwgJ2FtZDY0J11dLCBbLyhpYTMyKD89OykpL2kgLy8gSUEzMiAocXVpY2t0aW1lKVxuICAgICAgICBdLCBbW0FSQ0hJVEVDVFVSRSwgdXRpbC5sb3dlcml6ZV1dLCBbLygoPzppWzM0Nl18eCk4NilbO1xcKV0vaSAvLyBJQTMyXG4gICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCAnaWEzMiddXSwgW1xuXG4gICAgICAgIC8vIFBvY2tldFBDIG1pc3Rha2VubHkgaWRlbnRpZmllZCBhcyBQb3dlclBDXG4gICAgICAgIC93aW5kb3dzXFxzKGNlfG1vYmlsZSk7XFxzcHBjOy9pXSwgW1tBUkNISVRFQ1RVUkUsICdhcm0nXV0sIFsvKCg/OnBwY3xwb3dlcnBjKSg/OjY0KT8pKD86XFxzbWFjfDt8XFwpKS9pIC8vIFBvd2VyUENcbiAgICAgICAgXSwgW1tBUkNISVRFQ1RVUkUsIC9vd2VyLywgJycsIHV0aWwubG93ZXJpemVdXSwgWy8oc3VuNFxcdylbO1xcKV0vaSAvLyBTUEFSQ1xuICAgICAgICBdLCBbW0FSQ0hJVEVDVFVSRSwgJ3NwYXJjJ11dLCBbLygoPzphdnIzMnxpYTY0KD89OykpfDY4ayg/PVxcKSl8YXJtKD86NjR8KD89dlxcZCs7KSl8KD89YXRtZWxcXHMpYXZyfCg/OmlyaXh8bWlwc3xzcGFyYykoPzo2NCk/KD89Oyl8cGEtcmlzYykvaVxuICAgICAgICAvLyBJQTY0LCA2OEssIEFSTS82NCwgQVZSLzMyLCBJUklYLzY0LCBNSVBTLzY0LCBTUEFSQy82NCwgUEEtUklTQ1xuICAgICAgICBdLCBbW0FSQ0hJVEVDVFVSRSwgdXRpbC5sb3dlcml6ZV1dXSxcblxuICAgICAgICBkZXZpY2U6IFtbL1xcKChpcGFkfHBsYXlib29rKTtbXFx3XFxzXFwpOy1dKyhyaW18YXBwbGUpL2kgLy8gaVBhZC9QbGF5Qm9va1xuICAgICAgICBdLCBbTU9ERUwsIFZFTkRPUiwgW1RZUEUsIFRBQkxFVF1dLCBbL2FwcGxlY29yZW1lZGlhXFwvW1xcd1xcLl0rIFxcKChpcGFkKS8gLy8gaVBhZFxuICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdBcHBsZSddLCBbVFlQRSwgVEFCTEVUXV0sIFsvKGFwcGxlXFxzezAsMX10dikvaSAvLyBBcHBsZSBUVlxuICAgICAgICBdLCBbW01PREVMLCAnQXBwbGUgVFYnXSwgW1ZFTkRPUiwgJ0FwcGxlJ11dLCBbLyhhcmNob3MpXFxzKGdhbWVwYWQyPykvaSwgLy8gQXJjaG9zXG4gICAgICAgIC8oaHApLisodG91Y2hwYWQpL2ksIC8vIEhQIFRvdWNoUGFkXG4gICAgICAgIC8oa2luZGxlKVxcLyhbXFx3XFwuXSspL2ksIC8vIEtpbmRsZVxuICAgICAgICAvXFxzKG5vb2spW1xcd1xcc10rYnVpbGRcXC8oXFx3KykvaSwgLy8gTm9va1xuICAgICAgICAvKGRlbGwpXFxzKHN0cmVhW2twclxcc1xcZF0qW1xcZGtvXSkvaSAvLyBEZWxsIFN0cmVha1xuICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIFRBQkxFVF1dLCBbLyhrZltBLXpdKylcXHNidWlsZFxcL1tcXHdcXC5dKy4qc2lsa1xcLy9pIC8vIEtpbmRsZSBGaXJlIEhEXG4gICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0FtYXpvbiddLCBbVFlQRSwgVEFCTEVUXV0sIFsvKHNkfGtmKVswMzQ5aGlqb3JzdHV3XStcXHNidWlsZFxcL1tcXHdcXC5dKy4qc2lsa1xcLy9pIC8vIEZpcmUgUGhvbmVcbiAgICAgICAgXSwgW1tNT0RFTCwgbWFwcGVyLnN0ciwgbWFwcy5kZXZpY2UuYW1hem9uLm1vZGVsXSwgW1ZFTkRPUiwgJ0FtYXpvbiddLCBbVFlQRSwgTU9CSUxFXV0sIFsvXFwoKGlwW2hvbmVkfFxcc1xcdypdKyk7LisoYXBwbGUpL2kgLy8gaVBvZC9pUGhvbmVcbiAgICAgICAgXSwgW01PREVMLCBWRU5ET1IsIFtUWVBFLCBNT0JJTEVdXSwgWy9cXCgoaXBbaG9uZWR8XFxzXFx3Kl0rKTsvaSAvLyBpUG9kL2lQaG9uZVxuICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdBcHBsZSddLCBbVFlQRSwgTU9CSUxFXV0sIFsvKGJsYWNrYmVycnkpW1xccy1dPyhcXHcrKS9pLCAvLyBCbGFja0JlcnJ5XG4gICAgICAgIC8oYmxhY2tiZXJyeXxiZW5xfHBhbG0oPz1cXC0pfHNvbnllcmljc3NvbnxhY2VyfGFzdXN8ZGVsbHxodWF3ZWl8bWVpenV8bW90b3JvbGF8cG9seXRyb24pW1xcc18tXT8oW1xcdy1dKykqL2ksXG4gICAgICAgIC8vIEJlblEvUGFsbS9Tb255LUVyaWNzc29uL0FjZXIvQXN1cy9EZWxsL0h1YXdlaS9NZWl6dS9Nb3Rvcm9sYS9Qb2x5dHJvblxuICAgICAgICAvKGhwKVxccyhbXFx3XFxzXStcXHcpL2ksIC8vIEhQIGlQQVFcbiAgICAgICAgLyhhc3VzKS0/KFxcdyspL2kgLy8gQXN1c1xuICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIE1PQklMRV1dLCBbL1xcKGJiMTA7XFxzKFxcdyspL2kgLy8gQmxhY2tCZXJyeSAxMFxuICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdCbGFja0JlcnJ5J10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAvLyBBc3VzIFRhYmxldHNcbiAgICAgICAgL2FuZHJvaWQuKyh0cmFuc2ZvW3ByaW1lXFxzXXs0LDEwfVxcc1xcdyt8ZWVlcGN8c2xpZGVyXFxzXFx3K3xuZXh1cyA3KS9pXSwgW01PREVMLCBbVkVORE9SLCAnQXN1cyddLCBbVFlQRSwgVEFCTEVUXV0sIFsvKHNvbnkpXFxzKHRhYmxldFxcc1twc10pXFxzYnVpbGRcXC8vaSwgLy8gU29ueVxuICAgICAgICAvKHNvbnkpPyg/OnNncC4rKVxcc2J1aWxkXFwvL2ldLCBbW1ZFTkRPUiwgJ1NvbnknXSwgW01PREVMLCAnWHBlcmlhIFRhYmxldCddLCBbVFlQRSwgVEFCTEVUXV0sIFsvKD86c29ueSk/KD86KD86KD86Y3xkKVxcZHs0fSl8KD86c29bLWxdLispKVxcc2J1aWxkXFwvL2ldLCBbW1ZFTkRPUiwgJ1NvbnknXSwgW01PREVMLCAnWHBlcmlhIFBob25lJ10sIFtUWVBFLCBNT0JJTEVdXSwgWy9cXHMob3V5YSlcXHMvaSwgLy8gT3V5YVxuICAgICAgICAvKG5pbnRlbmRvKVxccyhbd2lkczN1XSspL2kgLy8gTmludGVuZG9cbiAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBDT05TT0xFXV0sIFsvYW5kcm9pZC4rO1xccyhzaGllbGQpXFxzYnVpbGQvaSAvLyBOdmlkaWFcbiAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTnZpZGlhJ10sIFtUWVBFLCBDT05TT0xFXV0sIFsvKHBsYXlzdGF0aW9uXFxzWzM0cG9ydGFibGV2aV0rKS9pIC8vIFBsYXlzdGF0aW9uXG4gICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ1NvbnknXSwgW1RZUEUsIENPTlNPTEVdXSwgWy8oc3ByaW50XFxzKFxcdyspKS9pIC8vIFNwcmludCBQaG9uZXNcbiAgICAgICAgXSwgW1tWRU5ET1IsIG1hcHBlci5zdHIsIG1hcHMuZGV2aWNlLnNwcmludC52ZW5kb3JdLCBbTU9ERUwsIG1hcHBlci5zdHIsIG1hcHMuZGV2aWNlLnNwcmludC5tb2RlbF0sIFtUWVBFLCBNT0JJTEVdXSwgWy8obGVub3ZvKVxccz8oUyg/OjUwMDB8NjAwMCkrKD86Wy1dW1xcdytdKSkvaSAvLyBMZW5vdm8gdGFibGV0c1xuICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIFRBQkxFVF1dLCBbLyhodGMpWztfXFxzLV0rKFtcXHdcXHNdKyg/PVxcKSl8XFx3KykqL2ksIC8vIEhUQ1xuICAgICAgICAvKHp0ZSktKFxcdyspKi9pLCAvLyBaVEVcbiAgICAgICAgLyhhbGNhdGVsfGdlZWtzcGhvbmV8aHVhd2VpfGxlbm92b3xuZXhpYW58cGFuYXNvbmljfCg/PTtcXHMpc29ueSlbX1xccy1dPyhbXFx3LV0rKSovaVxuICAgICAgICAvLyBBbGNhdGVsL0dlZWtzUGhvbmUvSHVhd2VpL0xlbm92by9OZXhpYW4vUGFuYXNvbmljL1NvbnlcbiAgICAgICAgXSwgW1ZFTkRPUiwgW01PREVMLCAvXy9nLCAnICddLCBbVFlQRSwgTU9CSUxFXV0sIFsvKG5leHVzXFxzOSkvaSAvLyBIVEMgTmV4dXMgOVxuICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdIVEMnXSwgW1RZUEUsIFRBQkxFVF1dLCBbL1tcXHNcXCg7XSh4Ym94KD86XFxzb25lKT8pW1xcc1xcKTtdL2kgLy8gTWljcm9zb2Z0IFhib3hcbiAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTWljcm9zb2Z0J10sIFtUWVBFLCBDT05TT0xFXV0sIFsvKGtpblxcLltvbmV0d117M30pL2kgLy8gTWljcm9zb2Z0IEtpblxuICAgICAgICBdLCBbW01PREVMLCAvXFwuL2csICcgJ10sIFtWRU5ET1IsICdNaWNyb3NvZnQnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgLy8gTW90b3JvbGFcbiAgICAgICAgL1xccyhtaWxlc3RvbmV8ZHJvaWQoPzpbMi00eF18XFxzKD86YmlvbmljfHgyfHByb3xyYXpyKSk/KDo/XFxzNGcpPylbXFx3XFxzXStidWlsZFxcLy9pLCAvbW90W1xccy1dPyhcXHcrKSovaSwgLyhYVFxcZHszLDR9KSBidWlsZFxcLy9pLCAvKG5leHVzXFxzWzZdKS9pXSwgW01PREVMLCBbVkVORE9SLCAnTW90b3JvbGEnXSwgW1RZUEUsIE1PQklMRV1dLCBbL2FuZHJvaWQuK1xccyhtejYwXFxkfHhvb21bXFxzMl17MCwyfSlcXHNidWlsZFxcLy9pXSwgW01PREVMLCBbVkVORE9SLCAnTW90b3JvbGEnXSwgW1RZUEUsIFRBQkxFVF1dLCBbL2FuZHJvaWQuKygoc2NoLWlbODldMFxcZHxzaHctbTM4MHN8Z3QtcFxcZHs0fXxndC1uODAwMHxzZ2gtdDhbNTZdOXxuZXh1cyAxMCkpL2ksIC8oKFNNLVRcXHcrKSkvaV0sIFtbVkVORE9SLCAnU2Ftc3VuZyddLCBNT0RFTCwgW1RZUEUsIFRBQkxFVF1dLCBbLy8gU2Ftc3VuZ1xuICAgICAgICAvKChzW2NncF1oLVxcdyt8Z3QtXFx3K3xnYWxheHlcXHNuZXh1c3xzbS1uOTAwKSkvaSwgLyhzYW1bc3VuZ10qKVtcXHMtXSooXFx3Ky0/W1xcdy1dKikqL2ksIC9zZWMtKChzZ2hcXHcrKSkvaV0sIFtbVkVORE9SLCAnU2Ftc3VuZyddLCBNT0RFTCwgW1RZUEUsIE1PQklMRV1dLCBbLyhzYW1zdW5nKTtzbWFydHR2L2ldLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIFNNQVJUVFZdXSwgWy9cXChkdHZbXFwpO10uKyhhcXVvcykvaSAvLyBTaGFycFxuICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdTaGFycCddLCBbVFlQRSwgU01BUlRUVl1dLCBbL3NpZS0oXFx3KykqL2kgLy8gU2llbWVuc1xuICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdTaWVtZW5zJ10sIFtUWVBFLCBNT0JJTEVdXSwgWy8obWFlbW98bm9raWEpLioobjkwMHxsdW1pYVxcc1xcZCspL2ksIC8vIE5va2lhXG4gICAgICAgIC8obm9raWEpW1xcc18tXT8oW1xcdy1dKykqL2ldLCBbW1ZFTkRPUiwgJ05va2lhJ10sIE1PREVMLCBbVFlQRSwgTU9CSUxFXV0sIFsvYW5kcm9pZFxcczNcXC5bXFxzXFx3Oy1dezEwfShhXFxkezN9KS9pIC8vIEFjZXJcbiAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnQWNlciddLCBbVFlQRSwgVEFCTEVUXV0sIFsvYW5kcm9pZFxcczNcXC5bXFxzXFx3Oy1dezEwfShsZz8pLShbMDZjdjldezMsNH0pL2kgLy8gTEcgVGFibGV0XG4gICAgICAgIF0sIFtbVkVORE9SLCAnTEcnXSwgTU9ERUwsIFtUWVBFLCBUQUJMRVRdXSwgWy8obGcpIG5ldGNhc3RcXC50di9pIC8vIExHIFNtYXJ0VFZcbiAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBTTUFSVFRWXV0sIFsvKG5leHVzXFxzWzQ1XSkvaSwgLy8gTEdcbiAgICAgICAgL2xnW2U7XFxzXFwvLV0rKFxcdyspKi9pXSwgW01PREVMLCBbVkVORE9SLCAnTEcnXSwgW1RZUEUsIE1PQklMRV1dLCBbL2FuZHJvaWQuKyhpZGVhdGFiW2EtejAtOVxcLVxcc10rKS9pIC8vIExlbm92b1xuICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdMZW5vdm8nXSwgW1RZUEUsIFRBQkxFVF1dLCBbL2xpbnV4Oy4rKChqb2xsYSkpOy9pIC8vIEpvbGxhXG4gICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgTU9CSUxFXV0sIFsvKChwZWJibGUpKWFwcFxcL1tcXGRcXC5dK1xccy9pIC8vIFBlYmJsZVxuICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIFdFQVJBQkxFXV0sIFsvYW5kcm9pZC4rO1xccyhnbGFzcylcXHNcXGQvaSAvLyBHb29nbGUgR2xhc3NcbiAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnR29vZ2xlJ10sIFtUWVBFLCBXRUFSQUJMRV1dLCBbL2FuZHJvaWQuKyhcXHcrKVxccytidWlsZFxcL2htXFwxL2ksIC8vIFhpYW9taSBIb25nbWkgJ251bWVyaWMnIG1vZGVsc1xuICAgICAgICAvYW5kcm9pZC4rKGhtW1xcc1xcLV9dKm5vdGU/W1xcc19dKig/OlxcZFxcdyk/KVxccytidWlsZC9pLCAvLyBYaWFvbWkgSG9uZ21pXG4gICAgICAgIC9hbmRyb2lkLisobWlbXFxzXFwtX10qKD86b25lfG9uZVtcXHNfXXBsdXMpP1tcXHNfXSooPzpcXGRcXHcpPylcXHMrYnVpbGQvaSAvLyBYaWFvbWkgTWlcbiAgICAgICAgXSwgW1tNT0RFTCwgL18vZywgJyAnXSwgW1ZFTkRPUiwgJ1hpYW9taSddLCBbVFlQRSwgTU9CSUxFXV0sIFsvXFxzKHRhYmxldClbO1xcL1xcc10vaSwgLy8gVW5pZGVudGlmaWFibGUgVGFibGV0XG4gICAgICAgIC9cXHMobW9iaWxlKVs7XFwvXFxzXS9pIC8vIFVuaWRlbnRpZmlhYmxlIE1vYmlsZVxuICAgICAgICBdLCBbW1RZUEUsIHV0aWwubG93ZXJpemVdLCBWRU5ET1IsIE1PREVMXVxuXG4gICAgICAgIC8qLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgLy8gVE9ETzogbW92ZSB0byBzdHJpbmcgbWFwXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgIC8oQzY2MDMpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29ueSBYcGVyaWEgWiBDNjYwM1xuICAgICAgICBdLCBbW01PREVMLCAnWHBlcmlhIFogQzY2MDMnXSwgW1ZFTkRPUiwgJ1NvbnknXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgIC8oQzY5MDMpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29ueSBYcGVyaWEgWiAxXG4gICAgICAgIF0sIFtbTU9ERUwsICdYcGVyaWEgWiAxJ10sIFtWRU5ET1IsICdTb255J10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgLyhTTS1HOTAwW0Z8SF0pL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTYW1zdW5nIEdhbGF4eSBTNVxuICAgICAgICBdLCBbW01PREVMLCAnR2FsYXh5IFM1J10sIFtWRU5ET1IsICdTYW1zdW5nJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAvKFNNLUc3MTAyKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhbXN1bmcgR2FsYXh5IEdyYW5kIDJcbiAgICAgICAgXSwgW1tNT0RFTCwgJ0dhbGF4eSBHcmFuZCAyJ10sIFtWRU5ET1IsICdTYW1zdW5nJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAvKFNNLUc1MzBIKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhbXN1bmcgR2FsYXh5IEdyYW5kIFByaW1lXG4gICAgICAgIF0sIFtbTU9ERUwsICdHYWxheHkgR3JhbmQgUHJpbWUnXSwgW1ZFTkRPUiwgJ1NhbXN1bmcnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgIC8oU00tRzMxM0haKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2Ftc3VuZyBHYWxheHkgVlxuICAgICAgICBdLCBbW01PREVMLCAnR2FsYXh5IFYnXSwgW1ZFTkRPUiwgJ1NhbXN1bmcnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgIC8oU00tVDgwNSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2Ftc3VuZyBHYWxheHkgVGFiIFMgMTAuNVxuICAgICAgICBdLCBbW01PREVMLCAnR2FsYXh5IFRhYiBTIDEwLjUnXSwgW1ZFTkRPUiwgJ1NhbXN1bmcnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgIC8oU00tRzgwMEYpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2Ftc3VuZyBHYWxheHkgUzUgTWluaVxuICAgICAgICBdLCBbW01PREVMLCAnR2FsYXh5IFM1IE1pbmknXSwgW1ZFTkRPUiwgJ1NhbXN1bmcnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgIC8oU00tVDMxMSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2Ftc3VuZyBHYWxheHkgVGFiIDMgOC4wXG4gICAgICAgIF0sIFtbTU9ERUwsICdHYWxheHkgVGFiIDMgOC4wJ10sIFtWRU5ET1IsICdTYW1zdW5nJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgLyhSMTAwMSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcHBvIFIxMDAxXG4gICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ09QUE8nXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgIC8oWDkwMDYpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BwbyBGaW5kIDdhXG4gICAgICAgIF0sIFtbTU9ERUwsICdGaW5kIDdhJ10sIFtWRU5ET1IsICdPcHBvJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAvKFIyMDAxKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wcG8gWU9ZTyBSMjAwMVxuICAgICAgICBdLCBbW01PREVMLCAnWW95byBSMjAwMSddLCBbVkVORE9SLCAnT3BwbyddLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgLyhSODE1KS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcHBvIENsb3ZlciBSODE1XG4gICAgICAgIF0sIFtbTU9ERUwsICdDbG92ZXIgUjgxNSddLCBbVkVORE9SLCAnT3BwbyddLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgIC8oVTcwNykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcHBvIEZpbmQgV2F5IFNcbiAgICAgICAgXSwgW1tNT0RFTCwgJ0ZpbmQgV2F5IFMnXSwgW1ZFTkRPUiwgJ09wcG8nXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAvKFQzQykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuIFZhbmRyb2lkIFQzQ1xuICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdBZHZhbiddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgLyhBRFZBTiBUMUpcXCspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW4gVmFuZHJvaWQgVDFKK1xuICAgICAgICBdLCBbW01PREVMLCAnVmFuZHJvaWQgVDFKKyddLCBbVkVORE9SLCAnQWR2YW4nXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgIC8oQURWQU4gUzRBKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW4gVmFuZHJvaWQgUzRBXG4gICAgICAgIF0sIFtbTU9ERUwsICdWYW5kcm9pZCBTNEEnXSwgW1ZFTkRPUiwgJ0FkdmFuJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgLyhWOTcyTSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBaVEUgVjk3Mk1cbiAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnWlRFJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgLyhpLW1vYmlsZSlcXHMoSVFcXHNbXFxkXFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaS1tb2JpbGUgSVFcbiAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAvKElRNi4zKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGktbW9iaWxlIElRIElRIDYuM1xuICAgICAgICBdLCBbW01PREVMLCAnSVEgNi4zJ10sIFtWRU5ET1IsICdpLW1vYmlsZSddLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgLyhpLW1vYmlsZSlcXHMoaS1zdHlsZVxcc1tcXGRcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaS1tb2JpbGUgaS1TVFlMRVxuICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgIC8oaS1TVFlMRTIuMSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaS1tb2JpbGUgaS1TVFlMRSAyLjFcbiAgICAgICAgXSwgW1tNT0RFTCwgJ2ktU1RZTEUgMi4xJ10sIFtWRU5ET1IsICdpLW1vYmlsZSddLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgIC8obW9iaWlzdGFyIHRvdWNoIExBSSA1MTIpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9iaWlzdGFyIHRvdWNoIExBSSA1MTJcbiAgICAgICAgXSwgW1tNT0RFTCwgJ1RvdWNoIExBSSA1MTInXSwgW1ZFTkRPUiwgJ21vYmlpc3RhciddLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgIC8vLy8vLy8vLy8vLy9cbiAgICAgICAgLy8gRU5EIFRPRE9cbiAgICAgICAgLy8vLy8vLy8vLy8qL1xuXG4gICAgICAgIF0sXG5cbiAgICAgICAgZW5naW5lOiBbWy93aW5kb3dzLitcXHNlZGdlXFwvKFtcXHdcXC5dKykvaSAvLyBFZGdlSFRNTFxuICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdFZGdlSFRNTCddXSwgWy8ocHJlc3RvKVxcLyhbXFx3XFwuXSspL2ksIC8vIFByZXN0b1xuICAgICAgICAvKHdlYmtpdHx0cmlkZW50fG5ldGZyb250fG5ldHN1cmZ8YW1heWF8bHlueHx3M20pXFwvKFtcXHdcXC5dKykvaSwgLy8gV2ViS2l0L1RyaWRlbnQvTmV0RnJvbnQvTmV0U3VyZi9BbWF5YS9MeW54L3czbVxuICAgICAgICAvKGtodG1sfHRhc21hbnxsaW5rcylbXFwvXFxzXVxcKD8oW1xcd1xcLl0rKS9pLCAvLyBLSFRNTC9UYXNtYW4vTGlua3NcbiAgICAgICAgLyhpY2FiKVtcXC9cXHNdKFsyM11cXC5bXFxkXFwuXSspL2kgLy8gaUNhYlxuICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFsvcnZcXDooW1xcd1xcLl0rKS4qKGdlY2tvKS9pIC8vIEdlY2tvXG4gICAgICAgIF0sIFtWRVJTSU9OLCBOQU1FXV0sXG5cbiAgICAgICAgb3M6IFtbXG5cbiAgICAgICAgLy8gV2luZG93cyBiYXNlZFxuICAgICAgICAvbWljcm9zb2Z0XFxzKHdpbmRvd3MpXFxzKHZpc3RhfHhwKS9pIC8vIFdpbmRvd3MgKGlUdW5lcylcbiAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbLyh3aW5kb3dzKVxcc250XFxzNlxcLjI7XFxzKGFybSkvaSwgLy8gV2luZG93cyBSVFxuICAgICAgICAvKHdpbmRvd3NcXHNwaG9uZSg/Olxcc29zKSp8d2luZG93c1xcc21vYmlsZXx3aW5kb3dzKVtcXHNcXC9dPyhbbnRjZVxcZFxcLlxcc10rXFx3KS9pXSwgW1tOQU1FLCBtYXBwZXIuc3RyLCBtYXBzLm9zLndpbmRvd3MubmFtZV0sIFtWRVJTSU9OLCBtYXBwZXIuc3RyLCBtYXBzLm9zLndpbmRvd3MudmVyc2lvbl1dLCBbLyh3aW4oPz0zfDl8bil8d2luXFxzOXhcXHMpKFtudFxcZFxcLl0rKS9pXSwgW1tOQU1FLCAnV2luZG93cyddLCBbVkVSU0lPTiwgbWFwcGVyLnN0ciwgbWFwcy5vcy53aW5kb3dzLnZlcnNpb25dXSwgW1xuXG4gICAgICAgIC8vIE1vYmlsZS9FbWJlZGRlZCBPU1xuICAgICAgICAvXFwoKGJiKSgxMCk7L2kgLy8gQmxhY2tCZXJyeSAxMFxuICAgICAgICBdLCBbW05BTUUsICdCbGFja0JlcnJ5J10sIFZFUlNJT05dLCBbLyhibGFja2JlcnJ5KVxcdypcXC8/KFtcXHdcXC5dKykqL2ksIC8vIEJsYWNrYmVycnlcbiAgICAgICAgLyh0aXplbilbXFwvXFxzXShbXFx3XFwuXSspL2ksIC8vIFRpemVuXG4gICAgICAgIC8oYW5kcm9pZHx3ZWJvc3xwYWxtXFxzb3N8cW54fGJhZGF8cmltXFxzdGFibGV0XFxzb3N8bWVlZ298Y29udGlraSlbXFwvXFxzLV0/KFtcXHdcXC5dKykqL2ksXG4gICAgICAgIC8vIEFuZHJvaWQvV2ViT1MvUGFsbS9RTlgvQmFkYS9SSU0vTWVlR28vQ29udGlraVxuICAgICAgICAvbGludXg7Lisoc2FpbGZpc2gpOy9pIC8vIFNhaWxmaXNoIE9TXG4gICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgWy8oc3ltYmlhblxccz9vP3M/fHN5bWJvc3xzNjAoPz07KSlbXFwvXFxzLV0/KFtcXHdcXC5dKykqL2kgLy8gU3ltYmlhblxuICAgICAgICBdLCBbW05BTUUsICdTeW1iaWFuJ10sIFZFUlNJT05dLCBbL1xcKChzZXJpZXM0MCk7L2kgLy8gU2VyaWVzIDQwXG4gICAgICAgIF0sIFtOQU1FXSwgWy9tb3ppbGxhLitcXChtb2JpbGU7LitnZWNrby4rZmlyZWZveC9pIC8vIEZpcmVmb3ggT1NcbiAgICAgICAgXSwgW1tOQU1FLCAnRmlyZWZveCBPUyddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgIC8vIENvbnNvbGVcbiAgICAgICAgLyhuaW50ZW5kb3xwbGF5c3RhdGlvbilcXHMoW3dpZHMzNHBvcnRhYmxldnVdKykvaSwgLy8gTmludGVuZG8vUGxheXN0YXRpb25cblxuICAgICAgICAvLyBHTlUvTGludXggYmFzZWRcbiAgICAgICAgLyhtaW50KVtcXC9cXHNcXChdPyhcXHcrKSovaSwgLy8gTWludFxuICAgICAgICAvKG1hZ2VpYXx2ZWN0b3JsaW51eClbO1xcc10vaSwgLy8gTWFnZWlhL1ZlY3RvckxpbnV4XG4gICAgICAgIC8oam9saXxba3hsbl0/dWJ1bnR1fGRlYmlhbnxbb3Blbl0qc3VzZXxnZW50b298KD89XFxzKWFyY2h8c2xhY2t3YXJlfGZlZG9yYXxtYW5kcml2YXxjZW50b3N8cGNsaW51eG9zfHJlZGhhdHx6ZW53YWxrfGxpbnB1cylbXFwvXFxzLV0/KFtcXHdcXC4tXSspKi9pLFxuICAgICAgICAvLyBKb2xpL1VidW50dS9EZWJpYW4vU1VTRS9HZW50b28vQXJjaC9TbGFja3dhcmVcbiAgICAgICAgLy8gRmVkb3JhL01hbmRyaXZhL0NlbnRPUy9QQ0xpbnV4T1MvUmVkSGF0L1plbndhbGsvTGlucHVzXG4gICAgICAgIC8oaHVyZHxsaW51eClcXHM/KFtcXHdcXC5dKykqL2ksIC8vIEh1cmQvTGludXhcbiAgICAgICAgLyhnbnUpXFxzPyhbXFx3XFwuXSspKi9pIC8vIEdOVVxuICAgICAgICBdLCBbW05BTUUsICdMaW51eCddLCBWRVJTSU9OXSwgWy8oY3JvcylcXHNbXFx3XStcXHMoW1xcd1xcLl0rXFx3KS9pIC8vIENocm9taXVtIE9TXG4gICAgICAgIF0sIFtbTkFNRSwgJ0Nocm9taXVtIE9TJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgLy8gU29sYXJpc1xuICAgICAgICAvKHN1bm9zKVxccz8oW1xcd1xcLl0rXFxkKSovaSAvLyBTb2xhcmlzXG4gICAgICAgIF0sIFtbTkFNRSwgJ1NvbGFyaXMnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAvLyBCU0QgYmFzZWRcbiAgICAgICAgL1xccyhbZnJlbnRvcGMtXXswLDR9YnNkfGRyYWdvbmZseSlcXHM/KFtcXHdcXC5dKykqL2kgLy8gRnJlZUJTRC9OZXRCU0QvT3BlbkJTRC9QQy1CU0QvRHJhZ29uRmx5XG4gICAgICAgIF0sIFtbTkFNRSwgJ0xpbnV4J10sIFZFUlNJT05dLCBbLyhpcGhvbmUpKD86Lipvc1xccyooW1xcd10rKSpcXHNsaWtlXFxzbWFjfDtcXHNvcGVyYSkvaSAvLyBpT1NcbiAgICAgICAgXSwgW1tOQU1FLCAnaVBob25lJ10sIFtWRVJTSU9OLCAvXy9nLCAnLiddXSwgWy8oaXBhZCkoPzouKm9zXFxzKihbXFx3XSspKlxcc2xpa2VcXHNtYWN8O1xcc29wZXJhKS9pIC8vIGlPU1xuICAgICAgICBdLCBbW05BTUUsICdpUGFkJ10sIFtWRVJTSU9OLCAvXy9nLCAnLiddXSwgWy8oaXBbaG9uZWFkXSspKD86Lipvc1xccyhbXFx3XSspKlxcc2xpa2VcXHNtYWN8O1xcc29wZXJhKS9pIC8vIGlPU1xuICAgICAgICBdLCBbW05BTUUsICdpT1MnXSwgW1ZFUlNJT04sIC9fL2csICcuJ11dLCBbLyhtYWNcXHNvc1xcc3gpXFxzPyhbXFx3XFxzXFwuXStcXHcpKi9pLCAvKG1hY2ludG9zaHxtYWMoPz1fcG93ZXJwYylcXHMpL2kgLy8gTWFjIE9TXG4gICAgICAgIF0sIFtbTkFNRSwgJ01hYyddLCBbVkVSU0lPTiwgL18vZywgJy4nXV0sIFtcblxuICAgICAgICAvLyBPdGhlclxuICAgICAgICAvKCg/Om9wZW4pP3NvbGFyaXMpW1xcL1xccy1dPyhbXFx3XFwuXSspKi9pLCAvLyBTb2xhcmlzXG4gICAgICAgIC8oaGFpa3UpXFxzKFxcdyspL2ksIC8vIEhhaWt1XG4gICAgICAgIC8oYWl4KVxccygoXFxkKSg/PVxcLnxcXCl8XFxzKVtcXHdcXC5dKikqL2ksIC8vIEFJWFxuICAgICAgICAvKHBsYW5cXHM5fG1pbml4fGJlb3N8b3NcXC8yfGFtaWdhb3N8bW9ycGhvc3xyaXNjXFxzb3N8b3BlbnZtcykvaSxcbiAgICAgICAgLy8gUGxhbjkvTWluaXgvQmVPUy9PUzIvQW1pZ2FPUy9Nb3JwaE9TL1JJU0NPUy9PcGVuVk1TXG4gICAgICAgIC8odW5peClcXHM/KFtcXHdcXC5dKykqL2kgLy8gVU5JWFxuICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl1dXG4gICAgICB9O1xuXG4gICAgICAvLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgLy8gQ29uc3RydWN0b3JcbiAgICAgIC8vLy8vLy8vLy8vLy8vLy9cblxuXG4gICAgICB2YXIgVUFQYXJzZXIgPSBmdW5jdGlvbiBVQVBhcnNlcih1YXN0cmluZywgZXh0ZW5zaW9ucykge1xuXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVQVBhcnNlcikpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVBUGFyc2VyKHVhc3RyaW5nLCBleHRlbnNpb25zKS5nZXRSZXN1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1YSA9IHVhc3RyaW5nIHx8ICh3aW5kb3cgJiYgd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCA/IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50IDogRU1QVFkpO1xuICAgICAgICB2YXIgcmd4bWFwID0gZXh0ZW5zaW9ucyA/IHV0aWwuZXh0ZW5kKHJlZ2V4ZXMsIGV4dGVuc2lvbnMpIDogcmVnZXhlcztcblxuICAgICAgICB0aGlzLmdldEJyb3dzZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGJyb3dzZXIgPSBtYXBwZXIucmd4LmFwcGx5KHRoaXMsIHJneG1hcC5icm93c2VyKTtcbiAgICAgICAgICBicm93c2VyLm1ham9yID0gdXRpbC5tYWpvcihicm93c2VyLnZlcnNpb24pO1xuICAgICAgICAgIHJldHVybiBicm93c2VyO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldENQVSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbWFwcGVyLnJneC5hcHBseSh0aGlzLCByZ3htYXAuY3B1KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXREZXZpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG1hcHBlci5yZ3guYXBwbHkodGhpcywgcmd4bWFwLmRldmljZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0RW5naW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBtYXBwZXIucmd4LmFwcGx5KHRoaXMsIHJneG1hcC5lbmdpbmUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldE9TID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBtYXBwZXIucmd4LmFwcGx5KHRoaXMsIHJneG1hcC5vcyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0UmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1YTogdGhpcy5nZXRVQSgpLFxuICAgICAgICAgICAgYnJvd3NlcjogdGhpcy5nZXRCcm93c2VyKCksXG4gICAgICAgICAgICBlbmdpbmU6IHRoaXMuZ2V0RW5naW5lKCksXG4gICAgICAgICAgICBvczogdGhpcy5nZXRPUygpLFxuICAgICAgICAgICAgZGV2aWNlOiB0aGlzLmdldERldmljZSgpLFxuICAgICAgICAgICAgY3B1OiB0aGlzLmdldENQVSgpXG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRVQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdWE7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0VUEgPSBmdW5jdGlvbiAodWFzdHJpbmcpIHtcbiAgICAgICAgICB1YSA9IHVhc3RyaW5nO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIFVBUGFyc2VyLlZFUlNJT04gPSBMSUJWRVJTSU9OO1xuICAgICAgVUFQYXJzZXIuQlJPV1NFUiA9IHtcbiAgICAgICAgTkFNRTogTkFNRSxcbiAgICAgICAgTUFKT1I6IE1BSk9SLCAvLyBkZXByZWNhdGVkXG4gICAgICAgIFZFUlNJT046IFZFUlNJT05cbiAgICAgIH07XG4gICAgICBVQVBhcnNlci5DUFUgPSB7XG4gICAgICAgIEFSQ0hJVEVDVFVSRTogQVJDSElURUNUVVJFXG4gICAgICB9O1xuICAgICAgVUFQYXJzZXIuREVWSUNFID0ge1xuICAgICAgICBNT0RFTDogTU9ERUwsXG4gICAgICAgIFZFTkRPUjogVkVORE9SLFxuICAgICAgICBUWVBFOiBUWVBFLFxuICAgICAgICBDT05TT0xFOiBDT05TT0xFLFxuICAgICAgICBNT0JJTEU6IE1PQklMRSxcbiAgICAgICAgU01BUlRUVjogU01BUlRUVixcbiAgICAgICAgVEFCTEVUOiBUQUJMRVQsXG4gICAgICAgIFdFQVJBQkxFOiBXRUFSQUJMRSxcbiAgICAgICAgRU1CRURERUQ6IEVNQkVEREVEXG4gICAgICB9O1xuICAgICAgVUFQYXJzZXIuRU5HSU5FID0ge1xuICAgICAgICBOQU1FOiBOQU1FLFxuICAgICAgICBWRVJTSU9OOiBWRVJTSU9OXG4gICAgICB9O1xuICAgICAgVUFQYXJzZXIuT1MgPSB7XG4gICAgICAgIE5BTUU6IE5BTUUsXG4gICAgICAgIFZFUlNJT046IFZFUlNJT05cbiAgICAgIH07XG5cbiAgICAgIC8vLy8vLy8vLy8vXG4gICAgICAvLyBFeHBvcnRcbiAgICAgIC8vLy8vLy8vLy9cblxuXG4gICAgICAvLyBjaGVjayBqcyBlbnZpcm9ubWVudFxuICAgICAgaWYgKCdvYmplY3QnICE9PSBVTkRFRl9UWVBFKSB7XG4gICAgICAgIC8vIG5vZGVqcyBlbnZcbiAgICAgICAgaWYgKCdvYmplY3QnICE9PSBVTkRFRl9UWVBFICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gVUFQYXJzZXI7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0cy5VQVBhcnNlciA9IFVBUGFyc2VyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVxdWlyZWpzIGVudiAob3B0aW9uYWwpXG4gICAgICAgIGlmICgodHlwZW9mIHVuZGVmaW5lZCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YyKHVuZGVmaW5lZCkpID09PSBGVU5DX1RZUEUgJiYgdW5kZWZpbmVkLmFtZCkge1xuICAgICAgICAgIHVuZGVmaW5lZChcInVhLXBhcnNlci1qc1wiLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFVBUGFyc2VyO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGJyb3dzZXIgZW52XG4gICAgICAgICAgd2luZG93LlVBUGFyc2VyID0gVUFQYXJzZXI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8galF1ZXJ5L1plcHRvIHNwZWNpZmljIChvcHRpb25hbClcbiAgICAgIC8vIE5vdGU6XG4gICAgICAvLyAgIEluIEFNRCBlbnYgdGhlIGdsb2JhbCBzY29wZSBzaG91bGQgYmUga2VwdCBjbGVhbiwgYnV0IGpRdWVyeSBpcyBhbiBleGNlcHRpb24uXG4gICAgICAvLyAgIGpRdWVyeSBhbHdheXMgZXhwb3J0cyB0byBnbG9iYWwgc2NvcGUsIHVubGVzcyBqUXVlcnkubm9Db25mbGljdCh0cnVlKSBpcyB1c2VkLFxuICAgICAgLy8gICBhbmQgd2Ugc2hvdWxkIGNhdGNoIHRoYXQuXG4gICAgICB2YXIgJCA9IHdpbmRvdy5qUXVlcnkgfHwgd2luZG93LlplcHRvO1xuICAgICAgaWYgKCh0eXBlb2YgJCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YyKCQpKSAhPT0gVU5ERUZfVFlQRSkge1xuICAgICAgICB2YXIgcGFyc2VyID0gbmV3IFVBUGFyc2VyKCk7XG4gICAgICAgICQudWEgPSBwYXJzZXIuZ2V0UmVzdWx0KCk7XG4gICAgICAgICQudWEuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwYXJzZXIuZ2V0VUEoKTtcbiAgICAgICAgfTtcbiAgICAgICAgJC51YS5zZXQgPSBmdW5jdGlvbiAodWFzdHJpbmcpIHtcbiAgICAgICAgICBwYXJzZXIuc2V0VUEodWFzdHJpbmcpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBwYXJzZXIuZ2V0UmVzdWx0KCk7XG4gICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICQudWFbcHJvcF0gPSByZXN1bHRbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pKCh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZjIod2luZG93KSkgPT09ICdvYmplY3QnID8gd2luZG93IDogY29tbW9uanNHbG9iYWwpO1xuICB9KTtcblxuICAvKiBqc2hpbnQgYml0d2lzZTogZmFsc2UsIGxheGJyZWFrOiB0cnVlICovXG5cbiAgLyoqXG4gICAqIFNvdXJjZTogW2plZCdzIGdpc3Rde0BsaW5rIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzk4Mjg4M30uXG4gICAqIFJldHVybnMgYSByYW5kb20gdjQgVVVJRCBvZiB0aGUgZm9ybSB4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgsXG4gICAqIHdoZXJlIGVhY2ggeCBpcyByZXBsYWNlZCB3aXRoIGEgcmFuZG9tIGhleGFkZWNpbWFsIGRpZ2l0IGZyb20gMCB0byBmLCBhbmRcbiAgICogeSBpcyByZXBsYWNlZCB3aXRoIGEgcmFuZG9tIGhleGFkZWNpbWFsIGRpZ2l0IGZyb20gOCB0byBiLlxuICAgKiBVc2VkIHRvIGdlbmVyYXRlIFVVSURzIGZvciBkZXZpY2VJZHMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB2YXIgdXVpZCQxID0gZnVuY3Rpb24gdXVpZChhKSB7XG4gICAgcmV0dXJuIGEgLy8gaWYgdGhlIHBsYWNlaG9sZGVyIHdhcyBwYXNzZWQsIHJldHVyblxuICAgID8gKCAvLyBhIHJhbmRvbSBudW1iZXIgZnJvbSAwIHRvIDE1XG4gICAgYSBeIC8vIHVubGVzcyBiIGlzIDgsXG4gICAgTWF0aC5yYW5kb20oKSAvLyBpbiB3aGljaCBjYXNlXG4gICAgKiAxNiAvLyBhIHJhbmRvbSBudW1iZXIgZnJvbVxuICAgID4+IGEgLyA0IC8vIDggdG8gMTFcbiAgICApLnRvU3RyaW5nKDE2KSAvLyBpbiBoZXhhZGVjaW1hbFxuICAgIDogKCAvLyBvciBvdGhlcndpc2UgYSBjb25jYXRlbmF0ZWQgc3RyaW5nOlxuICAgIFsxZTddICsgLy8gMTAwMDAwMDAgK1xuICAgIC0xZTMgKyAvLyAtMTAwMCArXG4gICAgLTRlMyArIC8vIC00MDAwICtcbiAgICAtOGUzICsgLy8gLTgwMDAwMDAwICtcbiAgICAtMWUxMSAvLyAtMTAwMDAwMDAwMDAwLFxuICAgICkucmVwbGFjZSggLy8gcmVwbGFjaW5nXG4gICAgL1swMThdL2csIC8vIHplcm9lcywgb25lcywgYW5kIGVpZ2h0cyB3aXRoXG4gICAgdXVpZCAvLyByYW5kb20gaGV4IGRpZ2l0c1xuICAgICk7XG4gIH07XG5cbiAgdmFyIHZlcnNpb24gPSAnMy44LjAnO1xuXG4gIHZhciBnZXRMYW5ndWFnZSA9IGZ1bmN0aW9uIGdldExhbmd1YWdlKCkge1xuICAgIHJldHVybiBuYXZpZ2F0b3IgJiYgKG5hdmlnYXRvci5sYW5ndWFnZXMgJiYgbmF2aWdhdG9yLmxhbmd1YWdlc1swXSB8fCBuYXZpZ2F0b3IubGFuZ3VhZ2UgfHwgbmF2aWdhdG9yLnVzZXJMYW5ndWFnZSkgfHwgdW5kZWZpbmVkO1xuICB9O1xuXG4gIHZhciBsYW5ndWFnZSA9IHtcbiAgICBsYW5ndWFnZTogZ2V0TGFuZ3VhZ2UoKVxuICB9O1xuXG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIGFwaUVuZHBvaW50OiAnYXBpLmFtcGxpdHVkZS5jb20nLFxuICAgIGNvb2tpZUV4cGlyYXRpb246IDM2NSAqIDEwLFxuICAgIGNvb2tpZU5hbWU6ICdhbXBsaXR1ZGVfaWQnLFxuICAgIGRvbWFpbjogJycsXG4gICAgaW5jbHVkZVJlZmVycmVyOiBmYWxzZSxcbiAgICBpbmNsdWRlVXRtOiBmYWxzZSxcbiAgICBsYW5ndWFnZTogbGFuZ3VhZ2UubGFuZ3VhZ2UsXG4gICAgbG9nTGV2ZWw6ICdXQVJOJyxcbiAgICBvcHRPdXQ6IGZhbHNlLFxuICAgIHBsYXRmb3JtOiAnV2ViJyxcbiAgICBzYXZlZE1heENvdW50OiAxMDAwLFxuICAgIHNhdmVFdmVudHM6IHRydWUsXG4gICAgc2Vzc2lvblRpbWVvdXQ6IDMwICogNjAgKiAxMDAwLFxuICAgIHVuc2VudEtleTogJ2FtcGxpdHVkZV91bnNlbnQnLFxuICAgIHVuc2VudElkZW50aWZ5S2V5OiAnYW1wbGl0dWRlX3Vuc2VudF9pZGVudGlmeScsXG4gICAgdXBsb2FkQmF0Y2hTaXplOiAxMDAsXG4gICAgYmF0Y2hFdmVudHM6IGZhbHNlLFxuICAgIGV2ZW50VXBsb2FkVGhyZXNob2xkOiAzMCxcbiAgICBldmVudFVwbG9hZFBlcmlvZE1pbGxpczogMzAgKiAxMDAwLCAvLyAzMHNcbiAgICBmb3JjZUh0dHBzOiBmYWxzZSxcbiAgICBpbmNsdWRlR2NsaWQ6IGZhbHNlLFxuICAgIHNhdmVQYXJhbXNSZWZlcnJlck9uY2VQZXJTZXNzaW9uOiB0cnVlLFxuICAgIGRldmljZUlkRnJvbVVybFBhcmFtOiBmYWxzZVxuICB9O1xuXG4gIC8qKlxuICAgKiBBbXBsaXR1ZGVDbGllbnQgU0RLIEFQSSAtIGluc3RhbmNlIGNvbnN0cnVjdG9yLlxuICAgKiBUaGUgQW1wbGl0dWRlIGNsYXNzIGhhbmRsZXMgY3JlYXRpb24gb2YgY2xpZW50IGluc3RhbmNlcywgYWxsIHlvdSBuZWVkIHRvIGRvIGlzIGNhbGwgYW1wbGl0dWRlLmdldEluc3RhbmNlKClcbiAgICogQGNvbnN0cnVjdG9yIEFtcGxpdHVkZUNsaWVudFxuICAgKiBAcHVibGljXG4gICAqIEBleGFtcGxlIHZhciBhbXBsaXR1ZGVDbGllbnQgPSBuZXcgQW1wbGl0dWRlQ2xpZW50KCk7XG4gICAqL1xuICB2YXIgQW1wbGl0dWRlQ2xpZW50ID0gZnVuY3Rpb24gQW1wbGl0dWRlQ2xpZW50KGluc3RhbmNlTmFtZSkge1xuICAgIHRoaXMuX2luc3RhbmNlTmFtZSA9IHV0aWxzLmlzRW1wdHlTdHJpbmcoaW5zdGFuY2VOYW1lKSA/IGNvbnN0YW50cy5ERUZBVUxUX0lOU1RBTkNFIDogaW5zdGFuY2VOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5fc3RvcmFnZVN1ZmZpeCA9IHRoaXMuX2luc3RhbmNlTmFtZSA9PT0gY29uc3RhbnRzLkRFRkFVTFRfSU5TVEFOQ0UgPyAnJyA6ICdfJyArIHRoaXMuX2luc3RhbmNlTmFtZTtcbiAgICB0aGlzLl91bnNlbnRFdmVudHMgPSBbXTtcbiAgICB0aGlzLl91bnNlbnRJZGVudGlmeXMgPSBbXTtcbiAgICB0aGlzLl91YSA9IG5ldyB1YVBhcnNlcihuYXZpZ2F0b3IudXNlckFnZW50KS5nZXRSZXN1bHQoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBhc3NpZ25fMSQxKHt9LCBERUZBVUxUX09QVElPTlMpO1xuICAgIHRoaXMuY29va2llU3RvcmFnZSA9IG5ldyBjb29raWVTdG9yYWdlKCkuZ2V0U3RvcmFnZSgpO1xuICAgIHRoaXMuX3EgPSBbXTsgLy8gcXVldWUgZm9yIHByb3hpZWQgZnVuY3Rpb25zIGJlZm9yZSBzY3JpcHQgbG9hZFxuICAgIHRoaXMuX3NlbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl91cGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAgIC8vIGV2ZW50IG1ldGEgZGF0YVxuICAgIHRoaXMuX2V2ZW50SWQgPSAwO1xuICAgIHRoaXMuX2lkZW50aWZ5SWQgPSAwO1xuICAgIHRoaXMuX2xhc3RFdmVudFRpbWUgPSBudWxsO1xuICAgIHRoaXMuX25ld1Nlc3Npb24gPSBmYWxzZTtcbiAgICB0aGlzLl9zZXF1ZW5jZU51bWJlciA9IDA7XG4gICAgdGhpcy5fc2Vzc2lvbklkID0gbnVsbDtcblxuICAgIHRoaXMuX3VzZXJBZ2VudCA9IG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50IHx8IG51bGw7XG4gIH07XG5cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5JZGVudGlmeSA9IElkZW50aWZ5O1xuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLlJldmVudWUgPSBSZXZlbnVlO1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgQW1wbGl0dWRlIEphdmFzY3JpcHQgU0RLIHdpdGggeW91ciBhcGlLZXkgYW5kIGFueSBvcHRpb25hbCBjb25maWd1cmF0aW9ucy5cbiAgICogVGhpcyBpcyByZXF1aXJlZCBiZWZvcmUgYW55IG90aGVyIG1ldGhvZHMgY2FuIGJlIGNhbGxlZC5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gYXBpS2V5IC0gVGhlIEFQSSBrZXkgZm9yIHlvdXIgYXBwLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0X3VzZXJJZCAtIChvcHRpb25hbCkgQW4gaWRlbnRpZmllciBmb3IgdGhpcyB1c2VyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0X2NvbmZpZyAtIChvcHRpb25hbCkgQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgKiBTZWUgW1JlYWRtZV17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FtcGxpdHVkZS9BbXBsaXR1ZGUtSmF2YXNjcmlwdCNjb25maWd1cmF0aW9uLW9wdGlvbnN9IGZvciBsaXN0IG9mIG9wdGlvbnMgYW5kIGRlZmF1bHQgdmFsdWVzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRfY2FsbGJhY2sgLSAob3B0aW9uYWwpIFByb3ZpZGUgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBydW4gYWZ0ZXIgaW5pdGlhbGl6YXRpb24gaXMgY29tcGxldGUuXG4gICAqIEBleGFtcGxlIGFtcGxpdHVkZUNsaWVudC5pbml0KCdBUElfS0VZJywgJ1VTRVJfSUQnLCB7aW5jbHVkZVJlZmVycmVyOiB0cnVlLCBpbmNsdWRlVXRtOiB0cnVlfSwgZnVuY3Rpb24oKSB7IGFsZXJ0KCdpbml0IGNvbXBsZXRlJyk7IH0pO1xuICAgKi9cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdChhcGlLZXksIG9wdF91c2VySWQsIG9wdF9jb25maWcsIG9wdF9jYWxsYmFjaykge1xuICAgIGlmICh0eXBlKGFwaUtleSkgIT09ICdzdHJpbmcnIHx8IHV0aWxzLmlzRW1wdHlTdHJpbmcoYXBpS2V5KSkge1xuICAgICAgdXRpbHMubG9nLmVycm9yKCdJbnZhbGlkIGFwaUtleS4gUGxlYXNlIHJlLWluaXRpYWxpemUgd2l0aCBhIHZhbGlkIGFwaUtleScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB0aGlzLm9wdGlvbnMuYXBpS2V5ID0gYXBpS2V5O1xuICAgICAgX3BhcnNlQ29uZmlnKHRoaXMub3B0aW9ucywgb3B0X2NvbmZpZyk7XG4gICAgICB0aGlzLmNvb2tpZVN0b3JhZ2Uub3B0aW9ucyh7XG4gICAgICAgIGV4cGlyYXRpb25EYXlzOiB0aGlzLm9wdGlvbnMuY29va2llRXhwaXJhdGlvbixcbiAgICAgICAgZG9tYWluOiB0aGlzLm9wdGlvbnMuZG9tYWluXG4gICAgICB9KTtcbiAgICAgIHRoaXMub3B0aW9ucy5kb21haW4gPSB0aGlzLmNvb2tpZVN0b3JhZ2Uub3B0aW9ucygpLmRvbWFpbjtcblxuICAgICAgaWYgKHRoaXMuX2luc3RhbmNlTmFtZSA9PT0gY29uc3RhbnRzLkRFRkFVTFRfSU5TVEFOQ0UpIHtcbiAgICAgICAgX3VwZ3JhZGVDb29rZURhdGEodGhpcyk7XG4gICAgICB9XG4gICAgICBfbG9hZENvb2tpZURhdGEodGhpcyk7XG5cbiAgICAgIC8vIGxvYWQgZGV2aWNlSWQgYW5kIHVzZXJJZCBmcm9tIGlucHV0LCBvciB0cnkgdG8gZmV0Y2ggZXhpc3RpbmcgdmFsdWUgZnJvbSBjb29raWVcbiAgICAgIHRoaXMub3B0aW9ucy5kZXZpY2VJZCA9IHR5cGUob3B0X2NvbmZpZykgPT09ICdvYmplY3QnICYmIHR5cGUob3B0X2NvbmZpZy5kZXZpY2VJZCkgPT09ICdzdHJpbmcnICYmICF1dGlscy5pc0VtcHR5U3RyaW5nKG9wdF9jb25maWcuZGV2aWNlSWQpICYmIG9wdF9jb25maWcuZGV2aWNlSWQgfHwgdGhpcy5vcHRpb25zLmRldmljZUlkRnJvbVVybFBhcmFtICYmIHRoaXMuX2dldERldmljZUlkRnJvbVVybFBhcmFtKHRoaXMuX2dldFVybFBhcmFtcygpKSB8fCB0aGlzLm9wdGlvbnMuZGV2aWNlSWQgfHwgdXVpZCQxKCkgKyAnUic7XG4gICAgICB0aGlzLm9wdGlvbnMudXNlcklkID0gdHlwZShvcHRfdXNlcklkKSA9PT0gJ3N0cmluZycgJiYgIXV0aWxzLmlzRW1wdHlTdHJpbmcob3B0X3VzZXJJZCkgJiYgb3B0X3VzZXJJZCB8fCB0aGlzLm9wdGlvbnMudXNlcklkIHx8IG51bGw7XG5cbiAgICAgIC8vIGxvYWQgdW5zZW50IGV2ZW50cyBhbmQgaWRlbnRpZmllcyBiZWZvcmUgYW55IGF0dGVtcHQgdG8gbG9nIG5ldyBvbmVzXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNhdmVFdmVudHMpIHtcbiAgICAgICAgdGhpcy5fdW5zZW50RXZlbnRzID0gdGhpcy5fbG9hZFNhdmVkVW5zZW50RXZlbnRzKHRoaXMub3B0aW9ucy51bnNlbnRLZXkpO1xuICAgICAgICB0aGlzLl91bnNlbnRJZGVudGlmeXMgPSB0aGlzLl9sb2FkU2F2ZWRVbnNlbnRFdmVudHModGhpcy5vcHRpb25zLnVuc2VudElkZW50aWZ5S2V5KTtcblxuICAgICAgICAvLyB2YWxpZGF0ZSBldmVudCBwcm9wZXJ0aWVzIGZvciB1bnNlbnQgZXZlbnRzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdW5zZW50RXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGV2ZW50UHJvcGVydGllcyA9IHRoaXMuX3Vuc2VudEV2ZW50c1tpXS5ldmVudF9wcm9wZXJ0aWVzO1xuICAgICAgICAgIHZhciBncm91cHMgPSB0aGlzLl91bnNlbnRFdmVudHNbaV0uZ3JvdXBzO1xuICAgICAgICAgIHRoaXMuX3Vuc2VudEV2ZW50c1tpXS5ldmVudF9wcm9wZXJ0aWVzID0gdXRpbHMudmFsaWRhdGVQcm9wZXJ0aWVzKGV2ZW50UHJvcGVydGllcyk7XG4gICAgICAgICAgdGhpcy5fdW5zZW50RXZlbnRzW2ldLmdyb3VwcyA9IHV0aWxzLnZhbGlkYXRlR3JvdXBzKGdyb3Vwcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZGF0ZSB1c2VyIHByb3BlcnRpZXMgZm9yIHVuc2VudCBpZGVudGlmeXNcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl91bnNlbnRJZGVudGlmeXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgdXNlclByb3BlcnRpZXMgPSB0aGlzLl91bnNlbnRJZGVudGlmeXNbal0udXNlcl9wcm9wZXJ0aWVzO1xuICAgICAgICAgIHZhciBpZGVudGlmeUdyb3VwcyA9IHRoaXMuX3Vuc2VudElkZW50aWZ5c1tqXS5ncm91cHM7XG4gICAgICAgICAgdGhpcy5fdW5zZW50SWRlbnRpZnlzW2pdLnVzZXJfcHJvcGVydGllcyA9IHV0aWxzLnZhbGlkYXRlUHJvcGVydGllcyh1c2VyUHJvcGVydGllcyk7XG4gICAgICAgICAgdGhpcy5fdW5zZW50SWRlbnRpZnlzW2pdLmdyb3VwcyA9IHV0aWxzLnZhbGlkYXRlR3JvdXBzKGlkZW50aWZ5R3JvdXBzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICBpZiAoIXRoaXMuX3Nlc3Npb25JZCB8fCAhdGhpcy5fbGFzdEV2ZW50VGltZSB8fCBub3cgLSB0aGlzLl9sYXN0RXZlbnRUaW1lID4gdGhpcy5vcHRpb25zLnNlc3Npb25UaW1lb3V0KSB7XG4gICAgICAgIHRoaXMuX25ld1Nlc3Npb24gPSB0cnVlO1xuICAgICAgICB0aGlzLl9zZXNzaW9uSWQgPSBub3c7XG5cbiAgICAgICAgLy8gb25seSBjYXB0dXJlIFVUTSBwYXJhbXMgYW5kIHJlZmVycmVyIGlmIG5ldyBzZXNzaW9uXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2F2ZVBhcmFtc1JlZmVycmVyT25jZVBlclNlc3Npb24pIHtcbiAgICAgICAgICB0aGlzLl90cmFja1BhcmFtc0FuZFJlZmVycmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2F2ZVBhcmFtc1JlZmVycmVyT25jZVBlclNlc3Npb24pIHtcbiAgICAgICAgdGhpcy5fdHJhY2tQYXJhbXNBbmRSZWZlcnJlcigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9sYXN0RXZlbnRUaW1lID0gbm93O1xuICAgICAgX3NhdmVDb29raWVEYXRhKHRoaXMpO1xuXG4gICAgICB0aGlzLl9zZW5kRXZlbnRzSWZSZWFkeSgpOyAvLyB0cnkgc2VuZGluZyB1bnNlbnQgZXZlbnRzXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdXRpbHMubG9nLmVycm9yKGUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodHlwZShvcHRfY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9wdF9jYWxsYmFjayh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLl90cmFja1BhcmFtc0FuZFJlZmVycmVyID0gZnVuY3Rpb24gX3RyYWNrUGFyYW1zQW5kUmVmZXJyZXIoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pbmNsdWRlVXRtKSB7XG4gICAgICB0aGlzLl9pbml0VXRtRGF0YSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmluY2x1ZGVSZWZlcnJlcikge1xuICAgICAgdGhpcy5fc2F2ZVJlZmVycmVyKHRoaXMuX2dldFJlZmVycmVyKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmluY2x1ZGVHY2xpZCkge1xuICAgICAgdGhpcy5fc2F2ZUdjbGlkKHRoaXMuX2dldFVybFBhcmFtcygpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIGFuZCB2YWxpZGF0ZSB1c2VyIHNwZWNpZmllZCBjb25maWcgdmFsdWVzIGFuZCBvdmVyd3JpdGUgZXhpc3Rpbmcgb3B0aW9uIHZhbHVlXG4gICAqIERFRkFVTFRfT1BUSU9OUyBwcm92aWRlcyBsaXN0IG9mIGFsbCBjb25maWcga2V5cyB0aGF0IGFyZSBtb2RpZmlhYmxlLCBhcyB3ZWxsIGFzIGV4cGVjdGVkIHR5cGVzIGZvciB2YWx1ZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHZhciBfcGFyc2VDb25maWcgPSBmdW5jdGlvbiBfcGFyc2VDb25maWcob3B0aW9ucywgY29uZmlnKSB7XG4gICAgaWYgKHR5cGUoY29uZmlnKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB2YWxpZGF0ZXMgY29uZmlnIHZhbHVlIGlzIGRlZmluZWQsIGlzIHRoZSBjb3JyZWN0IHR5cGUsIGFuZCBzb21lIGFkZGl0aW9uYWwgdmFsdWUgc2FuaXR5IGNoZWNrc1xuICAgIHZhciBwYXJzZVZhbGlkYXRlQW5kTG9hZCA9IGZ1bmN0aW9uIHBhcnNlVmFsaWRhdGVBbmRMb2FkKGtleSkge1xuICAgICAgaWYgKCFERUZBVUxUX09QVElPTlMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICByZXR1cm47IC8vIHNraXAgYm9ndXMgY29uZmlnIHZhbHVlc1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5wdXRWYWx1ZSA9IGNvbmZpZ1trZXldO1xuICAgICAgdmFyIGV4cGVjdGVkVHlwZSA9IHR5cGUoREVGQVVMVF9PUFRJT05TW2tleV0pO1xuICAgICAgaWYgKCF1dGlscy52YWxpZGF0ZUlucHV0KGlucHV0VmFsdWUsIGtleSArICcgb3B0aW9uJywgZXhwZWN0ZWRUeXBlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXhwZWN0ZWRUeXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgb3B0aW9uc1trZXldID0gISFpbnB1dFZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdzdHJpbmcnICYmICF1dGlscy5pc0VtcHR5U3RyaW5nKGlucHV0VmFsdWUpIHx8IGV4cGVjdGVkVHlwZSA9PT0gJ251bWJlcicgJiYgaW5wdXRWYWx1ZSA+IDApIHtcbiAgICAgICAgb3B0aW9uc1trZXldID0gaW5wdXRWYWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIGNvbmZpZykge1xuICAgICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHBhcnNlVmFsaWRhdGVBbmRMb2FkKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSdW4gZnVuY3Rpb25zIHF1ZXVlZCB1cCBieSBwcm94eSBsb2FkaW5nIHNuaXBwZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUucnVuUXVldWVkRnVuY3Rpb25zID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZuID0gdGhpc1t0aGlzLl9xW2ldWzBdXTtcbiAgICAgIGlmICh0eXBlKGZuKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmbi5hcHBseSh0aGlzLCB0aGlzLl9xW2ldLnNsaWNlKDEpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fcSA9IFtdOyAvLyBjbGVhciBmdW5jdGlvbiBxdWV1ZSBhZnRlciBydW5uaW5nXG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoYXQgdGhlIGFwaUtleSBpcyBzZXQgYmVmb3JlIGNhbGxpbmcgYSBmdW5jdGlvbi4gTG9ncyBhIHdhcm5pbmcgbWVzc2FnZSBpZiBub3Qgc2V0LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5fYXBpS2V5U2V0ID0gZnVuY3Rpb24gX2FwaUtleVNldChtZXRob2ROYW1lKSB7XG4gICAgaWYgKHV0aWxzLmlzRW1wdHlTdHJpbmcodGhpcy5vcHRpb25zLmFwaUtleSkpIHtcbiAgICAgIHV0aWxzLmxvZy5lcnJvcignSW52YWxpZCBhcGlLZXkuIFBsZWFzZSBzZXQgYSB2YWxpZCBhcGlLZXkgd2l0aCBpbml0KCkgYmVmb3JlIGNhbGxpbmcgJyArIG1ldGhvZE5hbWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogTG9hZCBzYXZlZCBldmVudHMgZnJvbSBsb2NhbFN0b3JhZ2UuIEpTT04gZGVzZXJpYWxpemVzIGV2ZW50IGFycmF5LiBIYW5kbGVzIGNhc2Ugd2hlcmUgc3RyaW5nIGlzIGNvcnJ1cHRlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUuX2xvYWRTYXZlZFVuc2VudEV2ZW50cyA9IGZ1bmN0aW9uIF9sb2FkU2F2ZWRVbnNlbnRFdmVudHModW5zZW50S2V5KSB7XG4gICAgdmFyIHNhdmVkVW5zZW50RXZlbnRzU3RyaW5nID0gdGhpcy5fZ2V0RnJvbVN0b3JhZ2UobG9jYWxTdG9yYWdlJDEsIHVuc2VudEtleSk7XG4gICAgaWYgKHV0aWxzLmlzRW1wdHlTdHJpbmcoc2F2ZWRVbnNlbnRFdmVudHNTdHJpbmcpKSB7XG4gICAgICByZXR1cm4gW107IC8vIG5ldyBhcHAsIGRvZXMgbm90IGhhdmUgYW55IHNhdmVkIGV2ZW50c1xuICAgIH1cblxuICAgIGlmICh0eXBlKHNhdmVkVW5zZW50RXZlbnRzU3RyaW5nKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBldmVudHMgPSBKU09OLnBhcnNlKHNhdmVkVW5zZW50RXZlbnRzU3RyaW5nKTtcbiAgICAgICAgaWYgKHR5cGUoZXZlbnRzKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgIC8vIGhhbmRsZSBjYXNlIHdoZXJlIEpTT04gZHVtcGluZyBvZiB1bnNlbnQgZXZlbnRzIGlzIGNvcnJ1cHRlZFxuICAgICAgICAgIHJldHVybiBldmVudHM7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuICAgIHV0aWxzLmxvZy5lcnJvcignVW5hYmxlIHRvIGxvYWQgJyArIHVuc2VudEtleSArICcgZXZlbnRzLiBSZXN0YXJ0IHdpdGggYSBuZXcgZW1wdHkgcXVldWUuJyk7XG4gICAgcmV0dXJuIFtdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYSBuZXcgc2Vzc2lvbiB3YXMgY3JlYXRlZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24sIG90aGVyd2lzZSBmYWxzZS5cbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIGEgbmV3IHNlc3Npb24gd2FzIGNyZWF0ZWQgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgKi9cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5pc05ld1Nlc3Npb24gPSBmdW5jdGlvbiBpc05ld1Nlc3Npb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX25ld1Nlc3Npb247XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGlkIG9mIHRoZSBjdXJyZW50IHNlc3Npb24uXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybiB7bnVtYmVyfSBJZCBvZiB0aGUgY3VycmVudCBzZXNzaW9uLlxuICAgKi9cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5nZXRTZXNzaW9uSWQgPSBmdW5jdGlvbiBnZXRTZXNzaW9uSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nlc3Npb25JZDtcbiAgfTtcblxuICAvKipcbiAgICogSW5jcmVtZW50cyB0aGUgZXZlbnRJZCBhbmQgcmV0dXJucyBpdC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUubmV4dEV2ZW50SWQgPSBmdW5jdGlvbiBuZXh0RXZlbnRJZCgpIHtcbiAgICB0aGlzLl9ldmVudElkKys7XG4gICAgcmV0dXJuIHRoaXMuX2V2ZW50SWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudHMgdGhlIGlkZW50aWZ5SWQgYW5kIHJldHVybnMgaXQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLm5leHRJZGVudGlmeUlkID0gZnVuY3Rpb24gbmV4dElkZW50aWZ5SWQoKSB7XG4gICAgdGhpcy5faWRlbnRpZnlJZCsrO1xuICAgIHJldHVybiB0aGlzLl9pZGVudGlmeUlkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbmNyZW1lbnRzIHRoZSBzZXF1ZW5jZU51bWJlciBhbmQgcmV0dXJucyBpdC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUubmV4dFNlcXVlbmNlTnVtYmVyID0gZnVuY3Rpb24gbmV4dFNlcXVlbmNlTnVtYmVyKCkge1xuICAgIHRoaXMuX3NlcXVlbmNlTnVtYmVyKys7XG4gICAgcmV0dXJuIHRoaXMuX3NlcXVlbmNlTnVtYmVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0b3RhbCBjb3VudCBvZiB1bnNlbnQgZXZlbnRzIGFuZCBpZGVudGlmeXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUuX3Vuc2VudENvdW50ID0gZnVuY3Rpb24gX3Vuc2VudENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl91bnNlbnRFdmVudHMubGVuZ3RoICsgdGhpcy5fdW5zZW50SWRlbnRpZnlzLmxlbmd0aDtcbiAgfTtcblxuICAvKipcbiAgICogU2VuZCBldmVudHMgaWYgcmVhZHkuIFJldHVybnMgdHJ1ZSBpZiBldmVudHMgYXJlIHNlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLl9zZW5kRXZlbnRzSWZSZWFkeSA9IGZ1bmN0aW9uIF9zZW5kRXZlbnRzSWZSZWFkeShjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl91bnNlbnRDb3VudCgpID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gaWYgYmF0Y2hpbmcgZGlzYWJsZWQsIHNlbmQgYW55IHVuc2VudCBldmVudHMgaW1tZWRpYXRlbHlcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5iYXRjaEV2ZW50cykge1xuICAgICAgdGhpcy5zZW5kRXZlbnRzKGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGlmIGJhdGNoaW5nIGVuYWJsZWQsIGNoZWNrIGlmIG1pbiB0aHJlc2hvbGQgbWV0IGZvciBiYXRjaCBzaXplXG4gICAgaWYgKHRoaXMuX3Vuc2VudENvdW50KCkgPj0gdGhpcy5vcHRpb25zLmV2ZW50VXBsb2FkVGhyZXNob2xkKSB7XG4gICAgICB0aGlzLnNlbmRFdmVudHMoY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlIHNjaGVkdWxlIGFuIHVwbG9hZCBhZnRlciAzMHNcbiAgICBpZiAoIXRoaXMuX3VwZGF0ZVNjaGVkdWxlZCkge1xuICAgICAgLy8gbWFrZSBzdXJlIHdlIG9ubHkgc2NoZWR1bGUgMSB1cGxvYWRcbiAgICAgIHRoaXMuX3VwZGF0ZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VuZEV2ZW50cygpO1xuICAgICAgfS5iaW5kKHRoaXMpLCB0aGlzLm9wdGlvbnMuZXZlbnRVcGxvYWRQZXJpb2RNaWxsaXMpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTsgLy8gYW4gdXBsb2FkIHdhcyBzY2hlZHVsZWQsIG5vIGV2ZW50cyB3ZXJlIHVwbG9hZGVkXG4gIH07XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byBmZXRjaCB2YWx1ZXMgZnJvbSBzdG9yYWdlXG4gICAqIFN0b3JhZ2UgYXJndW1lbnQgYWxsb3dzIGZvciBsb2NhbFN0b3Jhb2dlIGFuZCBzZXNzaW9uU3RvcmFvZ2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUuX2dldEZyb21TdG9yYWdlID0gZnVuY3Rpb24gX2dldEZyb21TdG9yYWdlKHN0b3JhZ2UsIGtleSkge1xuICAgIHJldHVybiBzdG9yYWdlLmdldEl0ZW0oa2V5ICsgdGhpcy5fc3RvcmFnZVN1ZmZpeCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byBzZXQgdmFsdWVzIGluIHN0b3JhZ2VcbiAgICogU3RvcmFnZSBhcmd1bWVudCBhbGxvd3MgZm9yIGxvY2FsU3RvcmFvZ2UgYW5kIHNlc3Npb25TdG9yYW9nZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5fc2V0SW5TdG9yYWdlID0gZnVuY3Rpb24gX3NldEluU3RvcmFnZShzdG9yYWdlLCBrZXksIHZhbHVlKSB7XG4gICAgc3RvcmFnZS5zZXRJdGVtKGtleSArIHRoaXMuX3N0b3JhZ2VTdWZmaXgsIHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogY29va2llRGF0YSAoZGV2aWNlSWQsIHVzZXJJZCwgb3B0T3V0LCBzZXNzaW9uSWQsIGxhc3RFdmVudFRpbWUsIGV2ZW50SWQsIGlkZW50aWZ5SWQsIHNlcXVlbmNlTnVtYmVyKVxuICAgKiBjYW4gYmUgc3RvcmVkIGluIG1hbnkgZGlmZmVyZW50IHBsYWNlcyAobG9jYWxTdG9yYWdlLCBjb29raWUsIGV0YykuXG4gICAqIE5lZWQgdG8gdW5pZnkgYWxsIHNvdXJjZXMgaW50byBvbmUgcGxhY2Ugd2l0aCBhIG9uZS10aW1lIHVwZ3JhZGUvbWlncmF0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFyIF91cGdyYWRlQ29va2VEYXRhID0gZnVuY3Rpb24gX3VwZ3JhZGVDb29rZURhdGEoc2NvcGUpIHtcbiAgICAvLyBza2lwIGlmIG1pZ3JhdGlvbiBhbHJlYWR5IGhhcHBlbmVkXG4gICAgdmFyIGNvb2tpZURhdGEgPSBzY29wZS5jb29raWVTdG9yYWdlLmdldChzY29wZS5vcHRpb25zLmNvb2tpZU5hbWUpO1xuICAgIGlmICh0eXBlKGNvb2tpZURhdGEpID09PSAnb2JqZWN0JyAmJiBjb29raWVEYXRhLmRldmljZUlkICYmIGNvb2tpZURhdGEuc2Vzc2lvbklkICYmIGNvb2tpZURhdGEubGFzdEV2ZW50VGltZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBfZ2V0QW5kUmVtb3ZlRnJvbUxvY2FsU3RvcmFnZSA9IGZ1bmN0aW9uIF9nZXRBbmRSZW1vdmVGcm9tTG9jYWxTdG9yYWdlKGtleSkge1xuICAgICAgdmFyIHZhbHVlID0gbG9jYWxTdG9yYWdlJDEuZ2V0SXRlbShrZXkpO1xuICAgICAgbG9jYWxTdG9yYWdlJDEucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICAvLyBpbiB2Mi42LjAsIGRldmljZUlkLCB1c2VySWQsIG9wdE91dCB3YXMgbWlncmF0ZWQgdG8gbG9jYWxTdG9yYWdlIHdpdGgga2V5cyArIGZpcnN0IDYgY2hhciBvZiBhcGlLZXlcbiAgICB2YXIgYXBpS2V5U3VmZml4ID0gdHlwZShzY29wZS5vcHRpb25zLmFwaUtleSkgPT09ICdzdHJpbmcnICYmICdfJyArIHNjb3BlLm9wdGlvbnMuYXBpS2V5LnNsaWNlKDAsIDYpIHx8ICcnO1xuICAgIHZhciBsb2NhbFN0b3JhZ2VEZXZpY2VJZCA9IF9nZXRBbmRSZW1vdmVGcm9tTG9jYWxTdG9yYWdlKGNvbnN0YW50cy5ERVZJQ0VfSUQgKyBhcGlLZXlTdWZmaXgpO1xuICAgIHZhciBsb2NhbFN0b3JhZ2VVc2VySWQgPSBfZ2V0QW5kUmVtb3ZlRnJvbUxvY2FsU3RvcmFnZShjb25zdGFudHMuVVNFUl9JRCArIGFwaUtleVN1ZmZpeCk7XG4gICAgdmFyIGxvY2FsU3RvcmFnZU9wdE91dCA9IF9nZXRBbmRSZW1vdmVGcm9tTG9jYWxTdG9yYWdlKGNvbnN0YW50cy5PUFRfT1VUICsgYXBpS2V5U3VmZml4KTtcbiAgICBpZiAobG9jYWxTdG9yYWdlT3B0T3V0ICE9PSBudWxsICYmIGxvY2FsU3RvcmFnZU9wdE91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsb2NhbFN0b3JhZ2VPcHRPdXQgPSBTdHJpbmcobG9jYWxTdG9yYWdlT3B0T3V0KSA9PT0gJ3RydWUnOyAvLyBjb252ZXJ0IHRvIGJvb2xlYW5cbiAgICB9XG5cbiAgICAvLyBwcmUtdjIuNy4wIGV2ZW50IGFuZCBzZXNzaW9uIG1ldGEtZGF0YSB3YXMgc3RvcmVkIGluIGxvY2FsU3RvcmFnZS4gbW92ZSB0byBjb29raWUgZm9yIHN1Yi1kb21haW4gc3VwcG9ydFxuICAgIHZhciBsb2NhbFN0b3JhZ2VTZXNzaW9uSWQgPSBwYXJzZUludChfZ2V0QW5kUmVtb3ZlRnJvbUxvY2FsU3RvcmFnZShjb25zdGFudHMuU0VTU0lPTl9JRCkpO1xuICAgIHZhciBsb2NhbFN0b3JhZ2VMYXN0RXZlbnRUaW1lID0gcGFyc2VJbnQoX2dldEFuZFJlbW92ZUZyb21Mb2NhbFN0b3JhZ2UoY29uc3RhbnRzLkxBU1RfRVZFTlRfVElNRSkpO1xuICAgIHZhciBsb2NhbFN0b3JhZ2VFdmVudElkID0gcGFyc2VJbnQoX2dldEFuZFJlbW92ZUZyb21Mb2NhbFN0b3JhZ2UoY29uc3RhbnRzLkxBU1RfRVZFTlRfSUQpKTtcbiAgICB2YXIgbG9jYWxTdG9yYWdlSWRlbnRpZnlJZCA9IHBhcnNlSW50KF9nZXRBbmRSZW1vdmVGcm9tTG9jYWxTdG9yYWdlKGNvbnN0YW50cy5MQVNUX0lERU5USUZZX0lEKSk7XG4gICAgdmFyIGxvY2FsU3RvcmFnZVNlcXVlbmNlTnVtYmVyID0gcGFyc2VJbnQoX2dldEFuZFJlbW92ZUZyb21Mb2NhbFN0b3JhZ2UoY29uc3RhbnRzLkxBU1RfU0VRVUVOQ0VfTlVNQkVSKSk7XG5cbiAgICB2YXIgX2dldEZyb21Db29raWUgPSBmdW5jdGlvbiBfZ2V0RnJvbUNvb2tpZShrZXkpIHtcbiAgICAgIHJldHVybiB0eXBlKGNvb2tpZURhdGEpID09PSAnb2JqZWN0JyAmJiBjb29raWVEYXRhW2tleV07XG4gICAgfTtcbiAgICBzY29wZS5vcHRpb25zLmRldmljZUlkID0gX2dldEZyb21Db29raWUoJ2RldmljZUlkJykgfHwgbG9jYWxTdG9yYWdlRGV2aWNlSWQ7XG4gICAgc2NvcGUub3B0aW9ucy51c2VySWQgPSBfZ2V0RnJvbUNvb2tpZSgndXNlcklkJykgfHwgbG9jYWxTdG9yYWdlVXNlcklkO1xuICAgIHNjb3BlLl9zZXNzaW9uSWQgPSBfZ2V0RnJvbUNvb2tpZSgnc2Vzc2lvbklkJykgfHwgbG9jYWxTdG9yYWdlU2Vzc2lvbklkIHx8IHNjb3BlLl9zZXNzaW9uSWQ7XG4gICAgc2NvcGUuX2xhc3RFdmVudFRpbWUgPSBfZ2V0RnJvbUNvb2tpZSgnbGFzdEV2ZW50VGltZScpIHx8IGxvY2FsU3RvcmFnZUxhc3RFdmVudFRpbWUgfHwgc2NvcGUuX2xhc3RFdmVudFRpbWU7XG4gICAgc2NvcGUuX2V2ZW50SWQgPSBfZ2V0RnJvbUNvb2tpZSgnZXZlbnRJZCcpIHx8IGxvY2FsU3RvcmFnZUV2ZW50SWQgfHwgc2NvcGUuX2V2ZW50SWQ7XG4gICAgc2NvcGUuX2lkZW50aWZ5SWQgPSBfZ2V0RnJvbUNvb2tpZSgnaWRlbnRpZnlJZCcpIHx8IGxvY2FsU3RvcmFnZUlkZW50aWZ5SWQgfHwgc2NvcGUuX2lkZW50aWZ5SWQ7XG4gICAgc2NvcGUuX3NlcXVlbmNlTnVtYmVyID0gX2dldEZyb21Db29raWUoJ3NlcXVlbmNlTnVtYmVyJykgfHwgbG9jYWxTdG9yYWdlU2VxdWVuY2VOdW1iZXIgfHwgc2NvcGUuX3NlcXVlbmNlTnVtYmVyO1xuXG4gICAgLy8gb3B0T3V0IGlzIGEgbGl0dGxlIHRyaWNraWVyIHNpbmNlIGl0IGlzIGEgYm9vbGVhblxuICAgIHNjb3BlLm9wdGlvbnMub3B0T3V0ID0gbG9jYWxTdG9yYWdlT3B0T3V0IHx8IGZhbHNlO1xuICAgIGlmIChjb29raWVEYXRhICYmIGNvb2tpZURhdGEub3B0T3V0ICE9PSB1bmRlZmluZWQgJiYgY29va2llRGF0YS5vcHRPdXQgIT09IG51bGwpIHtcbiAgICAgIHNjb3BlLm9wdGlvbnMub3B0T3V0ID0gU3RyaW5nKGNvb2tpZURhdGEub3B0T3V0KSA9PT0gJ3RydWUnO1xuICAgIH1cblxuICAgIF9zYXZlQ29va2llRGF0YShzY29wZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZldGNoZXMgZGV2aWNlSWQsIHVzZXJJZCwgZXZlbnQgbWV0YSBkYXRhIGZyb20gYW1wbGl0dWRlIGNvb2tpZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFyIF9sb2FkQ29va2llRGF0YSA9IGZ1bmN0aW9uIF9sb2FkQ29va2llRGF0YShzY29wZSkge1xuICAgIHZhciBjb29raWVEYXRhID0gc2NvcGUuY29va2llU3RvcmFnZS5nZXQoc2NvcGUub3B0aW9ucy5jb29raWVOYW1lICsgc2NvcGUuX3N0b3JhZ2VTdWZmaXgpO1xuICAgIGlmICh0eXBlKGNvb2tpZURhdGEpID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGNvb2tpZURhdGEuZGV2aWNlSWQpIHtcbiAgICAgICAgc2NvcGUub3B0aW9ucy5kZXZpY2VJZCA9IGNvb2tpZURhdGEuZGV2aWNlSWQ7XG4gICAgICB9XG4gICAgICBpZiAoY29va2llRGF0YS51c2VySWQpIHtcbiAgICAgICAgc2NvcGUub3B0aW9ucy51c2VySWQgPSBjb29raWVEYXRhLnVzZXJJZDtcbiAgICAgIH1cbiAgICAgIGlmIChjb29raWVEYXRhLm9wdE91dCAhPT0gbnVsbCAmJiBjb29raWVEYXRhLm9wdE91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNjb3BlLm9wdGlvbnMub3B0T3V0ID0gY29va2llRGF0YS5vcHRPdXQ7XG4gICAgICB9XG4gICAgICBpZiAoY29va2llRGF0YS5zZXNzaW9uSWQpIHtcbiAgICAgICAgc2NvcGUuX3Nlc3Npb25JZCA9IHBhcnNlSW50KGNvb2tpZURhdGEuc2Vzc2lvbklkKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb29raWVEYXRhLmxhc3RFdmVudFRpbWUpIHtcbiAgICAgICAgc2NvcGUuX2xhc3RFdmVudFRpbWUgPSBwYXJzZUludChjb29raWVEYXRhLmxhc3RFdmVudFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKGNvb2tpZURhdGEuZXZlbnRJZCkge1xuICAgICAgICBzY29wZS5fZXZlbnRJZCA9IHBhcnNlSW50KGNvb2tpZURhdGEuZXZlbnRJZCk7XG4gICAgICB9XG4gICAgICBpZiAoY29va2llRGF0YS5pZGVudGlmeUlkKSB7XG4gICAgICAgIHNjb3BlLl9pZGVudGlmeUlkID0gcGFyc2VJbnQoY29va2llRGF0YS5pZGVudGlmeUlkKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb29raWVEYXRhLnNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgIHNjb3BlLl9zZXF1ZW5jZU51bWJlciA9IHBhcnNlSW50KGNvb2tpZURhdGEuc2VxdWVuY2VOdW1iZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2F2ZXMgZGV2aWNlSWQsIHVzZXJJZCwgZXZlbnQgbWV0YSBkYXRhIHRvIGFtcGxpdHVkZSBjb29raWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHZhciBfc2F2ZUNvb2tpZURhdGEgPSBmdW5jdGlvbiBfc2F2ZUNvb2tpZURhdGEoc2NvcGUpIHtcbiAgICBzY29wZS5jb29raWVTdG9yYWdlLnNldChzY29wZS5vcHRpb25zLmNvb2tpZU5hbWUgKyBzY29wZS5fc3RvcmFnZVN1ZmZpeCwge1xuICAgICAgZGV2aWNlSWQ6IHNjb3BlLm9wdGlvbnMuZGV2aWNlSWQsXG4gICAgICB1c2VySWQ6IHNjb3BlLm9wdGlvbnMudXNlcklkLFxuICAgICAgb3B0T3V0OiBzY29wZS5vcHRpb25zLm9wdE91dCxcbiAgICAgIHNlc3Npb25JZDogc2NvcGUuX3Nlc3Npb25JZCxcbiAgICAgIGxhc3RFdmVudFRpbWU6IHNjb3BlLl9sYXN0RXZlbnRUaW1lLFxuICAgICAgZXZlbnRJZDogc2NvcGUuX2V2ZW50SWQsXG4gICAgICBpZGVudGlmeUlkOiBzY29wZS5faWRlbnRpZnlJZCxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiBzY29wZS5fc2VxdWVuY2VOdW1iZXJcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2UgdGhlIHV0bSBwcm9wZXJ0aWVzIG91dCBvZiBjb29raWVzIGFuZCBxdWVyeSBmb3IgYWRkaW5nIHRvIHVzZXIgcHJvcGVydGllcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUuX2luaXRVdG1EYXRhID0gZnVuY3Rpb24gX2luaXRVdG1EYXRhKHF1ZXJ5UGFyYW1zLCBjb29raWVQYXJhbXMpIHtcbiAgICBxdWVyeVBhcmFtcyA9IHF1ZXJ5UGFyYW1zIHx8IHRoaXMuX2dldFVybFBhcmFtcygpO1xuICAgIGNvb2tpZVBhcmFtcyA9IGNvb2tpZVBhcmFtcyB8fCB0aGlzLmNvb2tpZVN0b3JhZ2UuZ2V0KCdfX3V0bXonKTtcbiAgICB2YXIgdXRtUHJvcGVydGllcyA9IGdldFV0bURhdGEoY29va2llUGFyYW1zLCBxdWVyeVBhcmFtcyk7XG4gICAgX3NlbmRQYXJhbXNSZWZlcnJlclVzZXJQcm9wZXJ0aWVzKHRoaXMsIHV0bVByb3BlcnRpZXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgY2FsbGluZyBmdW5jdGlvbiBzaG91bGQgZGV0ZXJtaW5lIHdoZW4gaXQgaXMgYXBwcm9wcmlhdGUgdG8gc2VuZCB0aGVzZSB1c2VyIHByb3BlcnRpZXMuIFRoaXMgZnVuY3Rpb25cbiAgICogd2lsbCBubyBsb25nZXIgY29udGFpbiBhbnkgc2Vzc2lvbiBzdG9yYWdlIGNoZWNraW5nIGxvZ2ljLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFyIF9zZW5kUGFyYW1zUmVmZXJyZXJVc2VyUHJvcGVydGllcyA9IGZ1bmN0aW9uIF9zZW5kUGFyYW1zUmVmZXJyZXJVc2VyUHJvcGVydGllcyhzY29wZSwgdXNlclByb3BlcnRpZXMpIHtcbiAgICBpZiAodHlwZSh1c2VyUHJvcGVydGllcykgIT09ICdvYmplY3QnIHx8IE9iamVjdC5rZXlzKHVzZXJQcm9wZXJ0aWVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzZXRPbmNlIHRoZSBpbml0aWFsIHVzZXIgcHJvcGVydGllc1xuICAgIHZhciBpZGVudGlmeSA9IG5ldyBJZGVudGlmeSgpO1xuICAgIGZvciAodmFyIGtleSBpbiB1c2VyUHJvcGVydGllcykge1xuICAgICAgaWYgKHVzZXJQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaWRlbnRpZnkuc2V0T25jZSgnaW5pdGlhbF8nICsga2V5LCB1c2VyUHJvcGVydGllc1trZXldKTtcbiAgICAgICAgaWRlbnRpZnkuc2V0KGtleSwgdXNlclByb3BlcnRpZXNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2NvcGUuaWRlbnRpZnkoaWRlbnRpZnkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5fZ2V0UmVmZXJyZXIgPSBmdW5jdGlvbiBfZ2V0UmVmZXJyZXIoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LnJlZmVycmVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5fZ2V0VXJsUGFyYW1zID0gZnVuY3Rpb24gX2dldFVybFBhcmFtcygpIHtcbiAgICByZXR1cm4gbG9jYXRpb24uc2VhcmNoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcnkgdG8gZmV0Y2ggR29vZ2xlIEdjbGlkIGZyb20gdXJsIHBhcmFtcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUuX3NhdmVHY2xpZCA9IGZ1bmN0aW9uIF9zYXZlR2NsaWQodXJsUGFyYW1zKSB7XG4gICAgdmFyIGdjbGlkID0gdXRpbHMuZ2V0UXVlcnlQYXJhbSgnZ2NsaWQnLCB1cmxQYXJhbXMpO1xuICAgIGlmICh1dGlscy5pc0VtcHR5U3RyaW5nKGdjbGlkKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZ2NsaWRQcm9wZXJ0aWVzID0geyAnZ2NsaWQnOiBnY2xpZCB9O1xuICAgIF9zZW5kUGFyYW1zUmVmZXJyZXJVc2VyUHJvcGVydGllcyh0aGlzLCBnY2xpZFByb3BlcnRpZXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcnkgdG8gZmV0Y2ggQW1wbGl0dWRlIGRldmljZSBpZCBmcm9tIHVybCBwYXJhbXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLl9nZXREZXZpY2VJZEZyb21VcmxQYXJhbSA9IGZ1bmN0aW9uIF9nZXREZXZpY2VJZEZyb21VcmxQYXJhbSh1cmxQYXJhbXMpIHtcbiAgICByZXR1cm4gdXRpbHMuZ2V0UXVlcnlQYXJhbShjb25zdGFudHMuQU1QX0RFVklDRV9JRF9QQVJBTSwgdXJsUGFyYW1zKTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2UgdGhlIGRvbWFpbiBmcm9tIHJlZmVycmVyIGluZm9cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUuX2dldFJlZmVycmluZ0RvbWFpbiA9IGZ1bmN0aW9uIF9nZXRSZWZlcnJpbmdEb21haW4ocmVmZXJyZXIpIHtcbiAgICBpZiAodXRpbHMuaXNFbXB0eVN0cmluZyhyZWZlcnJlcikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgcGFydHMgPSByZWZlcnJlci5zcGxpdCgnLycpO1xuICAgIGlmIChwYXJ0cy5sZW5ndGggPj0gMykge1xuICAgICAgcmV0dXJuIHBhcnRzWzJdO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogRmV0Y2ggdGhlIHJlZmVycmVyIGluZm9ybWF0aW9uLCBwYXJzZSB0aGUgZG9tYWluIGFuZCBzZW5kLlxuICAgKiBTaW5jZSB1c2VyIHByb3BlcnRpZXMgYXJlIHByb3BhZ2F0ZWQgb24gdGhlIHNlcnZlciwgb25seSBzZW5kIG9uY2UgcGVyIHNlc3Npb24sIGRvbid0IG5lZWQgdG8gc2VuZCB3aXRoIGV2ZXJ5IGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLl9zYXZlUmVmZXJyZXIgPSBmdW5jdGlvbiBfc2F2ZVJlZmVycmVyKHJlZmVycmVyKSB7XG4gICAgaWYgKHV0aWxzLmlzRW1wdHlTdHJpbmcocmVmZXJyZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByZWZlcnJlckluZm8gPSB7XG4gICAgICAncmVmZXJyZXInOiByZWZlcnJlcixcbiAgICAgICdyZWZlcnJpbmdfZG9tYWluJzogdGhpcy5fZ2V0UmVmZXJyaW5nRG9tYWluKHJlZmVycmVyKVxuICAgIH07XG4gICAgX3NlbmRQYXJhbXNSZWZlcnJlclVzZXJQcm9wZXJ0aWVzKHRoaXMsIHJlZmVycmVySW5mbyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNhdmVzIHVuc2VudCBldmVudHMgYW5kIGlkZW50aWZpZXMgdG8gbG9jYWxTdG9yYWdlLiBKU09OIHN0cmluZ2lmaWVzIGV2ZW50IHF1ZXVlcyBiZWZvcmUgc2F2aW5nLlxuICAgKiBOb3RlOiB0aGlzIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGV2ZXJ5IHRpbWUgZXZlbnRzIGFyZSBsb2dnZWQsIHVubGVzcyB5b3UgZXhwbGljaXRseSBzZXQgb3B0aW9uIHNhdmVFdmVudHMgdG8gZmFsc2UuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLnNhdmVFdmVudHMgPSBmdW5jdGlvbiBzYXZlRXZlbnRzKCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9zZXRJblN0b3JhZ2UobG9jYWxTdG9yYWdlJDEsIHRoaXMub3B0aW9ucy51bnNlbnRLZXksIEpTT04uc3RyaW5naWZ5KHRoaXMuX3Vuc2VudEV2ZW50cykpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5fc2V0SW5TdG9yYWdlKGxvY2FsU3RvcmFnZSQxLCB0aGlzLm9wdGlvbnMudW5zZW50SWRlbnRpZnlLZXksIEpTT04uc3RyaW5naWZ5KHRoaXMuX3Vuc2VudElkZW50aWZ5cykpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgYSBjdXN0b21lciBkb21haW4gZm9yIHRoZSBhbXBsaXR1ZGUgY29va2llLiBVc2VmdWwgaWYgeW91IHdhbnQgdG8gc3VwcG9ydCBjcm9zcy1zdWJkb21haW4gdHJhY2tpbmcuXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRvbWFpbiB0byBzZXQuXG4gICAqIEBleGFtcGxlIGFtcGxpdHVkZUNsaWVudC5zZXREb21haW4oJy5hbXBsaXR1ZGUuY29tJyk7XG4gICAqL1xuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLnNldERvbWFpbiA9IGZ1bmN0aW9uIHNldERvbWFpbihkb21haW4pIHtcbiAgICBpZiAoIXV0aWxzLnZhbGlkYXRlSW5wdXQoZG9tYWluLCAnZG9tYWluJywgJ3N0cmluZycpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuY29va2llU3RvcmFnZS5vcHRpb25zKHtcbiAgICAgICAgZG9tYWluOiBkb21haW5cbiAgICAgIH0pO1xuICAgICAgdGhpcy5vcHRpb25zLmRvbWFpbiA9IHRoaXMuY29va2llU3RvcmFnZS5vcHRpb25zKCkuZG9tYWluO1xuICAgICAgX2xvYWRDb29raWVEYXRhKHRoaXMpO1xuICAgICAgX3NhdmVDb29raWVEYXRhKHRoaXMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHV0aWxzLmxvZy5lcnJvcihlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgYW4gaWRlbnRpZmllciBmb3IgdGhlIGN1cnJlbnQgdXNlci5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIC0gaWRlbnRpZmllciB0byBzZXQuIENhbiBiZSBudWxsLlxuICAgKiBAZXhhbXBsZSBhbXBsaXR1ZGVDbGllbnQuc2V0VXNlcklkKCdqb2VAZ21haWwuY29tJyk7XG4gICAqL1xuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLnNldFVzZXJJZCA9IGZ1bmN0aW9uIHNldFVzZXJJZCh1c2VySWQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5vcHRpb25zLnVzZXJJZCA9IHVzZXJJZCAhPT0gdW5kZWZpbmVkICYmIHVzZXJJZCAhPT0gbnVsbCAmJiAnJyArIHVzZXJJZCB8fCBudWxsO1xuICAgICAgX3NhdmVDb29raWVEYXRhKHRoaXMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHV0aWxzLmxvZy5lcnJvcihlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCB1c2VyIHRvIGEgZ3JvdXAgb3IgZ3JvdXBzLiBZb3UgbmVlZCB0byBzcGVjaWZ5IGEgZ3JvdXBUeXBlIGFuZCBncm91cE5hbWUocykuXG4gICAqIEZvciBleGFtcGxlIHlvdSBjYW4gZ3JvdXAgcGVvcGxlIGJ5IHRoZWlyIG9yZ2FuaXphdGlvbi5cbiAgICogSW4gdGhhdCBjYXNlIGdyb3VwVHlwZSBpcyBcIm9yZ0lkXCIgYW5kIGdyb3VwTmFtZSB3b3VsZCBiZSB0aGUgYWN0dWFsIElEKHMpLlxuICAgKiBncm91cE5hbWUgY2FuIGJlIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgdG8gaW5kaWNhdGUgYSB1c2VyIGluIG11bHRpcGxlIGdydXVwcy5cbiAgICogWW91IGNhbiBhbHNvIGNhbGwgc2V0R3JvdXAgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgZ3JvdXBUeXBlcyB0byB0cmFjayBtdWx0aXBsZSB0eXBlcyBvZiBncm91cHMgKHVwIHRvIDUgcGVyIGFwcCkuXG4gICAqIE5vdGU6IHRoaXMgd2lsbCBhbHNvIHNldCBncm91cFR5cGU6IGdyb3VwTmFtZSBhcyBhIHVzZXIgcHJvcGVydHkuXG4gICAqIFNlZSB0aGUgW1NESyBSZWFkbWVde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9hbXBsaXR1ZGUvQW1wbGl0dWRlLUphdmFzY3JpcHQjc2V0dGluZy1ncm91cHN9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBncm91cFR5cGUgLSB0aGUgZ3JvdXAgdHlwZSAoZXg6IG9yZ0lkKVxuICAgKiBAcGFyYW0ge3N0cmluZ3xsaXN0fSBncm91cE5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgZ3JvdXAgKGV4OiAxNSksIG9yIGEgbGlzdCBvZiBuYW1lcyBvZiB0aGUgZ3JvdXBzXG4gICAqIEBleGFtcGxlIGFtcGxpdHVkZUNsaWVudC5zZXRHcm91cCgnb3JnSWQnLCAxNSk7IC8vIHRoaXMgYWRkcyB0aGUgY3VycmVudCB1c2VyIHRvIG9yZ0lkIDE1LlxuICAgKi9cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5zZXRHcm91cCA9IGZ1bmN0aW9uIChncm91cFR5cGUsIGdyb3VwTmFtZSkge1xuICAgIGlmICghdGhpcy5fYXBpS2V5U2V0KCdzZXRHcm91cCgpJykgfHwgIXV0aWxzLnZhbGlkYXRlSW5wdXQoZ3JvdXBUeXBlLCAnZ3JvdXBUeXBlJywgJ3N0cmluZycpIHx8IHV0aWxzLmlzRW1wdHlTdHJpbmcoZ3JvdXBUeXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBncm91cHMgPSB7fTtcbiAgICBncm91cHNbZ3JvdXBUeXBlXSA9IGdyb3VwTmFtZTtcbiAgICB2YXIgaWRlbnRpZnkgPSBuZXcgSWRlbnRpZnkoKS5zZXQoZ3JvdXBUeXBlLCBncm91cE5hbWUpO1xuICAgIHRoaXMuX2xvZ0V2ZW50KGNvbnN0YW50cy5JREVOVElGWV9FVkVOVCwgbnVsbCwgbnVsbCwgaWRlbnRpZnkudXNlclByb3BlcnRpZXNPcGVyYXRpb25zLCBncm91cHMsIG51bGwsIG51bGwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHdoZXRoZXIgdG8gb3B0IGN1cnJlbnQgdXNlciBvdXQgb2YgdHJhY2tpbmcuXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGUgLSBpZiB0cnVlIHRoZW4gbm8gZXZlbnRzIHdpbGwgYmUgbG9nZ2VkIG9yIHNlbnQuXG4gICAqIEBleGFtcGxlOiBhbXBsaXR1ZGUuc2V0T3B0T3V0KHRydWUpO1xuICAgKi9cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5zZXRPcHRPdXQgPSBmdW5jdGlvbiBzZXRPcHRPdXQoZW5hYmxlKSB7XG4gICAgaWYgKCF1dGlscy52YWxpZGF0ZUlucHV0KGVuYWJsZSwgJ2VuYWJsZScsICdib29sZWFuJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5vcHRpb25zLm9wdE91dCA9IGVuYWJsZTtcbiAgICAgIF9zYXZlQ29va2llRGF0YSh0aGlzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB1dGlscy5sb2cuZXJyb3IoZSk7XG4gICAgfVxuICB9O1xuXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUuc2V0U2Vzc2lvbklkID0gZnVuY3Rpb24gc2V0U2Vzc2lvbklkKHNlc3Npb25JZCkge1xuICAgIGlmICghdXRpbHMudmFsaWRhdGVJbnB1dChzZXNzaW9uSWQsICdzZXNzaW9uSWQnLCAnbnVtYmVyJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5fc2Vzc2lvbklkID0gc2Vzc2lvbklkO1xuICAgICAgX3NhdmVDb29raWVEYXRhKHRoaXMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHV0aWxzLmxvZy5lcnJvcihlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAgKiBSZWdlbmVyYXRlcyBhIG5ldyByYW5kb20gZGV2aWNlSWQgZm9yIGN1cnJlbnQgdXNlci4gTm90ZTogdGhpcyBpcyBub3QgcmVjb21tZW5kZWQgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91XG4gICAgKiBhcmUgZG9pbmcuIFRoaXMgY2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgc2V0VXNlcklkKG51bGwpYCB0byBhbm9ueW1pemUgdXNlcnMgYWZ0ZXIgdGhleSBsb2cgb3V0LlxuICAgICogV2l0aCBhIG51bGwgdXNlcklkIGFuZCBhIGNvbXBsZXRlbHkgbmV3IGRldmljZUlkLCB0aGUgY3VycmVudCB1c2VyIHdvdWxkIGFwcGVhciBhcyBhIGJyYW5kIG5ldyB1c2VyIGluIGRhc2hib2FyZC5cbiAgICAqIFRoaXMgdXNlcyBzcmMvdXVpZC5qcyB0byByZWdlbmVyYXRlIHRoZSBkZXZpY2VJZC5cbiAgICAqIEBwdWJsaWNcbiAgICAqL1xuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLnJlZ2VuZXJhdGVEZXZpY2VJZCA9IGZ1bmN0aW9uIHJlZ2VuZXJhdGVEZXZpY2VJZCgpIHtcbiAgICB0aGlzLnNldERldmljZUlkKHV1aWQkMSgpICsgJ1InKTtcbiAgfTtcblxuICAvKipcbiAgICAqIFNldHMgYSBjdXN0b20gZGV2aWNlSWQgZm9yIGN1cnJlbnQgdXNlci4gTm90ZTogdGhpcyBpcyBub3QgcmVjb21tZW5kZWQgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZ1xuICAgICogKGxpa2UgaWYgeW91IGhhdmUgeW91ciBvd24gc3lzdGVtIGZvciBtYW5hZ2luZyBkZXZpY2VJZHMpLiBNYWtlIHN1cmUgdGhlIGRldmljZUlkIHlvdSBzZXQgaXMgc3VmZmljaWVudGx5IHVuaXF1ZVxuICAgICogKHdlIHJlY29tbWVuZCBzb21ldGhpbmcgbGlrZSBhIFVVSUQgLSBzZWUgc3JjL3V1aWQuanMgZm9yIGFuIGV4YW1wbGUgb2YgaG93IHRvIGdlbmVyYXRlKSB0byBwcmV2ZW50IGNvbmZsaWN0cyB3aXRoIG90aGVyIGRldmljZXMgaW4gb3VyIHN5c3RlbS5cbiAgICAqIEBwdWJsaWNcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBkZXZpY2VJZCAtIGN1c3RvbSBkZXZpY2VJZCBmb3IgY3VycmVudCB1c2VyLlxuICAgICogQGV4YW1wbGUgYW1wbGl0dWRlQ2xpZW50LnNldERldmljZUlkKCc0NWYwOTU0Zi1lYjc5LTQ0NjMtYWM4YS0yMzNhNmY0NWE4ZjAnKTtcbiAgICAqL1xuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLnNldERldmljZUlkID0gZnVuY3Rpb24gc2V0RGV2aWNlSWQoZGV2aWNlSWQpIHtcbiAgICBpZiAoIXV0aWxzLnZhbGlkYXRlSW5wdXQoZGV2aWNlSWQsICdkZXZpY2VJZCcsICdzdHJpbmcnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpZiAoIXV0aWxzLmlzRW1wdHlTdHJpbmcoZGV2aWNlSWQpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5kZXZpY2VJZCA9ICcnICsgZGV2aWNlSWQ7XG4gICAgICAgIF9zYXZlQ29va2llRGF0YSh0aGlzKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB1dGlscy5sb2cuZXJyb3IoZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHVzZXIgcHJvcGVydGllcyBmb3IgdGhlIGN1cnJlbnQgdXNlci5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge29iamVjdH0gLSBvYmplY3Qgd2l0aCBzdHJpbmcga2V5cyBhbmQgdmFsdWVzIGZvciB0aGUgdXNlciBwcm9wZXJ0aWVzIHRvIHNldC5cbiAgICogQHBhcmFtIHtib29sZWFufSAtIERFUFJFQ0FURUQgb3B0X3JlcGxhY2U6IGluIGVhcmxpZXIgdmVyc2lvbnMgb2YgdGhlIEpTIFNESyB0aGUgdXNlciBwcm9wZXJ0aWVzIG9iamVjdCB3YXMga2VwdCBpblxuICAgKiBtZW1vcnkgYW5kIHJlcGxhY2UgPSB0cnVlIHdvdWxkIHJlcGxhY2UgdGhlIG9iamVjdCBpbiBtZW1vcnkuIE5vdyB0aGUgcHJvcGVydGllcyBhcmUgbm8gbG9uZ2VyIHN0b3JlZCBpbiBtZW1vcnksIHNvIHJlcGxhY2UgaXMgZGVwcmVjYXRlZC5cbiAgICogQGV4YW1wbGUgYW1wbGl0dWRlQ2xpZW50LnNldFVzZXJQcm9wZXJ0aWVzKHsnZ2VuZGVyJzogJ2ZlbWFsZScsICdzaWduX3VwX2NvbXBsZXRlJzogdHJ1ZX0pXG4gICAqL1xuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLnNldFVzZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gc2V0VXNlclByb3BlcnRpZXModXNlclByb3BlcnRpZXMpIHtcbiAgICBpZiAoIXRoaXMuX2FwaUtleVNldCgnc2V0VXNlclByb3BlcnRpZXMoKScpIHx8ICF1dGlscy52YWxpZGF0ZUlucHV0KHVzZXJQcm9wZXJ0aWVzLCAndXNlclByb3BlcnRpZXMnLCAnb2JqZWN0JykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gc2FuaXRpemUgdGhlIHVzZXJQcm9wZXJ0aWVzIGRpY3QgYmVmb3JlIGNvbnZlcnRpbmcgaW50byBpZGVudGlmeVxuICAgIHZhciBzYW5pdGl6ZWQgPSB1dGlscy50cnVuY2F0ZSh1dGlscy52YWxpZGF0ZVByb3BlcnRpZXModXNlclByb3BlcnRpZXMpKTtcbiAgICBpZiAoT2JqZWN0LmtleXMoc2FuaXRpemVkKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IHVzZXJQcm9wZXJ0aWVzIGludG8gYW4gaWRlbnRpZnkgY2FsbFxuICAgIHZhciBpZGVudGlmeSA9IG5ldyBJZGVudGlmeSgpO1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHNhbml0aXplZCkge1xuICAgICAgaWYgKHNhbml0aXplZC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgaWRlbnRpZnkuc2V0KHByb3BlcnR5LCBzYW5pdGl6ZWRbcHJvcGVydHldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5pZGVudGlmeShpZGVudGlmeSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBvZiB0aGUgdXNlciBwcm9wZXJ0aWVzIGZvciB0aGUgY3VycmVudCB1c2VyLiBOb3RlOiBjbGVhcmluZyB1c2VyIHByb3BlcnRpZXMgaXMgaXJyZXZlcnNpYmxlIVxuICAgKiBAcHVibGljXG4gICAqIEBleGFtcGxlIGFtcGxpdHVkZUNsaWVudC5jbGVhclVzZXJQcm9wZXJ0aWVzKCk7XG4gICAqL1xuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLmNsZWFyVXNlclByb3BlcnRpZXMgPSBmdW5jdGlvbiBjbGVhclVzZXJQcm9wZXJ0aWVzKCkge1xuICAgIGlmICghdGhpcy5fYXBpS2V5U2V0KCdjbGVhclVzZXJQcm9wZXJ0aWVzKCknKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpZGVudGlmeSA9IG5ldyBJZGVudGlmeSgpO1xuICAgIGlkZW50aWZ5LmNsZWFyQWxsKCk7XG4gICAgdGhpcy5pZGVudGlmeShpZGVudGlmeSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIHByb3hpZWQgZnVuY3Rpb25zIG9uIHRoZSBwcm94aWVkIG9iamVjdCB0byBhbiBpbnN0YW5jZSBvZiB0aGUgcmVhbCBvYmplY3QuXG4gICAqIFVzZWQgdG8gY29udmVydCBwcm94aWVkIElkZW50aWZ5IGFuZCBSZXZlbnVlIG9iamVjdHMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB2YXIgX2NvbnZlcnRQcm94eU9iamVjdFRvUmVhbE9iamVjdCA9IGZ1bmN0aW9uIF9jb252ZXJ0UHJveHlPYmplY3RUb1JlYWxPYmplY3QoaW5zdGFuY2UsIHByb3h5KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm94eS5fcS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZuID0gaW5zdGFuY2VbcHJveHkuX3FbaV1bMF1dO1xuICAgICAgaWYgKHR5cGUoZm4pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZuLmFwcGx5KGluc3RhbmNlLCBwcm94eS5fcVtpXS5zbGljZSgxKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICAvKipcbiAgICogU2VuZCBhbiBpZGVudGlmeSBjYWxsIGNvbnRhaW5pbmcgdXNlciBwcm9wZXJ0eSBvcGVyYXRpb25zIHRvIEFtcGxpdHVkZSBzZXJ2ZXJzLlxuICAgKiBTZWUgW1JlYWRtZV17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FtcGxpdHVkZS9BbXBsaXR1ZGUtSmF2YXNjcmlwdCN1c2VyLXByb3BlcnRpZXMtYW5kLXVzZXItcHJvcGVydHktb3BlcmF0aW9uc31cbiAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlIElkZW50aWZ5IEFQSSBhbmQgdXNlciBwcm9wZXJ0eSBvcGVyYXRpb25zLlxuICAgKiBAcGFyYW0ge0lkZW50aWZ5fSBpZGVudGlmeV9vYmogLSB0aGUgSWRlbnRpZnkgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHVzZXIgcHJvcGVydHkgb3BlcmF0aW9ucyB0byBzZW5kLlxuICAgKiBAcGFyYW0ge0FtcGxpdHVkZX5ldmVudENhbGxiYWNrfSBvcHRfY2FsbGJhY2sgLSAob3B0aW9uYWwpIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIHRoZSBpZGVudGlmeSBldmVudCBoYXMgYmVlbiBzZW50LlxuICAgKiBOb3RlOiB0aGUgc2VydmVyIHJlc3BvbnNlIGNvZGUgYW5kIHJlc3BvbnNlIGJvZHkgZnJvbSB0aGUgaWRlbnRpZnkgZXZlbnQgdXBsb2FkIGFyZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgaWRlbnRpZnkgPSBuZXcgYW1wbGl0dWRlLklkZW50aWZ5KCkuc2V0KCdjb2xvcnMnLCBbJ3Jvc2UnLCAnZ29sZCddKS5hZGQoJ2thcm1hJywgMSkuc2V0T25jZSgnc2lnbl91cF9kYXRlJywgJzIwMTYtMDMtMzEnKTtcbiAgICogYW1wbGl0dWRlLmlkZW50aWZ5KGlkZW50aWZ5KTtcbiAgICovXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUuaWRlbnRpZnkgPSBmdW5jdGlvbiAoaWRlbnRpZnlfb2JqLCBvcHRfY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX2FwaUtleVNldCgnaWRlbnRpZnkoKScpKSB7XG4gICAgICBpZiAodHlwZShvcHRfY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9wdF9jYWxsYmFjaygwLCAnTm8gcmVxdWVzdCBzZW50Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgaWRlbnRpZnkgaW5wdXQgaXMgYSBwcm94aWVkIG9iamVjdCBjcmVhdGVkIGJ5IHRoZSBhc3luYyBsb2FkaW5nIHNuaXBwZXQsIGNvbnZlcnQgaXQgaW50byBhbiBpZGVudGlmeSBvYmplY3RcbiAgICBpZiAodHlwZShpZGVudGlmeV9vYmopID09PSAnb2JqZWN0JyAmJiBpZGVudGlmeV9vYmouaGFzT3duUHJvcGVydHkoJ19xJykpIHtcbiAgICAgIGlkZW50aWZ5X29iaiA9IF9jb252ZXJ0UHJveHlPYmplY3RUb1JlYWxPYmplY3QobmV3IElkZW50aWZ5KCksIGlkZW50aWZ5X29iaik7XG4gICAgfVxuXG4gICAgaWYgKGlkZW50aWZ5X29iaiBpbnN0YW5jZW9mIElkZW50aWZ5KSB7XG4gICAgICAvLyBvbmx5IHNlbmQgaWYgdGhlcmUgYXJlIG9wZXJhdGlvbnNcbiAgICAgIGlmIChPYmplY3Qua2V5cyhpZGVudGlmeV9vYmoudXNlclByb3BlcnRpZXNPcGVyYXRpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dFdmVudChjb25zdGFudHMuSURFTlRJRllfRVZFTlQsIG51bGwsIG51bGwsIGlkZW50aWZ5X29iai51c2VyUHJvcGVydGllc09wZXJhdGlvbnMsIG51bGwsIG51bGwsIG9wdF9jYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWxzLmxvZy5lcnJvcignSW52YWxpZCBpZGVudGlmeSBpbnB1dCB0eXBlLiBFeHBlY3RlZCBJZGVudGlmeSBvYmplY3QgYnV0IHNhdyAnICsgdHlwZShpZGVudGlmeV9vYmopKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZShvcHRfY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvcHRfY2FsbGJhY2soMCwgJ05vIHJlcXVlc3Qgc2VudCcpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IGEgdmVyc2lvbk5hbWUgZm9yIHlvdXIgYXBwbGljYXRpb24uXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZlcnNpb25OYW1lIC0gVGhlIHZlcnNpb24gdG8gc2V0IGZvciB5b3VyIGFwcGxpY2F0aW9uLlxuICAgKiBAZXhhbXBsZSBhbXBsaXR1ZGVDbGllbnQuc2V0VmVyc2lvbk5hbWUoJzEuMTIuMycpO1xuICAgKi9cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5zZXRWZXJzaW9uTmFtZSA9IGZ1bmN0aW9uIHNldFZlcnNpb25OYW1lKHZlcnNpb25OYW1lKSB7XG4gICAgaWYgKCF1dGlscy52YWxpZGF0ZUlucHV0KHZlcnNpb25OYW1lLCAndmVyc2lvbk5hbWUnLCAnc3RyaW5nJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zLnZlcnNpb25OYW1lID0gdmVyc2lvbk5hbWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByaXZhdGUgbG9nRXZlbnQgbWV0aG9kLiBLZWVwcyBhcGlQcm9wZXJ0aWVzIGZyb20gYmVpbmcgcHVibGljbHkgZXhwb3NlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUuX2xvZ0V2ZW50ID0gZnVuY3Rpb24gX2xvZ0V2ZW50KGV2ZW50VHlwZSwgZXZlbnRQcm9wZXJ0aWVzLCBhcGlQcm9wZXJ0aWVzLCB1c2VyUHJvcGVydGllcywgZ3JvdXBzLCB0aW1lc3RhbXAsIGNhbGxiYWNrKSB7XG4gICAgX2xvYWRDb29raWVEYXRhKHRoaXMpOyAvLyByZWxvYWQgY29va2llIGJlZm9yZSBlYWNoIGxvZyBldmVudCB0byBzeW5jIGV2ZW50IG1ldGEtZGF0YSBiZXR3ZWVuIHdpbmRvd3MgYW5kIHRhYnNcbiAgICBpZiAoIWV2ZW50VHlwZSB8fCB0aGlzLm9wdGlvbnMub3B0T3V0KSB7XG4gICAgICBpZiAodHlwZShjYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2soMCwgJ05vIHJlcXVlc3Qgc2VudCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB2YXIgZXZlbnRJZDtcbiAgICAgIGlmIChldmVudFR5cGUgPT09IGNvbnN0YW50cy5JREVOVElGWV9FVkVOVCkge1xuICAgICAgICBldmVudElkID0gdGhpcy5uZXh0SWRlbnRpZnlJZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXZlbnRJZCA9IHRoaXMubmV4dEV2ZW50SWQoKTtcbiAgICAgIH1cbiAgICAgIHZhciBzZXF1ZW5jZU51bWJlciA9IHRoaXMubmV4dFNlcXVlbmNlTnVtYmVyKCk7XG4gICAgICB2YXIgZXZlbnRUaW1lID0gdHlwZSh0aW1lc3RhbXApID09PSAnbnVtYmVyJyA/IHRpbWVzdGFtcCA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgaWYgKCF0aGlzLl9zZXNzaW9uSWQgfHwgIXRoaXMuX2xhc3RFdmVudFRpbWUgfHwgZXZlbnRUaW1lIC0gdGhpcy5fbGFzdEV2ZW50VGltZSA+IHRoaXMub3B0aW9ucy5zZXNzaW9uVGltZW91dCkge1xuICAgICAgICB0aGlzLl9zZXNzaW9uSWQgPSBldmVudFRpbWU7XG4gICAgICB9XG4gICAgICB0aGlzLl9sYXN0RXZlbnRUaW1lID0gZXZlbnRUaW1lO1xuICAgICAgX3NhdmVDb29raWVEYXRhKHRoaXMpO1xuXG4gICAgICB1c2VyUHJvcGVydGllcyA9IHVzZXJQcm9wZXJ0aWVzIHx8IHt9O1xuICAgICAgYXBpUHJvcGVydGllcyA9IGFwaVByb3BlcnRpZXMgfHwge307XG4gICAgICBldmVudFByb3BlcnRpZXMgPSBldmVudFByb3BlcnRpZXMgfHwge307XG4gICAgICBncm91cHMgPSBncm91cHMgfHwge307XG4gICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgIGRldmljZV9pZDogdGhpcy5vcHRpb25zLmRldmljZUlkLFxuICAgICAgICB1c2VyX2lkOiB0aGlzLm9wdGlvbnMudXNlcklkLFxuICAgICAgICB0aW1lc3RhbXA6IGV2ZW50VGltZSxcbiAgICAgICAgZXZlbnRfaWQ6IGV2ZW50SWQsXG4gICAgICAgIHNlc3Npb25faWQ6IHRoaXMuX3Nlc3Npb25JZCB8fCAtMSxcbiAgICAgICAgZXZlbnRfdHlwZTogZXZlbnRUeXBlLFxuICAgICAgICB2ZXJzaW9uX25hbWU6IHRoaXMub3B0aW9ucy52ZXJzaW9uTmFtZSB8fCBudWxsLFxuICAgICAgICBwbGF0Zm9ybTogdGhpcy5vcHRpb25zLnBsYXRmb3JtLFxuICAgICAgICBvc19uYW1lOiB0aGlzLl91YS5icm93c2VyLm5hbWUgfHwgbnVsbCxcbiAgICAgICAgb3NfdmVyc2lvbjogdGhpcy5fdWEuYnJvd3Nlci5tYWpvciB8fCBudWxsLFxuICAgICAgICBkZXZpY2VfbW9kZWw6IHRoaXMuX3VhLm9zLm5hbWUgfHwgbnVsbCxcbiAgICAgICAgbGFuZ3VhZ2U6IHRoaXMub3B0aW9ucy5sYW5ndWFnZSxcbiAgICAgICAgYXBpX3Byb3BlcnRpZXM6IGFwaVByb3BlcnRpZXMsXG4gICAgICAgIGV2ZW50X3Byb3BlcnRpZXM6IHV0aWxzLnRydW5jYXRlKHV0aWxzLnZhbGlkYXRlUHJvcGVydGllcyhldmVudFByb3BlcnRpZXMpKSxcbiAgICAgICAgdXNlcl9wcm9wZXJ0aWVzOiB1dGlscy50cnVuY2F0ZSh1dGlscy52YWxpZGF0ZVByb3BlcnRpZXModXNlclByb3BlcnRpZXMpKSxcbiAgICAgICAgdXVpZDogdXVpZCQxKCksXG4gICAgICAgIGxpYnJhcnk6IHtcbiAgICAgICAgICBuYW1lOiAnYW1wbGl0dWRlLWpzJyxcbiAgICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uXG4gICAgICAgIH0sXG4gICAgICAgIHNlcXVlbmNlX251bWJlcjogc2VxdWVuY2VOdW1iZXIsIC8vIGZvciBvcmRlcmluZyBldmVudHMgYW5kIGlkZW50aWZ5c1xuICAgICAgICBncm91cHM6IHV0aWxzLnRydW5jYXRlKHV0aWxzLnZhbGlkYXRlR3JvdXBzKGdyb3VwcykpLFxuICAgICAgICB1c2VyX2FnZW50OiB0aGlzLl91c2VyQWdlbnRcbiAgICAgICAgLy8gY291bnRyeTogbnVsbFxuICAgICAgfTtcblxuICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gY29uc3RhbnRzLklERU5USUZZX0VWRU5UKSB7XG4gICAgICAgIHRoaXMuX3Vuc2VudElkZW50aWZ5cy5wdXNoKGV2ZW50KTtcbiAgICAgICAgdGhpcy5fbGltaXRFdmVudHNRdWV1ZWQodGhpcy5fdW5zZW50SWRlbnRpZnlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Vuc2VudEV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgICAgdGhpcy5fbGltaXRFdmVudHNRdWV1ZWQodGhpcy5fdW5zZW50RXZlbnRzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zYXZlRXZlbnRzKSB7XG4gICAgICAgIHRoaXMuc2F2ZUV2ZW50cygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX3NlbmRFdmVudHNJZlJlYWR5KGNhbGxiYWNrKSAmJiB0eXBlKGNhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjaygwLCAnTm8gcmVxdWVzdCBzZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBldmVudElkO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHV0aWxzLmxvZy5lcnJvcihlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBvbGQgZXZlbnRzIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXkgaWYgdG9vIG1hbnkgaGF2ZSBhY2N1bXVsYXRlZC4gRGVmYXVsdCBsaW1pdCBpcyAxMDAwIGV2ZW50cy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUuX2xpbWl0RXZlbnRzUXVldWVkID0gZnVuY3Rpb24gX2xpbWl0RXZlbnRzUXVldWVkKHF1ZXVlKSB7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA+IHRoaXMub3B0aW9ucy5zYXZlZE1heENvdW50KSB7XG4gICAgICBxdWV1ZS5zcGxpY2UoMCwgcXVldWUubGVuZ3RoIC0gdGhpcy5vcHRpb25zLnNhdmVkTWF4Q291bnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBpcyB0aGUgY2FsbGJhY2sgZm9yIGxvZ0V2ZW50IGFuZCBpZGVudGlmeSBjYWxscy4gSXQgZ2V0cyBjYWxsZWQgYWZ0ZXIgdGhlIGV2ZW50L2lkZW50aWZ5IGlzIHVwbG9hZGVkLFxuICAgKiBhbmQgdGhlIHNlcnZlciByZXNwb25zZSBjb2RlIGFuZCByZXNwb25zZSBib2R5IGZyb20gdGhlIHVwbG9hZCByZXF1ZXN0IGFyZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAY2FsbGJhY2sgQW1wbGl0dWRlfmV2ZW50Q2FsbGJhY2tcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc3BvbnNlQ29kZSAtIFNlcnZlciByZXNwb25zZSBjb2RlIGZvciB0aGUgZXZlbnQgLyBpZGVudGlmeSB1cGxvYWQgcmVxdWVzdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlc3BvbnNlQm9keSAtIFNlcnZlciByZXNwb25zZSBib2R5IGZvciB0aGUgZXZlbnQgLyBpZGVudGlmeSB1cGxvYWQgcmVxdWVzdC5cbiAgICovXG5cbiAgLyoqXG4gICAqIExvZyBhbiBldmVudCB3aXRoIGV2ZW50VHlwZSBhbmQgZXZlbnRQcm9wZXJ0aWVzXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSAtIG5hbWUgb2YgZXZlbnRcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50UHJvcGVydGllcyAtIChvcHRpb25hbCkgYW4gb2JqZWN0IHdpdGggc3RyaW5nIGtleXMgYW5kIHZhbHVlcyBmb3IgdGhlIGV2ZW50IHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSB7QW1wbGl0dWRlfmV2ZW50Q2FsbGJhY2t9IG9wdF9jYWxsYmFjayAtIChvcHRpb25hbCkgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBydW4gYWZ0ZXIgdGhlIGV2ZW50IGlzIGxvZ2dlZC5cbiAgICogTm90ZTogdGhlIHNlcnZlciByZXNwb25zZSBjb2RlIGFuZCByZXNwb25zZSBib2R5IGZyb20gdGhlIGV2ZW50IHVwbG9hZCBhcmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGUgYW1wbGl0dWRlQ2xpZW50LmxvZ0V2ZW50KCdDbGlja2VkIEhvbWVwYWdlIEJ1dHRvbicsIHsnZmluaXNoZWRfZmxvdyc6IGZhbHNlLCAnY2xpY2tzJzogMTV9KTtcbiAgICovXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUubG9nRXZlbnQgPSBmdW5jdGlvbiBsb2dFdmVudChldmVudFR5cGUsIGV2ZW50UHJvcGVydGllcywgb3B0X2NhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMubG9nRXZlbnRXaXRoVGltZXN0YW1wKGV2ZW50VHlwZSwgZXZlbnRQcm9wZXJ0aWVzLCBudWxsLCBvcHRfY2FsbGJhY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb2cgYW4gZXZlbnQgd2l0aCBldmVudFR5cGUgYW5kIGV2ZW50UHJvcGVydGllcyBhbmQgYSBjdXN0b20gdGltZXN0YW1wXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSAtIG5hbWUgb2YgZXZlbnRcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50UHJvcGVydGllcyAtIChvcHRpb25hbCkgYW4gb2JqZWN0IHdpdGggc3RyaW5nIGtleXMgYW5kIHZhbHVlcyBmb3IgdGhlIGV2ZW50IHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc2F0bXAgLSAob3B0aW9uYWwpIHRoZSBjdXN0b20gdGltZXN0YW1wIGFzIG1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaC5cbiAgICogQHBhcmFtIHtBbXBsaXR1ZGV+ZXZlbnRDYWxsYmFja30gb3B0X2NhbGxiYWNrIC0gKG9wdGlvbmFsKSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1biBhZnRlciB0aGUgZXZlbnQgaXMgbG9nZ2VkLlxuICAgKiBOb3RlOiB0aGUgc2VydmVyIHJlc3BvbnNlIGNvZGUgYW5kIHJlc3BvbnNlIGJvZHkgZnJvbSB0aGUgZXZlbnQgdXBsb2FkIGFyZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZSBhbXBsaXR1ZGVDbGllbnQubG9nRXZlbnQoJ0NsaWNrZWQgSG9tZXBhZ2UgQnV0dG9uJywgeydmaW5pc2hlZF9mbG93JzogZmFsc2UsICdjbGlja3MnOiAxNX0pO1xuICAgKi9cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5sb2dFdmVudFdpdGhUaW1lc3RhbXAgPSBmdW5jdGlvbiBsb2dFdmVudChldmVudFR5cGUsIGV2ZW50UHJvcGVydGllcywgdGltZXN0YW1wLCBvcHRfY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX2FwaUtleVNldCgnbG9nRXZlbnQoKScpIHx8ICF1dGlscy52YWxpZGF0ZUlucHV0KGV2ZW50VHlwZSwgJ2V2ZW50VHlwZScsICdzdHJpbmcnKSB8fCB1dGlscy5pc0VtcHR5U3RyaW5nKGV2ZW50VHlwZSkpIHtcbiAgICAgIGlmICh0eXBlKG9wdF9jYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3B0X2NhbGxiYWNrKDAsICdObyByZXF1ZXN0IHNlbnQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2xvZ0V2ZW50KGV2ZW50VHlwZSwgZXZlbnRQcm9wZXJ0aWVzLCBudWxsLCBudWxsLCBudWxsLCB0aW1lc3RhbXAsIG9wdF9jYWxsYmFjayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvZyBhbiBldmVudCB3aXRoIGV2ZW50VHlwZSwgZXZlbnRQcm9wZXJ0aWVzLCBhbmQgZ3JvdXBzLiBVc2UgdGhpcyB0byBzZXQgZXZlbnQtbGV2ZWwgZ3JvdXBzLlxuICAgKiBOb3RlOiB0aGUgZ3JvdXAocykgc2V0IG9ubHkgYXBwbHkgZm9yIHRoZSBzcGVjaWZpYyBldmVudCB0eXBlIGJlaW5nIGxvZ2dlZCBhbmQgZG9lcyBub3QgcGVyc2lzdCBvbiB0aGUgdXNlclxuICAgKiAodW5sZXNzIHlvdSBleHBsaWNpdGx5IHNldCBpdCB3aXRoIHNldEdyb3VwKS5cbiAgICogU2VlIHRoZSBbU0RLIFJlYWRtZV17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FtcGxpdHVkZS9BbXBsaXR1ZGUtSmF2YXNjcmlwdCNzZXR0aW5nLWdyb3Vwc30gZm9yIG1vcmUgaW5mb3JtYXRpb25cbiAgICogYWJvdXQgZ3JvdXBzIGFuZCBDb3VudCBieSBEaXN0aW5jdCBvbiB0aGUgQW1wbGl0dWRlIHBsYXRmb3JtLlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgLSBuYW1lIG9mIGV2ZW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFByb3BlcnRpZXMgLSAob3B0aW9uYWwpIGFuIG9iamVjdCB3aXRoIHN0cmluZyBrZXlzIGFuZCB2YWx1ZXMgZm9yIHRoZSBldmVudCBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0ge29iamVjdH0gZ3JvdXBzIC0gKG9wdGlvbmFsKSBhbiBvYmplY3Qgd2l0aCBzdHJpbmcgZ3JvdXBUeXBlOiBncm91cE5hbWUgdmFsdWVzIGZvciB0aGUgZXZlbnQgYmVpbmcgbG9nZ2VkLlxuICAgKiBncm91cE5hbWUgY2FuIGJlIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gICAqIEBwYXJhbSB7QW1wbGl0dWRlfmV2ZW50Q2FsbGJhY2t9IG9wdF9jYWxsYmFjayAtIChvcHRpb25hbCkgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBydW4gYWZ0ZXIgdGhlIGV2ZW50IGlzIGxvZ2dlZC5cbiAgICogTm90ZTogdGhlIHNlcnZlciByZXNwb25zZSBjb2RlIGFuZCByZXNwb25zZSBib2R5IGZyb20gdGhlIGV2ZW50IHVwbG9hZCBhcmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGUgYW1wbGl0dWRlQ2xpZW50LmxvZ0V2ZW50V2l0aEdyb3VwcygnQ2xpY2tlZCBCdXR0b24nLCBudWxsLCB7J29yZ0lkJzogMjR9KTtcbiAgICovXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUubG9nRXZlbnRXaXRoR3JvdXBzID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgZXZlbnRQcm9wZXJ0aWVzLCBncm91cHMsIG9wdF9jYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5fYXBpS2V5U2V0KCdsb2dFdmVudFdpdGhHcm91cCgpJykgfHwgIXV0aWxzLnZhbGlkYXRlSW5wdXQoZXZlbnRUeXBlLCAnZXZlbnRUeXBlJywgJ3N0cmluZycpKSB7XG4gICAgICBpZiAodHlwZShvcHRfY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9wdF9jYWxsYmFjaygwLCAnTm8gcmVxdWVzdCBzZW50Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9sb2dFdmVudChldmVudFR5cGUsIGV2ZW50UHJvcGVydGllcywgbnVsbCwgbnVsbCwgZ3JvdXBzLCBudWxsLCBvcHRfY2FsbGJhY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0IHRoYXQgbiBpcyBhIG51bWJlciBvciBhIG51bWVyaWMgdmFsdWUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB2YXIgX2lzTnVtYmVyID0gZnVuY3Rpb24gX2lzTnVtYmVyKG4pIHtcbiAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb2cgcmV2ZW51ZSB3aXRoIFJldmVudWUgaW50ZXJmYWNlLiBUaGUgbmV3IHJldmVudWUgaW50ZXJmYWNlIGFsbG93cyBmb3IgbW9yZSByZXZlbnVlIGZpZWxkcyBsaWtlXG4gICAqIHJldmVudWVUeXBlIGFuZCBldmVudCBwcm9wZXJ0aWVzLlxuICAgKiBTZWUgW1JlYWRtZV17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FtcGxpdHVkZS9BbXBsaXR1ZGUtSmF2YXNjcmlwdCN0cmFja2luZy1yZXZlbnVlfVxuICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGUgUmV2ZW51ZSBpbnRlcmZhY2UgYW5kIGxvZ2dpbmcgcmV2ZW51ZS5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1JldmVudWV9IHJldmVudWVfb2JqIC0gdGhlIHJldmVudWUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJldmVudWUgZGF0YSBiZWluZyBsb2dnZWQuXG4gICAqIEBleGFtcGxlIHZhciByZXZlbnVlID0gbmV3IGFtcGxpdHVkZS5SZXZlbnVlKCkuc2V0UHJvZHVjdElkKCdwcm9kdWN0SWRlbnRpZmllcicpLnNldFByaWNlKDEwLjk5KTtcbiAgICogYW1wbGl0dWRlLmxvZ1JldmVudWVWMihyZXZlbnVlKTtcbiAgICovXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUubG9nUmV2ZW51ZVYyID0gZnVuY3Rpb24gbG9nUmV2ZW51ZVYyKHJldmVudWVfb2JqKSB7XG4gICAgaWYgKCF0aGlzLl9hcGlLZXlTZXQoJ2xvZ1JldmVudWVWMigpJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpZiByZXZlbnVlIGlucHV0IGlzIGEgcHJveGllZCBvYmplY3QgY3JlYXRlZCBieSB0aGUgYXN5bmMgbG9hZGluZyBzbmlwcGV0LCBjb252ZXJ0IGl0IGludG8gYW4gcmV2ZW51ZSBvYmplY3RcbiAgICBpZiAodHlwZShyZXZlbnVlX29iaikgPT09ICdvYmplY3QnICYmIHJldmVudWVfb2JqLmhhc093blByb3BlcnR5KCdfcScpKSB7XG4gICAgICByZXZlbnVlX29iaiA9IF9jb252ZXJ0UHJveHlPYmplY3RUb1JlYWxPYmplY3QobmV3IFJldmVudWUoKSwgcmV2ZW51ZV9vYmopO1xuICAgIH1cblxuICAgIGlmIChyZXZlbnVlX29iaiBpbnN0YW5jZW9mIFJldmVudWUpIHtcbiAgICAgIC8vIG9ubHkgc2VuZCBpZiByZXZlbnVlIGlzIHZhbGlkXG4gICAgICBpZiAocmV2ZW51ZV9vYmogJiYgcmV2ZW51ZV9vYmouX2lzVmFsaWRSZXZlbnVlKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nRXZlbnQoY29uc3RhbnRzLlJFVkVOVUVfRVZFTlQsIHJldmVudWVfb2JqLl90b0pTT05PYmplY3QoKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWxzLmxvZy5lcnJvcignSW52YWxpZCByZXZlbnVlIGlucHV0IHR5cGUuIEV4cGVjdGVkIFJldmVudWUgb2JqZWN0IGJ1dCBzYXcgJyArIHR5cGUocmV2ZW51ZV9vYmopKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIExvZyByZXZlbnVlIGV2ZW50IHdpdGggYSBwcmljZSwgcXVhbnRpdHksIGFuZCBwcm9kdWN0IGlkZW50aWZpZXIuIERFUFJFQ0FURUQgLSB1c2UgbG9nUmV2ZW51ZVYyXG4gICAqIEBwdWJsaWNcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHByaWNlIC0gcHJpY2Ugb2YgcmV2ZW51ZSBldmVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gcXVhbnRpdHkgLSAob3B0aW9uYWwpIHF1YW50aXR5IG9mIHByb2R1Y3RzIGluIHJldmVudWUgZXZlbnQuIElmIG5vIHF1YW50aXR5IHNwZWNpZmllZCBkZWZhdWx0IHRvIDEuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9kdWN0IC0gKG9wdGlvbmFsKSBwcm9kdWN0IGlkZW50aWZpZXJcbiAgICogQGV4YW1wbGUgYW1wbGl0dWRlQ2xpZW50LmxvZ1JldmVudWUoMy45OSwgMSwgJ3Byb2R1Y3RfMTIzNCcpO1xuICAgKi9cbiAgQW1wbGl0dWRlQ2xpZW50LnByb3RvdHlwZS5sb2dSZXZlbnVlID0gZnVuY3Rpb24gbG9nUmV2ZW51ZShwcmljZSwgcXVhbnRpdHksIHByb2R1Y3QpIHtcbiAgICAvLyBUZXN0IHRoYXQgdGhlIHBhcmFtZXRlcnMgYXJlIG9mIHRoZSByaWdodCB0eXBlLlxuICAgIGlmICghdGhpcy5fYXBpS2V5U2V0KCdsb2dSZXZlbnVlKCknKSB8fCAhX2lzTnVtYmVyKHByaWNlKSB8fCBxdWFudGl0eSAhPT0gdW5kZWZpbmVkICYmICFfaXNOdW1iZXIocXVhbnRpdHkpKSB7XG4gICAgICAvLyB1dGlscy5sb2coJ1ByaWNlIGFuZCBxdWFudGl0eSBhcmd1bWVudHMgdG8gbG9nUmV2ZW51ZSBtdXN0IGJlIG51bWJlcnMnKTtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fbG9nRXZlbnQoY29uc3RhbnRzLlJFVkVOVUVfRVZFTlQsIHt9LCB7XG4gICAgICBwcm9kdWN0SWQ6IHByb2R1Y3QsXG4gICAgICBzcGVjaWFsOiAncmV2ZW51ZV9hbW91bnQnLFxuICAgICAgcXVhbnRpdHk6IHF1YW50aXR5IHx8IDEsXG4gICAgICBwcmljZTogcHJpY2VcbiAgICB9LCBudWxsLCBudWxsLCBudWxsLCBudWxsKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGV2ZW50cyBpbiBzdG9yYWdlIHdpdGggZXZlbnQgaWRzIHVwIHRvIGFuZCBpbmNsdWRpbmcgbWF4RXZlbnRJZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUucmVtb3ZlRXZlbnRzID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRzKG1heEV2ZW50SWQsIG1heElkZW50aWZ5SWQpIHtcbiAgICBfcmVtb3ZlRXZlbnRzKHRoaXMsICdfdW5zZW50RXZlbnRzJywgbWF4RXZlbnRJZCk7XG4gICAgX3JlbW92ZUV2ZW50cyh0aGlzLCAnX3Vuc2VudElkZW50aWZ5cycsIG1heElkZW50aWZ5SWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gcmVtb3ZlIGV2ZW50cyB1cCB0byBtYXhJZCBmcm9tIGEgc2luZ2xlIHF1ZXVlLlxuICAgKiBEb2VzIGEgdHJ1ZSBmaWx0ZXIgaW4gY2FzZSBldmVudHMgZ2V0IG91dCBvZiBvcmRlciBvciBvbGQgZXZlbnRzIGFyZSByZW1vdmVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFyIF9yZW1vdmVFdmVudHMgPSBmdW5jdGlvbiBfcmVtb3ZlRXZlbnRzKHNjb3BlLCBldmVudFF1ZXVlLCBtYXhJZCkge1xuICAgIGlmIChtYXhJZCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZmlsdGVyZWRFdmVudHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjb3BlW2V2ZW50UXVldWVdLmxlbmd0aCB8fCAwOyBpKyspIHtcbiAgICAgIGlmIChzY29wZVtldmVudFF1ZXVlXVtpXS5ldmVudF9pZCA+IG1heElkKSB7XG4gICAgICAgIGZpbHRlcmVkRXZlbnRzLnB1c2goc2NvcGVbZXZlbnRRdWV1ZV1baV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBzY29wZVtldmVudFF1ZXVlXSA9IGZpbHRlcmVkRXZlbnRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZW5kIHVuc2VudCBldmVudHMuIE5vdGU6IHRoaXMgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYWZ0ZXIgZXZlbnRzIGFyZSBsb2dnZWQgaWYgb3B0aW9uIGJhdGNoRXZlbnRzIGlzIGZhbHNlLlxuICAgKiBJZiBiYXRjaEV2ZW50cyBpcyB0cnVlLCB0aGVuIGV2ZW50cyBhcmUgb25seSBzZW50IHdoZW4gYmF0Y2ggY3JpdGVyaWFzIGFyZSBtZXQuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QW1wbGl0dWRlfmV2ZW50Q2FsbGJhY2t9IGNhbGxiYWNrIC0gKG9wdGlvbmFsKSBjYWxsYmFjayB0byBydW4gYWZ0ZXIgZXZlbnRzIGFyZSBzZW50LlxuICAgKiBOb3RlIHRoZSBzZXJ2ZXIgcmVzcG9uc2UgY29kZSBhbmQgcmVzcG9uc2UgYm9keSBhcmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBhcyBpbnB1dCBhcmd1bWVudHMuXG4gICAqL1xuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLnNlbmRFdmVudHMgPSBmdW5jdGlvbiBzZW5kRXZlbnRzKGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9hcGlLZXlTZXQoJ3NlbmRFdmVudHMoKScpIHx8IHRoaXMuX3NlbmRpbmcgfHwgdGhpcy5vcHRpb25zLm9wdE91dCB8fCB0aGlzLl91bnNlbnRDb3VudCgpID09PSAwKSB7XG4gICAgICBpZiAodHlwZShjYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2soMCwgJ05vIHJlcXVlc3Qgc2VudCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3NlbmRpbmcgPSB0cnVlO1xuICAgIHZhciBwcm90b2NvbCA9IHRoaXMub3B0aW9ucy5mb3JjZUh0dHBzID8gJ2h0dHBzJyA6ICdodHRwczonID09PSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPyAnaHR0cHMnIDogJ2h0dHAnO1xuICAgIHZhciB1cmwgPSBwcm90b2NvbCArICc6Ly8nICsgdGhpcy5vcHRpb25zLmFwaUVuZHBvaW50ICsgJy8nO1xuXG4gICAgLy8gZmV0Y2ggZXZlbnRzIHRvIHNlbmRcbiAgICB2YXIgbnVtRXZlbnRzID0gTWF0aC5taW4odGhpcy5fdW5zZW50Q291bnQoKSwgdGhpcy5vcHRpb25zLnVwbG9hZEJhdGNoU2l6ZSk7XG4gICAgdmFyIG1lcmdlZEV2ZW50cyA9IHRoaXMuX21lcmdlRXZlbnRzQW5kSWRlbnRpZnlzKG51bUV2ZW50cyk7XG4gICAgdmFyIG1heEV2ZW50SWQgPSBtZXJnZWRFdmVudHMubWF4RXZlbnRJZDtcbiAgICB2YXIgbWF4SWRlbnRpZnlJZCA9IG1lcmdlZEV2ZW50cy5tYXhJZGVudGlmeUlkO1xuICAgIHZhciBldmVudHMgPSBKU09OLnN0cmluZ2lmeShtZXJnZWRFdmVudHMuZXZlbnRzVG9TZW5kKTtcbiAgICB2YXIgdXBsb2FkVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBjbGllbnQ6IHRoaXMub3B0aW9ucy5hcGlLZXksXG4gICAgICBlOiBldmVudHMsXG4gICAgICB2OiBjb25zdGFudHMuQVBJX1ZFUlNJT04sXG4gICAgICB1cGxvYWRfdGltZTogdXBsb2FkVGltZSxcbiAgICAgIGNoZWNrc3VtOiBtZDUoY29uc3RhbnRzLkFQSV9WRVJTSU9OICsgdGhpcy5vcHRpb25zLmFwaUtleSArIGV2ZW50cyArIHVwbG9hZFRpbWUpXG4gICAgfTtcblxuICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgbmV3IFJlcXVlc3QodXJsLCBkYXRhKS5zZW5kKGZ1bmN0aW9uIChzdGF0dXMsIHJlc3BvbnNlKSB7XG4gICAgICBzY29wZS5fc2VuZGluZyA9IGZhbHNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMjAwICYmIHJlc3BvbnNlID09PSAnc3VjY2VzcycpIHtcbiAgICAgICAgICBzY29wZS5yZW1vdmVFdmVudHMobWF4RXZlbnRJZCwgbWF4SWRlbnRpZnlJZCk7XG5cbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIGV2ZW50IGNhY2hlIGFmdGVyIHRoZSByZW1vdmFsIG9mIHNlbnQgZXZlbnRzLlxuICAgICAgICAgIGlmIChzY29wZS5vcHRpb25zLnNhdmVFdmVudHMpIHtcbiAgICAgICAgICAgIHNjb3BlLnNhdmVFdmVudHMoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZW5kIG1vcmUgZXZlbnRzIGlmIGFueSBxdWV1ZWQgZHVyaW5nIHByZXZpb3VzIHNlbmQuXG4gICAgICAgICAgaWYgKCFzY29wZS5fc2VuZEV2ZW50c0lmUmVhZHkoY2FsbGJhY2spICYmIHR5cGUoY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhzdGF0dXMsIHJlc3BvbnNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBoYW5kbGUgcGF5bG9hZCB0b28gbGFyZ2VcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDQxMykge1xuICAgICAgICAgIC8vIHV0aWxzLmxvZygncmVxdWVzdCB0b28gbGFyZ2UnKTtcbiAgICAgICAgICAvLyBDYW4ndCBldmVuIGdldCB0aGlzIG9uZSBtYXNzaXZlIGV2ZW50IHRocm91Z2guIERyb3AgaXQsIGV2ZW4gaWYgaXQgaXMgYW4gaWRlbnRpZnkuXG4gICAgICAgICAgaWYgKHNjb3BlLm9wdGlvbnMudXBsb2FkQmF0Y2hTaXplID09PSAxKSB7XG4gICAgICAgICAgICBzY29wZS5yZW1vdmVFdmVudHMobWF4RXZlbnRJZCwgbWF4SWRlbnRpZnlJZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVGhlIHNlcnZlciBjb21wbGFpbmVkIGFib3V0IHRoZSBsZW5ndGggb2YgdGhlIHJlcXVlc3QuIEJhY2tvZmYgYW5kIHRyeSBhZ2Fpbi5cbiAgICAgICAgICBzY29wZS5vcHRpb25zLnVwbG9hZEJhdGNoU2l6ZSA9IE1hdGguY2VpbChudW1FdmVudHMgLyAyKTtcbiAgICAgICAgICBzY29wZS5zZW5kRXZlbnRzKGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlKGNhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIElmIHNlcnZlciB0dXJucyBzb21ldGhpbmcgbGlrZSBhIDQwMFxuICAgICAgICAgIGNhbGxiYWNrKHN0YXR1cywgcmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIHV0aWxzLmxvZygnZmFpbGVkIHVwbG9hZCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNZXJnZSB1bnNlbnQgZXZlbnRzIGFuZCBpZGVudGlmeXMgdG9nZXRoZXIgaW4gc2VxdWVudGlhbCBvcmRlciBiYXNlZCBvbiB0aGVpciBzZXF1ZW5jZSBudW1iZXIsIGZvciB1cGxvYWRpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBBbXBsaXR1ZGVDbGllbnQucHJvdG90eXBlLl9tZXJnZUV2ZW50c0FuZElkZW50aWZ5cyA9IGZ1bmN0aW9uIF9tZXJnZUV2ZW50c0FuZElkZW50aWZ5cyhudW1FdmVudHMpIHtcbiAgICAvLyBjb2FsZXNjZSBldmVudHMgZnJvbSBib3RoIHF1ZXVlc1xuICAgIHZhciBldmVudHNUb1NlbmQgPSBbXTtcbiAgICB2YXIgZXZlbnRJbmRleCA9IDA7XG4gICAgdmFyIG1heEV2ZW50SWQgPSAtMTtcbiAgICB2YXIgaWRlbnRpZnlJbmRleCA9IDA7XG4gICAgdmFyIG1heElkZW50aWZ5SWQgPSAtMTtcblxuICAgIHdoaWxlIChldmVudHNUb1NlbmQubGVuZ3RoIDwgbnVtRXZlbnRzKSB7XG4gICAgICB2YXIgZXZlbnQ7XG4gICAgICB2YXIgbm9JZGVudGlmeXMgPSBpZGVudGlmeUluZGV4ID49IHRoaXMuX3Vuc2VudElkZW50aWZ5cy5sZW5ndGg7XG4gICAgICB2YXIgbm9FdmVudHMgPSBldmVudEluZGV4ID49IHRoaXMuX3Vuc2VudEV2ZW50cy5sZW5ndGg7XG5cbiAgICAgIC8vIGNhc2UgMDogbm8gZXZlbnRzIG9yIGlkZW50aWZ5cyBsZWZ0XG4gICAgICAvLyBub3RlIHRoaXMgc2hvdWxkIG5vdCBoYXBwZW4sIHRoaXMgbWVhbnMgd2UgaGF2ZSBsZXNzIGV2ZW50cyBhbmQgaWRlbnRpZnlzIHRoYW4gZXhwZWN0ZWRcbiAgICAgIGlmIChub0V2ZW50cyAmJiBub0lkZW50aWZ5cykge1xuICAgICAgICB1dGlscy5sb2cuZXJyb3IoJ01lcmdpbmcgRXZlbnRzIGFuZCBJZGVudGlmeXMsIGxlc3MgZXZlbnRzIGFuZCBpZGVudGlmeXMgdGhhbiBleHBlY3RlZCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gY2FzZSAxOiBubyBpZGVudGlmeXMgLSBncmFiIGZyb20gZXZlbnRzXG4gICAgICBlbHNlIGlmIChub0lkZW50aWZ5cykge1xuICAgICAgICAgIGV2ZW50ID0gdGhpcy5fdW5zZW50RXZlbnRzW2V2ZW50SW5kZXgrK107XG4gICAgICAgICAgbWF4RXZlbnRJZCA9IGV2ZW50LmV2ZW50X2lkO1xuXG4gICAgICAgICAgLy8gY2FzZSAyOiBubyBldmVudHMgLSBncmFiIGZyb20gaWRlbnRpZnlzXG4gICAgICAgIH0gZWxzZSBpZiAobm9FdmVudHMpIHtcbiAgICAgICAgICBldmVudCA9IHRoaXMuX3Vuc2VudElkZW50aWZ5c1tpZGVudGlmeUluZGV4KytdO1xuICAgICAgICAgIG1heElkZW50aWZ5SWQgPSBldmVudC5ldmVudF9pZDtcblxuICAgICAgICAgIC8vIGNhc2UgMzogbmVlZCB0byBjb21wYXJlIHNlcXVlbmNlIG51bWJlcnNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBldmVudHMgbG9nZ2VkIGJlZm9yZSB2Mi41LjAgd29uJ3QgaGF2ZSBhIHNlcXVlbmNlIG51bWJlciwgcHV0IHRob3NlIGZpcnN0XG4gICAgICAgICAgaWYgKCEoJ3NlcXVlbmNlX251bWJlcicgaW4gdGhpcy5fdW5zZW50RXZlbnRzW2V2ZW50SW5kZXhdKSB8fCB0aGlzLl91bnNlbnRFdmVudHNbZXZlbnRJbmRleF0uc2VxdWVuY2VfbnVtYmVyIDwgdGhpcy5fdW5zZW50SWRlbnRpZnlzW2lkZW50aWZ5SW5kZXhdLnNlcXVlbmNlX251bWJlcikge1xuICAgICAgICAgICAgZXZlbnQgPSB0aGlzLl91bnNlbnRFdmVudHNbZXZlbnRJbmRleCsrXTtcbiAgICAgICAgICAgIG1heEV2ZW50SWQgPSBldmVudC5ldmVudF9pZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXZlbnQgPSB0aGlzLl91bnNlbnRJZGVudGlmeXNbaWRlbnRpZnlJbmRleCsrXTtcbiAgICAgICAgICAgIG1heElkZW50aWZ5SWQgPSBldmVudC5ldmVudF9pZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgZXZlbnRzVG9TZW5kLnB1c2goZXZlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBldmVudHNUb1NlbmQ6IGV2ZW50c1RvU2VuZCxcbiAgICAgIG1heEV2ZW50SWQ6IG1heEV2ZW50SWQsXG4gICAgICBtYXhJZGVudGlmeUlkOiBtYXhJZGVudGlmeUlkXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGdsb2JhbCB1c2VyIHByb3BlcnRpZXMuIE5vdGUgdGhpcyBpcyBkZXByZWNhdGVkLCBhbmQgd2UgcmVjb21tZW5kIHVzaW5nIHNldFVzZXJQcm9wZXJ0aWVzXG4gICAqIEBwdWJsaWNcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUuc2V0R2xvYmFsVXNlclByb3BlcnRpZXMgPSBmdW5jdGlvbiBzZXRHbG9iYWxVc2VyUHJvcGVydGllcyh1c2VyUHJvcGVydGllcykge1xuICAgIHRoaXMuc2V0VXNlclByb3BlcnRpZXModXNlclByb3BlcnRpZXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBBbXBsaXR1ZGUncyBKYXZhc2NyaXB0IFNESy5cbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7bnVtYmVyfSB2ZXJzaW9uIG51bWJlclxuICAgKiBAZXhhbXBsZSB2YXIgYW1wbGl0dWRlVmVyc2lvbiA9IGFtcGxpdHVkZS5fX1ZFUlNJT05fXztcbiAgICovXG4gIEFtcGxpdHVkZUNsaWVudC5wcm90b3R5cGUuX19WRVJTSU9OX18gPSB2ZXJzaW9uO1xuXG4gIC8qKlxuICAgKiBBbXBsaXR1ZGUgU0RLIEFQSSAtIGluc3RhbmNlIG1hbmFnZXIuXG4gICAqIEZ1bmN0aW9uIGNhbGxzIGRpcmVjdGx5IG9uIGFtcGxpdHVkZSBoYXZlIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIGNhbGwgbWV0aG9kcyBvbiB0aGUgZGVmYXVsdCBzaGFyZWQgaW5zdGFuY2U6IGFtcGxpdHVkZS5nZXRJbnN0YW5jZSgpIGluc3RlYWQuXG4gICAqIFNlZSBbUmVhZG1lXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vYW1wbGl0dWRlL0FtcGxpdHVkZS1KYXZhc2NyaXB0IzMwMC11cGRhdGUtYW5kLWxvZ2dpbmctZXZlbnRzLXRvLW11bHRpcGxlLWFtcGxpdHVkZS1hcHBzfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIGNoYW5nZS5cbiAgICogQGNvbnN0cnVjdG9yIEFtcGxpdHVkZVxuICAgKiBAcHVibGljXG4gICAqIEBleGFtcGxlIHZhciBhbXBsaXR1ZGUgPSBuZXcgQW1wbGl0dWRlKCk7XG4gICAqL1xuICB2YXIgQW1wbGl0dWRlID0gZnVuY3Rpb24gQW1wbGl0dWRlKCkge1xuICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbl8xJDEoe30sIERFRkFVTFRfT1BUSU9OUyk7XG4gICAgdGhpcy5fcSA9IFtdO1xuICAgIHRoaXMuX2luc3RhbmNlcyA9IHt9OyAvLyBtYXBwaW5nIG9mIGluc3RhbmNlIG5hbWVzIHRvIGluc3RhbmNlc1xuICB9O1xuXG4gIEFtcGxpdHVkZS5wcm90b3R5cGUuSWRlbnRpZnkgPSBJZGVudGlmeTtcbiAgQW1wbGl0dWRlLnByb3RvdHlwZS5SZXZlbnVlID0gUmV2ZW51ZTtcblxuICBBbXBsaXR1ZGUucHJvdG90eXBlLmdldEluc3RhbmNlID0gZnVuY3Rpb24gZ2V0SW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICBpbnN0YW5jZSA9IHV0aWxzLmlzRW1wdHlTdHJpbmcoaW5zdGFuY2UpID8gY29uc3RhbnRzLkRFRkFVTFRfSU5TVEFOQ0UgOiBpbnN0YW5jZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBjbGllbnQgPSB0aGlzLl9pbnN0YW5jZXNbaW5zdGFuY2VdO1xuICAgIGlmIChjbGllbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xpZW50ID0gbmV3IEFtcGxpdHVkZUNsaWVudChpbnN0YW5jZSk7XG4gICAgICB0aGlzLl9pbnN0YW5jZXNbaW5zdGFuY2VdID0gY2xpZW50O1xuICAgIH1cbiAgICByZXR1cm4gY2xpZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgQW1wbGl0dWRlIEphdmFzY3JpcHQgU0RLIHdpdGggeW91ciBhcGlLZXkgYW5kIGFueSBvcHRpb25hbCBjb25maWd1cmF0aW9ucy5cbiAgICogVGhpcyBpcyByZXF1aXJlZCBiZWZvcmUgYW55IG90aGVyIG1ldGhvZHMgY2FuIGJlIGNhbGxlZC5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gYXBpS2V5IC0gVGhlIEFQSSBrZXkgZm9yIHlvdXIgYXBwLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0X3VzZXJJZCAtIChvcHRpb25hbCkgQW4gaWRlbnRpZmllciBmb3IgdGhpcyB1c2VyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0X2NvbmZpZyAtIChvcHRpb25hbCkgQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgKiBTZWUgW1JlYWRtZV17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FtcGxpdHVkZS9BbXBsaXR1ZGUtSmF2YXNjcmlwdCNjb25maWd1cmF0aW9uLW9wdGlvbnN9IGZvciBsaXN0IG9mIG9wdGlvbnMgYW5kIGRlZmF1bHQgdmFsdWVzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRfY2FsbGJhY2sgLSAob3B0aW9uYWwpIFByb3ZpZGUgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBydW4gYWZ0ZXIgaW5pdGlhbGl6YXRpb24gaXMgY29tcGxldGUuXG4gICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYW1wbGl0dWRlLmdldEluc3RhbmNlKCkuaW5pdChhcGlLZXksIG9wdF91c2VySWQsIG9wdF9jb25maWcsIG9wdF9jYWxsYmFjayk7XG4gICAqIEBleGFtcGxlIGFtcGxpdHVkZS5pbml0KCdBUElfS0VZJywgJ1VTRVJfSUQnLCB7aW5jbHVkZVJlZmVycmVyOiB0cnVlLCBpbmNsdWRlVXRtOiB0cnVlfSwgZnVuY3Rpb24oKSB7IGFsZXJ0KCdpbml0IGNvbXBsZXRlJyk7IH0pO1xuICAgKi9cbiAgQW1wbGl0dWRlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdChhcGlLZXksIG9wdF91c2VySWQsIG9wdF9jb25maWcsIG9wdF9jYWxsYmFjaykge1xuICAgIHRoaXMuZ2V0SW5zdGFuY2UoKS5pbml0KGFwaUtleSwgb3B0X3VzZXJJZCwgb3B0X2NvbmZpZywgZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAvLyBtYWtlIG9wdGlvbnMgc3VjaCBhcyBkZXZpY2VJZCBhdmFpbGFibGUgZm9yIGNhbGxiYWNrIGZ1bmN0aW9uc1xuICAgICAgdGhpcy5vcHRpb25zID0gaW5zdGFuY2Uub3B0aW9ucztcbiAgICAgIGlmICh0eXBlKG9wdF9jYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3B0X2NhbGxiYWNrKGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSdW4gZnVuY3Rpb25zIHF1ZXVlZCB1cCBieSBwcm94eSBsb2FkaW5nIHNuaXBwZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEFtcGxpdHVkZS5wcm90b3R5cGUucnVuUXVldWVkRnVuY3Rpb25zID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHJ1biBxdWV1ZWQgdXAgb2xkIHZlcnNpb25zIG9mIGZ1bmN0aW9uc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZuID0gdGhpc1t0aGlzLl9xW2ldWzBdXTtcbiAgICAgIGlmICh0eXBlKGZuKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmbi5hcHBseSh0aGlzLCB0aGlzLl9xW2ldLnNsaWNlKDEpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fcSA9IFtdOyAvLyBjbGVhciBmdW5jdGlvbiBxdWV1ZSBhZnRlciBydW5uaW5nXG5cbiAgICAvLyBydW4gcXVldWVkIHVwIGZ1bmN0aW9ucyBvbiBpbnN0YW5jZXNcbiAgICBmb3IgKHZhciBpbnN0YW5jZSBpbiB0aGlzLl9pbnN0YW5jZXMpIHtcbiAgICAgIGlmICh0aGlzLl9pbnN0YW5jZXMuaGFzT3duUHJvcGVydHkoaW5zdGFuY2UpKSB7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlc1tpbnN0YW5jZV0ucnVuUXVldWVkRnVuY3Rpb25zKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYSBuZXcgc2Vzc2lvbiB3YXMgY3JlYXRlZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24sIG90aGVyd2lzZSBmYWxzZS5cbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIGEgbmV3IHNlc3Npb24gd2FzIGNyZWF0ZWQgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGFtcGxpdHVkZS5nZXRJbnN0YW5jZSgpLmlzTmV3U2Vzc2lvbigpO1xuICAgKi9cbiAgQW1wbGl0dWRlLnByb3RvdHlwZS5pc05ld1Nlc3Npb24gPSBmdW5jdGlvbiBpc05ld1Nlc3Npb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UoKS5pc05ld1Nlc3Npb24oKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaWQgb2YgdGhlIGN1cnJlbnQgc2Vzc2lvbi5cbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9IElkIG9mIHRoZSBjdXJyZW50IHNlc3Npb24uXG4gICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYW1wbGl0dWRlLmdldEluc3RhbmNlKCkuZ2V0U2Vzc2lvbklkKCk7XG4gICAqL1xuICBBbXBsaXR1ZGUucHJvdG90eXBlLmdldFNlc3Npb25JZCA9IGZ1bmN0aW9uIGdldFNlc3Npb25JZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSgpLmdldFNlc3Npb25JZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbmNyZW1lbnRzIHRoZSBldmVudElkIGFuZCByZXR1cm5zIGl0LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQW1wbGl0dWRlLnByb3RvdHlwZS5uZXh0RXZlbnRJZCA9IGZ1bmN0aW9uIG5leHRFdmVudElkKCkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKCkubmV4dEV2ZW50SWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogSW5jcmVtZW50cyB0aGUgaWRlbnRpZnlJZCBhbmQgcmV0dXJucyBpdC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEFtcGxpdHVkZS5wcm90b3R5cGUubmV4dElkZW50aWZ5SWQgPSBmdW5jdGlvbiBuZXh0SWRlbnRpZnlJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSgpLm5leHRJZGVudGlmeUlkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudHMgdGhlIHNlcXVlbmNlTnVtYmVyIGFuZCByZXR1cm5zIGl0LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQW1wbGl0dWRlLnByb3RvdHlwZS5uZXh0U2VxdWVuY2VOdW1iZXIgPSBmdW5jdGlvbiBuZXh0U2VxdWVuY2VOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UoKS5uZXh0U2VxdWVuY2VOdW1iZXIoKTtcbiAgfTtcblxuICAvKipcbiAgICogU2F2ZXMgdW5zZW50IGV2ZW50cyBhbmQgaWRlbnRpZmllcyB0byBsb2NhbFN0b3JhZ2UuIEpTT04gc3RyaW5naWZpZXMgZXZlbnQgcXVldWVzIGJlZm9yZSBzYXZpbmcuXG4gICAqIE5vdGU6IHRoaXMgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgZXZlcnkgdGltZSBldmVudHMgYXJlIGxvZ2dlZCwgdW5sZXNzIHlvdSBleHBsaWNpdGx5IHNldCBvcHRpb24gc2F2ZUV2ZW50cyB0byBmYWxzZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEFtcGxpdHVkZS5wcm90b3R5cGUuc2F2ZUV2ZW50cyA9IGZ1bmN0aW9uIHNhdmVFdmVudHMoKSB7XG4gICAgdGhpcy5nZXRJbnN0YW5jZSgpLnNhdmVFdmVudHMoKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyBhIGN1c3RvbWVyIGRvbWFpbiBmb3IgdGhlIGFtcGxpdHVkZSBjb29raWUuIFVzZWZ1bCBpZiB5b3Ugd2FudCB0byBzdXBwb3J0IGNyb3NzLXN1YmRvbWFpbiB0cmFja2luZy5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZG9tYWluIHRvIHNldC5cbiAgICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBhbXBsaXR1ZGUuZ2V0SW5zdGFuY2UoKS5zZXREb21haW4oZG9tYWluKTtcbiAgICogQGV4YW1wbGUgYW1wbGl0dWRlLnNldERvbWFpbignLmFtcGxpdHVkZS5jb20nKTtcbiAgICovXG4gIEFtcGxpdHVkZS5wcm90b3R5cGUuc2V0RG9tYWluID0gZnVuY3Rpb24gc2V0RG9tYWluKGRvbWFpbikge1xuICAgIHRoaXMuZ2V0SW5zdGFuY2UoKS5zZXREb21haW4oZG9tYWluKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyBhbiBpZGVudGlmaWVyIGZvciB0aGUgY3VycmVudCB1c2VyLlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgLSBpZGVudGlmaWVyIHRvIHNldC4gQ2FuIGJlIG51bGwuXG4gICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYW1wbGl0dWRlLmdldEluc3RhbmNlKCkuc2V0VXNlcklkKHVzZXJJZCk7XG4gICAqIEBleGFtcGxlIGFtcGxpdHVkZS5zZXRVc2VySWQoJ2pvZUBnbWFpbC5jb20nKTtcbiAgICovXG4gIEFtcGxpdHVkZS5wcm90b3R5cGUuc2V0VXNlcklkID0gZnVuY3Rpb24gc2V0VXNlcklkKHVzZXJJZCkge1xuICAgIHRoaXMuZ2V0SW5zdGFuY2UoKS5zZXRVc2VySWQodXNlcklkKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIHVzZXIgdG8gYSBncm91cCBvciBncm91cHMuIFlvdSBuZWVkIHRvIHNwZWNpZnkgYSBncm91cFR5cGUgYW5kIGdyb3VwTmFtZShzKS5cbiAgICogRm9yIGV4YW1wbGUgeW91IGNhbiBncm91cCBwZW9wbGUgYnkgdGhlaXIgb3JnYW5pemF0aW9uLlxuICAgKiBJbiB0aGF0IGNhc2UgZ3JvdXBUeXBlIGlzIFwib3JnSWRcIiBhbmQgZ3JvdXBOYW1lIHdvdWxkIGJlIHRoZSBhY3R1YWwgSUQocykuXG4gICAqIGdyb3VwTmFtZSBjYW4gYmUgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0byBpbmRpY2F0ZSBhIHVzZXIgaW4gbXVsdGlwbGUgZ3J1dXBzLlxuICAgKiBZb3UgY2FuIGFsc28gY2FsbCBzZXRHcm91cCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBncm91cFR5cGVzIHRvIHRyYWNrIG11bHRpcGxlIHR5cGVzIG9mIGdyb3VwcyAodXAgdG8gNSBwZXIgYXBwKS5cbiAgICogTm90ZTogdGhpcyB3aWxsIGFsc28gc2V0IGdyb3VwVHlwZTogZ3JvdXBOYW1lIGFzIGEgdXNlciBwcm9wZXJ0eS5cbiAgICogU2VlIHRoZSBbU0RLIFJlYWRtZV17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FtcGxpdHVkZS9BbXBsaXR1ZGUtSmF2YXNjcmlwdCNzZXR0aW5nLWdyb3Vwc30gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGdyb3VwVHlwZSAtIHRoZSBncm91cCB0eXBlIChleDogb3JnSWQpXG4gICAqIEBwYXJhbSB7c3RyaW5nfGxpc3R9IGdyb3VwTmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBncm91cCAoZXg6IDE1KSwgb3IgYSBsaXN0IG9mIG5hbWVzIG9mIHRoZSBncm91cHNcbiAgICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBhbXBsaXR1ZGUuZ2V0SW5zdGFuY2UoKS5zZXRHcm91cChncm91cFR5cGUsIGdyb3VwTmFtZSk7XG4gICAqIEBleGFtcGxlIGFtcGxpdHVkZS5zZXRHcm91cCgnb3JnSWQnLCAxNSk7IC8vIHRoaXMgYWRkcyB0aGUgY3VycmVudCB1c2VyIHRvIG9yZ0lkIDE1LlxuICAgKi9cbiAgQW1wbGl0dWRlLnByb3RvdHlwZS5zZXRHcm91cCA9IGZ1bmN0aW9uIChncm91cFR5cGUsIGdyb3VwTmFtZSkge1xuICAgIHRoaXMuZ2V0SW5zdGFuY2UoKS5zZXRHcm91cChncm91cFR5cGUsIGdyb3VwTmFtZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0byBvcHQgY3VycmVudCB1c2VyIG91dCBvZiB0cmFja2luZy5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZSAtIGlmIHRydWUgdGhlbiBubyBldmVudHMgd2lsbCBiZSBsb2dnZWQgb3Igc2VudC5cbiAgICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBhbXBsaXR1ZGUuZ2V0SW5zdGFuY2UoKS5zZXRPcHRPdXQoZW5hYmxlKTtcbiAgICogQGV4YW1wbGU6IGFtcGxpdHVkZS5zZXRPcHRPdXQodHJ1ZSk7XG4gICAqL1xuICBBbXBsaXR1ZGUucHJvdG90eXBlLnNldE9wdE91dCA9IGZ1bmN0aW9uIHNldE9wdE91dChlbmFibGUpIHtcbiAgICB0aGlzLmdldEluc3RhbmNlKCkuc2V0T3B0T3V0KGVuYWJsZSk7XG4gIH07XG5cbiAgLyoqXG4gICAgKiBSZWdlbmVyYXRlcyBhIG5ldyByYW5kb20gZGV2aWNlSWQgZm9yIGN1cnJlbnQgdXNlci4gTm90ZTogdGhpcyBpcyBub3QgcmVjb21tZW5kZWQgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91XG4gICAgKiBhcmUgZG9pbmcuIFRoaXMgY2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgc2V0VXNlcklkKG51bGwpYCB0byBhbm9ueW1pemUgdXNlcnMgYWZ0ZXIgdGhleSBsb2cgb3V0LlxuICAgICogV2l0aCBhIG51bGwgdXNlcklkIGFuZCBhIGNvbXBsZXRlbHkgbmV3IGRldmljZUlkLCB0aGUgY3VycmVudCB1c2VyIHdvdWxkIGFwcGVhciBhcyBhIGJyYW5kIG5ldyB1c2VyIGluIGRhc2hib2FyZC5cbiAgICAqIFRoaXMgdXNlcyBzcmMvdXVpZC5qcyB0byByZWdlbmVyYXRlIHRoZSBkZXZpY2VJZC5cbiAgICAqIEBwdWJsaWNcbiAgICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYW1wbGl0dWRlLmdldEluc3RhbmNlKCkucmVnZW5lcmF0ZURldmljZUlkKCk7XG4gICAgKi9cbiAgQW1wbGl0dWRlLnByb3RvdHlwZS5yZWdlbmVyYXRlRGV2aWNlSWQgPSBmdW5jdGlvbiByZWdlbmVyYXRlRGV2aWNlSWQoKSB7XG4gICAgdGhpcy5nZXRJbnN0YW5jZSgpLnJlZ2VuZXJhdGVEZXZpY2VJZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgICogU2V0cyBhIGN1c3RvbSBkZXZpY2VJZCBmb3IgY3VycmVudCB1c2VyLiBOb3RlOiB0aGlzIGlzIG5vdCByZWNvbW1lbmRlZCB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nXG4gICAgKiAobGlrZSBpZiB5b3UgaGF2ZSB5b3VyIG93biBzeXN0ZW0gZm9yIG1hbmFnaW5nIGRldmljZUlkcykuIE1ha2Ugc3VyZSB0aGUgZGV2aWNlSWQgeW91IHNldCBpcyBzdWZmaWNpZW50bHkgdW5pcXVlXG4gICAgKiAod2UgcmVjb21tZW5kIHNvbWV0aGluZyBsaWtlIGEgVVVJRCAtIHNlZSBzcmMvdXVpZC5qcyBmb3IgYW4gZXhhbXBsZSBvZiBob3cgdG8gZ2VuZXJhdGUpIHRvIHByZXZlbnQgY29uZmxpY3RzIHdpdGggb3RoZXIgZGV2aWNlcyBpbiBvdXIgc3lzdGVtLlxuICAgICogQHB1YmxpY1xuICAgICogQHBhcmFtIHtzdHJpbmd9IGRldmljZUlkIC0gY3VzdG9tIGRldmljZUlkIGZvciBjdXJyZW50IHVzZXIuXG4gICAgKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGFtcGxpdHVkZS5nZXRJbnN0YW5jZSgpLnNldERldmljZUlkKGRldmljZUlkKTtcbiAgICAqIEBleGFtcGxlIGFtcGxpdHVkZS5zZXREZXZpY2VJZCgnNDVmMDk1NGYtZWI3OS00NDYzLWFjOGEtMjMzYTZmNDVhOGYwJyk7XG4gICAgKi9cbiAgQW1wbGl0dWRlLnByb3RvdHlwZS5zZXREZXZpY2VJZCA9IGZ1bmN0aW9uIHNldERldmljZUlkKGRldmljZUlkKSB7XG4gICAgdGhpcy5nZXRJbnN0YW5jZSgpLnNldERldmljZUlkKGRldmljZUlkKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB1c2VyIHByb3BlcnRpZXMgZm9yIHRoZSBjdXJyZW50IHVzZXIuXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtvYmplY3R9IC0gb2JqZWN0IHdpdGggc3RyaW5nIGtleXMgYW5kIHZhbHVlcyBmb3IgdGhlIHVzZXIgcHJvcGVydGllcyB0byBzZXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gLSBERVBSRUNBVEVEIG9wdF9yZXBsYWNlOiBpbiBlYXJsaWVyIHZlcnNpb25zIG9mIHRoZSBKUyBTREsgdGhlIHVzZXIgcHJvcGVydGllcyBvYmplY3Qgd2FzIGtlcHQgaW5cbiAgICogbWVtb3J5IGFuZCByZXBsYWNlID0gdHJ1ZSB3b3VsZCByZXBsYWNlIHRoZSBvYmplY3QgaW4gbWVtb3J5LiBOb3cgdGhlIHByb3BlcnRpZXMgYXJlIG5vIGxvbmdlciBzdG9yZWQgaW4gbWVtb3J5LCBzbyByZXBsYWNlIGlzIGRlcHJlY2F0ZWQuXG4gICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYW1wbGl0dWRlLmdldEluc3RhbmNlLnNldFVzZXJQcm9wZXJ0aWVzKHVzZXJQcm9wZXJ0aWVzKTtcbiAgICogQGV4YW1wbGUgYW1wbGl0dWRlLnNldFVzZXJQcm9wZXJ0aWVzKHsnZ2VuZGVyJzogJ2ZlbWFsZScsICdzaWduX3VwX2NvbXBsZXRlJzogdHJ1ZX0pXG4gICAqL1xuICBBbXBsaXR1ZGUucHJvdG90eXBlLnNldFVzZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gc2V0VXNlclByb3BlcnRpZXModXNlclByb3BlcnRpZXMpIHtcbiAgICB0aGlzLmdldEluc3RhbmNlKCkuc2V0VXNlclByb3BlcnRpZXModXNlclByb3BlcnRpZXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgb2YgdGhlIHVzZXIgcHJvcGVydGllcyBmb3IgdGhlIGN1cnJlbnQgdXNlci4gTm90ZTogY2xlYXJpbmcgdXNlciBwcm9wZXJ0aWVzIGlzIGlycmV2ZXJzaWJsZSFcbiAgICogQHB1YmxpY1xuICAgKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGFtcGxpdHVkZS5nZXRJbnN0YW5jZSgpLmNsZWFyVXNlclByb3BlcnRpZXMoKTtcbiAgICogQGV4YW1wbGUgYW1wbGl0dWRlLmNsZWFyVXNlclByb3BlcnRpZXMoKTtcbiAgICovXG4gIEFtcGxpdHVkZS5wcm90b3R5cGUuY2xlYXJVc2VyUHJvcGVydGllcyA9IGZ1bmN0aW9uIGNsZWFyVXNlclByb3BlcnRpZXMoKSB7XG4gICAgdGhpcy5nZXRJbnN0YW5jZSgpLmNsZWFyVXNlclByb3BlcnRpZXMoKTtcbiAgfTtcblxuICAvKipcbiAgICogU2VuZCBhbiBpZGVudGlmeSBjYWxsIGNvbnRhaW5pbmcgdXNlciBwcm9wZXJ0eSBvcGVyYXRpb25zIHRvIEFtcGxpdHVkZSBzZXJ2ZXJzLlxuICAgKiBTZWUgW1JlYWRtZV17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FtcGxpdHVkZS9BbXBsaXR1ZGUtSmF2YXNjcmlwdCN1c2VyLXByb3BlcnRpZXMtYW5kLXVzZXItcHJvcGVydHktb3BlcmF0aW9uc31cbiAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlIElkZW50aWZ5IEFQSSBhbmQgdXNlciBwcm9wZXJ0eSBvcGVyYXRpb25zLlxuICAgKiBAcGFyYW0ge0lkZW50aWZ5fSBpZGVudGlmeV9vYmogLSB0aGUgSWRlbnRpZnkgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHVzZXIgcHJvcGVydHkgb3BlcmF0aW9ucyB0byBzZW5kLlxuICAgKiBAcGFyYW0ge0FtcGxpdHVkZX5ldmVudENhbGxiYWNrfSBvcHRfY2FsbGJhY2sgLSAob3B0aW9uYWwpIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIHRoZSBpZGVudGlmeSBldmVudCBoYXMgYmVlbiBzZW50LlxuICAgKiBOb3RlOiB0aGUgc2VydmVyIHJlc3BvbnNlIGNvZGUgYW5kIHJlc3BvbnNlIGJvZHkgZnJvbSB0aGUgaWRlbnRpZnkgZXZlbnQgdXBsb2FkIGFyZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGFtcGxpdHVkZS5nZXRJbnN0YW5jZSgpLmlkZW50aWZ5KGlkZW50aWZ5KTtcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGlkZW50aWZ5ID0gbmV3IGFtcGxpdHVkZS5JZGVudGlmeSgpLnNldCgnY29sb3JzJywgWydyb3NlJywgJ2dvbGQnXSkuYWRkKCdrYXJtYScsIDEpLnNldE9uY2UoJ3NpZ25fdXBfZGF0ZScsICcyMDE2LTAzLTMxJyk7XG4gICAqIGFtcGxpdHVkZS5pZGVudGlmeShpZGVudGlmeSk7XG4gICAqL1xuICBBbXBsaXR1ZGUucHJvdG90eXBlLmlkZW50aWZ5ID0gZnVuY3Rpb24gKGlkZW50aWZ5X29iaiwgb3B0X2NhbGxiYWNrKSB7XG4gICAgdGhpcy5nZXRJbnN0YW5jZSgpLmlkZW50aWZ5KGlkZW50aWZ5X29iaiwgb3B0X2NhbGxiYWNrKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGEgdmVyc2lvbk5hbWUgZm9yIHlvdXIgYXBwbGljYXRpb24uXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZlcnNpb25OYW1lIC0gVGhlIHZlcnNpb24gdG8gc2V0IGZvciB5b3VyIGFwcGxpY2F0aW9uLlxuICAgKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGFtcGxpdHVkZS5nZXRJbnN0YW5jZSgpLnNldFZlcnNpb25OYW1lKHZlcnNpb25OYW1lKTtcbiAgICogQGV4YW1wbGUgYW1wbGl0dWRlLnNldFZlcnNpb25OYW1lKCcxLjEyLjMnKTtcbiAgICovXG4gIEFtcGxpdHVkZS5wcm90b3R5cGUuc2V0VmVyc2lvbk5hbWUgPSBmdW5jdGlvbiBzZXRWZXJzaW9uTmFtZSh2ZXJzaW9uTmFtZSkge1xuICAgIHRoaXMuZ2V0SW5zdGFuY2UoKS5zZXRWZXJzaW9uTmFtZSh2ZXJzaW9uTmFtZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIGNhbGxiYWNrIGZvciBsb2dFdmVudCBhbmQgaWRlbnRpZnkgY2FsbHMuIEl0IGdldHMgY2FsbGVkIGFmdGVyIHRoZSBldmVudC9pZGVudGlmeSBpcyB1cGxvYWRlZCxcbiAgICogYW5kIHRoZSBzZXJ2ZXIgcmVzcG9uc2UgY29kZSBhbmQgcmVzcG9uc2UgYm9keSBmcm9tIHRoZSB1cGxvYWQgcmVxdWVzdCBhcmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQGNhbGxiYWNrIEFtcGxpdHVkZX5ldmVudENhbGxiYWNrXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNwb25zZUNvZGUgLSBTZXJ2ZXIgcmVzcG9uc2UgY29kZSBmb3IgdGhlIGV2ZW50IC8gaWRlbnRpZnkgdXBsb2FkIHJlcXVlc3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZXNwb25zZUJvZHkgLSBTZXJ2ZXIgcmVzcG9uc2UgYm9keSBmb3IgdGhlIGV2ZW50IC8gaWRlbnRpZnkgdXBsb2FkIHJlcXVlc3QuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBMb2cgYW4gZXZlbnQgd2l0aCBldmVudFR5cGUgYW5kIGV2ZW50UHJvcGVydGllc1xuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgLSBuYW1lIG9mIGV2ZW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFByb3BlcnRpZXMgLSAob3B0aW9uYWwpIGFuIG9iamVjdCB3aXRoIHN0cmluZyBrZXlzIGFuZCB2YWx1ZXMgZm9yIHRoZSBldmVudCBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0ge0FtcGxpdHVkZX5ldmVudENhbGxiYWNrfSBvcHRfY2FsbGJhY2sgLSAob3B0aW9uYWwpIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gcnVuIGFmdGVyIHRoZSBldmVudCBpcyBsb2dnZWQuXG4gICAqIE5vdGU6IHRoZSBzZXJ2ZXIgcmVzcG9uc2UgY29kZSBhbmQgcmVzcG9uc2UgYm9keSBmcm9tIHRoZSBldmVudCB1cGxvYWQgYXJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYW1wbGl0dWRlLmdldEluc3RhbmNlKCkubG9nRXZlbnQoZXZlbnRUeXBlLCBldmVudFByb3BlcnRpZXMsIG9wdF9jYWxsYmFjayk7XG4gICAqIEBleGFtcGxlIGFtcGxpdHVkZS5sb2dFdmVudCgnQ2xpY2tlZCBIb21lcGFnZSBCdXR0b24nLCB7J2ZpbmlzaGVkX2Zsb3cnOiBmYWxzZSwgJ2NsaWNrcyc6IDE1fSk7XG4gICAqL1xuICBBbXBsaXR1ZGUucHJvdG90eXBlLmxvZ0V2ZW50ID0gZnVuY3Rpb24gbG9nRXZlbnQoZXZlbnRUeXBlLCBldmVudFByb3BlcnRpZXMsIG9wdF9jYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKCkubG9nRXZlbnQoZXZlbnRUeXBlLCBldmVudFByb3BlcnRpZXMsIG9wdF9jYWxsYmFjayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvZyBhbiBldmVudCB3aXRoIGV2ZW50VHlwZSwgZXZlbnRQcm9wZXJ0aWVzLCBhbmQgZ3JvdXBzLiBVc2UgdGhpcyB0byBzZXQgZXZlbnQtbGV2ZWwgZ3JvdXBzLlxuICAgKiBOb3RlOiB0aGUgZ3JvdXAocykgc2V0IG9ubHkgYXBwbHkgZm9yIHRoZSBzcGVjaWZpYyBldmVudCB0eXBlIGJlaW5nIGxvZ2dlZCBhbmQgZG9lcyBub3QgcGVyc2lzdCBvbiB0aGUgdXNlclxuICAgKiAodW5sZXNzIHlvdSBleHBsaWNpdGx5IHNldCBpdCB3aXRoIHNldEdyb3VwKS5cbiAgICogU2VlIHRoZSBbU0RLIFJlYWRtZV17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FtcGxpdHVkZS9BbXBsaXR1ZGUtSmF2YXNjcmlwdCNzZXR0aW5nLWdyb3Vwc30gZm9yIG1vcmUgaW5mb3JtYXRpb25cbiAgICogYWJvdXQgZ3JvdXBzIGFuZCBDb3VudCBieSBEaXN0aW5jdCBvbiB0aGUgQW1wbGl0dWRlIHBsYXRmb3JtLlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgLSBuYW1lIG9mIGV2ZW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFByb3BlcnRpZXMgLSAob3B0aW9uYWwpIGFuIG9iamVjdCB3aXRoIHN0cmluZyBrZXlzIGFuZCB2YWx1ZXMgZm9yIHRoZSBldmVudCBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0ge29iamVjdH0gZ3JvdXBzIC0gKG9wdGlvbmFsKSBhbiBvYmplY3Qgd2l0aCBzdHJpbmcgZ3JvdXBUeXBlOiBncm91cE5hbWUgdmFsdWVzIGZvciB0aGUgZXZlbnQgYmVpbmcgbG9nZ2VkLlxuICAgKiBncm91cE5hbWUgY2FuIGJlIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gICAqIEBwYXJhbSB7QW1wbGl0dWRlfmV2ZW50Q2FsbGJhY2t9IG9wdF9jYWxsYmFjayAtIChvcHRpb25hbCkgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBydW4gYWZ0ZXIgdGhlIGV2ZW50IGlzIGxvZ2dlZC5cbiAgICogTm90ZTogdGhlIHNlcnZlciByZXNwb25zZSBjb2RlIGFuZCByZXNwb25zZSBib2R5IGZyb20gdGhlIGV2ZW50IHVwbG9hZCBhcmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICogRGVwcmVjYXRlZCBQbGVhc2UgdXNlIGFtcGxpdHVkZS5nZXRJbnN0YW5jZSgpLmxvZ0V2ZW50V2l0aEdyb3VwcyhldmVudFR5cGUsIGV2ZW50UHJvcGVydGllcywgZ3JvdXBzLCBvcHRfY2FsbGJhY2spO1xuICAgKiBAZXhhbXBsZSBhbXBsaXR1ZGUubG9nRXZlbnRXaXRoR3JvdXBzKCdDbGlja2VkIEJ1dHRvbicsIG51bGwsIHsnb3JnSWQnOiAyNH0pO1xuICAgKi9cbiAgQW1wbGl0dWRlLnByb3RvdHlwZS5sb2dFdmVudFdpdGhHcm91cHMgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBldmVudFByb3BlcnRpZXMsIGdyb3Vwcywgb3B0X2NhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UoKS5sb2dFdmVudFdpdGhHcm91cHMoZXZlbnRUeXBlLCBldmVudFByb3BlcnRpZXMsIGdyb3Vwcywgb3B0X2NhbGxiYWNrKTtcbiAgfTtcblxuICAvKipcbiAgICogTG9nIHJldmVudWUgd2l0aCBSZXZlbnVlIGludGVyZmFjZS4gVGhlIG5ldyByZXZlbnVlIGludGVyZmFjZSBhbGxvd3MgZm9yIG1vcmUgcmV2ZW51ZSBmaWVsZHMgbGlrZVxuICAgKiByZXZlbnVlVHlwZSBhbmQgZXZlbnQgcHJvcGVydGllcy5cbiAgICogU2VlIFtSZWFkbWVde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9hbXBsaXR1ZGUvQW1wbGl0dWRlLUphdmFzY3JpcHQjdHJhY2tpbmctcmV2ZW51ZX1cbiAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlIFJldmVudWUgaW50ZXJmYWNlIGFuZCBsb2dnaW5nIHJldmVudWUuXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtSZXZlbnVlfSByZXZlbnVlX29iaiAtIHRoZSByZXZlbnVlIG9iamVjdCBjb250YWluaW5nIHRoZSByZXZlbnVlIGRhdGEgYmVpbmcgbG9nZ2VkLlxuICAgKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGFtcGxpdHVkZS5nZXRJbnN0YW5jZSgpLmxvZ1JldmVudWVWMihyZXZlbnVlX29iaik7XG4gICAqIEBleGFtcGxlIHZhciByZXZlbnVlID0gbmV3IGFtcGxpdHVkZS5SZXZlbnVlKCkuc2V0UHJvZHVjdElkKCdwcm9kdWN0SWRlbnRpZmllcicpLnNldFByaWNlKDEwLjk5KTtcbiAgICogYW1wbGl0dWRlLmxvZ1JldmVudWVWMihyZXZlbnVlKTtcbiAgICovXG4gIEFtcGxpdHVkZS5wcm90b3R5cGUubG9nUmV2ZW51ZVYyID0gZnVuY3Rpb24gbG9nUmV2ZW51ZVYyKHJldmVudWVfb2JqKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UoKS5sb2dSZXZlbnVlVjIocmV2ZW51ZV9vYmopO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb2cgcmV2ZW51ZSBldmVudCB3aXRoIGEgcHJpY2UsIHF1YW50aXR5LCBhbmQgcHJvZHVjdCBpZGVudGlmaWVyLiBERVBSRUNBVEVEIC0gdXNlIGxvZ1JldmVudWVWMlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwcmljZSAtIHByaWNlIG9mIHJldmVudWUgZXZlbnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHF1YW50aXR5IC0gKG9wdGlvbmFsKSBxdWFudGl0eSBvZiBwcm9kdWN0cyBpbiByZXZlbnVlIGV2ZW50LiBJZiBubyBxdWFudGl0eSBzcGVjaWZpZWQgZGVmYXVsdCB0byAxLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvZHVjdCAtIChvcHRpb25hbCkgcHJvZHVjdCBpZGVudGlmaWVyXG4gICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYW1wbGl0dWRlLmdldEluc3RhbmNlKCkubG9nUmV2ZW51ZVYyKHJldmVudWVfb2JqKTtcbiAgICogQGV4YW1wbGUgYW1wbGl0dWRlLmxvZ1JldmVudWUoMy45OSwgMSwgJ3Byb2R1Y3RfMTIzNCcpO1xuICAgKi9cbiAgQW1wbGl0dWRlLnByb3RvdHlwZS5sb2dSZXZlbnVlID0gZnVuY3Rpb24gbG9nUmV2ZW51ZShwcmljZSwgcXVhbnRpdHksIHByb2R1Y3QpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSgpLmxvZ1JldmVudWUocHJpY2UsIHF1YW50aXR5LCBwcm9kdWN0KTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGV2ZW50cyBpbiBzdG9yYWdlIHdpdGggZXZlbnQgaWRzIHVwIHRvIGFuZCBpbmNsdWRpbmcgbWF4RXZlbnRJZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEFtcGxpdHVkZS5wcm90b3R5cGUucmVtb3ZlRXZlbnRzID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRzKG1heEV2ZW50SWQsIG1heElkZW50aWZ5SWQpIHtcbiAgICB0aGlzLmdldEluc3RhbmNlKCkucmVtb3ZlRXZlbnRzKG1heEV2ZW50SWQsIG1heElkZW50aWZ5SWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZW5kIHVuc2VudCBldmVudHMuIE5vdGU6IHRoaXMgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYWZ0ZXIgZXZlbnRzIGFyZSBsb2dnZWQgaWYgb3B0aW9uIGJhdGNoRXZlbnRzIGlzIGZhbHNlLlxuICAgKiBJZiBiYXRjaEV2ZW50cyBpcyB0cnVlLCB0aGVuIGV2ZW50cyBhcmUgb25seSBzZW50IHdoZW4gYmF0Y2ggY3JpdGVyaWFzIGFyZSBtZXQuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QW1wbGl0dWRlfmV2ZW50Q2FsbGJhY2t9IGNhbGxiYWNrIC0gKG9wdGlvbmFsKSBjYWxsYmFjayB0byBydW4gYWZ0ZXIgZXZlbnRzIGFyZSBzZW50LlxuICAgKiBOb3RlIHRoZSBzZXJ2ZXIgcmVzcG9uc2UgY29kZSBhbmQgcmVzcG9uc2UgYm9keSBhcmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBhcyBpbnB1dCBhcmd1bWVudHMuXG4gICAqL1xuICBBbXBsaXR1ZGUucHJvdG90eXBlLnNlbmRFdmVudHMgPSBmdW5jdGlvbiBzZW5kRXZlbnRzKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5nZXRJbnN0YW5jZSgpLnNlbmRFdmVudHMoY2FsbGJhY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgZ2xvYmFsIHVzZXIgcHJvcGVydGllcy4gTm90ZSB0aGlzIGlzIGRlcHJlY2F0ZWQsIGFuZCB3ZSByZWNvbW1lbmQgdXNpbmcgc2V0VXNlclByb3BlcnRpZXNcbiAgICogQHB1YmxpY1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgQW1wbGl0dWRlLnByb3RvdHlwZS5zZXRHbG9iYWxVc2VyUHJvcGVydGllcyA9IGZ1bmN0aW9uIHNldEdsb2JhbFVzZXJQcm9wZXJ0aWVzKHVzZXJQcm9wZXJ0aWVzKSB7XG4gICAgdGhpcy5nZXRJbnN0YW5jZSgpLnNldFVzZXJQcm9wZXJ0aWVzKHVzZXJQcm9wZXJ0aWVzKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHZlcnNpb24gb2YgQW1wbGl0dWRlJ3MgSmF2YXNjcmlwdCBTREsuXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge251bWJlcn0gdmVyc2lvbiBudW1iZXJcbiAgICogQGV4YW1wbGUgdmFyIGFtcGxpdHVkZVZlcnNpb24gPSBhbXBsaXR1ZGUuX19WRVJTSU9OX187XG4gICAqL1xuICBBbXBsaXR1ZGUucHJvdG90eXBlLl9fVkVSU0lPTl9fID0gdmVyc2lvbjtcblxuICAvKiBqc2hpbnQgZXhwcjp0cnVlICovXG4gIHZhciBvbGQgPSB3aW5kb3cuYW1wbGl0dWRlIHx8IHt9O1xuICB2YXIgbmV3SW5zdGFuY2UgPSBuZXcgQW1wbGl0dWRlKCk7XG4gIG5ld0luc3RhbmNlLl9xID0gb2xkLl9xIHx8IFtdO1xuICBmb3IgKHZhciBpbnN0YW5jZSBpbiBvbGQuX2lxKSB7XG4gICAgLy8gbWlncmF0ZSBlYWNoIGluc3RhbmNlJ3MgcXVldWVcbiAgICBpZiAob2xkLl9pcS5oYXNPd25Qcm9wZXJ0eShpbnN0YW5jZSkpIHtcbiAgICAgIG5ld0luc3RhbmNlLmdldEluc3RhbmNlKGluc3RhbmNlKS5fcSA9IG9sZC5faXFbaW5zdGFuY2VdLl9xIHx8IFtdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdJbnN0YW5jZTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2FtcGxpdHVkZS1qcy9hbXBsaXR1ZGUuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///44\n");

/***/ }),

/***/ 45:
/*!***********************************************!*\
  !*** ./frontend/node_modules/buffer/index.js ***!
  \***********************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ 46);\nvar ieee754 = __webpack_require__(/*! ieee754 */ 47);\nvar isArray = __webpack_require__(/*! isarray */ 48);\n\nexports.Buffer = Buffer;\nexports.SlowBuffer = SlowBuffer;\nexports.INSPECT_MAX_BYTES = 50;\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength();\n\nfunction typedArraySupport() {\n  try {\n    var arr = new Uint8Array(1);\n    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {\n        return 42;\n      } };\n    return arr.foo() === 42 && // typed array instances can be augmented\n    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction kMaxLength() {\n  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;\n}\n\nfunction createBuffer(that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length');\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length);\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length);\n    }\n    that.length = length;\n  }\n\n  return that;\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer(arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length);\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error('If encoding is specified then the first argument must be a string');\n    }\n    return allocUnsafe(this, arg);\n  }\n  return from(this, arg, encodingOrOffset, length);\n}\n\nBuffer.poolSize = 8192; // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype;\n  return arr;\n};\n\nfunction from(that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number');\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length);\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset);\n  }\n\n  return fromObject(that, value);\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length);\n};\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype;\n  Buffer.__proto__ = Uint8Array;\n  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    });\n  }\n}\n\nfunction assertSize(size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number');\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative');\n  }\n}\n\nfunction alloc(that, size, fill, encoding) {\n  assertSize(size);\n  if (size <= 0) {\n    return createBuffer(that, size);\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);\n  }\n  return createBuffer(that, size);\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding);\n};\n\nfunction allocUnsafe(that, size) {\n  assertSize(size);\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0;\n    }\n  }\n  return that;\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size);\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size);\n};\n\nfunction fromString(that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8';\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding');\n  }\n\n  var length = byteLength(string, encoding) | 0;\n  that = createBuffer(that, length);\n\n  var actual = that.write(string, encoding);\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual);\n  }\n\n  return that;\n}\n\nfunction fromArrayLike(that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0;\n  that = createBuffer(that, length);\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255;\n  }\n  return that;\n}\n\nfunction fromArrayBuffer(that, array, byteOffset, length) {\n  array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds');\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds');\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array);\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset);\n  } else {\n    array = new Uint8Array(array, byteOffset, length);\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array;\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array);\n  }\n  return that;\n}\n\nfunction fromObject(that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0;\n    that = createBuffer(that, len);\n\n    if (that.length === 0) {\n      return that;\n    }\n\n    obj.copy(that, 0, 0, len);\n    return that;\n  }\n\n  if (obj) {\n    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0);\n      }\n      return fromArrayLike(that, obj);\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data);\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');\n}\n\nfunction checked(length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');\n  }\n  return length | 0;\n}\n\nfunction SlowBuffer(length) {\n  if (+length != length) {\n    // eslint-disable-line eqeqeq\n    length = 0;\n  }\n  return Buffer.alloc(+length);\n}\n\nBuffer.isBuffer = function isBuffer(b) {\n  return !!(b != null && b._isBuffer);\n};\n\nBuffer.compare = function compare(a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers');\n  }\n\n  if (a === b) return 0;\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) return -1;\n  if (y < x) return 1;\n  return 0;\n};\n\nBuffer.isEncoding = function isEncoding(encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true;\n    default:\n      return false;\n  }\n};\n\nBuffer.concat = function concat(list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers');\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0);\n  }\n\n  var i;\n  if (length === undefined) {\n    length = 0;\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length;\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length);\n  var pos = 0;\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i];\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers');\n    }\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\n\nfunction byteLength(string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length;\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength;\n  }\n  if (typeof string !== 'string') {\n    string = '' + string;\n  }\n\n  var len = string.length;\n  if (len === 0) return 0;\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len;\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length;\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2;\n      case 'hex':\n        return len >>> 1;\n      case 'base64':\n        return base64ToBytes(string).length;\n      default:\n        if (loweredCase) return utf8ToBytes(string).length; // assume utf8\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\nBuffer.byteLength = byteLength;\n\nfunction slowToString(encoding, start, end) {\n  var loweredCase = false;\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0;\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return '';\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length;\n  }\n\n  if (end <= 0) {\n    return '';\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0;\n  start >>>= 0;\n\n  if (end <= start) {\n    return '';\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end);\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end);\n\n      case 'ascii':\n        return asciiSlice(this, start, end);\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end);\n\n      case 'base64':\n        return base64Slice(this, start, end);\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end);\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n        encoding = (encoding + '').toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true;\n\nfunction swap(b, n, m) {\n  var i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16() {\n  var len = this.length;\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits');\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1);\n  }\n  return this;\n};\n\nBuffer.prototype.swap32 = function swap32() {\n  var len = this.length;\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits');\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3);\n    swap(this, i + 1, i + 2);\n  }\n  return this;\n};\n\nBuffer.prototype.swap64 = function swap64() {\n  var len = this.length;\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits');\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7);\n    swap(this, i + 1, i + 6);\n    swap(this, i + 2, i + 5);\n    swap(this, i + 3, i + 4);\n  }\n  return this;\n};\n\nBuffer.prototype.toString = function toString() {\n  var length = this.length | 0;\n  if (length === 0) return '';\n  if (arguments.length === 0) return utf8Slice(this, 0, length);\n  return slowToString.apply(this, arguments);\n};\n\nBuffer.prototype.equals = function equals(b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');\n  if (this === b) return true;\n  return Buffer.compare(this, b) === 0;\n};\n\nBuffer.prototype.inspect = function inspect() {\n  var str = '';\n  var max = exports.INSPECT_MAX_BYTES;\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n    if (this.length > max) str += ' ... ';\n  }\n  return '<Buffer ' + str + '>';\n};\n\nBuffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer');\n  }\n\n  if (start === undefined) {\n    start = 0;\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0;\n  }\n  if (thisStart === undefined) {\n    thisStart = 0;\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length;\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index');\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0;\n  }\n  if (thisStart >= thisEnd) {\n    return -1;\n  }\n  if (start >= end) {\n    return 1;\n  }\n\n  start >>>= 0;\n  end >>>= 0;\n  thisStart >>>= 0;\n  thisEnd >>>= 0;\n\n  if (this === target) return 0;\n\n  var x = thisEnd - thisStart;\n  var y = end - start;\n  var len = Math.min(x, y);\n\n  var thisCopy = this.slice(thisStart, thisEnd);\n  var targetCopy = target.slice(start, end);\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i];\n      y = targetCopy[i];\n      break;\n    }\n  }\n\n  if (x < y) return -1;\n  if (y < x) return 1;\n  return 0;\n};\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1;\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = 0;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  byteOffset = +byteOffset; // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : buffer.length - 1;\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1;else byteOffset = buffer.length - 1;\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0;else return -1;\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding);\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1;\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n  } else if (typeof val === 'number') {\n    val = val & 0xFF; // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n  }\n\n  throw new TypeError('val must be string, number or Buffer');\n}\n\nfunction arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1;\n  var arrLength = arr.length;\n  var valLength = val.length;\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase();\n    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1;\n      }\n      indexSize = 2;\n      arrLength /= 2;\n      valLength /= 2;\n      byteOffset /= 2;\n    }\n  }\n\n  function read(buf, i) {\n    if (indexSize === 1) {\n      return buf[i];\n    } else {\n      return buf.readUInt16BE(i * indexSize);\n    }\n  }\n\n  var i;\n  if (dir) {\n    var foundIndex = -1;\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i;\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex;\n        foundIndex = -1;\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true;\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false;\n          break;\n        }\n      }\n      if (found) return i;\n    }\n  }\n\n  return -1;\n}\n\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1;\n};\n\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\n\nfunction hexWrite(buf, string, offset, length) {\n  offset = Number(offset) || 0;\n  var remaining = buf.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = Number(length);\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');\n\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(parsed)) return i;\n    buf[offset + i] = parsed;\n  }\n  return i;\n}\n\nfunction utf8Write(buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\n\nfunction asciiWrite(buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length);\n}\n\nfunction latin1Write(buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length);\n}\n\nfunction base64Write(buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length);\n}\n\nfunction ucs2Write(buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n}\n\nBuffer.prototype.write = function write(string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8';\n    length = this.length;\n    offset = 0;\n    // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n    // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0;\n    if (isFinite(length)) {\n      length = length | 0;\n      if (encoding === undefined) encoding = 'utf8';\n    } else {\n      encoding = length;\n      length = undefined;\n    }\n    // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n  }\n\n  var remaining = this.length - offset;\n  if (length === undefined || length > remaining) length = remaining;\n\n  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds');\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length);\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length);\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length);\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length);\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length);\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length);\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n};\n\nBuffer.prototype.toJSON = function toJSON() {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  };\n};\n\nfunction base64Slice(buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf);\n  } else {\n    return base64.fromByteArray(buf.slice(start, end));\n  }\n}\n\nfunction utf8Slice(buf, start, end) {\n  end = Math.min(buf.length, end);\n  var res = [];\n\n  var i = start;\n  while (i < end) {\n    var firstByte = buf[i];\n    var codePoint = null;\n    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte;\n          }\n          break;\n        case 2:\n          secondByte = buf[i + 1];\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break;\n        case 3:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break;\n        case 4:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          fourthByte = buf[i + 3];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint;\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD;\n      bytesPerSequence = 1;\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000;\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n      codePoint = 0xDC00 | codePoint & 0x3FF;\n    }\n\n    res.push(codePoint);\n    i += bytesPerSequence;\n  }\n\n  return decodeCodePointsArray(res);\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000;\n\nfunction decodeCodePointsArray(codePoints) {\n  var len = codePoints.length;\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = '';\n  var i = 0;\n  while (i < len) {\n    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n  }\n  return res;\n}\n\nfunction asciiSlice(buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F);\n  }\n  return ret;\n}\n\nfunction latin1Slice(buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i]);\n  }\n  return ret;\n}\n\nfunction hexSlice(buf, start, end) {\n  var len = buf.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = '';\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i]);\n  }\n  return out;\n}\n\nfunction utf16leSlice(buf, start, end) {\n  var bytes = buf.slice(start, end);\n  var res = '';\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n  }\n  return res;\n}\n\nBuffer.prototype.slice = function slice(start, end) {\n  var len = this.length;\n  start = ~~start;\n  end = end === undefined ? len : ~~end;\n\n  if (start < 0) {\n    start += len;\n    if (start < 0) start = 0;\n  } else if (start > len) {\n    start = len;\n  }\n\n  if (end < 0) {\n    end += len;\n    if (end < 0) end = 0;\n  } else if (end > len) {\n    end = len;\n  }\n\n  if (end < start) end = start;\n\n  var newBuf;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end);\n    newBuf.__proto__ = Buffer.prototype;\n  } else {\n    var sliceLen = end - start;\n    newBuf = new Buffer(sliceLen, undefined);\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start];\n    }\n  }\n\n  return newBuf;\n};\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset(offset, ext, length) {\n  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n\n  return val;\n};\n\nBuffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length);\n  }\n\n  var val = this[offset + --byteLength];\n  var mul = 1;\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul;\n  }\n\n  return val;\n};\n\nBuffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  return this[offset];\n};\n\nBuffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] | this[offset + 1] << 8;\n};\n\nBuffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] << 8 | this[offset + 1];\n};\n\nBuffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n};\n\nBuffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n};\n\nBuffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val;\n};\n\nBuffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var i = byteLength;\n  var mul = 1;\n  var val = this[offset + --i];\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val;\n};\n\nBuffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  if (!(this[offset] & 0x80)) return this[offset];\n  return (0xff - this[offset] + 1) * -1;\n};\n\nBuffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset] | this[offset + 1] << 8;\n  return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n\nBuffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset + 1] | this[offset] << 8;\n  return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n\nBuffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n};\n\nBuffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n};\n\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return ieee754.read(this, offset, true, 23, 4);\n};\n\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return ieee754.read(this, offset, false, 23, 4);\n};\n\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return ieee754.read(this, offset, true, 52, 8);\n};\n\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return ieee754.read(this, offset, false, 52, 8);\n};\n\nfunction checkInt(buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n  if (offset + ext > buf.length) throw new RangeError('Index out of range');\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var mul = 1;\n  var i = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = value / mul & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = value / mul & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  this[offset] = value & 0xff;\n  return offset + 1;\n};\n\nfunction objectWriteUInt16(buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n  return offset + 2;\n};\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n  return offset + 2;\n};\n\nfunction objectWriteUInt32(buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = value >>> 24;\n    this[offset + 2] = value >>> 16;\n    this[offset + 1] = value >>> 8;\n    this[offset] = value & 0xff;\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n  return offset + 4;\n};\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n  return offset + 4;\n};\n\nBuffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = 0;\n  var mul = 1;\n  var sub = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  var sub = 0;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  if (value < 0) value = 0xff + value + 1;\n  this[offset] = value & 0xff;\n  return offset + 1;\n};\n\nBuffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n  return offset + 2;\n};\n\nBuffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n  return offset + 2;\n};\n\nBuffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    this[offset + 2] = value >>> 16;\n    this[offset + 3] = value >>> 24;\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n  return offset + 4;\n};\n\nBuffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (value < 0) value = 0xffffffff + value + 1;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n  return offset + 4;\n};\n\nfunction checkIEEE754(buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range');\n  if (offset < 0) throw new RangeError('Index out of range');\n}\n\nfunction writeFloat(buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4);\n  return offset + 4;\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert);\n};\n\nfunction writeDouble(buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8);\n  return offset + 8;\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert);\n};\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n  if (!start) start = 0;\n  if (!end && end !== 0) end = this.length;\n  if (targetStart >= target.length) targetStart = target.length;\n  if (!targetStart) targetStart = 0;\n  if (end > 0 && end < start) end = start;\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0;\n  if (target.length === 0 || this.length === 0) return 0;\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds');\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');\n  if (end < 0) throw new RangeError('sourceEnd out of bounds');\n\n  // Are we oob?\n  if (end > this.length) end = this.length;\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start;\n  }\n\n  var len = end - start;\n  var i;\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else {\n    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n  }\n\n  return len;\n};\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill(val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start;\n      start = 0;\n      end = this.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = this.length;\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0);\n      if (code < 256) {\n        val = code;\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string');\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding);\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255;\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index');\n  }\n\n  if (end <= start) {\n    return this;\n  }\n\n  start = start >>> 0;\n  end = end === undefined ? this.length : end >>> 0;\n\n  if (!val) val = 0;\n\n  var i;\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val;\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());\n    var len = bytes.length;\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len];\n    }\n  }\n\n  return this;\n};\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n\nfunction base64clean(str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '');\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return '';\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '=';\n  }\n  return str;\n}\n\nfunction stringtrim(str) {\n  if (str.trim) return str.trim();\n  return str.replace(/^\\s+|\\s+$/g, '');\n}\n\nfunction toHex(n) {\n  if (n < 16) return '0' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(string, units) {\n  units = units || Infinity;\n  var codePoint;\n  var length = string.length;\n  var leadSurrogate = null;\n  var bytes = [];\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i);\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n        }\n\n        // valid lead\n        leadSurrogate = codePoint;\n\n        continue;\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        leadSurrogate = codePoint;\n        continue;\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n    }\n\n    leadSurrogate = null;\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break;\n      bytes.push(codePoint);\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break;\n      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break;\n      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break;\n      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n    } else {\n      throw new Error('Invalid code point');\n    }\n  }\n\n  return bytes;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF);\n  }\n  return byteArray;\n}\n\nfunction utf16leToBytes(str, units) {\n  var c, hi, lo;\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break;\n\n    c = str.charCodeAt(i);\n    hi = c >> 8;\n    lo = c % 256;\n    byteArray.push(lo);\n    byteArray.push(hi);\n  }\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return base64.toByteArray(base64clean(str));\n}\n\nfunction blitBuffer(src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if (i + offset >= dst.length || i >= src.length) break;\n    dst[i + offset] = src[i];\n  }\n  return i;\n}\n\nfunction isnan(val) {\n  return val !== val; // eslint-disable-line no-self-compare\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../webpack/buildin/global.js */ 9)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzP2NmOTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0gsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixZQUFZO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCLEMiLCJmaWxlIjoiNDUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKTtcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyO1xuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlcjtcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MDtcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgOiB0eXBlZEFycmF5U3VwcG9ydCgpO1xuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKCk7XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0KCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICBhcnIuX19wcm90b19fID0geyBfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uIGZvbygpIHtcbiAgICAgICAgcmV0dXJuIDQyO1xuICAgICAgfSB9O1xuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMDsgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPyAweDdmZmZmZmZmIDogMHgzZmZmZmZmZjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJyk7XG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlO1xuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKTtcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGg7XG4gIH1cblxuICByZXR1cm4gdGhhdDtcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpO1xuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZyk7XG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpO1xufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyOyAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZTtcbiAgcmV0dXJuIGFycjtcbn07XG5cbmZ1bmN0aW9uIGZyb20odGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KTtcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTtcbn07XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlO1xuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheTtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZShzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpO1xuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKTtcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKTtcbn07XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKTtcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMCk7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0O1xufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpO1xufTtcbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSk7XG59O1xuXG5mdW5jdGlvbiBmcm9tU3RyaW5nKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJyk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDA7XG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKTtcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKTtcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbCk7XG4gIH1cblxuICByZXR1cm4gdGhhdDtcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwO1xuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTU7XG4gIH1cbiAgcmV0dXJuIHRoYXQ7XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlcih0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGg7IC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KTtcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpO1xuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXk7XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlO1xuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHRoYXQ7XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMDtcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbik7XG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0O1xuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbik7XG4gICAgcmV0dXJuIHRoYXQ7XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKTtcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpO1xufVxuXG5mdW5jdGlvbiBjaGVja2VkKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpO1xuICB9XG4gIHJldHVybiBsZW5ndGggfCAwO1xufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDA7XG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKTtcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKTtcbn07XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJyk7XG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDA7XG5cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTE7XG4gIGlmICh5IDwgeCkgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufTtcblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKTtcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gIH1cblxuICB2YXIgaTtcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKTtcbiAgdmFyIHBvcyA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV07XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7XG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKTtcbiAgICBwb3MgKz0gYnVmLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufTtcblxuZnVuY3Rpb24gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoO1xuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aDtcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZztcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoO1xuICBpZiAobGVuID09PSAwKSByZXR1cm4gMDtcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2U7XG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlbjtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aDtcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyO1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMTtcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGg7IC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDA7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCc7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZCk7XG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpO1xuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpO1xuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpO1xuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZCk7XG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZCk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZTtcblxuZnVuY3Rpb24gc3dhcChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXTtcbiAgYltuXSA9IGJbbV07XG4gIGJbbV0gPSBpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNigpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJyk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpO1xuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0KCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJyk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpO1xuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KTtcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSk7XG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwO1xuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aCk7XG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKTtcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlO1xuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDA7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICB2YXIgc3RyID0gJyc7XG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTO1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJyk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJztcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+Jztcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKTtcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwO1xuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDA7XG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKTtcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgc3RhcnQgPj4+PSAwO1xuICBlbmQgPj4+PSAwO1xuICB0aGlzU3RhcnQgPj4+PSAwO1xuICB0aGlzRW5kID4+Pj0gMDtcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMDtcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnQ7XG4gIHZhciB5ID0gZW5kIC0gc3RhcnQ7XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KTtcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZCk7XG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXTtcbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTE7XG4gIGlmICh5IDwgeCkgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufTtcblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMTtcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0O1xuICAgIGJ5dGVPZmZzZXQgPSAwO1xuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmY7XG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwO1xuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldDsgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiBidWZmZXIubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0O1xuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xO2Vsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxO1xuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDA7ZWxzZSByZXR1cm4gLTE7XG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpO1xuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRjsgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFt2YWxdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKTtcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpO1xufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDE7XG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoO1xuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aDtcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8IGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyO1xuICAgICAgYXJyTGVuZ3RoIC89IDI7XG4gICAgICB2YWxMZW5ndGggLz0gMjtcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpO1xuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMTtcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaTtcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleDtcbiAgICAgICAgZm91bmRJbmRleCA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aDtcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXModmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gaGV4V3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDA7XG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKTtcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGg7XG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKTtcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDI7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpO1xuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaTtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWQ7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpO1xufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgb2Zmc2V0ID0gMDtcbiAgICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIG9mZnNldCA9IDA7XG4gICAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMDtcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4JztcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJyk7XG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZztcblxuICBpZiAoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKTtcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnO1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9O1xufTtcblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG4gIHZhciByZXMgPSBbXTtcblxuICB2YXIgaSA9IHN0YXJ0O1xuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV07XG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGw7XG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSBmaXJzdEJ5dGUgPiAweEVGID8gNCA6IGZpcnN0Qnl0ZSA+IDB4REYgPyAzIDogZmlyc3RCeXRlID4gMHhCRiA/IDIgOiAxO1xuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludDtcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdO1xuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IHNlY29uZEJ5dGUgJiAweDNGO1xuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTtcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IHRoaXJkQnl0ZSAmIDB4M0Y7XG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTtcbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXTtcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCBmb3VydGhCeXRlICYgMHgzRjtcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkQ7XG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMTtcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGO1xuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludCk7XG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpO1xufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMDtcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5KGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoO1xuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKTsgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJyc7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJztcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTtcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJyc7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aDtcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuO1xuXG4gIHZhciBvdXQgPSAnJztcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKTtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgc3RhcnQgPSB+fnN0YXJ0O1xuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kO1xuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW47XG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW47XG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW47XG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDA7XG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuO1xuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydDtcblxuICB2YXIgbmV3QnVmO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpO1xuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlO1xuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0O1xuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1Zjtcbn07XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAob2Zmc2V0ICUgMSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50Jyk7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF07XG4gIHZhciBtdWwgPSAxO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWw7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRShvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXTtcbiAgdmFyIG11bCA9IDE7XG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWw7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDgob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDg7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gdGhpc1tvZmZzZXRdIDw8IDggfCB0aGlzW29mZnNldCArIDFdO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpICsgdGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMDtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCArICh0aGlzW29mZnNldCArIDFdIDw8IDE2IHwgdGhpc1tvZmZzZXQgKyAyXSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAzXSk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRShvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XTtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDtcbiAgfVxuICBtdWwgKj0gMHg4MDtcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKTtcblxuICByZXR1cm4gdmFsO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuXG4gIHZhciBpID0gYnl0ZUxlbmd0aDtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV07XG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWw7XG4gIH1cbiAgbXVsICo9IDB4ODA7XG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCk7XG5cbiAgcmV0dXJuIHZhbDtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpO1xuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuIHRoaXNbb2Zmc2V0XTtcbiAgcmV0dXJuICgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgdGhpc1tvZmZzZXQgKyAxXSA8PCA4O1xuICByZXR1cm4gdmFsICYgMHg4MDAwID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbDtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8IHRoaXNbb2Zmc2V0XSA8PCA4O1xuICByZXR1cm4gdmFsICYgMHg4MDAwID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbDtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDggfCB0aGlzW29mZnNldCArIDJdIDw8IDE2IHwgdGhpc1tvZmZzZXQgKyAzXSA8PCAyNDtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuXG4gIHJldHVybiB0aGlzW29mZnNldF0gPDwgMjQgfCB0aGlzW29mZnNldCArIDFdIDw8IDE2IHwgdGhpc1tvZmZzZXQgKyAyXSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAzXTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpO1xufTtcblxuZnVuY3Rpb24gY2hlY2tJbnQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpO1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpO1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDE7XG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApO1xuICB9XG5cbiAgdmFyIG11bCA9IDE7XG4gIHZhciBpID0gMDtcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAvIG11bCAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMTtcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMCk7XG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxO1xuICB2YXIgbXVsID0gMTtcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRjtcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlIC8gbXVsICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMCk7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhmZjtcbiAgcmV0dXJuIG9mZnNldCArIDE7XG59O1xuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNihidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmIDB4ZmYgPDwgOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4O1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhmZjtcbiAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDg7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDI7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gODtcbiAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgJiAweGZmO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMjtcbn07XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDggJiAweGZmO1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWUgPj4+IDI0O1xuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+Pj4gMTY7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiA4O1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhmZjtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNDtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gMjQ7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiAxNjtcbiAgICB0aGlzW29mZnNldCArIDJdID0gdmFsdWUgPj4+IDg7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlICYgMHhmZjtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDQ7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKTtcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KTtcbiAgfVxuXG4gIHZhciBpID0gMDtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBzdWIgPSAwO1xuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkY7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDE7XG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwgPj4gMCkgLSBzdWIgJiAweEZGO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGg7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKTtcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KTtcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDE7XG4gIHZhciBtdWwgPSAxO1xuICB2YXIgc3ViID0gMDtcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRjtcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDE7XG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwgPj4gMCkgLSBzdWIgJiAweEZGO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGg7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApO1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpO1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDE7XG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhmZjtcbiAgcmV0dXJuIG9mZnNldCArIDE7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweGZmO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gODtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMjtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gODtcbiAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgJiAweGZmO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMjtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhmZjtcbiAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDg7XG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiAxNjtcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWUgPj4+IDI0O1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0O1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gMjQ7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiAxNjtcbiAgICB0aGlzW29mZnNldCArIDJdID0gdmFsdWUgPj4+IDg7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlICYgMHhmZjtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDQ7XG59O1xuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJyk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOCk7XG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpO1xuICByZXR1cm4gb2Zmc2V0ICsgNDtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCk7XG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpO1xuICByZXR1cm4gb2Zmc2V0ICsgODtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDA7XG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGg7XG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMDtcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0O1xuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDA7XG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMDtcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJyk7XG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKTtcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoO1xuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydDtcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcbiAgdmFyIGk7XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdO1xuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbCh0YXJnZXQsIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0U3RhcnQpO1xuICB9XG5cbiAgcmV0dXJuIGxlbjtcbn07XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0O1xuICAgICAgc3RhcnQgPSAwO1xuICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmQ7XG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMCk7XG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1O1xuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKTtcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDA7XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDA7XG5cbiAgaWYgKCF2YWwpIHZhbCA9IDA7XG5cbiAgdmFyIGk7XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpID8gdmFsIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKTtcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nO1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbihzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJyk7XG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJyc7XG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSc7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbShzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKTtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG59XG5cbmZ1bmN0aW9uIHRvSGV4KG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpO1xuICByZXR1cm4gbi50b1N0cmluZygxNik7XG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eTtcbiAgdmFyIGNvZGVQb2ludDtcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbDtcbiAgdmFyIGJ5dGVzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50O1xuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrO1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVhaztcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwKTtcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVhaztcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCwgY29kZVBvaW50ICYgMHgzRiB8IDB4ODApO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVhaztcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLCBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCwgY29kZVBvaW50ICYgMHgzRiB8IDB4ODApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlcztcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKTtcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5O1xufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyhzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG87XG4gIHZhciBieXRlQXJyYXkgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWs7XG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaGkgPSBjID4+IDg7XG4gICAgbG8gPSBjICUgMjU2O1xuICAgIGJ5dGVBcnJheS5wdXNoKGxvKTtcbiAgICBieXRlQXJyYXkucHVzaChoaSk7XG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5O1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpO1xufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCB8fCBpID49IHNyYy5sZW5ndGgpIGJyZWFrO1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXTtcbiAgfVxuICByZXR1cm4gaTtcbn1cblxuZnVuY3Rpb24gaXNuYW4odmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///45\n");

/***/ }),

/***/ 46:
/*!**************************************************!*\
  !*** ./frontend/node_modules/base64-js/index.js ***!
  \**************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength;\nexports.toByteArray = toByteArray;\nexports.fromByteArray = fromByteArray;\n\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i];\n  revLookup[code.charCodeAt(i)] = i;\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62;\nrevLookup['_'.charCodeAt(0)] = 63;\n\nfunction getLens(b64) {\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4');\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=');\n  if (validLen === -1) validLen = len;\n\n  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n\n  return [validLen, placeHoldersLen];\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength(b64) {\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\n\nfunction _byteLength(b64, validLen, placeHoldersLen) {\n  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\n\nfunction toByteArray(b64) {\n  var tmp;\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n\n  var curByte = 0;\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n\n  for (var i = 0; i < len; i += 4) {\n    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n    arr[curByte++] = tmp >> 16 & 0xFF;\n    arr[curByte++] = tmp >> 8 & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n    arr[curByte++] = tmp >> 8 & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  return arr;\n}\n\nfunction tripletToBase64(num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n}\n\nfunction encodeChunk(uint8, start, end) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join('');\n}\n\nfunction fromByteArray(uint8) {\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');\n  }\n\n  return parts.join('');\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzPzkyMzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiNDYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7XG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXk7XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5O1xuXG52YXIgbG9va3VwID0gW107XG52YXIgcmV2TG9va3VwID0gW107XG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5O1xuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV07XG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaTtcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyO1xucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzO1xuXG5mdW5jdGlvbiBnZXRMZW5zKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aDtcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKTtcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKTtcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW47XG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW4gPyAwIDogNCAtIHZhbGlkTGVuICUgNDtcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dO1xufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGgoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpO1xuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdO1xuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXTtcbiAgcmV0dXJuICh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCAtIHBsYWNlSG9sZGVyc0xlbjtcbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQgLSBwbGFjZUhvbGRlcnNMZW47XG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5KGI2NCkge1xuICB2YXIgdG1wO1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KTtcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXTtcbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV07XG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSk7XG5cbiAgdmFyIGN1ckJ5dGUgPSAwO1xuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDAgPyB2YWxpZExlbiAtIDQgOiB2YWxpZExlbjtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID0gcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNiB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldO1xuICAgIGFycltjdXJCeXRlKytdID0gdG1wID4+IDE2ICYgMHhGRjtcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCA+PiA4ICYgMHhGRjtcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkY7XG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID0gcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNDtcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkY7XG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID0gcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyO1xuICAgIGFycltjdXJCeXRlKytdID0gdG1wID4+IDggJiAweEZGO1xuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wO1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2ICYgMHhGRjAwMDApICsgKHVpbnQ4W2kgKyAxXSA8PCA4ICYgMHhGRjAwKSArICh1aW50OFtpICsgMl0gJiAweEZGKTtcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSh1aW50OCkge1xuICB2YXIgdG1wO1xuICB2YXIgbGVuID0gdWludDgubGVuZ3RoO1xuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDM7IC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdO1xuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MzsgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgaSArIG1heENodW5rTGVuZ3RoID4gbGVuMiA/IGxlbjIgOiBpICsgbWF4Q2h1bmtMZW5ndGgpKTtcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXTtcbiAgICBwYXJ0cy5wdXNoKGxvb2t1cFt0bXAgPj4gMl0gKyBsb29rdXBbdG1wIDw8IDQgJiAweDNGXSArICc9PScpO1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXTtcbiAgICBwYXJ0cy5wdXNoKGxvb2t1cFt0bXAgPj4gMTBdICsgbG9va3VwW3RtcCA+PiA0ICYgMHgzRl0gKyBsb29rdXBbdG1wIDw8IDIgJiAweDNGXSArICc9Jyk7XG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJyk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///46\n");

/***/ }),

/***/ 47:
/*!************************************************!*\
  !*** ./frontend/node_modules/ieee754/index.js ***!
  \************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? nBytes - 1 : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer[offset + i];\n\n  i += d;\n\n  e = s & (1 << -nBits) - 1;\n  s >>= -nBits;\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & (1 << -nBits) - 1;\n  e >>= -nBits;\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : (s ? -1 : 1) * Infinity;\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n  var i = isLE ? 0 : nBytes - 1;\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = e << mLen | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcz83NGQ2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBLFFBQVEsVUFBVTs7QUFFbEI7QUFDQSIsImZpbGUiOiI0Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbTtcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBuQml0cyA9IC03O1xuICB2YXIgaSA9IGlzTEUgPyBuQnl0ZXMgLSAxIDogMDtcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxO1xuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcblxuICBpICs9IGQ7XG5cbiAgZSA9IHMgJiAoMSA8PCAtbkJpdHMpIC0gMTtcbiAgcyA+Pj0gLW5CaXRzO1xuICBuQml0cyArPSBlTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKDEgPDwgLW5CaXRzKSAtIDE7XG4gIGUgPj49IC1uQml0cztcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKHMgPyAtMSA6IDEpICogSW5maW5pdHk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xufTtcblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYztcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBydCA9IG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwO1xuICB2YXIgaSA9IGlzTEUgPyAwIDogbkJ5dGVzIC0gMTtcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xO1xuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IGUgPDwgbUxlbiB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///47\n");

/***/ }),

/***/ 48:
/*!************************************************!*\
  !*** ./frontend/node_modules/isarray/index.js ***!
  \************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcz81NjJiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBIiwiZmlsZSI6IjQ4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///48\n");

/***/ }),

/***/ 49:
/*!*********************************************!*\
  !*** ./frontend/devkit-fbpixel/js/index.js ***!
  \*********************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar pixelLoaded = typeof window.fbq !== 'undefined';\n\nvar FacebookPixelWrapper = function () {\n  function FacebookPixelWrapper() {\n    _classCallCheck(this, FacebookPixelWrapper);\n  }\n\n  FacebookPixelWrapper.prototype.track = function track(name, params) {\n    if (!pixelLoaded) {\n      return;\n    }\n\n    window.fbq('track', name, params);\n  };\n\n  FacebookPixelWrapper.prototype.trackCustom = function trackCustom(name, params) {\n    if (!pixelLoaded) {\n      return;\n    }\n\n    window.fbq('trackCustom', name, params);\n  };\n\n  _createClass(FacebookPixelWrapper, [{\n    key: 'enabled',\n    get: function get() {\n      return pixelLoaded;\n    }\n  }]);\n\n  return FacebookPixelWrapper;\n}();\n\nexports.default = new FacebookPixelWrapper();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9mcm9udGVuZC9kZXZraXQtZmJwaXhlbC9qcy9pbmRleC5qcz84NjExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBLGdDQUFnQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRSxFQUFFLHlEQUF5RCxxRUFBcUUsNkRBQTZELG9CQUFvQixHQUFHLEVBQUU7O0FBRWpqQixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2Sjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEIiwiZmlsZSI6IjQ5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgcGl4ZWxMb2FkZWQgPSB0eXBlb2Ygd2luZG93LmZicSAhPT0gJ3VuZGVmaW5lZCc7XG5cbnZhciBGYWNlYm9va1BpeGVsV3JhcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRmFjZWJvb2tQaXhlbFdyYXBwZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZhY2Vib29rUGl4ZWxXcmFwcGVyKTtcbiAgfVxuXG4gIEZhY2Vib29rUGl4ZWxXcmFwcGVyLnByb3RvdHlwZS50cmFjayA9IGZ1bmN0aW9uIHRyYWNrKG5hbWUsIHBhcmFtcykge1xuICAgIGlmICghcGl4ZWxMb2FkZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aW5kb3cuZmJxKCd0cmFjaycsIG5hbWUsIHBhcmFtcyk7XG4gIH07XG5cbiAgRmFjZWJvb2tQaXhlbFdyYXBwZXIucHJvdG90eXBlLnRyYWNrQ3VzdG9tID0gZnVuY3Rpb24gdHJhY2tDdXN0b20obmFtZSwgcGFyYW1zKSB7XG4gICAgaWYgKCFwaXhlbExvYWRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdpbmRvdy5mYnEoJ3RyYWNrQ3VzdG9tJywgbmFtZSwgcGFyYW1zKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoRmFjZWJvb2tQaXhlbFdyYXBwZXIsIFt7XG4gICAga2V5OiAnZW5hYmxlZCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gcGl4ZWxMb2FkZWQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZhY2Vib29rUGl4ZWxXcmFwcGVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgRmFjZWJvb2tQaXhlbFdyYXBwZXIoKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Zyb250ZW5kL2RldmtpdC1mYnBpeGVsL2pzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///49\n");

/***/ }),

/***/ 6:
/*!*********************************************************************************!*\
  !*** ./frontend/node_modules/node-libs-browser/node_modules/process/browser.js ***!
  \*********************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout() {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n})();\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while (len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n    return [];\n};\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n    return '/';\n};\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function () {\n    return 0;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcz9kNDY2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0pKCk7XG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlIChsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIFtdO1xufTtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJy8nO1xufTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAwO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6\n");

/***/ }),

/***/ 61:
/*!***********************************************!*\
  !*** ./frontend/devkit-fbinstant/js/index.js ***!
  \***********************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _bluebird = __webpack_require__(/*! bluebird */ 1);\n\nvar _bluebird2 = _interopRequireDefault(_bluebird);\n\nvar _FBInstant = __webpack_require__(/*! ./FBInstant */ 8);\n\nvar _FBInstant2 = _interopRequireDefault(_FBInstant);\n\nvar _player = __webpack_require__(/*! ./player */ 63);\n\nvar _player2 = _interopRequireDefault(_player);\n\nvar _context = __webpack_require__(/*! ./context */ 64);\n\nvar _context2 = _interopRequireDefault(_context);\n\nvar _payments = __webpack_require__(/*! ./payments */ 65);\n\nvar _payments2 = _interopRequireDefault(_payments);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @class FBInstantWrapper\n *\n * FBInstantWrapper wraps the top-Level FBInstant API,\n * updated through FBInstant 6.0, and substitures mock behavior during\n * development in the simulator.\n *\n * Docs: https://developers.facebook.com/docs/games/instant-games/sdk/fbinstant6.0\n */\n\nvar FBInstantWrapper = function () {\n  function FBInstantWrapper() {\n    _classCallCheck(this, FBInstantWrapper);\n\n    this.player = _player2.default;\n    this.context = _context2.default;\n    this.payments = _payments2.default;\n  }\n\n  /**\n   * @method initializeAsync\n   *\n   * Initializes the SDK library. This should be called before any other\n   * SDK functions.\n   *\n   * @returns {Promise}\n   */\n\n  FBInstantWrapper.prototype.initializeAsync = function initializeAsync() {\n    return _bluebird2.default.try(function () {\n      return _FBInstant2.default.initializeAsync();\n    });\n  };\n\n  /**\n   * @method getLocale\n   *\n   * The current locale.\n   * See https://www.facebook.com/translations/FacebookLocales.xml for a\n   * complete list of supported locale values. Use this to determine what language\n   * the current game should be localized with. The value will always be null\n   * until FBInstant.initializeAsync() resolves.\n   *\n   * @returns {string|null}\n   */\n\n  FBInstantWrapper.prototype.getLocale = function getLocale() {\n    return _FBInstant2.default.getLocale();\n  };\n\n  /**\n   * @method getPlatform\n   *\n   * The platform on which the game is currently running. Possible values are:\n   * 'IOS', 'ANDROID' and 'WEB'. The value will always be null until\n   * FBInstant.initializeAsync() resolves.\n   *\n   * @returns {string|null}\n   */\n\n  FBInstantWrapper.prototype.getPlatform = function getPlatform() {\n    return _FBInstant2.default.getPlatform();\n  };\n\n  /**\n   * @method getSDKVersion\n   *\n   * A string indicating the version of the SDK.\n   *\n   * @returns {string}\n   */\n\n  FBInstantWrapper.prototype.getSDKVersion = function getSDKVersion() {\n    return _FBInstant2.default.getSDKVersion();\n  };\n\n  /**\n   * @method getSupportedAPIs\n   *\n   * Provides a list of API functions that are supported by the client.\n   *\n   * @returns {string[]}\n   */\n\n  FBInstantWrapper.prototype.getSupportedAPIs = function getSupportedAPIs() {\n    return _FBInstant2.default.getSupportedAPIs();\n  };\n\n  /**\n   * @method setLoadingProgress\n   *\n   * Report the progress of initial resource loading.\n   *\n   * @arg {number} percent - A percentange in the range [0, 100]\n   */\n\n  FBInstantWrapper.prototype.setLoadingProgress = function setLoadingProgress(percent) {\n    _FBInstant2.default.setLoadingProgress(percent);\n  };\n\n  /**\n   * @method getEntryPointData\n   *\n   * Returns the data associated with the entry point that the game was\n   * launched from. The contents of the object are developer-defined, and can\n   * occur from entry points on different platforms. This will return null for\n   * older mobile clients, as well as when there is no data associated with the\n   * particular entry point.\n   *\n   * @returns {Object}\n   */\n\n  FBInstantWrapper.prototype.getEntryPointData = function getEntryPointData() {\n    return _FBInstant2.default.getEntryPointData();\n  };\n\n  /**\n   * @method setSessionData\n   *\n   * Sets the data associated with the individual gameplay session for the\n   * current context.\n   *\n   * This function should be called whenever the game would like to update the\n   * current session data. This session data may be used to populate a variety\n   * of payloads and entry points, such as game play webhooks.\n   *\n   * @arg {Object} data - An arbitrary data object, which must be less than or\n   *   equal to 1000 characters when stringified.\n   */\n\n  FBInstantWrapper.prototype.setSessionData = function setSessionData(data) {\n    _FBInstant2.default.setSessionData(data);\n  };\n\n  /**\n   * @method startGameAsync\n   *\n   * This indicates the game has finished loading resources and is ready to start.\n   * FBInstant.context.getID() will be set to its expected value after the\n   * returned promise resolves.\n   *\n   * NOTE: This promise may be rejected if the player has an out-of-date app.\n   * Be prepared to catch these rejections, and either force upgrade or allow\n   * play through as desired.\n   *\n   * @returns {Promise}\n   */\n\n  FBInstantWrapper.prototype.startGameAsync = function startGameAsync() {\n    return _bluebird2.default.try(function () {\n      return _FBInstant2.default.startGameAsync();\n    });\n  };\n\n  /**\n   * @method updateAsync\n   *\n   * Informs Facebook of an update that occurred in the game. This will\n   * temporarily yield control to Facebook and Facebook will decide what to do\n   * based on what the update is. The returned promise will resolve when Facebook\n   * gives control back to the game.\n   *\n   * @arg {Object} opts - See CustomUpdatePayload in the docs linked at the top.\n   * @returns {Promise}\n   */\n\n  FBInstantWrapper.prototype.updateAsync = function updateAsync(opts) {\n    return _bluebird2.default.try(function () {\n      return _FBInstant2.default.updateAsync(opts);\n    });\n  };\n\n  /**\n   * @method shareAsync\n   *\n   * This invokes a dialog to let the user share specified content either as a\n   * message in Messenger or as a post on the user's timeline. A blob of data can\n   * be attached to the share so that every game session launched from the share\n   * will be able to access the same data blob through\n   * FBInstant.getEntryPointData(). This data must be less than or equal to\n   * 1000 characters when stringified. The user may choose to cancel the share\n   * action and close the dialog, and the returned promise will resolve when the\n   * dialog is closed regardless if the user actually shared the content or not.\n   *\n   * @arg {Object} opts - See SharePayload in the docs linked at top.\n   * @returns {Promise}\n   */\n\n  FBInstantWrapper.prototype.shareAsync = function shareAsync(opts) {\n    return _bluebird2.default.try(function () {\n      return _FBInstant2.default.shareAsync(opts);\n    });\n  };\n\n  /**\n   * @method quit\n   *\n   * Quits the game.\n   */\n\n  FBInstantWrapper.prototype.quit = function quit() {\n    _FBInstant2.default.quit();\n  };\n\n  /**\n   * @method logEvent\n   *\n   * Log an app event with FB Analytics.\n   * See https://developers.facebook.com/docs/javascript/reference/v2.8#app_events\n   * for more details about FB Analytics.\n   *\n   * @arg {string} name - Name of the event. Must be 2 to 40 characters, and\n   *   can only contain '_', '-', ' ', and alphanumeric characters.\n   * @arg {number} value - An optional numeric value that FB Analytics can\n   *   calculate a sum with.\n   * @arg {Object} opts - An optional object that can contain up to 25 key-value\n   *   pairs to be logged with the event. Keys must be 2 to 40 characters, and\n   *   can only contain '_', '-', ' ', and alphanumeric characters. Values must\n   *   be less than 100 characters in length.\n   * @returns {boolean} whether or not the log was successful\n   */\n\n  FBInstantWrapper.prototype.logEvent = function logEvent(name, value, opts) {\n    return _FBInstant2.default.logEvent(name, value, opts);\n  };\n\n  /**\n   * @method onPause\n   *\n   * Set a callback to be fired when a pause event is triggered.\n   */\n\n  FBInstantWrapper.prototype.onPause = function onPause(fn) {\n    _FBInstant2.default.onPause(fn);\n  };\n\n  /**\n   * @method getInterstitialAdAsync\n   *\n   * Attempt to create an instance of interstitial ad. This instance can then\n   * be preloaded and presented.\n   *\n   * @arg {string} placementID - The placement ID that's been setup in your\n   *   Audience Network settings.\n   * @returns {Promise} A promise that resolves with a #adinstance, or rejects\n   *   with a #codederror if it couldn't be created.\n   */\n\n  FBInstantWrapper.prototype.getInterstitialAdAsync = function getInterstitialAdAsync(placementID) {\n    return _bluebird2.default.try(function () {\n      return _FBInstant2.default.getInterstitialAdAsync(placementID);\n    });\n  };\n\n  /**\n   * @method getRewardedVideoAysnc\n   *\n   * Attempt to create an instance of rewarded video. This instance can then be\n   * preloaded and presented.\n   *\n   * @arg {string} placementID - The placement ID that's been setup in your\n   *   Audience Network settings.\n   * @returns {Promise} A promise that resolves with a #adinstance, or rejects\n   *   with a #codederror if it couldn't be created.\n   */\n\n  FBInstantWrapper.prototype.getRewardedVideoAsync = function getRewardedVideoAsync(placementID) {\n    return _bluebird2.default.try(function () {\n      return _FBInstant2.default.getRewardedVideoAsync(placementID);\n    });\n  };\n\n  /**\n   * @method checkCanPlayerMatchAsync\n   *\n   * Returns a {Promise} that resolves with a boolean on whether the player can\n   * be matched by FB policy. This should be called every time before showing\n   * the match making in-game UI\n   *\n   * @returns {Promise} A promise that resolves with a boolean, or rejects\n   *   with a #codederror if it couldn't be created.\n   */\n\n  FBInstantWrapper.prototype.checkCanPlayerMatchAsync = function checkCanPlayerMatchAsync() {\n    return _bluebird2.default.try(function () {\n      return _FBInstant2.default.checkCanPlayerMatchAsync();\n    });\n  };\n\n  /**\n   * @method matchPlayerAsync\n   *\n   * Takes an arbitrary string matchTag as a param. FB will only match players\n   * with the same matchTag together.\n   *\n   * @arg {string} matchTag\n   *   NOTE: matchTag must only include letters, numbers and underscores\n   *   NOTE: matchTag must be 100 characters or less\n   * @returns {Promise}\n   */\n\n  FBInstantWrapper.prototype.matchPlayerAsync = function matchPlayerAsync(matchTag) {\n    return _bluebird2.default.try(function () {\n      return _FBInstant2.default.matchPlayerAsync(matchTag);\n    });\n  };\n\n  /**\n   * @method switchGameAsync\n   *\n   * Request that the client switch to a different Instant Game. The API will\n   * reject if the switch fails - else, the client will load the new game.\n   *\n   * NOTE: This Promise NEVER resolves; in production the game session closes\n   *\n   * @arg {string} appID\n   * @arg {Object} payload\n   *\n   * @returns {Promise}\n   */\n\n  FBInstantWrapper.prototype.switchGameAsync = function switchGameAsync(appID, payload) {\n    return _bluebird2.default.try(function () {\n      return _FBInstant2.default.switchGameAsync(appID, payload);\n    });\n  };\n\n  return FBInstantWrapper;\n}();\n\n;\n\n// Singleton Export\nexports.default = new FBInstantWrapper();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9mcm9udGVuZC9kZXZraXQtZmJpbnN0YW50L2pzL2luZGV4LmpzPzk2Y2MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQSIsImZpbGUiOiI2MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9ibHVlYmlyZCA9IHJlcXVpcmUoJ2JsdWViaXJkJyk7XG5cbnZhciBfYmx1ZWJpcmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmx1ZWJpcmQpO1xuXG52YXIgX0ZCSW5zdGFudCA9IHJlcXVpcmUoJy4vRkJJbnN0YW50Jyk7XG5cbnZhciBfRkJJbnN0YW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0ZCSW5zdGFudCk7XG5cbnZhciBfcGxheWVyID0gcmVxdWlyZSgnLi9wbGF5ZXInKTtcblxudmFyIF9wbGF5ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGxheWVyKTtcblxudmFyIF9jb250ZXh0ID0gcmVxdWlyZSgnLi9jb250ZXh0Jyk7XG5cbnZhciBfY29udGV4dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250ZXh0KTtcblxudmFyIF9wYXltZW50cyA9IHJlcXVpcmUoJy4vcGF5bWVudHMnKTtcblxudmFyIF9wYXltZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXltZW50cyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQGNsYXNzIEZCSW5zdGFudFdyYXBwZXJcbiAqXG4gKiBGQkluc3RhbnRXcmFwcGVyIHdyYXBzIHRoZSB0b3AtTGV2ZWwgRkJJbnN0YW50IEFQSSxcbiAqIHVwZGF0ZWQgdGhyb3VnaCBGQkluc3RhbnQgNi4wLCBhbmQgc3Vic3RpdHVyZXMgbW9jayBiZWhhdmlvciBkdXJpbmdcbiAqIGRldmVsb3BtZW50IGluIHRoZSBzaW11bGF0b3IuXG4gKlxuICogRG9jczogaHR0cHM6Ly9kZXZlbG9wZXJzLmZhY2Vib29rLmNvbS9kb2NzL2dhbWVzL2luc3RhbnQtZ2FtZXMvc2RrL2ZiaW5zdGFudDYuMFxuICovXG5cbnZhciBGQkluc3RhbnRXcmFwcGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGQkluc3RhbnRXcmFwcGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGQkluc3RhbnRXcmFwcGVyKTtcblxuICAgIHRoaXMucGxheWVyID0gX3BsYXllcjIuZGVmYXVsdDtcbiAgICB0aGlzLmNvbnRleHQgPSBfY29udGV4dDIuZGVmYXVsdDtcbiAgICB0aGlzLnBheW1lbnRzID0gX3BheW1lbnRzMi5kZWZhdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaW5pdGlhbGl6ZUFzeW5jXG4gICAqXG4gICAqIEluaXRpYWxpemVzIHRoZSBTREsgbGlicmFyeS4gVGhpcyBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBhbnkgb3RoZXJcbiAgICogU0RLIGZ1bmN0aW9ucy5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuXG4gIEZCSW5zdGFudFdyYXBwZXIucHJvdG90eXBlLmluaXRpYWxpemVBc3luYyA9IGZ1bmN0aW9uIGluaXRpYWxpemVBc3luYygpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkMi5kZWZhdWx0LnRyeShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX0ZCSW5zdGFudDIuZGVmYXVsdC5pbml0aWFsaXplQXN5bmMoKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQG1ldGhvZCBnZXRMb2NhbGVcbiAgICpcbiAgICogVGhlIGN1cnJlbnQgbG9jYWxlLlxuICAgKiBTZWUgaHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL3RyYW5zbGF0aW9ucy9GYWNlYm9va0xvY2FsZXMueG1sIGZvciBhXG4gICAqIGNvbXBsZXRlIGxpc3Qgb2Ygc3VwcG9ydGVkIGxvY2FsZSB2YWx1ZXMuIFVzZSB0aGlzIHRvIGRldGVybWluZSB3aGF0IGxhbmd1YWdlXG4gICAqIHRoZSBjdXJyZW50IGdhbWUgc2hvdWxkIGJlIGxvY2FsaXplZCB3aXRoLiBUaGUgdmFsdWUgd2lsbCBhbHdheXMgYmUgbnVsbFxuICAgKiB1bnRpbCBGQkluc3RhbnQuaW5pdGlhbGl6ZUFzeW5jKCkgcmVzb2x2ZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH1cbiAgICovXG5cbiAgRkJJbnN0YW50V3JhcHBlci5wcm90b3R5cGUuZ2V0TG9jYWxlID0gZnVuY3Rpb24gZ2V0TG9jYWxlKCkge1xuICAgIHJldHVybiBfRkJJbnN0YW50Mi5kZWZhdWx0LmdldExvY2FsZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGdldFBsYXRmb3JtXG4gICAqXG4gICAqIFRoZSBwbGF0Zm9ybSBvbiB3aGljaCB0aGUgZ2FtZSBpcyBjdXJyZW50bHkgcnVubmluZy4gUG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICogJ0lPUycsICdBTkRST0lEJyBhbmQgJ1dFQicuIFRoZSB2YWx1ZSB3aWxsIGFsd2F5cyBiZSBudWxsIHVudGlsXG4gICAqIEZCSW5zdGFudC5pbml0aWFsaXplQXN5bmMoKSByZXNvbHZlcy5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ3xudWxsfVxuICAgKi9cblxuICBGQkluc3RhbnRXcmFwcGVyLnByb3RvdHlwZS5nZXRQbGF0Zm9ybSA9IGZ1bmN0aW9uIGdldFBsYXRmb3JtKCkge1xuICAgIHJldHVybiBfRkJJbnN0YW50Mi5kZWZhdWx0LmdldFBsYXRmb3JtKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgZ2V0U0RLVmVyc2lvblxuICAgKlxuICAgKiBBIHN0cmluZyBpbmRpY2F0aW5nIHRoZSB2ZXJzaW9uIG9mIHRoZSBTREsuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuXG4gIEZCSW5zdGFudFdyYXBwZXIucHJvdG90eXBlLmdldFNES1ZlcnNpb24gPSBmdW5jdGlvbiBnZXRTREtWZXJzaW9uKCkge1xuICAgIHJldHVybiBfRkJJbnN0YW50Mi5kZWZhdWx0LmdldFNES1ZlcnNpb24oKTtcbiAgfTtcblxuICAvKipcbiAgICogQG1ldGhvZCBnZXRTdXBwb3J0ZWRBUElzXG4gICAqXG4gICAqIFByb3ZpZGVzIGEgbGlzdCBvZiBBUEkgZnVuY3Rpb25zIHRoYXQgYXJlIHN1cHBvcnRlZCBieSB0aGUgY2xpZW50LlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAqL1xuXG4gIEZCSW5zdGFudFdyYXBwZXIucHJvdG90eXBlLmdldFN1cHBvcnRlZEFQSXMgPSBmdW5jdGlvbiBnZXRTdXBwb3J0ZWRBUElzKCkge1xuICAgIHJldHVybiBfRkJJbnN0YW50Mi5kZWZhdWx0LmdldFN1cHBvcnRlZEFQSXMoKTtcbiAgfTtcblxuICAvKipcbiAgICogQG1ldGhvZCBzZXRMb2FkaW5nUHJvZ3Jlc3NcbiAgICpcbiAgICogUmVwb3J0IHRoZSBwcm9ncmVzcyBvZiBpbml0aWFsIHJlc291cmNlIGxvYWRpbmcuXG4gICAqXG4gICAqIEBhcmcge251bWJlcn0gcGVyY2VudCAtIEEgcGVyY2VudGFuZ2UgaW4gdGhlIHJhbmdlIFswLCAxMDBdXG4gICAqL1xuXG4gIEZCSW5zdGFudFdyYXBwZXIucHJvdG90eXBlLnNldExvYWRpbmdQcm9ncmVzcyA9IGZ1bmN0aW9uIHNldExvYWRpbmdQcm9ncmVzcyhwZXJjZW50KSB7XG4gICAgX0ZCSW5zdGFudDIuZGVmYXVsdC5zZXRMb2FkaW5nUHJvZ3Jlc3MocGVyY2VudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgZ2V0RW50cnlQb2ludERhdGFcbiAgICpcbiAgICogUmV0dXJucyB0aGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGVudHJ5IHBvaW50IHRoYXQgdGhlIGdhbWUgd2FzXG4gICAqIGxhdW5jaGVkIGZyb20uIFRoZSBjb250ZW50cyBvZiB0aGUgb2JqZWN0IGFyZSBkZXZlbG9wZXItZGVmaW5lZCwgYW5kIGNhblxuICAgKiBvY2N1ciBmcm9tIGVudHJ5IHBvaW50cyBvbiBkaWZmZXJlbnQgcGxhdGZvcm1zLiBUaGlzIHdpbGwgcmV0dXJuIG51bGwgZm9yXG4gICAqIG9sZGVyIG1vYmlsZSBjbGllbnRzLCBhcyB3ZWxsIGFzIHdoZW4gdGhlcmUgaXMgbm8gZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAqIHBhcnRpY3VsYXIgZW50cnkgcG9pbnQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuXG4gIEZCSW5zdGFudFdyYXBwZXIucHJvdG90eXBlLmdldEVudHJ5UG9pbnREYXRhID0gZnVuY3Rpb24gZ2V0RW50cnlQb2ludERhdGEoKSB7XG4gICAgcmV0dXJuIF9GQkluc3RhbnQyLmRlZmF1bHQuZ2V0RW50cnlQb2ludERhdGEoKTtcbiAgfTtcblxuICAvKipcbiAgICogQG1ldGhvZCBzZXRTZXNzaW9uRGF0YVxuICAgKlxuICAgKiBTZXRzIHRoZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgaW5kaXZpZHVhbCBnYW1lcGxheSBzZXNzaW9uIGZvciB0aGVcbiAgICogY3VycmVudCBjb250ZXh0LlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIGdhbWUgd291bGQgbGlrZSB0byB1cGRhdGUgdGhlXG4gICAqIGN1cnJlbnQgc2Vzc2lvbiBkYXRhLiBUaGlzIHNlc3Npb24gZGF0YSBtYXkgYmUgdXNlZCB0byBwb3B1bGF0ZSBhIHZhcmlldHlcbiAgICogb2YgcGF5bG9hZHMgYW5kIGVudHJ5IHBvaW50cywgc3VjaCBhcyBnYW1lIHBsYXkgd2ViaG9va3MuXG4gICAqXG4gICAqIEBhcmcge09iamVjdH0gZGF0YSAtIEFuIGFyYml0cmFyeSBkYXRhIG9iamVjdCwgd2hpY2ggbXVzdCBiZSBsZXNzIHRoYW4gb3JcbiAgICogICBlcXVhbCB0byAxMDAwIGNoYXJhY3RlcnMgd2hlbiBzdHJpbmdpZmllZC5cbiAgICovXG5cbiAgRkJJbnN0YW50V3JhcHBlci5wcm90b3R5cGUuc2V0U2Vzc2lvbkRhdGEgPSBmdW5jdGlvbiBzZXRTZXNzaW9uRGF0YShkYXRhKSB7XG4gICAgX0ZCSW5zdGFudDIuZGVmYXVsdC5zZXRTZXNzaW9uRGF0YShkYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogQG1ldGhvZCBzdGFydEdhbWVBc3luY1xuICAgKlxuICAgKiBUaGlzIGluZGljYXRlcyB0aGUgZ2FtZSBoYXMgZmluaXNoZWQgbG9hZGluZyByZXNvdXJjZXMgYW5kIGlzIHJlYWR5IHRvIHN0YXJ0LlxuICAgKiBGQkluc3RhbnQuY29udGV4dC5nZXRJRCgpIHdpbGwgYmUgc2V0IHRvIGl0cyBleHBlY3RlZCB2YWx1ZSBhZnRlciB0aGVcbiAgICogcmV0dXJuZWQgcHJvbWlzZSByZXNvbHZlcy5cbiAgICpcbiAgICogTk9URTogVGhpcyBwcm9taXNlIG1heSBiZSByZWplY3RlZCBpZiB0aGUgcGxheWVyIGhhcyBhbiBvdXQtb2YtZGF0ZSBhcHAuXG4gICAqIEJlIHByZXBhcmVkIHRvIGNhdGNoIHRoZXNlIHJlamVjdGlvbnMsIGFuZCBlaXRoZXIgZm9yY2UgdXBncmFkZSBvciBhbGxvd1xuICAgKiBwbGF5IHRocm91Z2ggYXMgZGVzaXJlZC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuXG4gIEZCSW5zdGFudFdyYXBwZXIucHJvdG90eXBlLnN0YXJ0R2FtZUFzeW5jID0gZnVuY3Rpb24gc3RhcnRHYW1lQXN5bmMoKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZDIuZGVmYXVsdC50cnkoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9GQkluc3RhbnQyLmRlZmF1bHQuc3RhcnRHYW1lQXN5bmMoKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQG1ldGhvZCB1cGRhdGVBc3luY1xuICAgKlxuICAgKiBJbmZvcm1zIEZhY2Vib29rIG9mIGFuIHVwZGF0ZSB0aGF0IG9jY3VycmVkIGluIHRoZSBnYW1lLiBUaGlzIHdpbGxcbiAgICogdGVtcG9yYXJpbHkgeWllbGQgY29udHJvbCB0byBGYWNlYm9vayBhbmQgRmFjZWJvb2sgd2lsbCBkZWNpZGUgd2hhdCB0byBkb1xuICAgKiBiYXNlZCBvbiB3aGF0IHRoZSB1cGRhdGUgaXMuIFRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgcmVzb2x2ZSB3aGVuIEZhY2Vib29rXG4gICAqIGdpdmVzIGNvbnRyb2wgYmFjayB0byB0aGUgZ2FtZS5cbiAgICpcbiAgICogQGFyZyB7T2JqZWN0fSBvcHRzIC0gU2VlIEN1c3RvbVVwZGF0ZVBheWxvYWQgaW4gdGhlIGRvY3MgbGlua2VkIGF0IHRoZSB0b3AuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuICBGQkluc3RhbnRXcmFwcGVyLnByb3RvdHlwZS51cGRhdGVBc3luYyA9IGZ1bmN0aW9uIHVwZGF0ZUFzeW5jKG9wdHMpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkMi5kZWZhdWx0LnRyeShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX0ZCSW5zdGFudDIuZGVmYXVsdC51cGRhdGVBc3luYyhvcHRzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQG1ldGhvZCBzaGFyZUFzeW5jXG4gICAqXG4gICAqIFRoaXMgaW52b2tlcyBhIGRpYWxvZyB0byBsZXQgdGhlIHVzZXIgc2hhcmUgc3BlY2lmaWVkIGNvbnRlbnQgZWl0aGVyIGFzIGFcbiAgICogbWVzc2FnZSBpbiBNZXNzZW5nZXIgb3IgYXMgYSBwb3N0IG9uIHRoZSB1c2VyJ3MgdGltZWxpbmUuIEEgYmxvYiBvZiBkYXRhIGNhblxuICAgKiBiZSBhdHRhY2hlZCB0byB0aGUgc2hhcmUgc28gdGhhdCBldmVyeSBnYW1lIHNlc3Npb24gbGF1bmNoZWQgZnJvbSB0aGUgc2hhcmVcbiAgICogd2lsbCBiZSBhYmxlIHRvIGFjY2VzcyB0aGUgc2FtZSBkYXRhIGJsb2IgdGhyb3VnaFxuICAgKiBGQkluc3RhbnQuZ2V0RW50cnlQb2ludERhdGEoKS4gVGhpcyBkYXRhIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvXG4gICAqIDEwMDAgY2hhcmFjdGVycyB3aGVuIHN0cmluZ2lmaWVkLiBUaGUgdXNlciBtYXkgY2hvb3NlIHRvIGNhbmNlbCB0aGUgc2hhcmVcbiAgICogYWN0aW9uIGFuZCBjbG9zZSB0aGUgZGlhbG9nLCBhbmQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCByZXNvbHZlIHdoZW4gdGhlXG4gICAqIGRpYWxvZyBpcyBjbG9zZWQgcmVnYXJkbGVzcyBpZiB0aGUgdXNlciBhY3R1YWxseSBzaGFyZWQgdGhlIGNvbnRlbnQgb3Igbm90LlxuICAgKlxuICAgKiBAYXJnIHtPYmplY3R9IG9wdHMgLSBTZWUgU2hhcmVQYXlsb2FkIGluIHRoZSBkb2NzIGxpbmtlZCBhdCB0b3AuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuICBGQkluc3RhbnRXcmFwcGVyLnByb3RvdHlwZS5zaGFyZUFzeW5jID0gZnVuY3Rpb24gc2hhcmVBc3luYyhvcHRzKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZDIuZGVmYXVsdC50cnkoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9GQkluc3RhbnQyLmRlZmF1bHQuc2hhcmVBc3luYyhvcHRzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQG1ldGhvZCBxdWl0XG4gICAqXG4gICAqIFF1aXRzIHRoZSBnYW1lLlxuICAgKi9cblxuICBGQkluc3RhbnRXcmFwcGVyLnByb3RvdHlwZS5xdWl0ID0gZnVuY3Rpb24gcXVpdCgpIHtcbiAgICBfRkJJbnN0YW50Mi5kZWZhdWx0LnF1aXQoKTtcbiAgfTtcblxuICAvKipcbiAgICogQG1ldGhvZCBsb2dFdmVudFxuICAgKlxuICAgKiBMb2cgYW4gYXBwIGV2ZW50IHdpdGggRkIgQW5hbHl0aWNzLlxuICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmZhY2Vib29rLmNvbS9kb2NzL2phdmFzY3JpcHQvcmVmZXJlbmNlL3YyLjgjYXBwX2V2ZW50c1xuICAgKiBmb3IgbW9yZSBkZXRhaWxzIGFib3V0IEZCIEFuYWx5dGljcy5cbiAgICpcbiAgICogQGFyZyB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgZXZlbnQuIE11c3QgYmUgMiB0byA0MCBjaGFyYWN0ZXJzLCBhbmRcbiAgICogICBjYW4gb25seSBjb250YWluICdfJywgJy0nLCAnICcsIGFuZCBhbHBoYW51bWVyaWMgY2hhcmFjdGVycy5cbiAgICogQGFyZyB7bnVtYmVyfSB2YWx1ZSAtIEFuIG9wdGlvbmFsIG51bWVyaWMgdmFsdWUgdGhhdCBGQiBBbmFseXRpY3MgY2FuXG4gICAqICAgY2FsY3VsYXRlIGEgc3VtIHdpdGguXG4gICAqIEBhcmcge09iamVjdH0gb3B0cyAtIEFuIG9wdGlvbmFsIG9iamVjdCB0aGF0IGNhbiBjb250YWluIHVwIHRvIDI1IGtleS12YWx1ZVxuICAgKiAgIHBhaXJzIHRvIGJlIGxvZ2dlZCB3aXRoIHRoZSBldmVudC4gS2V5cyBtdXN0IGJlIDIgdG8gNDAgY2hhcmFjdGVycywgYW5kXG4gICAqICAgY2FuIG9ubHkgY29udGFpbiAnXycsICctJywgJyAnLCBhbmQgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuIFZhbHVlcyBtdXN0XG4gICAqICAgYmUgbGVzcyB0aGFuIDEwMCBjaGFyYWN0ZXJzIGluIGxlbmd0aC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRoZSBsb2cgd2FzIHN1Y2Nlc3NmdWxcbiAgICovXG5cbiAgRkJJbnN0YW50V3JhcHBlci5wcm90b3R5cGUubG9nRXZlbnQgPSBmdW5jdGlvbiBsb2dFdmVudChuYW1lLCB2YWx1ZSwgb3B0cykge1xuICAgIHJldHVybiBfRkJJbnN0YW50Mi5kZWZhdWx0LmxvZ0V2ZW50KG5hbWUsIHZhbHVlLCBvcHRzKTtcbiAgfTtcblxuICAvKipcbiAgICogQG1ldGhvZCBvblBhdXNlXG4gICAqXG4gICAqIFNldCBhIGNhbGxiYWNrIHRvIGJlIGZpcmVkIHdoZW4gYSBwYXVzZSBldmVudCBpcyB0cmlnZ2VyZWQuXG4gICAqL1xuXG4gIEZCSW5zdGFudFdyYXBwZXIucHJvdG90eXBlLm9uUGF1c2UgPSBmdW5jdGlvbiBvblBhdXNlKGZuKSB7XG4gICAgX0ZCSW5zdGFudDIuZGVmYXVsdC5vblBhdXNlKGZuKTtcbiAgfTtcblxuICAvKipcbiAgICogQG1ldGhvZCBnZXRJbnRlcnN0aXRpYWxBZEFzeW5jXG4gICAqXG4gICAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIGluc3RhbmNlIG9mIGludGVyc3RpdGlhbCBhZC4gVGhpcyBpbnN0YW5jZSBjYW4gdGhlblxuICAgKiBiZSBwcmVsb2FkZWQgYW5kIHByZXNlbnRlZC5cbiAgICpcbiAgICogQGFyZyB7c3RyaW5nfSBwbGFjZW1lbnRJRCAtIFRoZSBwbGFjZW1lbnQgSUQgdGhhdCdzIGJlZW4gc2V0dXAgaW4geW91clxuICAgKiAgIEF1ZGllbmNlIE5ldHdvcmsgc2V0dGluZ3MuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGEgI2FkaW5zdGFuY2UsIG9yIHJlamVjdHNcbiAgICogICB3aXRoIGEgI2NvZGVkZXJyb3IgaWYgaXQgY291bGRuJ3QgYmUgY3JlYXRlZC5cbiAgICovXG5cbiAgRkJJbnN0YW50V3JhcHBlci5wcm90b3R5cGUuZ2V0SW50ZXJzdGl0aWFsQWRBc3luYyA9IGZ1bmN0aW9uIGdldEludGVyc3RpdGlhbEFkQXN5bmMocGxhY2VtZW50SUQpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkMi5kZWZhdWx0LnRyeShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX0ZCSW5zdGFudDIuZGVmYXVsdC5nZXRJbnRlcnN0aXRpYWxBZEFzeW5jKHBsYWNlbWVudElEKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQG1ldGhvZCBnZXRSZXdhcmRlZFZpZGVvQXlzbmNcbiAgICpcbiAgICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgcmV3YXJkZWQgdmlkZW8uIFRoaXMgaW5zdGFuY2UgY2FuIHRoZW4gYmVcbiAgICogcHJlbG9hZGVkIGFuZCBwcmVzZW50ZWQuXG4gICAqXG4gICAqIEBhcmcge3N0cmluZ30gcGxhY2VtZW50SUQgLSBUaGUgcGxhY2VtZW50IElEIHRoYXQncyBiZWVuIHNldHVwIGluIHlvdXJcbiAgICogICBBdWRpZW5jZSBOZXR3b3JrIHNldHRpbmdzLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhICNhZGluc3RhbmNlLCBvciByZWplY3RzXG4gICAqICAgd2l0aCBhICNjb2RlZGVycm9yIGlmIGl0IGNvdWxkbid0IGJlIGNyZWF0ZWQuXG4gICAqL1xuXG4gIEZCSW5zdGFudFdyYXBwZXIucHJvdG90eXBlLmdldFJld2FyZGVkVmlkZW9Bc3luYyA9IGZ1bmN0aW9uIGdldFJld2FyZGVkVmlkZW9Bc3luYyhwbGFjZW1lbnRJRCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmQyLmRlZmF1bHQudHJ5KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfRkJJbnN0YW50Mi5kZWZhdWx0LmdldFJld2FyZGVkVmlkZW9Bc3luYyhwbGFjZW1lbnRJRCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgY2hlY2tDYW5QbGF5ZXJNYXRjaEFzeW5jXG4gICAqXG4gICAqIFJldHVybnMgYSB7UHJvbWlzZX0gdGhhdCByZXNvbHZlcyB3aXRoIGEgYm9vbGVhbiBvbiB3aGV0aGVyIHRoZSBwbGF5ZXIgY2FuXG4gICAqIGJlIG1hdGNoZWQgYnkgRkIgcG9saWN5LiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgZXZlcnkgdGltZSBiZWZvcmUgc2hvd2luZ1xuICAgKiB0aGUgbWF0Y2ggbWFraW5nIGluLWdhbWUgVUlcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYSBib29sZWFuLCBvciByZWplY3RzXG4gICAqICAgd2l0aCBhICNjb2RlZGVycm9yIGlmIGl0IGNvdWxkbid0IGJlIGNyZWF0ZWQuXG4gICAqL1xuXG4gIEZCSW5zdGFudFdyYXBwZXIucHJvdG90eXBlLmNoZWNrQ2FuUGxheWVyTWF0Y2hBc3luYyA9IGZ1bmN0aW9uIGNoZWNrQ2FuUGxheWVyTWF0Y2hBc3luYygpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkMi5kZWZhdWx0LnRyeShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX0ZCSW5zdGFudDIuZGVmYXVsdC5jaGVja0NhblBsYXllck1hdGNoQXN5bmMoKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQG1ldGhvZCBtYXRjaFBsYXllckFzeW5jXG4gICAqXG4gICAqIFRha2VzIGFuIGFyYml0cmFyeSBzdHJpbmcgbWF0Y2hUYWcgYXMgYSBwYXJhbS4gRkIgd2lsbCBvbmx5IG1hdGNoIHBsYXllcnNcbiAgICogd2l0aCB0aGUgc2FtZSBtYXRjaFRhZyB0b2dldGhlci5cbiAgICpcbiAgICogQGFyZyB7c3RyaW5nfSBtYXRjaFRhZ1xuICAgKiAgIE5PVEU6IG1hdGNoVGFnIG11c3Qgb25seSBpbmNsdWRlIGxldHRlcnMsIG51bWJlcnMgYW5kIHVuZGVyc2NvcmVzXG4gICAqICAgTk9URTogbWF0Y2hUYWcgbXVzdCBiZSAxMDAgY2hhcmFjdGVycyBvciBsZXNzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuICBGQkluc3RhbnRXcmFwcGVyLnByb3RvdHlwZS5tYXRjaFBsYXllckFzeW5jID0gZnVuY3Rpb24gbWF0Y2hQbGF5ZXJBc3luYyhtYXRjaFRhZykge1xuICAgIHJldHVybiBfYmx1ZWJpcmQyLmRlZmF1bHQudHJ5KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfRkJJbnN0YW50Mi5kZWZhdWx0Lm1hdGNoUGxheWVyQXN5bmMobWF0Y2hUYWcpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHN3aXRjaEdhbWVBc3luY1xuICAgKlxuICAgKiBSZXF1ZXN0IHRoYXQgdGhlIGNsaWVudCBzd2l0Y2ggdG8gYSBkaWZmZXJlbnQgSW5zdGFudCBHYW1lLiBUaGUgQVBJIHdpbGxcbiAgICogcmVqZWN0IGlmIHRoZSBzd2l0Y2ggZmFpbHMgLSBlbHNlLCB0aGUgY2xpZW50IHdpbGwgbG9hZCB0aGUgbmV3IGdhbWUuXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgUHJvbWlzZSBORVZFUiByZXNvbHZlczsgaW4gcHJvZHVjdGlvbiB0aGUgZ2FtZSBzZXNzaW9uIGNsb3Nlc1xuICAgKlxuICAgKiBAYXJnIHtzdHJpbmd9IGFwcElEXG4gICAqIEBhcmcge09iamVjdH0gcGF5bG9hZFxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG5cbiAgRkJJbnN0YW50V3JhcHBlci5wcm90b3R5cGUuc3dpdGNoR2FtZUFzeW5jID0gZnVuY3Rpb24gc3dpdGNoR2FtZUFzeW5jKGFwcElELCBwYXlsb2FkKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZDIuZGVmYXVsdC50cnkoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9GQkluc3RhbnQyLmRlZmF1bHQuc3dpdGNoR2FtZUFzeW5jKGFwcElELCBwYXlsb2FkKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gRkJJbnN0YW50V3JhcHBlcjtcbn0oKTtcblxuO1xuXG4vLyBTaW5nbGV0b24gRXhwb3J0XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgRkJJbnN0YW50V3JhcHBlcigpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZnJvbnRlbmQvZGV2a2l0LWZiaW5zdGFudC9qcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///61\n");

/***/ }),

/***/ 62:
/*!*******************************************************!*\
  !*** ./frontend/devkit-fbinstant/js/MockFBInstant.js ***!
  \*******************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _bluebird = __webpack_require__(/*! bluebird */ 1);\n\nvar _bluebird2 = _interopRequireDefault(_bluebird);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// TODO: Use jsio-webpack-v1 to build this.  bring back string-hash then.\n// import stringHash from 'string-hash';\n\nvar LS_KEY = 'devkit-fbinstant:MockFBInstant';\nvar PLAYER_DATA_PREFIX = 'playerData';\n\n// change the simulated mock behavior\nvar SIMULATE_LOCALE_TYPE = 'en_US';\nvar SIMULATE_PLATFORM_TYPE = '';\nvar SIMULATE_SDK_VERSION = '6.0';\nvar SIMULATE_CONTEXT_TYPE = 'THREAD';\nvar SIMULATE_OUTDATED_APP = false;\nvar SIMULATE_USER_INPUT_CANCEL_ERROR = false;\nvar SIMULATE_AD_LOAD_TIME = 3000;\nvar SIMULATE_AD_UNAVAILABLE = false;\nvar SIMULATE_AD_LOAD_FAILURE = false;\nvar SIMULATE_AD_WATCH_CANCELLED = false;\nvar SIMULATE_CONTEXT_SIZE = 5;\nvar SIMULATE_CAN_PLAYER_MATCH = true;\nvar SIMULATE_MATCH_WAIT_TIME = 5000;\nvar SIMULATE_MATCH_FAILED = false;\n\nvar SIMULATE_SUPPORTED_APIS = ['initializeAsync', 'getLocale', 'getPlatform', 'getSDKVersion', 'getSupportedAPIs', 'setLoadingProgress', 'getEntryPointData', 'setSessionData', 'startGameAsync', 'updateAsync', 'shareAsync', 'quit', 'logEvent', 'onPause', 'getInterstitialAdAsync', 'getRewardedVideoAsync', 'checkCanPlayerMatchAsync', 'matchPlayerAsync', 'switchGameAsync', 'player.getID', 'player.getName', 'player.getPhoto', 'player.getDataAsync', 'player.setDataAsync', 'player.flushDataAsync', 'player.getConnectedPlayersAsync', 'player.getSignedPlayerInfoAsync', 'context.getID', 'context.getType', 'context.switchAsync', 'context.chooseAsync', 'context.createAsync', 'context.getPlayersAsync', 'context.isSizeBetween', 'payments.getCatalogAsync', 'payments.purchaseAsync', 'payments.getPurchasesAsync', 'payments.consumePurchaseAsync', 'payments.onReady', 'payments.restorePurchasesAsync'];\n\n// simulate real FBInstant getPlatform behavior\nvar _userAgent = navigator && navigator.userAgent;\nvar _isIOS = /iPod|iPhone|iPad/i.test(_userAgent);\nvar _isAndroid = /Android/.test(_userAgent);\n\n// simulate real FBInstant behavior around initializeAsync\nvar _initialized = false;\n\n// simulate real FBInstant behavior around startGameAsync\nvar _gameStarted = false;\n\n// simulate state for loading progress\nvar _loadingProgress = 0;\n\n// simulate session data\nvar _sessionData = {};\n\n// simulate onPause callback\nvar _onPauseCallback = null;\nvar onPause = function onPause() {\n  if (window.document && window.document.hidden) {\n    _onPauseCallback && _onPauseCallback();\n  }\n};\n\nwindow.addEventListener('visibilitychange', onPause, false);\n\n// NOTE: Do not use lambda arrow functions because we rely on 'this' context!\n\nvar MockFBInstant = function () {\n  function MockFBInstant() {\n    _classCallCheck(this, MockFBInstant);\n\n    this.player = new MockFBInstantPlayer();\n    this.context = new MockFBInstantContext();\n    this.payments = new MockFBInstantPayments();\n  }\n\n  /**\n   * Mock API's\n   */\n\n  MockFBInstant.prototype.initializeAsync = function initializeAsync() {\n    console.log(\"FBINSTANT: mock initializeAsync\");\n\n    _initialized = true;\n    return _bluebird2.default.resolve();\n  };\n\n  MockFBInstant.prototype.getLocale = function getLocale() {\n    if (_initialized) {\n      console.log(\"FBINSTANT: mock getLocale\");\n\n      return SIMULATE_LOCALE_TYPE;\n    } else {\n      console.warn(\"FBINSTANT: mock getLocale FAILED! \\\n        You must call initializeAsync first.\");\n\n      return null;\n    }\n  };\n\n  MockFBInstant.prototype.getPlatform = function getPlatform() {\n    console.log(\"FBINSTANT: mock getPlatform\");\n\n    if (SIMULATE_PLATFORM_TYPE) {\n      return SIMULATE_PLATFORM_TYPE;\n    } else if (_isIOS) {\n      return 'IOS';\n    } else if (_isAndroid) {\n      return 'ANDROID';\n    } else {\n      return 'WEB';\n    }\n  };\n\n  MockFBInstant.prototype.getSDKVersion = function getSDKVersion() {\n    console.log(\"FBINSTANT: mock getSDKVersion\");\n\n    return SIMULATE_SDK_VERSION;\n  };\n\n  MockFBInstant.prototype.getSupportedAPIs = function getSupportedAPIs() {\n    console.log(\"FBINSTANT: mock getSupportedAPIs\");\n\n    return SIMULATE_SUPPORTED_APIS;\n  };\n\n  MockFBInstant.prototype.setLoadingProgress = function setLoadingProgress(percent) {\n    console.log(\"FBINSTANT: mock setLoadingProgress, set to \" + percent + \"%\");\n\n    _loadingProgress = percent;\n  };\n\n  MockFBInstant.prototype.getEntryPointData = function getEntryPointData() {\n    if (_initialized) {\n      console.log(\"FBINSTANT: mock getEntryPointData\");\n    } else {\n      console.warn(\"FBINSTANT: mock getEntryPointData \\\n        called before initializeAsync!\");\n    }\n\n    return {};\n  };\n\n  MockFBInstant.prototype.setSessionData = function setSessionData(data) {\n    if (_initialized) {\n      console.log(\"FBINSTANT: mock setSessionData\", data);\n\n      _sessionData = data;\n    } else {\n      console.warn(\"FBINSTANT: mock setSessionData \\\n        called before initializeAsync!\");\n    }\n  };\n\n  MockFBInstant.prototype.startGameAsync = function startGameAsync() {\n    if (_initialized) {\n      _gameStarted = true;\n\n      if (SIMULATE_OUTDATED_APP) {\n        console.warn(\"FBINSTANT: mock startGameAsync. \\\n          Rejecting promise to simulate outdated app.\");\n\n        return _bluebird2.default.reject(new MockCodedError(ERROR_TYPE_CLIENT_REQUIRES_UPDATE));\n      } else {\n        console.log(\"FBINSTANT: mock startGameAsync. \\\n          Resolving promise to simulate up-to-date app.\");\n\n        return _bluebird2.default.resolve();\n      }\n    } else {\n      console.warn(\"FBINSTANT: mock startGameAsync FAILED!. \\\n        You must call initializeAsync first.\");\n\n      return _bluebird2.default.reject(new MockCodedError(ERROR_TYPE_UNKNOWN));\n    }\n  };\n\n  MockFBInstant.prototype.updateAsync = function updateAsync(opts) {\n    if (_initialized) {\n      console.log(\"FBINSTANT: mock updateAsync\", opts);\n    } else {\n      console.warn(\"FBINSTANT: mock updateAsync \\\n        called before initializeAsync!\", opts);\n    }\n\n    return _bluebird2.default.resolve();\n  };\n\n  MockFBInstant.prototype.shareAsync = function shareAsync(opts) {\n    if (_initialized) {\n      if (SIMULATE_USER_INPUT_CANCEL_ERROR) {\n        console.warn(\"FBINSTANT: mock shareAsync. \\\n          Rejecting promise to simulate user cancelled without sharing.\");\n\n        return _bluebird2.default.reject(new MockCodedError(ERROR_TYPE_USER_INPUT));\n      } else {\n        console.log(\"FBINSTANT: mock shareAsync\", opts);\n\n        return _bluebird2.default.resolve();\n      }\n    } else {\n      console.warn(\"FBINSTANT: mock shareAsync \\\n        called before initializeAsync!\", opts);\n\n      return _bluebird2.default.reject(new MockCodedError(ERROR_TYPE_UNKNOWN));\n    }\n  };\n\n  MockFBInstant.prototype.quit = function quit() {\n    console.log(\"FBINSTANT: mock quit\");\n    location.reload();\n  };\n\n  MockFBInstant.prototype.logEvent = function logEvent(name, value, opts) {\n    if (_initialized) {\n      console.log(\"FBINSTANT: mock logEvent\", name, value, opts);\n    } else {\n      console.warn(\"FBINSTANT: mock logEvent \\\n        called before initializeAsync!\", name, value, opts);\n    }\n\n    return false;\n  };\n\n  MockFBInstant.prototype.onPause = function onPause(fn) {\n    console.log(\"FBINSTANT: mock onPause\");\n\n    _onPauseCallback = fn;\n  };\n\n  MockFBInstant.prototype.getInterstitialAdAsync = function getInterstitialAdAsync(placementID) {\n    if (_initialized) {\n      console.log(\"FBINSTANT: mock getInterestialAdAsync\");\n\n      if (SIMULATE_AD_UNAVAILABLE) {\n        return _bluebird2.default.reject(new MockCodedError(ERROR_TYPE_ADS_NO_FILL));\n      } else {\n        return _bluebird2.default.resolve(new MockFBInstantAdInstance(placementID));\n      }\n    } else {\n      console.warn(\"FBINSTANT: mock getInterestialAdAsync \\\n        called before initalizeAsync!\");\n\n      return _bluebird2.default.reject(new MockCodedError(ERROR_TYPE_UNKNOWN));\n    }\n  };\n\n  MockFBInstant.prototype.getRewardedVideoAsync = function getRewardedVideoAsync(placementID) {\n    if (_initialized) {\n      console.log(\"FBINSTANT: mock getRewardedVideoAsync\");\n\n      if (SIMULATE_AD_UNAVAILABLE) {\n        return _bluebird2.default.reject(new MockCodedError(ERROR_TYPE_ADS_NO_FILL));\n      } else {\n        return _bluebird2.default.resolve(new MockFBInstantAdInstance(placementID));\n      }\n    } else {\n      console.warn(\"FBINSTANT: mock getRewardedVideoAsync \\\n        called before initalizeAsync!\");\n\n      return _bluebird2.default.reject(new MockCodedError(ERROR_TYPE_UNKNOWN));\n    }\n  };\n\n  MockFBInstant.prototype.checkCanPlayerMatchAsync = function checkCanPlayerMatchAsync() {\n    if (_initialized) {\n      console.log(\"FBINSTANT: mock checkCanPlayerMatchAsync\");\n\n      return new _bluebird2.default(function (resolve, reject) {\n        resolve(SIMULATE_CAN_PLAYER_MATCH);\n      });\n    } else {\n      console.warn(\"FBINSTANT: mock checkCanPlayerMatchAsync \\\n        called before initializeAsync!\");\n\n      return new _bluebird2.default(function (resolve, reject) {\n        reject(new MockCodedError(ERROR_TYPE_UNKNOWN));\n      });\n    }\n  };\n\n  MockFBInstant.prototype.matchPlayerAsync = function matchPlayerAsync(matchTag) {\n    if (_initialized) {\n      console.log(\"FBINSTANT: mock matchPlayerAsync\", matchTag);\n\n      return new _bluebird2.default(function (resolve, reject) {\n        setTimeout(function () {\n          if (SIMULATE_MATCH_FAILED) {\n            reject();\n          } else {\n            _setLSData('contextID', _getNewID());\n            resolve();\n          }\n        }, SIMULATE_MATCH_WAIT_TIME);\n      });\n    } else {\n      console.warn(\"FBINSTANT: mock matchPlayerAsync \\\n        called before initalizeAsync!\", matchTag);\n\n      return _bluebird2.default.reject(new MockCodedError(ERROR_TYPE_UNKNOWN));\n    }\n  };\n\n  MockFBInstant.prototype.switchGameAsync = function switchGameAsync(appID, payload) {\n    if (_initialized) {\n      console.log(\"FBINSTANT: mock switchGameAsync\", appID, payload);\n    } else {\n      console.warn(\"FBINSTANT: mock switchGameAsync \\\n        called before initalizeAsync!\", appID, payload);\n\n      return _bluebird2.default.reject(new MockCodedError(ERROR_TYPE_UNKNOWN));\n    }\n  };\n\n  return MockFBInstant;\n}();\n\n;\n\n/**\n * Mock Player API's\n */\n\nvar MockFBInstantPlayer = function () {\n  function MockFBInstantPlayer() {\n    _classCallCheck(this, MockFBInstantPlayer);\n  }\n\n  MockFBInstantPlayer.prototype.getID = function getID() {\n    console.log(\"FBINSTANT: mock player.getID\");\n\n    return _getLSData('playerID', _getNewID());\n  };\n\n  MockFBInstantPlayer.prototype.getName = function getName() {\n    if (_initialized) {\n      console.log(\"FBINSTANT: mock player.getName\");\n\n      var playerID = this.getID();\n      return \"TestName\" + playerID;\n    } else {\n      console.warn(\"FBINSTANT: mock player.getName FAILED! \\\n        You must call initializeAsync first.\");\n\n      return null;\n    }\n  };\n\n  MockFBInstantPlayer.prototype.getPhoto = function getPhoto() {\n    if (_initialized) {\n      console.log(\"FBINSTANT: mock player.getPhoto\");\n\n      var playerID = this.getID();\n      // TODO: Use stringHash when available\n      // const imageID = (stringHash(playerID) % 9 + 1).toString();\n      var imageID = '1';\n      var imageName = 'animal_000' + imageID + '.png';\n      return 'frontend/devkit-fbinstant/images/avatar/' + imageName;\n    } else {\n      console.warn(\"FBINSTANT: mock player.getPhoto FAILED! \\\n        You must call initializeAsync first.\");\n\n      return null;\n    }\n  };\n\n  MockFBInstantPlayer.prototype.getDataAsync = function getDataAsync(keys) {\n    if (_initialized) {\n      console.log(\"FBINSTANT: mock player.getDataAsync\", keys);\n\n      return _bluebird2.default.map(keys, function (key) {\n        return _getLSData(PLAYER_DATA_PREFIX + ':' + key);\n      }).then(function (values) {\n        var res = {};\n        keys.forEach(function (key, i) {\n          res[key] = values[i];\n        });\n        return res;\n      });\n    } else {\n      console.warn(\"FBINSTANT: mock player.getDataAsync FAILED! \\\n        You must call initializeAsync first.\", keys);\n\n      return _bluebird2.default.reject(new MockCodedError(ERROR_TYPE_UNKNOWN));\n    }\n  };\n\n  MockFBInstantPlayer.prototype.setDataAsync = function setDataAsync(data) {\n    if (_initialized) {\n      console.log(\"FBINSTANT: mock player.setDataAsync\", data);\n\n      return _bluebird2.default.resolve().then(function () {\n        Object.keys(data).forEach(function (key) {\n          _setLSData(PLAYER_DATA_PREFIX + ':' + key, data[key]);\n        });\n      });\n    } else {\n      console.warn(\"FBINSTANT: mock player.setDataAsync FAILED! \\\n        You must call initializeAsync first.\", data);\n\n      return _bluebird2.default.reject(new MockCodedError(ERROR_TYPE_UNKNOWN));\n    }\n  };\n\n  MockFBInstantPlayer.prototype.flushDataAsync = function flushDataAsync() {\n    if (_initialized) {\n      console.log(\"FBINSTANT: mock player.flushDataAsync\");\n\n      return _bluebird2.default.resolve();\n    } else {\n      console.warn(\"FBINSTANT: mock player.flushDataAsync FAILED! \\\n        You must call initializeAsync first.\");\n\n      return _bluebird2.default.reject(new MockCodedError(ERROR_TYPE_UNKNOWN));\n    }\n  };\n\n  MockFBInstantPlayer.prototype.getConnectedPlayersAsync = function getConnectedPlayersAsync() {\n    if (_initialized) {\n      console.log(\"FBINSTANT: mock player.getConnectedPlayersAsync\");\n\n      // TODO: return an array of instances of MockFBInstantConnectedPlayer\n      return _bluebird2.default.resolve([]);\n    } else {\n      console.warn(\"FBINSTANT: mock player.getConnectedPlayersAsync FAILED! \\\n        You must call initializeAsync first.\");\n\n      return _bluebird2.default.reject(new MockCodedError(ERROR_TYPE_UNKNOWN));\n    }\n  };\n\n  MockFBInstantPlayer.prototype.getSignedPlayerInfoAsync = function getSignedPlayerInfoAsync() {\n    if (_initialized) {\n      console.log(\"FBINSTANT: mock player.getSignedPlayerInfoAsync\");\n\n      return _bluebird2.default.resolve(new MockFBInstantSignedPlayerInfo());\n    } else {\n      console.warn(\"FBINSTANT: mock player.getSignedPlayerInfoAsync FAILED! \\\n        You must call initializeAsync first.\");\n\n      return _bluebird2.default.reject(new MockCodedError(ERROR_TYPE_UNKNOWN));\n    }\n  };\n\n  return MockFBInstantPlayer;\n}();\n\n;\n\n/**\n * Mock Context API's\n */\n\nvar MockFBInstantContext = function () {\n  function MockFBInstantContext() {\n    _classCallCheck(this, MockFBInstantContext);\n  }\n\n  MockFBInstantContext.prototype.getID = function getID() {\n    if (_initialized && _gameStarted) {\n      console.log(\"FBINSTANT: mock context.getID\");\n\n      return _getLSData('contextID', _getNewID());\n    } else {\n      console.warn(\"FBINSTANT: mock context.getID FAILED! \\\n        You must call startGameAsync first.\");\n\n      return null;\n    }\n  };\n\n  MockFBInstantContext.prototype.getType = function getType() {\n    if (_initialized && _gameStarted) {\n      console.log(\"FBINSTANT: mock context.getType\");\n\n      return SIMULATE_CONTEXT_TYPE;\n    } else {\n      console.warn(\"FBINSTANT: mock context.getType FAILED! \\\n        You must call startGameAsync first.\");\n\n      return null;\n    }\n  };\n\n  MockFBInstantContext.prototype.switchAsync = function switchAsync(contextID) {\n    if (_initialized && _gameStarted) {\n      console.log(\"FBINSTANT: mock context.switchAsync to \", contextID);\n\n      _setLSData('contextID', contextID);\n      return _bluebird2.default.resolve();\n    } else {\n      console.warn(\"FBINSTANT: mock context.switchAsync FAILED! \\\n        You must call startGameAsync first.\");\n\n      return _bluebird2.default.reject(new MockCodedError(ERROR_TYPE_UNKNOWN));\n    }\n  };\n\n  MockFBInstantContext.prototype.chooseAsync = function chooseAsync(opts) {\n    if (_initialized && _gameStarted) {\n      if (SIMULATE_USER_INPUT_CANCEL_ERROR) {\n        console.warn(\"FBINSTANT: mock chooseAsync. \\\n          Rejecting promise to simulate user cancelled without picking a context.\");\n\n        return _bluebird2.default.reject(new MockCodedError(ERROR_TYPE_USER_INPUT));\n      } else {\n        console.log(\"FBINSTANT: mock context.chooseAsync\", opts);\n\n        _setLSData('contextID', _getNewID());\n        return _bluebird2.default.resolve();\n      }\n    } else {\n      console.warn(\"FBINSTANT: mock context.chooseAsync FAILED! \\\n        You must call startGameAsync first.\");\n\n      return _bluebird2.default.reject(new MockCodedError(ERROR_TYPE_UNKNOWN));\n    }\n  };\n\n  MockFBInstantContext.prototype.createAsync = function createAsync(playerID) {\n    if (_initialized && _gameStarted) {\n      console.log(\"FBINSTANT: mock context.createAsync with player \", playerID);\n\n      _setLSData('contextID', _getNewID());\n      return _bluebird2.default.resolve();\n    } else {\n      console.warn(\"FBINSTANT: mock context.createAsync FAILED! \\\n        You must call startGameAsync first.\");\n\n      return _bluebird2.default.reject(new MockCodedError(ERROR_TYPE_UNKNOWN));\n    }\n  };\n\n  MockFBInstantContext.prototype.getPlayersAsync = function getPlayersAsync() {\n    if (_initialized && _gameStarted) {\n      console.log(\"FBINSTANT: mock context.getPlayersAsync\");\n\n      // TODO: return an array of instances of MockFBInstantContextPlayer\n      return _bluebird2.default.resolve([]);\n    } else {\n      console.warn(\"FBINSTANT: mock context.getPlayersAsync FAILED! \\\n        You must call startGameAsync first.\");\n\n      return _bluebird2.default.reject(new MockCodedError(ERROR_TYPE_UNKNOWN));\n    }\n  };\n\n  MockFBInstantContext.prototype.isSizeBetween = function isSizeBetween(minSize, maxSize) {\n    if (_initialized && _gameStarted) {\n      console.log(\"FBINSTANT: mock context.isSizeBetween\");\n\n      // currently, the API only returns a response once per session, and will\n      // always by design return that response for the rest of the session\n      if (this._hasCalledIsSizeBetween) {\n        minSize = this._isSizeBetweenMinSize;\n        maxSize = this._isSizeBetweenMaxSize;\n      } else {\n        this._hasCalledIsSizeBetween = true;\n        this._isSizeBetweenMinSize = minSize;\n        this._isSizeBetweenMaxSize = maxSize;\n      }\n\n      return {\n        answer: minSize <= SIMULATE_CONTEXT_SIZE && SIMULATE_CONTEXT_SIZE <= maxSize,\n        minSize: minSize,\n        maxSize: maxSize\n      };\n    } else {\n      console.warn(\"FBINSTANT: mock context.isSizeBetween FAILED! \\\n        You must call startGameAsync first.\");\n\n      return _bluebird2.default.reject(new MockCodedError(ERROR_TYPE_UNKNOWN));\n    }\n  };\n\n  return MockFBInstantContext;\n}();\n\n;\n\nvar MockFBInstantPayments = function () {\n  function MockFBInstantPayments() {\n    _classCallCheck(this, MockFBInstantPayments);\n  }\n\n  MockFBInstantPayments.prototype.getCatalogAsync = function getCatalogAsync() {\n    return _bluebird2.default.resolve([]);\n  };\n\n  MockFBInstantPayments.prototype.purchaseAsync = function purchaseAsync(purchaseConfig) {\n    return _bluebird2.default.resolve({\n      productID: purchaseConfig.productID,\n      developerPayload: purchaseConfig.developerPayload,\n      purchaseToken: 'MOCK_PURCHASE_TOKEN'\n    });\n  };\n\n  MockFBInstantPayments.prototype.getPurchasesAsync = function getPurchasesAsync() {\n    return _bluebird2.default.resolve([]);\n  };\n\n  MockFBInstantPayments.prototype.consumePurchaseAsync = function consumePurchaseAsync(purchaseID) {\n    return _bluebird2.default.resolve();\n  };\n\n  MockFBInstantPayments.prototype.onReady = function onReady(cb) {\n    cb();\n  };\n\n  MockFBInstantPayments.prototype.restorePurchasesAsync = function restorePurchasesAsync() {\n    return _bluebird2.default.resolve();\n  };\n\n  return MockFBInstantPayments;\n}();\n\n/**\n * Mock AdInstance object returned by getRewardedVideoAsync\n */\n\nvar MockFBInstantAdInstance = function () {\n  function MockFBInstantAdInstance(placementID) {\n    _classCallCheck(this, MockFBInstantAdInstance);\n\n    this.placementID = placementID;\n    this._onClickCallback = null;\n\n    // TODO: make a clickable ad view in devkit that stays up for sometime\n  }\n\n  MockFBInstantAdInstance.prototype.getPlacementID = function getPlacementID() {\n    return this.placementID;\n  };\n\n  MockFBInstantAdInstance.prototype.loadAsync = function loadAsync() {\n    if (!SIMULATE_AD_LOAD_FAILURE) {\n      console.log(\"FBINSTANT: mock adInstance.loadAsync\");\n\n      return new _bluebird2.default(function (resolve) {\n        setTimeout(resolve, SIMULATE_AD_LOAD_TIME);\n      });\n    } else {\n      return _bluebird2.default.reject(new MockCodedError(ERROR_TYPE_UNKNOWN));\n    }\n  };\n\n  MockFBInstantAdInstance.prototype.showAsync = function showAsync() {\n    if (!SIMULATE_AD_WATCH_CANCELLED) {\n      console.log(\"FBINSTANT: mock adInstance.showAsync\");\n\n      return _bluebird2.default.resolve();\n    } else {\n      return _bluebird2.default.reject(new MockCodedError(ERROR_TYPE_UNKNOWN));\n    }\n  };\n\n  MockFBInstantAdInstance.prototype.onClick = function onClick(callback) {\n    this._onClickCallback = callback;\n  };\n\n  return MockFBInstantAdInstance;\n}();\n\n/**\n * Mock SignedPlayerInfo object returned by player.getSignedPlayerInfoAsync\n */\n\nvar MockFBInstantSignedPlayerInfo = function () {\n  function MockFBInstantSignedPlayerInfo() {\n    _classCallCheck(this, MockFBInstantSignedPlayerInfo);\n  }\n\n  MockFBInstantSignedPlayerInfo.prototype.getPlayerID = function getPlayerID() {\n    return FBInstant.player.getID();\n  };\n\n  MockFBInstantSignedPlayerInfo.prototype.getSignature = function getSignature() {\n    return \"b67607cb5ecba55fbcc3c72771ebf9df\";\n  };\n\n  return MockFBInstantSignedPlayerInfo;\n}();\n\n/**\n * Mock ConnectedPlayer object returned by player.getConnectedPlayersAsync\n */\n\nvar MockFBInstantConnectedPlayer = function () {\n  function MockFBInstantConnectedPlayer() {\n    _classCallCheck(this, MockFBInstantConnectedPlayer);\n  }\n\n  MockFBInstantConnectedPlayer.prototype.getID = function getID() {\n    throw new Error('TODO');\n  };\n\n  MockFBInstantConnectedPlayer.prototype.getName = function getName() {\n    throw new Error('TODO');\n  };\n\n  MockFBInstantConnectedPlayer.prototype.getPhoto = function getPhoto() {\n    throw new Error('TODO');\n  };\n\n  return MockFBInstantConnectedPlayer;\n}();\n\n/**\n * Mock ContextPlayer object returned by context.getPlayersAsync\n */\n\nvar MockFBInstantContextPlayer = function () {\n  function MockFBInstantContextPlayer() {\n    _classCallCheck(this, MockFBInstantContextPlayer);\n  }\n\n  MockFBInstantContextPlayer.prototype.getID = function getID() {\n    throw new Error('TODO');\n  };\n\n  MockFBInstantContextPlayer.prototype.getName = function getName() {\n    throw new Error('TODO');\n  };\n\n  MockFBInstantContextPlayer.prototype.getPhoto = function getPhoto() {\n    throw new Error('TODO');\n  };\n\n  return MockFBInstantContextPlayer;\n}();\n\n/**\n * Mock FBInstant CodedError\n */\n\n// mock coded error types\n\n\nvar ERROR_TYPE_ADS_NO_FILL = 'ADS_NO_FILL';\nvar ERROR_TYPE_ADS_FREQUENT_LOAD = 'ADS_FREQUENT_LOAD';\nvar ERROR_TYPE_ANALYTICS_POST_EXCEPTION = 'ANALYTICS_POST_EXCEPTION';\nvar ERROR_TYPE_CLIENT_REQUIRES_UPDATE = 'CLIENT_REQUIRES_UPDATE';\nvar ERROR_TYPE_INVALID_PARAM = 'INVALID_PARAM';\nvar ERROR_TYPE_NETWORK_FAILURE = 'NETWORK_FAILURE';\nvar ERROR_TYPE_PENDING_REQUEST = 'PENDING_REQUEST';\nvar ERROR_TYPE_UNKNOWN = 'UNKNOWN';\nvar ERROR_TYPE_USER_INPUT = 'USER_INPUT';\n\n// mock coded error messages\nvar ERROR_MESSAGES = {};\n\nERROR_MESSAGES[ERROR_TYPE_ADS_NO_FILL] = \"MOCK ERROR MESSAGE: \\\n  We were not able to serve ads to the current user. \\\n  This can happen if the user has opted out of interest-based ads on their device, or if we do not have ad inventory to show for that user.\";\n\nERROR_MESSAGES[ERROR_TYPE_ADS_FREQUENT_LOAD] = \"MOCK ERROR MESSAGE: \\\n  Ads are being loaded too frequently.\";\n\nERROR_MESSAGES[ERROR_TYPE_ANALYTICS_POST_EXCEPTION] = \"MOCK ERROR MESSAGE: \\\n  The analytics API experienced a problem while attempting to post an event.\";\n\nERROR_MESSAGES[ERROR_TYPE_CLIENT_REQUIRES_UPDATE] = \"MOCK ERROR MESSAGE: \\\n  The client requires an update to access the feature that returned this result. \\\n  If this result is returned on web, it means the feature is not supported by the web client yet.\";\n\nERROR_MESSAGES[ERROR_TYPE_INVALID_PARAM] = \"MOCK ERROR MESSAGE: \\\n  The parameter(s) passed to the API are invalid. \\\n  Could indicate an incorrect type, invalid number of arguments, or a semantic issue (for example, passing an unserializable object to a serializing function).\";\n\nERROR_MESSAGES[ERROR_TYPE_NETWORK_FAILURE] = \"MOCK ERROR MESSAGE: \\\n  The client experienced an issue with a network request. \\\n  This is likely due to a transient issue, such as the player's internet connection dropping.\";\n\nERROR_MESSAGES[ERROR_TYPE_PENDING_REQUEST] = \"MOCK ERROR MESSAGE: \\\n  Represents a rejection due an existing request that conflicts with this one. \\\n  For example, we will reject any calls that would surface a Facebook UI when another request that depends on a Facebook UI is pending.\";\n\nERROR_MESSAGES[ERROR_TYPE_UNKNOWN] = \"MOCK ERROR MESSAGE: \\\n  An unknown or unspecified issue occurred. \\\n  This is the default error code returned when the client does not specify a code.\";\n\nERROR_MESSAGES[ERROR_TYPE_USER_INPUT] = \"MOCK ERROR MESSAGE: \\\n  The user made a choice that resulted in a rejection. \\\n  For example, if the game calls up the Context Switch dialog and the player closes it, this error code will be included in the promise rejection.\";\n\nvar MockCodedError = function MockCodedError(code) {\n  _classCallCheck(this, MockCodedError);\n\n  this.code = code || ERROR_TYPE_UNKNOWN;\n  this.message = ERROR_MESSAGES[this.code];\n};\n\nexports.default = new MockFBInstant();\n\n/**\n * Mock Data Helpers\n */\n\nvar _getNewID = function _getNewID() {\n  return Math.floor(1000 + Math.random() * 10000).toString();\n};\n\nvar _getLSData = function _getLSData(key, defaultValue) {\n  try {\n    var value = localStorage.getItem(LS_KEY + ':' + key);\n    console.log(\"FBINSTANT: mock getDataAsync \\\n      (\" + key + \", \" + defaultValue + \"): \" + value);\n\n    if (value) {\n      return JSON.parse(value);\n    }\n\n    _setLSData(key, defaultValue);\n  } catch (e) {\n    console.error(\"FBINSTANT: mock getDataAsync FAILED!\", e);\n  }\n\n  return defaultValue;\n};\n\nvar _setLSData = function _setLSData(key, value) {\n  try {\n    console.log(\"FBINSTANT: mock setDataAsync \" + key + \": \" + value);\n\n    if (!value) {\n      localStorage.removeItem(value);\n    } else {\n      localStorage.setItem(LS_KEY + ':' + key, JSON.stringify(value));\n    }\n  } catch (e) {\n    console.error(\"FBINSTANT: mock setDataAsync FAILED!\", e);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9mcm9udGVuZC9kZXZraXQtZmJpbnN0YW50L2pzL01vY2tGQkluc3RhbnQuanM/MWQwYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0YsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdko7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJmaWxlIjoiNjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfYmx1ZWJpcmQgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xuXG52YXIgX2JsdWViaXJkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JsdWViaXJkKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLy8gVE9ETzogVXNlIGpzaW8td2VicGFjay12MSB0byBidWlsZCB0aGlzLiAgYnJpbmcgYmFjayBzdHJpbmctaGFzaCB0aGVuLlxuLy8gaW1wb3J0IHN0cmluZ0hhc2ggZnJvbSAnc3RyaW5nLWhhc2gnO1xuXG52YXIgTFNfS0VZID0gJ2RldmtpdC1mYmluc3RhbnQ6TW9ja0ZCSW5zdGFudCc7XG52YXIgUExBWUVSX0RBVEFfUFJFRklYID0gJ3BsYXllckRhdGEnO1xuXG4vLyBjaGFuZ2UgdGhlIHNpbXVsYXRlZCBtb2NrIGJlaGF2aW9yXG52YXIgU0lNVUxBVEVfTE9DQUxFX1RZUEUgPSAnZW5fVVMnO1xudmFyIFNJTVVMQVRFX1BMQVRGT1JNX1RZUEUgPSAnJztcbnZhciBTSU1VTEFURV9TREtfVkVSU0lPTiA9ICc2LjAnO1xudmFyIFNJTVVMQVRFX0NPTlRFWFRfVFlQRSA9ICdUSFJFQUQnO1xudmFyIFNJTVVMQVRFX09VVERBVEVEX0FQUCA9IGZhbHNlO1xudmFyIFNJTVVMQVRFX1VTRVJfSU5QVVRfQ0FOQ0VMX0VSUk9SID0gZmFsc2U7XG52YXIgU0lNVUxBVEVfQURfTE9BRF9USU1FID0gMzAwMDtcbnZhciBTSU1VTEFURV9BRF9VTkFWQUlMQUJMRSA9IGZhbHNlO1xudmFyIFNJTVVMQVRFX0FEX0xPQURfRkFJTFVSRSA9IGZhbHNlO1xudmFyIFNJTVVMQVRFX0FEX1dBVENIX0NBTkNFTExFRCA9IGZhbHNlO1xudmFyIFNJTVVMQVRFX0NPTlRFWFRfU0laRSA9IDU7XG52YXIgU0lNVUxBVEVfQ0FOX1BMQVlFUl9NQVRDSCA9IHRydWU7XG52YXIgU0lNVUxBVEVfTUFUQ0hfV0FJVF9USU1FID0gNTAwMDtcbnZhciBTSU1VTEFURV9NQVRDSF9GQUlMRUQgPSBmYWxzZTtcblxudmFyIFNJTVVMQVRFX1NVUFBPUlRFRF9BUElTID0gWydpbml0aWFsaXplQXN5bmMnLCAnZ2V0TG9jYWxlJywgJ2dldFBsYXRmb3JtJywgJ2dldFNES1ZlcnNpb24nLCAnZ2V0U3VwcG9ydGVkQVBJcycsICdzZXRMb2FkaW5nUHJvZ3Jlc3MnLCAnZ2V0RW50cnlQb2ludERhdGEnLCAnc2V0U2Vzc2lvbkRhdGEnLCAnc3RhcnRHYW1lQXN5bmMnLCAndXBkYXRlQXN5bmMnLCAnc2hhcmVBc3luYycsICdxdWl0JywgJ2xvZ0V2ZW50JywgJ29uUGF1c2UnLCAnZ2V0SW50ZXJzdGl0aWFsQWRBc3luYycsICdnZXRSZXdhcmRlZFZpZGVvQXN5bmMnLCAnY2hlY2tDYW5QbGF5ZXJNYXRjaEFzeW5jJywgJ21hdGNoUGxheWVyQXN5bmMnLCAnc3dpdGNoR2FtZUFzeW5jJywgJ3BsYXllci5nZXRJRCcsICdwbGF5ZXIuZ2V0TmFtZScsICdwbGF5ZXIuZ2V0UGhvdG8nLCAncGxheWVyLmdldERhdGFBc3luYycsICdwbGF5ZXIuc2V0RGF0YUFzeW5jJywgJ3BsYXllci5mbHVzaERhdGFBc3luYycsICdwbGF5ZXIuZ2V0Q29ubmVjdGVkUGxheWVyc0FzeW5jJywgJ3BsYXllci5nZXRTaWduZWRQbGF5ZXJJbmZvQXN5bmMnLCAnY29udGV4dC5nZXRJRCcsICdjb250ZXh0LmdldFR5cGUnLCAnY29udGV4dC5zd2l0Y2hBc3luYycsICdjb250ZXh0LmNob29zZUFzeW5jJywgJ2NvbnRleHQuY3JlYXRlQXN5bmMnLCAnY29udGV4dC5nZXRQbGF5ZXJzQXN5bmMnLCAnY29udGV4dC5pc1NpemVCZXR3ZWVuJywgJ3BheW1lbnRzLmdldENhdGFsb2dBc3luYycsICdwYXltZW50cy5wdXJjaGFzZUFzeW5jJywgJ3BheW1lbnRzLmdldFB1cmNoYXNlc0FzeW5jJywgJ3BheW1lbnRzLmNvbnN1bWVQdXJjaGFzZUFzeW5jJywgJ3BheW1lbnRzLm9uUmVhZHknLCAncGF5bWVudHMucmVzdG9yZVB1cmNoYXNlc0FzeW5jJ107XG5cbi8vIHNpbXVsYXRlIHJlYWwgRkJJbnN0YW50IGdldFBsYXRmb3JtIGJlaGF2aW9yXG52YXIgX3VzZXJBZ2VudCA9IG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50O1xudmFyIF9pc0lPUyA9IC9pUG9kfGlQaG9uZXxpUGFkL2kudGVzdChfdXNlckFnZW50KTtcbnZhciBfaXNBbmRyb2lkID0gL0FuZHJvaWQvLnRlc3QoX3VzZXJBZ2VudCk7XG5cbi8vIHNpbXVsYXRlIHJlYWwgRkJJbnN0YW50IGJlaGF2aW9yIGFyb3VuZCBpbml0aWFsaXplQXN5bmNcbnZhciBfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuLy8gc2ltdWxhdGUgcmVhbCBGQkluc3RhbnQgYmVoYXZpb3IgYXJvdW5kIHN0YXJ0R2FtZUFzeW5jXG52YXIgX2dhbWVTdGFydGVkID0gZmFsc2U7XG5cbi8vIHNpbXVsYXRlIHN0YXRlIGZvciBsb2FkaW5nIHByb2dyZXNzXG52YXIgX2xvYWRpbmdQcm9ncmVzcyA9IDA7XG5cbi8vIHNpbXVsYXRlIHNlc3Npb24gZGF0YVxudmFyIF9zZXNzaW9uRGF0YSA9IHt9O1xuXG4vLyBzaW11bGF0ZSBvblBhdXNlIGNhbGxiYWNrXG52YXIgX29uUGF1c2VDYWxsYmFjayA9IG51bGw7XG52YXIgb25QYXVzZSA9IGZ1bmN0aW9uIG9uUGF1c2UoKSB7XG4gIGlmICh3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmhpZGRlbikge1xuICAgIF9vblBhdXNlQ2FsbGJhY2sgJiYgX29uUGF1c2VDYWxsYmFjaygpO1xuICB9XG59O1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIG9uUGF1c2UsIGZhbHNlKTtcblxuLy8gTk9URTogRG8gbm90IHVzZSBsYW1iZGEgYXJyb3cgZnVuY3Rpb25zIGJlY2F1c2Ugd2UgcmVseSBvbiAndGhpcycgY29udGV4dCFcblxudmFyIE1vY2tGQkluc3RhbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1vY2tGQkluc3RhbnQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vY2tGQkluc3RhbnQpO1xuXG4gICAgdGhpcy5wbGF5ZXIgPSBuZXcgTW9ja0ZCSW5zdGFudFBsYXllcigpO1xuICAgIHRoaXMuY29udGV4dCA9IG5ldyBNb2NrRkJJbnN0YW50Q29udGV4dCgpO1xuICAgIHRoaXMucGF5bWVudHMgPSBuZXcgTW9ja0ZCSW5zdGFudFBheW1lbnRzKCk7XG4gIH1cblxuICAvKipcbiAgICogTW9jayBBUEknc1xuICAgKi9cblxuICBNb2NrRkJJbnN0YW50LnByb3RvdHlwZS5pbml0aWFsaXplQXN5bmMgPSBmdW5jdGlvbiBpbml0aWFsaXplQXN5bmMoKSB7XG4gICAgY29uc29sZS5sb2coXCJGQklOU1RBTlQ6IG1vY2sgaW5pdGlhbGl6ZUFzeW5jXCIpO1xuXG4gICAgX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICByZXR1cm4gX2JsdWViaXJkMi5kZWZhdWx0LnJlc29sdmUoKTtcbiAgfTtcblxuICBNb2NrRkJJbnN0YW50LnByb3RvdHlwZS5nZXRMb2NhbGUgPSBmdW5jdGlvbiBnZXRMb2NhbGUoKSB7XG4gICAgaWYgKF9pbml0aWFsaXplZCkge1xuICAgICAgY29uc29sZS5sb2coXCJGQklOU1RBTlQ6IG1vY2sgZ2V0TG9jYWxlXCIpO1xuXG4gICAgICByZXR1cm4gU0lNVUxBVEVfTE9DQUxFX1RZUEU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkZCSU5TVEFOVDogbW9jayBnZXRMb2NhbGUgRkFJTEVEISBcXFxuICAgICAgICBZb3UgbXVzdCBjYWxsIGluaXRpYWxpemVBc3luYyBmaXJzdC5cIik7XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICBNb2NrRkJJbnN0YW50LnByb3RvdHlwZS5nZXRQbGF0Zm9ybSA9IGZ1bmN0aW9uIGdldFBsYXRmb3JtKCkge1xuICAgIGNvbnNvbGUubG9nKFwiRkJJTlNUQU5UOiBtb2NrIGdldFBsYXRmb3JtXCIpO1xuXG4gICAgaWYgKFNJTVVMQVRFX1BMQVRGT1JNX1RZUEUpIHtcbiAgICAgIHJldHVybiBTSU1VTEFURV9QTEFURk9STV9UWVBFO1xuICAgIH0gZWxzZSBpZiAoX2lzSU9TKSB7XG4gICAgICByZXR1cm4gJ0lPUyc7XG4gICAgfSBlbHNlIGlmIChfaXNBbmRyb2lkKSB7XG4gICAgICByZXR1cm4gJ0FORFJPSUQnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ1dFQic7XG4gICAgfVxuICB9O1xuXG4gIE1vY2tGQkluc3RhbnQucHJvdG90eXBlLmdldFNES1ZlcnNpb24gPSBmdW5jdGlvbiBnZXRTREtWZXJzaW9uKCkge1xuICAgIGNvbnNvbGUubG9nKFwiRkJJTlNUQU5UOiBtb2NrIGdldFNES1ZlcnNpb25cIik7XG5cbiAgICByZXR1cm4gU0lNVUxBVEVfU0RLX1ZFUlNJT047XG4gIH07XG5cbiAgTW9ja0ZCSW5zdGFudC5wcm90b3R5cGUuZ2V0U3VwcG9ydGVkQVBJcyA9IGZ1bmN0aW9uIGdldFN1cHBvcnRlZEFQSXMoKSB7XG4gICAgY29uc29sZS5sb2coXCJGQklOU1RBTlQ6IG1vY2sgZ2V0U3VwcG9ydGVkQVBJc1wiKTtcblxuICAgIHJldHVybiBTSU1VTEFURV9TVVBQT1JURURfQVBJUztcbiAgfTtcblxuICBNb2NrRkJJbnN0YW50LnByb3RvdHlwZS5zZXRMb2FkaW5nUHJvZ3Jlc3MgPSBmdW5jdGlvbiBzZXRMb2FkaW5nUHJvZ3Jlc3MocGVyY2VudCkge1xuICAgIGNvbnNvbGUubG9nKFwiRkJJTlNUQU5UOiBtb2NrIHNldExvYWRpbmdQcm9ncmVzcywgc2V0IHRvIFwiICsgcGVyY2VudCArIFwiJVwiKTtcblxuICAgIF9sb2FkaW5nUHJvZ3Jlc3MgPSBwZXJjZW50O1xuICB9O1xuXG4gIE1vY2tGQkluc3RhbnQucHJvdG90eXBlLmdldEVudHJ5UG9pbnREYXRhID0gZnVuY3Rpb24gZ2V0RW50cnlQb2ludERhdGEoKSB7XG4gICAgaWYgKF9pbml0aWFsaXplZCkge1xuICAgICAgY29uc29sZS5sb2coXCJGQklOU1RBTlQ6IG1vY2sgZ2V0RW50cnlQb2ludERhdGFcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkZCSU5TVEFOVDogbW9jayBnZXRFbnRyeVBvaW50RGF0YSBcXFxuICAgICAgICBjYWxsZWQgYmVmb3JlIGluaXRpYWxpemVBc3luYyFcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHt9O1xuICB9O1xuXG4gIE1vY2tGQkluc3RhbnQucHJvdG90eXBlLnNldFNlc3Npb25EYXRhID0gZnVuY3Rpb24gc2V0U2Vzc2lvbkRhdGEoZGF0YSkge1xuICAgIGlmIChfaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRkJJTlNUQU5UOiBtb2NrIHNldFNlc3Npb25EYXRhXCIsIGRhdGEpO1xuXG4gICAgICBfc2Vzc2lvbkRhdGEgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJGQklOU1RBTlQ6IG1vY2sgc2V0U2Vzc2lvbkRhdGEgXFxcbiAgICAgICAgY2FsbGVkIGJlZm9yZSBpbml0aWFsaXplQXN5bmMhXCIpO1xuICAgIH1cbiAgfTtcblxuICBNb2NrRkJJbnN0YW50LnByb3RvdHlwZS5zdGFydEdhbWVBc3luYyA9IGZ1bmN0aW9uIHN0YXJ0R2FtZUFzeW5jKCkge1xuICAgIGlmIChfaW5pdGlhbGl6ZWQpIHtcbiAgICAgIF9nYW1lU3RhcnRlZCA9IHRydWU7XG5cbiAgICAgIGlmIChTSU1VTEFURV9PVVREQVRFRF9BUFApIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRkJJTlNUQU5UOiBtb2NrIHN0YXJ0R2FtZUFzeW5jLiBcXFxuICAgICAgICAgIFJlamVjdGluZyBwcm9taXNlIHRvIHNpbXVsYXRlIG91dGRhdGVkIGFwcC5cIik7XG5cbiAgICAgICAgcmV0dXJuIF9ibHVlYmlyZDIuZGVmYXVsdC5yZWplY3QobmV3IE1vY2tDb2RlZEVycm9yKEVSUk9SX1RZUEVfQ0xJRU5UX1JFUVVJUkVTX1VQREFURSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJGQklOU1RBTlQ6IG1vY2sgc3RhcnRHYW1lQXN5bmMuIFxcXG4gICAgICAgICAgUmVzb2x2aW5nIHByb21pc2UgdG8gc2ltdWxhdGUgdXAtdG8tZGF0ZSBhcHAuXCIpO1xuXG4gICAgICAgIHJldHVybiBfYmx1ZWJpcmQyLmRlZmF1bHQucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJGQklOU1RBTlQ6IG1vY2sgc3RhcnRHYW1lQXN5bmMgRkFJTEVEIS4gXFxcbiAgICAgICAgWW91IG11c3QgY2FsbCBpbml0aWFsaXplQXN5bmMgZmlyc3QuXCIpO1xuXG4gICAgICByZXR1cm4gX2JsdWViaXJkMi5kZWZhdWx0LnJlamVjdChuZXcgTW9ja0NvZGVkRXJyb3IoRVJST1JfVFlQRV9VTktOT1dOKSk7XG4gICAgfVxuICB9O1xuXG4gIE1vY2tGQkluc3RhbnQucHJvdG90eXBlLnVwZGF0ZUFzeW5jID0gZnVuY3Rpb24gdXBkYXRlQXN5bmMob3B0cykge1xuICAgIGlmIChfaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRkJJTlNUQU5UOiBtb2NrIHVwZGF0ZUFzeW5jXCIsIG9wdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJGQklOU1RBTlQ6IG1vY2sgdXBkYXRlQXN5bmMgXFxcbiAgICAgICAgY2FsbGVkIGJlZm9yZSBpbml0aWFsaXplQXN5bmMhXCIsIG9wdHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfYmx1ZWJpcmQyLmRlZmF1bHQucmVzb2x2ZSgpO1xuICB9O1xuXG4gIE1vY2tGQkluc3RhbnQucHJvdG90eXBlLnNoYXJlQXN5bmMgPSBmdW5jdGlvbiBzaGFyZUFzeW5jKG9wdHMpIHtcbiAgICBpZiAoX2luaXRpYWxpemVkKSB7XG4gICAgICBpZiAoU0lNVUxBVEVfVVNFUl9JTlBVVF9DQU5DRUxfRVJST1IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRkJJTlNUQU5UOiBtb2NrIHNoYXJlQXN5bmMuIFxcXG4gICAgICAgICAgUmVqZWN0aW5nIHByb21pc2UgdG8gc2ltdWxhdGUgdXNlciBjYW5jZWxsZWQgd2l0aG91dCBzaGFyaW5nLlwiKTtcblxuICAgICAgICByZXR1cm4gX2JsdWViaXJkMi5kZWZhdWx0LnJlamVjdChuZXcgTW9ja0NvZGVkRXJyb3IoRVJST1JfVFlQRV9VU0VSX0lOUFVUKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkZCSU5TVEFOVDogbW9jayBzaGFyZUFzeW5jXCIsIG9wdHMpO1xuXG4gICAgICAgIHJldHVybiBfYmx1ZWJpcmQyLmRlZmF1bHQucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJGQklOU1RBTlQ6IG1vY2sgc2hhcmVBc3luYyBcXFxuICAgICAgICBjYWxsZWQgYmVmb3JlIGluaXRpYWxpemVBc3luYyFcIiwgb3B0cyk7XG5cbiAgICAgIHJldHVybiBfYmx1ZWJpcmQyLmRlZmF1bHQucmVqZWN0KG5ldyBNb2NrQ29kZWRFcnJvcihFUlJPUl9UWVBFX1VOS05PV04pKTtcbiAgICB9XG4gIH07XG5cbiAgTW9ja0ZCSW5zdGFudC5wcm90b3R5cGUucXVpdCA9IGZ1bmN0aW9uIHF1aXQoKSB7XG4gICAgY29uc29sZS5sb2coXCJGQklOU1RBTlQ6IG1vY2sgcXVpdFwiKTtcbiAgICBsb2NhdGlvbi5yZWxvYWQoKTtcbiAgfTtcblxuICBNb2NrRkJJbnN0YW50LnByb3RvdHlwZS5sb2dFdmVudCA9IGZ1bmN0aW9uIGxvZ0V2ZW50KG5hbWUsIHZhbHVlLCBvcHRzKSB7XG4gICAgaWYgKF9pbml0aWFsaXplZCkge1xuICAgICAgY29uc29sZS5sb2coXCJGQklOU1RBTlQ6IG1vY2sgbG9nRXZlbnRcIiwgbmFtZSwgdmFsdWUsIG9wdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJGQklOU1RBTlQ6IG1vY2sgbG9nRXZlbnQgXFxcbiAgICAgICAgY2FsbGVkIGJlZm9yZSBpbml0aWFsaXplQXN5bmMhXCIsIG5hbWUsIHZhbHVlLCBvcHRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgTW9ja0ZCSW5zdGFudC5wcm90b3R5cGUub25QYXVzZSA9IGZ1bmN0aW9uIG9uUGF1c2UoZm4pIHtcbiAgICBjb25zb2xlLmxvZyhcIkZCSU5TVEFOVDogbW9jayBvblBhdXNlXCIpO1xuXG4gICAgX29uUGF1c2VDYWxsYmFjayA9IGZuO1xuICB9O1xuXG4gIE1vY2tGQkluc3RhbnQucHJvdG90eXBlLmdldEludGVyc3RpdGlhbEFkQXN5bmMgPSBmdW5jdGlvbiBnZXRJbnRlcnN0aXRpYWxBZEFzeW5jKHBsYWNlbWVudElEKSB7XG4gICAgaWYgKF9pbml0aWFsaXplZCkge1xuICAgICAgY29uc29sZS5sb2coXCJGQklOU1RBTlQ6IG1vY2sgZ2V0SW50ZXJlc3RpYWxBZEFzeW5jXCIpO1xuXG4gICAgICBpZiAoU0lNVUxBVEVfQURfVU5BVkFJTEFCTEUpIHtcbiAgICAgICAgcmV0dXJuIF9ibHVlYmlyZDIuZGVmYXVsdC5yZWplY3QobmV3IE1vY2tDb2RlZEVycm9yKEVSUk9SX1RZUEVfQURTX05PX0ZJTEwpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBfYmx1ZWJpcmQyLmRlZmF1bHQucmVzb2x2ZShuZXcgTW9ja0ZCSW5zdGFudEFkSW5zdGFuY2UocGxhY2VtZW50SUQpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiRkJJTlNUQU5UOiBtb2NrIGdldEludGVyZXN0aWFsQWRBc3luYyBcXFxuICAgICAgICBjYWxsZWQgYmVmb3JlIGluaXRhbGl6ZUFzeW5jIVwiKTtcblxuICAgICAgcmV0dXJuIF9ibHVlYmlyZDIuZGVmYXVsdC5yZWplY3QobmV3IE1vY2tDb2RlZEVycm9yKEVSUk9SX1RZUEVfVU5LTk9XTikpO1xuICAgIH1cbiAgfTtcblxuICBNb2NrRkJJbnN0YW50LnByb3RvdHlwZS5nZXRSZXdhcmRlZFZpZGVvQXN5bmMgPSBmdW5jdGlvbiBnZXRSZXdhcmRlZFZpZGVvQXN5bmMocGxhY2VtZW50SUQpIHtcbiAgICBpZiAoX2luaXRpYWxpemVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkZCSU5TVEFOVDogbW9jayBnZXRSZXdhcmRlZFZpZGVvQXN5bmNcIik7XG5cbiAgICAgIGlmIChTSU1VTEFURV9BRF9VTkFWQUlMQUJMRSkge1xuICAgICAgICByZXR1cm4gX2JsdWViaXJkMi5kZWZhdWx0LnJlamVjdChuZXcgTW9ja0NvZGVkRXJyb3IoRVJST1JfVFlQRV9BRFNfTk9fRklMTCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9ibHVlYmlyZDIuZGVmYXVsdC5yZXNvbHZlKG5ldyBNb2NrRkJJbnN0YW50QWRJbnN0YW5jZShwbGFjZW1lbnRJRCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJGQklOU1RBTlQ6IG1vY2sgZ2V0UmV3YXJkZWRWaWRlb0FzeW5jIFxcXG4gICAgICAgIGNhbGxlZCBiZWZvcmUgaW5pdGFsaXplQXN5bmMhXCIpO1xuXG4gICAgICByZXR1cm4gX2JsdWViaXJkMi5kZWZhdWx0LnJlamVjdChuZXcgTW9ja0NvZGVkRXJyb3IoRVJST1JfVFlQRV9VTktOT1dOKSk7XG4gICAgfVxuICB9O1xuXG4gIE1vY2tGQkluc3RhbnQucHJvdG90eXBlLmNoZWNrQ2FuUGxheWVyTWF0Y2hBc3luYyA9IGZ1bmN0aW9uIGNoZWNrQ2FuUGxheWVyTWF0Y2hBc3luYygpIHtcbiAgICBpZiAoX2luaXRpYWxpemVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkZCSU5TVEFOVDogbW9jayBjaGVja0NhblBsYXllck1hdGNoQXN5bmNcIik7XG5cbiAgICAgIHJldHVybiBuZXcgX2JsdWViaXJkMi5kZWZhdWx0KGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcmVzb2x2ZShTSU1VTEFURV9DQU5fUExBWUVSX01BVENIKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJGQklOU1RBTlQ6IG1vY2sgY2hlY2tDYW5QbGF5ZXJNYXRjaEFzeW5jIFxcXG4gICAgICAgIGNhbGxlZCBiZWZvcmUgaW5pdGlhbGl6ZUFzeW5jIVwiKTtcblxuICAgICAgcmV0dXJuIG5ldyBfYmx1ZWJpcmQyLmRlZmF1bHQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZWplY3QobmV3IE1vY2tDb2RlZEVycm9yKEVSUk9SX1RZUEVfVU5LTk9XTikpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIE1vY2tGQkluc3RhbnQucHJvdG90eXBlLm1hdGNoUGxheWVyQXN5bmMgPSBmdW5jdGlvbiBtYXRjaFBsYXllckFzeW5jKG1hdGNoVGFnKSB7XG4gICAgaWYgKF9pbml0aWFsaXplZCkge1xuICAgICAgY29uc29sZS5sb2coXCJGQklOU1RBTlQ6IG1vY2sgbWF0Y2hQbGF5ZXJBc3luY1wiLCBtYXRjaFRhZyk7XG5cbiAgICAgIHJldHVybiBuZXcgX2JsdWViaXJkMi5kZWZhdWx0KGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKFNJTVVMQVRFX01BVENIX0ZBSUxFRCkge1xuICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9zZXRMU0RhdGEoJ2NvbnRleHRJRCcsIF9nZXROZXdJRCgpKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIFNJTVVMQVRFX01BVENIX1dBSVRfVElNRSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiRkJJTlNUQU5UOiBtb2NrIG1hdGNoUGxheWVyQXN5bmMgXFxcbiAgICAgICAgY2FsbGVkIGJlZm9yZSBpbml0YWxpemVBc3luYyFcIiwgbWF0Y2hUYWcpO1xuXG4gICAgICByZXR1cm4gX2JsdWViaXJkMi5kZWZhdWx0LnJlamVjdChuZXcgTW9ja0NvZGVkRXJyb3IoRVJST1JfVFlQRV9VTktOT1dOKSk7XG4gICAgfVxuICB9O1xuXG4gIE1vY2tGQkluc3RhbnQucHJvdG90eXBlLnN3aXRjaEdhbWVBc3luYyA9IGZ1bmN0aW9uIHN3aXRjaEdhbWVBc3luYyhhcHBJRCwgcGF5bG9hZCkge1xuICAgIGlmIChfaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRkJJTlNUQU5UOiBtb2NrIHN3aXRjaEdhbWVBc3luY1wiLCBhcHBJRCwgcGF5bG9hZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkZCSU5TVEFOVDogbW9jayBzd2l0Y2hHYW1lQXN5bmMgXFxcbiAgICAgICAgY2FsbGVkIGJlZm9yZSBpbml0YWxpemVBc3luYyFcIiwgYXBwSUQsIHBheWxvYWQpO1xuXG4gICAgICByZXR1cm4gX2JsdWViaXJkMi5kZWZhdWx0LnJlamVjdChuZXcgTW9ja0NvZGVkRXJyb3IoRVJST1JfVFlQRV9VTktOT1dOKSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBNb2NrRkJJbnN0YW50O1xufSgpO1xuXG47XG5cbi8qKlxuICogTW9jayBQbGF5ZXIgQVBJJ3NcbiAqL1xuXG52YXIgTW9ja0ZCSW5zdGFudFBsYXllciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTW9ja0ZCSW5zdGFudFBsYXllcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9ja0ZCSW5zdGFudFBsYXllcik7XG4gIH1cblxuICBNb2NrRkJJbnN0YW50UGxheWVyLnByb3RvdHlwZS5nZXRJRCA9IGZ1bmN0aW9uIGdldElEKCkge1xuICAgIGNvbnNvbGUubG9nKFwiRkJJTlNUQU5UOiBtb2NrIHBsYXllci5nZXRJRFwiKTtcblxuICAgIHJldHVybiBfZ2V0TFNEYXRhKCdwbGF5ZXJJRCcsIF9nZXROZXdJRCgpKTtcbiAgfTtcblxuICBNb2NrRkJJbnN0YW50UGxheWVyLnByb3RvdHlwZS5nZXROYW1lID0gZnVuY3Rpb24gZ2V0TmFtZSgpIHtcbiAgICBpZiAoX2luaXRpYWxpemVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkZCSU5TVEFOVDogbW9jayBwbGF5ZXIuZ2V0TmFtZVwiKTtcblxuICAgICAgdmFyIHBsYXllcklEID0gdGhpcy5nZXRJRCgpO1xuICAgICAgcmV0dXJuIFwiVGVzdE5hbWVcIiArIHBsYXllcklEO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJGQklOU1RBTlQ6IG1vY2sgcGxheWVyLmdldE5hbWUgRkFJTEVEISBcXFxuICAgICAgICBZb3UgbXVzdCBjYWxsIGluaXRpYWxpemVBc3luYyBmaXJzdC5cIik7XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICBNb2NrRkJJbnN0YW50UGxheWVyLnByb3RvdHlwZS5nZXRQaG90byA9IGZ1bmN0aW9uIGdldFBob3RvKCkge1xuICAgIGlmIChfaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRkJJTlNUQU5UOiBtb2NrIHBsYXllci5nZXRQaG90b1wiKTtcblxuICAgICAgdmFyIHBsYXllcklEID0gdGhpcy5nZXRJRCgpO1xuICAgICAgLy8gVE9ETzogVXNlIHN0cmluZ0hhc2ggd2hlbiBhdmFpbGFibGVcbiAgICAgIC8vIGNvbnN0IGltYWdlSUQgPSAoc3RyaW5nSGFzaChwbGF5ZXJJRCkgJSA5ICsgMSkudG9TdHJpbmcoKTtcbiAgICAgIHZhciBpbWFnZUlEID0gJzEnO1xuICAgICAgdmFyIGltYWdlTmFtZSA9ICdhbmltYWxfMDAwJyArIGltYWdlSUQgKyAnLnBuZyc7XG4gICAgICByZXR1cm4gJ2Zyb250ZW5kL2RldmtpdC1mYmluc3RhbnQvaW1hZ2VzL2F2YXRhci8nICsgaW1hZ2VOYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJGQklOU1RBTlQ6IG1vY2sgcGxheWVyLmdldFBob3RvIEZBSUxFRCEgXFxcbiAgICAgICAgWW91IG11c3QgY2FsbCBpbml0aWFsaXplQXN5bmMgZmlyc3QuXCIpO1xuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgTW9ja0ZCSW5zdGFudFBsYXllci5wcm90b3R5cGUuZ2V0RGF0YUFzeW5jID0gZnVuY3Rpb24gZ2V0RGF0YUFzeW5jKGtleXMpIHtcbiAgICBpZiAoX2luaXRpYWxpemVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkZCSU5TVEFOVDogbW9jayBwbGF5ZXIuZ2V0RGF0YUFzeW5jXCIsIGtleXMpO1xuXG4gICAgICByZXR1cm4gX2JsdWViaXJkMi5kZWZhdWx0Lm1hcChrZXlzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBfZ2V0TFNEYXRhKFBMQVlFUl9EQVRBX1BSRUZJWCArICc6JyArIGtleSk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSwgaSkge1xuICAgICAgICAgIHJlc1trZXldID0gdmFsdWVzW2ldO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJGQklOU1RBTlQ6IG1vY2sgcGxheWVyLmdldERhdGFBc3luYyBGQUlMRUQhIFxcXG4gICAgICAgIFlvdSBtdXN0IGNhbGwgaW5pdGlhbGl6ZUFzeW5jIGZpcnN0LlwiLCBrZXlzKTtcblxuICAgICAgcmV0dXJuIF9ibHVlYmlyZDIuZGVmYXVsdC5yZWplY3QobmV3IE1vY2tDb2RlZEVycm9yKEVSUk9SX1RZUEVfVU5LTk9XTikpO1xuICAgIH1cbiAgfTtcblxuICBNb2NrRkJJbnN0YW50UGxheWVyLnByb3RvdHlwZS5zZXREYXRhQXN5bmMgPSBmdW5jdGlvbiBzZXREYXRhQXN5bmMoZGF0YSkge1xuICAgIGlmIChfaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRkJJTlNUQU5UOiBtb2NrIHBsYXllci5zZXREYXRhQXN5bmNcIiwgZGF0YSk7XG5cbiAgICAgIHJldHVybiBfYmx1ZWJpcmQyLmRlZmF1bHQucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBfc2V0TFNEYXRhKFBMQVlFUl9EQVRBX1BSRUZJWCArICc6JyArIGtleSwgZGF0YVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiRkJJTlNUQU5UOiBtb2NrIHBsYXllci5zZXREYXRhQXN5bmMgRkFJTEVEISBcXFxuICAgICAgICBZb3UgbXVzdCBjYWxsIGluaXRpYWxpemVBc3luYyBmaXJzdC5cIiwgZGF0YSk7XG5cbiAgICAgIHJldHVybiBfYmx1ZWJpcmQyLmRlZmF1bHQucmVqZWN0KG5ldyBNb2NrQ29kZWRFcnJvcihFUlJPUl9UWVBFX1VOS05PV04pKTtcbiAgICB9XG4gIH07XG5cbiAgTW9ja0ZCSW5zdGFudFBsYXllci5wcm90b3R5cGUuZmx1c2hEYXRhQXN5bmMgPSBmdW5jdGlvbiBmbHVzaERhdGFBc3luYygpIHtcbiAgICBpZiAoX2luaXRpYWxpemVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkZCSU5TVEFOVDogbW9jayBwbGF5ZXIuZmx1c2hEYXRhQXN5bmNcIik7XG5cbiAgICAgIHJldHVybiBfYmx1ZWJpcmQyLmRlZmF1bHQucmVzb2x2ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJGQklOU1RBTlQ6IG1vY2sgcGxheWVyLmZsdXNoRGF0YUFzeW5jIEZBSUxFRCEgXFxcbiAgICAgICAgWW91IG11c3QgY2FsbCBpbml0aWFsaXplQXN5bmMgZmlyc3QuXCIpO1xuXG4gICAgICByZXR1cm4gX2JsdWViaXJkMi5kZWZhdWx0LnJlamVjdChuZXcgTW9ja0NvZGVkRXJyb3IoRVJST1JfVFlQRV9VTktOT1dOKSk7XG4gICAgfVxuICB9O1xuXG4gIE1vY2tGQkluc3RhbnRQbGF5ZXIucHJvdG90eXBlLmdldENvbm5lY3RlZFBsYXllcnNBc3luYyA9IGZ1bmN0aW9uIGdldENvbm5lY3RlZFBsYXllcnNBc3luYygpIHtcbiAgICBpZiAoX2luaXRpYWxpemVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkZCSU5TVEFOVDogbW9jayBwbGF5ZXIuZ2V0Q29ubmVjdGVkUGxheWVyc0FzeW5jXCIpO1xuXG4gICAgICAvLyBUT0RPOiByZXR1cm4gYW4gYXJyYXkgb2YgaW5zdGFuY2VzIG9mIE1vY2tGQkluc3RhbnRDb25uZWN0ZWRQbGF5ZXJcbiAgICAgIHJldHVybiBfYmx1ZWJpcmQyLmRlZmF1bHQucmVzb2x2ZShbXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkZCSU5TVEFOVDogbW9jayBwbGF5ZXIuZ2V0Q29ubmVjdGVkUGxheWVyc0FzeW5jIEZBSUxFRCEgXFxcbiAgICAgICAgWW91IG11c3QgY2FsbCBpbml0aWFsaXplQXN5bmMgZmlyc3QuXCIpO1xuXG4gICAgICByZXR1cm4gX2JsdWViaXJkMi5kZWZhdWx0LnJlamVjdChuZXcgTW9ja0NvZGVkRXJyb3IoRVJST1JfVFlQRV9VTktOT1dOKSk7XG4gICAgfVxuICB9O1xuXG4gIE1vY2tGQkluc3RhbnRQbGF5ZXIucHJvdG90eXBlLmdldFNpZ25lZFBsYXllckluZm9Bc3luYyA9IGZ1bmN0aW9uIGdldFNpZ25lZFBsYXllckluZm9Bc3luYygpIHtcbiAgICBpZiAoX2luaXRpYWxpemVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkZCSU5TVEFOVDogbW9jayBwbGF5ZXIuZ2V0U2lnbmVkUGxheWVySW5mb0FzeW5jXCIpO1xuXG4gICAgICByZXR1cm4gX2JsdWViaXJkMi5kZWZhdWx0LnJlc29sdmUobmV3IE1vY2tGQkluc3RhbnRTaWduZWRQbGF5ZXJJbmZvKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJGQklOU1RBTlQ6IG1vY2sgcGxheWVyLmdldFNpZ25lZFBsYXllckluZm9Bc3luYyBGQUlMRUQhIFxcXG4gICAgICAgIFlvdSBtdXN0IGNhbGwgaW5pdGlhbGl6ZUFzeW5jIGZpcnN0LlwiKTtcblxuICAgICAgcmV0dXJuIF9ibHVlYmlyZDIuZGVmYXVsdC5yZWplY3QobmV3IE1vY2tDb2RlZEVycm9yKEVSUk9SX1RZUEVfVU5LTk9XTikpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTW9ja0ZCSW5zdGFudFBsYXllcjtcbn0oKTtcblxuO1xuXG4vKipcbiAqIE1vY2sgQ29udGV4dCBBUEknc1xuICovXG5cbnZhciBNb2NrRkJJbnN0YW50Q29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTW9ja0ZCSW5zdGFudENvbnRleHQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vY2tGQkluc3RhbnRDb250ZXh0KTtcbiAgfVxuXG4gIE1vY2tGQkluc3RhbnRDb250ZXh0LnByb3RvdHlwZS5nZXRJRCA9IGZ1bmN0aW9uIGdldElEKCkge1xuICAgIGlmIChfaW5pdGlhbGl6ZWQgJiYgX2dhbWVTdGFydGVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkZCSU5TVEFOVDogbW9jayBjb250ZXh0LmdldElEXCIpO1xuXG4gICAgICByZXR1cm4gX2dldExTRGF0YSgnY29udGV4dElEJywgX2dldE5ld0lEKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJGQklOU1RBTlQ6IG1vY2sgY29udGV4dC5nZXRJRCBGQUlMRUQhIFxcXG4gICAgICAgIFlvdSBtdXN0IGNhbGwgc3RhcnRHYW1lQXN5bmMgZmlyc3QuXCIpO1xuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgTW9ja0ZCSW5zdGFudENvbnRleHQucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbiBnZXRUeXBlKCkge1xuICAgIGlmIChfaW5pdGlhbGl6ZWQgJiYgX2dhbWVTdGFydGVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkZCSU5TVEFOVDogbW9jayBjb250ZXh0LmdldFR5cGVcIik7XG5cbiAgICAgIHJldHVybiBTSU1VTEFURV9DT05URVhUX1RZUEU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkZCSU5TVEFOVDogbW9jayBjb250ZXh0LmdldFR5cGUgRkFJTEVEISBcXFxuICAgICAgICBZb3UgbXVzdCBjYWxsIHN0YXJ0R2FtZUFzeW5jIGZpcnN0LlwiKTtcblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIE1vY2tGQkluc3RhbnRDb250ZXh0LnByb3RvdHlwZS5zd2l0Y2hBc3luYyA9IGZ1bmN0aW9uIHN3aXRjaEFzeW5jKGNvbnRleHRJRCkge1xuICAgIGlmIChfaW5pdGlhbGl6ZWQgJiYgX2dhbWVTdGFydGVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkZCSU5TVEFOVDogbW9jayBjb250ZXh0LnN3aXRjaEFzeW5jIHRvIFwiLCBjb250ZXh0SUQpO1xuXG4gICAgICBfc2V0TFNEYXRhKCdjb250ZXh0SUQnLCBjb250ZXh0SUQpO1xuICAgICAgcmV0dXJuIF9ibHVlYmlyZDIuZGVmYXVsdC5yZXNvbHZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkZCSU5TVEFOVDogbW9jayBjb250ZXh0LnN3aXRjaEFzeW5jIEZBSUxFRCEgXFxcbiAgICAgICAgWW91IG11c3QgY2FsbCBzdGFydEdhbWVBc3luYyBmaXJzdC5cIik7XG5cbiAgICAgIHJldHVybiBfYmx1ZWJpcmQyLmRlZmF1bHQucmVqZWN0KG5ldyBNb2NrQ29kZWRFcnJvcihFUlJPUl9UWVBFX1VOS05PV04pKTtcbiAgICB9XG4gIH07XG5cbiAgTW9ja0ZCSW5zdGFudENvbnRleHQucHJvdG90eXBlLmNob29zZUFzeW5jID0gZnVuY3Rpb24gY2hvb3NlQXN5bmMob3B0cykge1xuICAgIGlmIChfaW5pdGlhbGl6ZWQgJiYgX2dhbWVTdGFydGVkKSB7XG4gICAgICBpZiAoU0lNVUxBVEVfVVNFUl9JTlBVVF9DQU5DRUxfRVJST1IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRkJJTlNUQU5UOiBtb2NrIGNob29zZUFzeW5jLiBcXFxuICAgICAgICAgIFJlamVjdGluZyBwcm9taXNlIHRvIHNpbXVsYXRlIHVzZXIgY2FuY2VsbGVkIHdpdGhvdXQgcGlja2luZyBhIGNvbnRleHQuXCIpO1xuXG4gICAgICAgIHJldHVybiBfYmx1ZWJpcmQyLmRlZmF1bHQucmVqZWN0KG5ldyBNb2NrQ29kZWRFcnJvcihFUlJPUl9UWVBFX1VTRVJfSU5QVVQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRkJJTlNUQU5UOiBtb2NrIGNvbnRleHQuY2hvb3NlQXN5bmNcIiwgb3B0cyk7XG5cbiAgICAgICAgX3NldExTRGF0YSgnY29udGV4dElEJywgX2dldE5ld0lEKCkpO1xuICAgICAgICByZXR1cm4gX2JsdWViaXJkMi5kZWZhdWx0LnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiRkJJTlNUQU5UOiBtb2NrIGNvbnRleHQuY2hvb3NlQXN5bmMgRkFJTEVEISBcXFxuICAgICAgICBZb3UgbXVzdCBjYWxsIHN0YXJ0R2FtZUFzeW5jIGZpcnN0LlwiKTtcblxuICAgICAgcmV0dXJuIF9ibHVlYmlyZDIuZGVmYXVsdC5yZWplY3QobmV3IE1vY2tDb2RlZEVycm9yKEVSUk9SX1RZUEVfVU5LTk9XTikpO1xuICAgIH1cbiAgfTtcblxuICBNb2NrRkJJbnN0YW50Q29udGV4dC5wcm90b3R5cGUuY3JlYXRlQXN5bmMgPSBmdW5jdGlvbiBjcmVhdGVBc3luYyhwbGF5ZXJJRCkge1xuICAgIGlmIChfaW5pdGlhbGl6ZWQgJiYgX2dhbWVTdGFydGVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkZCSU5TVEFOVDogbW9jayBjb250ZXh0LmNyZWF0ZUFzeW5jIHdpdGggcGxheWVyIFwiLCBwbGF5ZXJJRCk7XG5cbiAgICAgIF9zZXRMU0RhdGEoJ2NvbnRleHRJRCcsIF9nZXROZXdJRCgpKTtcbiAgICAgIHJldHVybiBfYmx1ZWJpcmQyLmRlZmF1bHQucmVzb2x2ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJGQklOU1RBTlQ6IG1vY2sgY29udGV4dC5jcmVhdGVBc3luYyBGQUlMRUQhIFxcXG4gICAgICAgIFlvdSBtdXN0IGNhbGwgc3RhcnRHYW1lQXN5bmMgZmlyc3QuXCIpO1xuXG4gICAgICByZXR1cm4gX2JsdWViaXJkMi5kZWZhdWx0LnJlamVjdChuZXcgTW9ja0NvZGVkRXJyb3IoRVJST1JfVFlQRV9VTktOT1dOKSk7XG4gICAgfVxuICB9O1xuXG4gIE1vY2tGQkluc3RhbnRDb250ZXh0LnByb3RvdHlwZS5nZXRQbGF5ZXJzQXN5bmMgPSBmdW5jdGlvbiBnZXRQbGF5ZXJzQXN5bmMoKSB7XG4gICAgaWYgKF9pbml0aWFsaXplZCAmJiBfZ2FtZVN0YXJ0ZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRkJJTlNUQU5UOiBtb2NrIGNvbnRleHQuZ2V0UGxheWVyc0FzeW5jXCIpO1xuXG4gICAgICAvLyBUT0RPOiByZXR1cm4gYW4gYXJyYXkgb2YgaW5zdGFuY2VzIG9mIE1vY2tGQkluc3RhbnRDb250ZXh0UGxheWVyXG4gICAgICByZXR1cm4gX2JsdWViaXJkMi5kZWZhdWx0LnJlc29sdmUoW10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJGQklOU1RBTlQ6IG1vY2sgY29udGV4dC5nZXRQbGF5ZXJzQXN5bmMgRkFJTEVEISBcXFxuICAgICAgICBZb3UgbXVzdCBjYWxsIHN0YXJ0R2FtZUFzeW5jIGZpcnN0LlwiKTtcblxuICAgICAgcmV0dXJuIF9ibHVlYmlyZDIuZGVmYXVsdC5yZWplY3QobmV3IE1vY2tDb2RlZEVycm9yKEVSUk9SX1RZUEVfVU5LTk9XTikpO1xuICAgIH1cbiAgfTtcblxuICBNb2NrRkJJbnN0YW50Q29udGV4dC5wcm90b3R5cGUuaXNTaXplQmV0d2VlbiA9IGZ1bmN0aW9uIGlzU2l6ZUJldHdlZW4obWluU2l6ZSwgbWF4U2l6ZSkge1xuICAgIGlmIChfaW5pdGlhbGl6ZWQgJiYgX2dhbWVTdGFydGVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkZCSU5TVEFOVDogbW9jayBjb250ZXh0LmlzU2l6ZUJldHdlZW5cIik7XG5cbiAgICAgIC8vIGN1cnJlbnRseSwgdGhlIEFQSSBvbmx5IHJldHVybnMgYSByZXNwb25zZSBvbmNlIHBlciBzZXNzaW9uLCBhbmQgd2lsbFxuICAgICAgLy8gYWx3YXlzIGJ5IGRlc2lnbiByZXR1cm4gdGhhdCByZXNwb25zZSBmb3IgdGhlIHJlc3Qgb2YgdGhlIHNlc3Npb25cbiAgICAgIGlmICh0aGlzLl9oYXNDYWxsZWRJc1NpemVCZXR3ZWVuKSB7XG4gICAgICAgIG1pblNpemUgPSB0aGlzLl9pc1NpemVCZXR3ZWVuTWluU2l6ZTtcbiAgICAgICAgbWF4U2l6ZSA9IHRoaXMuX2lzU2l6ZUJldHdlZW5NYXhTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faGFzQ2FsbGVkSXNTaXplQmV0d2VlbiA9IHRydWU7XG4gICAgICAgIHRoaXMuX2lzU2l6ZUJldHdlZW5NaW5TaXplID0gbWluU2l6ZTtcbiAgICAgICAgdGhpcy5faXNTaXplQmV0d2Vlbk1heFNpemUgPSBtYXhTaXplO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBhbnN3ZXI6IG1pblNpemUgPD0gU0lNVUxBVEVfQ09OVEVYVF9TSVpFICYmIFNJTVVMQVRFX0NPTlRFWFRfU0laRSA8PSBtYXhTaXplLFxuICAgICAgICBtaW5TaXplOiBtaW5TaXplLFxuICAgICAgICBtYXhTaXplOiBtYXhTaXplXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJGQklOU1RBTlQ6IG1vY2sgY29udGV4dC5pc1NpemVCZXR3ZWVuIEZBSUxFRCEgXFxcbiAgICAgICAgWW91IG11c3QgY2FsbCBzdGFydEdhbWVBc3luYyBmaXJzdC5cIik7XG5cbiAgICAgIHJldHVybiBfYmx1ZWJpcmQyLmRlZmF1bHQucmVqZWN0KG5ldyBNb2NrQ29kZWRFcnJvcihFUlJPUl9UWVBFX1VOS05PV04pKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE1vY2tGQkluc3RhbnRDb250ZXh0O1xufSgpO1xuXG47XG5cbnZhciBNb2NrRkJJbnN0YW50UGF5bWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1vY2tGQkluc3RhbnRQYXltZW50cygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9ja0ZCSW5zdGFudFBheW1lbnRzKTtcbiAgfVxuXG4gIE1vY2tGQkluc3RhbnRQYXltZW50cy5wcm90b3R5cGUuZ2V0Q2F0YWxvZ0FzeW5jID0gZnVuY3Rpb24gZ2V0Q2F0YWxvZ0FzeW5jKCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmQyLmRlZmF1bHQucmVzb2x2ZShbXSk7XG4gIH07XG5cbiAgTW9ja0ZCSW5zdGFudFBheW1lbnRzLnByb3RvdHlwZS5wdXJjaGFzZUFzeW5jID0gZnVuY3Rpb24gcHVyY2hhc2VBc3luYyhwdXJjaGFzZUNvbmZpZykge1xuICAgIHJldHVybiBfYmx1ZWJpcmQyLmRlZmF1bHQucmVzb2x2ZSh7XG4gICAgICBwcm9kdWN0SUQ6IHB1cmNoYXNlQ29uZmlnLnByb2R1Y3RJRCxcbiAgICAgIGRldmVsb3BlclBheWxvYWQ6IHB1cmNoYXNlQ29uZmlnLmRldmVsb3BlclBheWxvYWQsXG4gICAgICBwdXJjaGFzZVRva2VuOiAnTU9DS19QVVJDSEFTRV9UT0tFTidcbiAgICB9KTtcbiAgfTtcblxuICBNb2NrRkJJbnN0YW50UGF5bWVudHMucHJvdG90eXBlLmdldFB1cmNoYXNlc0FzeW5jID0gZnVuY3Rpb24gZ2V0UHVyY2hhc2VzQXN5bmMoKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZDIuZGVmYXVsdC5yZXNvbHZlKFtdKTtcbiAgfTtcblxuICBNb2NrRkJJbnN0YW50UGF5bWVudHMucHJvdG90eXBlLmNvbnN1bWVQdXJjaGFzZUFzeW5jID0gZnVuY3Rpb24gY29uc3VtZVB1cmNoYXNlQXN5bmMocHVyY2hhc2VJRCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmQyLmRlZmF1bHQucmVzb2x2ZSgpO1xuICB9O1xuXG4gIE1vY2tGQkluc3RhbnRQYXltZW50cy5wcm90b3R5cGUub25SZWFkeSA9IGZ1bmN0aW9uIG9uUmVhZHkoY2IpIHtcbiAgICBjYigpO1xuICB9O1xuXG4gIE1vY2tGQkluc3RhbnRQYXltZW50cy5wcm90b3R5cGUucmVzdG9yZVB1cmNoYXNlc0FzeW5jID0gZnVuY3Rpb24gcmVzdG9yZVB1cmNoYXNlc0FzeW5jKCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmQyLmRlZmF1bHQucmVzb2x2ZSgpO1xuICB9O1xuXG4gIHJldHVybiBNb2NrRkJJbnN0YW50UGF5bWVudHM7XG59KCk7XG5cbi8qKlxuICogTW9jayBBZEluc3RhbmNlIG9iamVjdCByZXR1cm5lZCBieSBnZXRSZXdhcmRlZFZpZGVvQXN5bmNcbiAqL1xuXG52YXIgTW9ja0ZCSW5zdGFudEFkSW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1vY2tGQkluc3RhbnRBZEluc3RhbmNlKHBsYWNlbWVudElEKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vY2tGQkluc3RhbnRBZEluc3RhbmNlKTtcblxuICAgIHRoaXMucGxhY2VtZW50SUQgPSBwbGFjZW1lbnRJRDtcbiAgICB0aGlzLl9vbkNsaWNrQ2FsbGJhY2sgPSBudWxsO1xuXG4gICAgLy8gVE9ETzogbWFrZSBhIGNsaWNrYWJsZSBhZCB2aWV3IGluIGRldmtpdCB0aGF0IHN0YXlzIHVwIGZvciBzb21ldGltZVxuICB9XG5cbiAgTW9ja0ZCSW5zdGFudEFkSW5zdGFuY2UucHJvdG90eXBlLmdldFBsYWNlbWVudElEID0gZnVuY3Rpb24gZ2V0UGxhY2VtZW50SUQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGxhY2VtZW50SUQ7XG4gIH07XG5cbiAgTW9ja0ZCSW5zdGFudEFkSW5zdGFuY2UucHJvdG90eXBlLmxvYWRBc3luYyA9IGZ1bmN0aW9uIGxvYWRBc3luYygpIHtcbiAgICBpZiAoIVNJTVVMQVRFX0FEX0xPQURfRkFJTFVSRSkge1xuICAgICAgY29uc29sZS5sb2coXCJGQklOU1RBTlQ6IG1vY2sgYWRJbnN0YW5jZS5sb2FkQXN5bmNcIik7XG5cbiAgICAgIHJldHVybiBuZXcgX2JsdWViaXJkMi5kZWZhdWx0KGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgU0lNVUxBVEVfQURfTE9BRF9USU1FKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX2JsdWViaXJkMi5kZWZhdWx0LnJlamVjdChuZXcgTW9ja0NvZGVkRXJyb3IoRVJST1JfVFlQRV9VTktOT1dOKSk7XG4gICAgfVxuICB9O1xuXG4gIE1vY2tGQkluc3RhbnRBZEluc3RhbmNlLnByb3RvdHlwZS5zaG93QXN5bmMgPSBmdW5jdGlvbiBzaG93QXN5bmMoKSB7XG4gICAgaWYgKCFTSU1VTEFURV9BRF9XQVRDSF9DQU5DRUxMRUQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRkJJTlNUQU5UOiBtb2NrIGFkSW5zdGFuY2Uuc2hvd0FzeW5jXCIpO1xuXG4gICAgICByZXR1cm4gX2JsdWViaXJkMi5kZWZhdWx0LnJlc29sdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9ibHVlYmlyZDIuZGVmYXVsdC5yZWplY3QobmV3IE1vY2tDb2RlZEVycm9yKEVSUk9SX1RZUEVfVU5LTk9XTikpO1xuICAgIH1cbiAgfTtcblxuICBNb2NrRkJJbnN0YW50QWRJbnN0YW5jZS5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIG9uQ2xpY2soY2FsbGJhY2spIHtcbiAgICB0aGlzLl9vbkNsaWNrQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfTtcblxuICByZXR1cm4gTW9ja0ZCSW5zdGFudEFkSW5zdGFuY2U7XG59KCk7XG5cbi8qKlxuICogTW9jayBTaWduZWRQbGF5ZXJJbmZvIG9iamVjdCByZXR1cm5lZCBieSBwbGF5ZXIuZ2V0U2lnbmVkUGxheWVySW5mb0FzeW5jXG4gKi9cblxudmFyIE1vY2tGQkluc3RhbnRTaWduZWRQbGF5ZXJJbmZvID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNb2NrRkJJbnN0YW50U2lnbmVkUGxheWVySW5mbygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9ja0ZCSW5zdGFudFNpZ25lZFBsYXllckluZm8pO1xuICB9XG5cbiAgTW9ja0ZCSW5zdGFudFNpZ25lZFBsYXllckluZm8ucHJvdG90eXBlLmdldFBsYXllcklEID0gZnVuY3Rpb24gZ2V0UGxheWVySUQoKSB7XG4gICAgcmV0dXJuIEZCSW5zdGFudC5wbGF5ZXIuZ2V0SUQoKTtcbiAgfTtcblxuICBNb2NrRkJJbnN0YW50U2lnbmVkUGxheWVySW5mby5wcm90b3R5cGUuZ2V0U2lnbmF0dXJlID0gZnVuY3Rpb24gZ2V0U2lnbmF0dXJlKCkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5GQl9JTlNUQU5UX01PQ0tfU0lHTkFUVVJFO1xuICB9O1xuXG4gIHJldHVybiBNb2NrRkJJbnN0YW50U2lnbmVkUGxheWVySW5mbztcbn0oKTtcblxuLyoqXG4gKiBNb2NrIENvbm5lY3RlZFBsYXllciBvYmplY3QgcmV0dXJuZWQgYnkgcGxheWVyLmdldENvbm5lY3RlZFBsYXllcnNBc3luY1xuICovXG5cbnZhciBNb2NrRkJJbnN0YW50Q29ubmVjdGVkUGxheWVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNb2NrRkJJbnN0YW50Q29ubmVjdGVkUGxheWVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNb2NrRkJJbnN0YW50Q29ubmVjdGVkUGxheWVyKTtcbiAgfVxuXG4gIE1vY2tGQkluc3RhbnRDb25uZWN0ZWRQbGF5ZXIucHJvdG90eXBlLmdldElEID0gZnVuY3Rpb24gZ2V0SUQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUT0RPJyk7XG4gIH07XG5cbiAgTW9ja0ZCSW5zdGFudENvbm5lY3RlZFBsYXllci5wcm90b3R5cGUuZ2V0TmFtZSA9IGZ1bmN0aW9uIGdldE5hbWUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUT0RPJyk7XG4gIH07XG5cbiAgTW9ja0ZCSW5zdGFudENvbm5lY3RlZFBsYXllci5wcm90b3R5cGUuZ2V0UGhvdG8gPSBmdW5jdGlvbiBnZXRQaG90bygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RPRE8nKTtcbiAgfTtcblxuICByZXR1cm4gTW9ja0ZCSW5zdGFudENvbm5lY3RlZFBsYXllcjtcbn0oKTtcblxuLyoqXG4gKiBNb2NrIENvbnRleHRQbGF5ZXIgb2JqZWN0IHJldHVybmVkIGJ5IGNvbnRleHQuZ2V0UGxheWVyc0FzeW5jXG4gKi9cblxudmFyIE1vY2tGQkluc3RhbnRDb250ZXh0UGxheWVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNb2NrRkJJbnN0YW50Q29udGV4dFBsYXllcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9ja0ZCSW5zdGFudENvbnRleHRQbGF5ZXIpO1xuICB9XG5cbiAgTW9ja0ZCSW5zdGFudENvbnRleHRQbGF5ZXIucHJvdG90eXBlLmdldElEID0gZnVuY3Rpb24gZ2V0SUQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUT0RPJyk7XG4gIH07XG5cbiAgTW9ja0ZCSW5zdGFudENvbnRleHRQbGF5ZXIucHJvdG90eXBlLmdldE5hbWUgPSBmdW5jdGlvbiBnZXROYW1lKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVE9ETycpO1xuICB9O1xuXG4gIE1vY2tGQkluc3RhbnRDb250ZXh0UGxheWVyLnByb3RvdHlwZS5nZXRQaG90byA9IGZ1bmN0aW9uIGdldFBob3RvKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVE9ETycpO1xuICB9O1xuXG4gIHJldHVybiBNb2NrRkJJbnN0YW50Q29udGV4dFBsYXllcjtcbn0oKTtcblxuLyoqXG4gKiBNb2NrIEZCSW5zdGFudCBDb2RlZEVycm9yXG4gKi9cblxuLy8gbW9jayBjb2RlZCBlcnJvciB0eXBlc1xuXG5cbnZhciBFUlJPUl9UWVBFX0FEU19OT19GSUxMID0gJ0FEU19OT19GSUxMJztcbnZhciBFUlJPUl9UWVBFX0FEU19GUkVRVUVOVF9MT0FEID0gJ0FEU19GUkVRVUVOVF9MT0FEJztcbnZhciBFUlJPUl9UWVBFX0FOQUxZVElDU19QT1NUX0VYQ0VQVElPTiA9ICdBTkFMWVRJQ1NfUE9TVF9FWENFUFRJT04nO1xudmFyIEVSUk9SX1RZUEVfQ0xJRU5UX1JFUVVJUkVTX1VQREFURSA9ICdDTElFTlRfUkVRVUlSRVNfVVBEQVRFJztcbnZhciBFUlJPUl9UWVBFX0lOVkFMSURfUEFSQU0gPSAnSU5WQUxJRF9QQVJBTSc7XG52YXIgRVJST1JfVFlQRV9ORVRXT1JLX0ZBSUxVUkUgPSAnTkVUV09SS19GQUlMVVJFJztcbnZhciBFUlJPUl9UWVBFX1BFTkRJTkdfUkVRVUVTVCA9ICdQRU5ESU5HX1JFUVVFU1QnO1xudmFyIEVSUk9SX1RZUEVfVU5LTk9XTiA9ICdVTktOT1dOJztcbnZhciBFUlJPUl9UWVBFX1VTRVJfSU5QVVQgPSAnVVNFUl9JTlBVVCc7XG5cbi8vIG1vY2sgY29kZWQgZXJyb3IgbWVzc2FnZXNcbnZhciBFUlJPUl9NRVNTQUdFUyA9IHt9O1xuXG5FUlJPUl9NRVNTQUdFU1tFUlJPUl9UWVBFX0FEU19OT19GSUxMXSA9IFwiTU9DSyBFUlJPUiBNRVNTQUdFOiBcXFxuICBXZSB3ZXJlIG5vdCBhYmxlIHRvIHNlcnZlIGFkcyB0byB0aGUgY3VycmVudCB1c2VyLiBcXFxuICBUaGlzIGNhbiBoYXBwZW4gaWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dCBvZiBpbnRlcmVzdC1iYXNlZCBhZHMgb24gdGhlaXIgZGV2aWNlLCBvciBpZiB3ZSBkbyBub3QgaGF2ZSBhZCBpbnZlbnRvcnkgdG8gc2hvdyBmb3IgdGhhdCB1c2VyLlwiO1xuXG5FUlJPUl9NRVNTQUdFU1tFUlJPUl9UWVBFX0FEU19GUkVRVUVOVF9MT0FEXSA9IFwiTU9DSyBFUlJPUiBNRVNTQUdFOiBcXFxuICBBZHMgYXJlIGJlaW5nIGxvYWRlZCB0b28gZnJlcXVlbnRseS5cIjtcblxuRVJST1JfTUVTU0FHRVNbRVJST1JfVFlQRV9BTkFMWVRJQ1NfUE9TVF9FWENFUFRJT05dID0gXCJNT0NLIEVSUk9SIE1FU1NBR0U6IFxcXG4gIFRoZSBhbmFseXRpY3MgQVBJIGV4cGVyaWVuY2VkIGEgcHJvYmxlbSB3aGlsZSBhdHRlbXB0aW5nIHRvIHBvc3QgYW4gZXZlbnQuXCI7XG5cbkVSUk9SX01FU1NBR0VTW0VSUk9SX1RZUEVfQ0xJRU5UX1JFUVVJUkVTX1VQREFURV0gPSBcIk1PQ0sgRVJST1IgTUVTU0FHRTogXFxcbiAgVGhlIGNsaWVudCByZXF1aXJlcyBhbiB1cGRhdGUgdG8gYWNjZXNzIHRoZSBmZWF0dXJlIHRoYXQgcmV0dXJuZWQgdGhpcyByZXN1bHQuIFxcXG4gIElmIHRoaXMgcmVzdWx0IGlzIHJldHVybmVkIG9uIHdlYiwgaXQgbWVhbnMgdGhlIGZlYXR1cmUgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgd2ViIGNsaWVudCB5ZXQuXCI7XG5cbkVSUk9SX01FU1NBR0VTW0VSUk9SX1RZUEVfSU5WQUxJRF9QQVJBTV0gPSBcIk1PQ0sgRVJST1IgTUVTU0FHRTogXFxcbiAgVGhlIHBhcmFtZXRlcihzKSBwYXNzZWQgdG8gdGhlIEFQSSBhcmUgaW52YWxpZC4gXFxcbiAgQ291bGQgaW5kaWNhdGUgYW4gaW5jb3JyZWN0IHR5cGUsIGludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cywgb3IgYSBzZW1hbnRpYyBpc3N1ZSAoZm9yIGV4YW1wbGUsIHBhc3NpbmcgYW4gdW5zZXJpYWxpemFibGUgb2JqZWN0IHRvIGEgc2VyaWFsaXppbmcgZnVuY3Rpb24pLlwiO1xuXG5FUlJPUl9NRVNTQUdFU1tFUlJPUl9UWVBFX05FVFdPUktfRkFJTFVSRV0gPSBcIk1PQ0sgRVJST1IgTUVTU0FHRTogXFxcbiAgVGhlIGNsaWVudCBleHBlcmllbmNlZCBhbiBpc3N1ZSB3aXRoIGEgbmV0d29yayByZXF1ZXN0LiBcXFxuICBUaGlzIGlzIGxpa2VseSBkdWUgdG8gYSB0cmFuc2llbnQgaXNzdWUsIHN1Y2ggYXMgdGhlIHBsYXllcidzIGludGVybmV0IGNvbm5lY3Rpb24gZHJvcHBpbmcuXCI7XG5cbkVSUk9SX01FU1NBR0VTW0VSUk9SX1RZUEVfUEVORElOR19SRVFVRVNUXSA9IFwiTU9DSyBFUlJPUiBNRVNTQUdFOiBcXFxuICBSZXByZXNlbnRzIGEgcmVqZWN0aW9uIGR1ZSBhbiBleGlzdGluZyByZXF1ZXN0IHRoYXQgY29uZmxpY3RzIHdpdGggdGhpcyBvbmUuIFxcXG4gIEZvciBleGFtcGxlLCB3ZSB3aWxsIHJlamVjdCBhbnkgY2FsbHMgdGhhdCB3b3VsZCBzdXJmYWNlIGEgRmFjZWJvb2sgVUkgd2hlbiBhbm90aGVyIHJlcXVlc3QgdGhhdCBkZXBlbmRzIG9uIGEgRmFjZWJvb2sgVUkgaXMgcGVuZGluZy5cIjtcblxuRVJST1JfTUVTU0FHRVNbRVJST1JfVFlQRV9VTktOT1dOXSA9IFwiTU9DSyBFUlJPUiBNRVNTQUdFOiBcXFxuICBBbiB1bmtub3duIG9yIHVuc3BlY2lmaWVkIGlzc3VlIG9jY3VycmVkLiBcXFxuICBUaGlzIGlzIHRoZSBkZWZhdWx0IGVycm9yIGNvZGUgcmV0dXJuZWQgd2hlbiB0aGUgY2xpZW50IGRvZXMgbm90IHNwZWNpZnkgYSBjb2RlLlwiO1xuXG5FUlJPUl9NRVNTQUdFU1tFUlJPUl9UWVBFX1VTRVJfSU5QVVRdID0gXCJNT0NLIEVSUk9SIE1FU1NBR0U6IFxcXG4gIFRoZSB1c2VyIG1hZGUgYSBjaG9pY2UgdGhhdCByZXN1bHRlZCBpbiBhIHJlamVjdGlvbi4gXFxcbiAgRm9yIGV4YW1wbGUsIGlmIHRoZSBnYW1lIGNhbGxzIHVwIHRoZSBDb250ZXh0IFN3aXRjaCBkaWFsb2cgYW5kIHRoZSBwbGF5ZXIgY2xvc2VzIGl0LCB0aGlzIGVycm9yIGNvZGUgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgcHJvbWlzZSByZWplY3Rpb24uXCI7XG5cbnZhciBNb2NrQ29kZWRFcnJvciA9IGZ1bmN0aW9uIE1vY2tDb2RlZEVycm9yKGNvZGUpIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vY2tDb2RlZEVycm9yKTtcblxuICB0aGlzLmNvZGUgPSBjb2RlIHx8IEVSUk9SX1RZUEVfVU5LTk9XTjtcbiAgdGhpcy5tZXNzYWdlID0gRVJST1JfTUVTU0FHRVNbdGhpcy5jb2RlXTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBNb2NrRkJJbnN0YW50KCk7XG5cbi8qKlxuICogTW9jayBEYXRhIEhlbHBlcnNcbiAqL1xuXG52YXIgX2dldE5ld0lEID0gZnVuY3Rpb24gX2dldE5ld0lEKCkge1xuICByZXR1cm4gTWF0aC5mbG9vcigxMDAwICsgTWF0aC5yYW5kb20oKSAqIDEwMDAwKS50b1N0cmluZygpO1xufTtcblxudmFyIF9nZXRMU0RhdGEgPSBmdW5jdGlvbiBfZ2V0TFNEYXRhKGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gIHRyeSB7XG4gICAgdmFyIHZhbHVlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oTFNfS0VZICsgJzonICsga2V5KTtcbiAgICBjb25zb2xlLmxvZyhcIkZCSU5TVEFOVDogbW9jayBnZXREYXRhQXN5bmMgXFxcbiAgICAgIChcIiArIGtleSArIFwiLCBcIiArIGRlZmF1bHRWYWx1ZSArIFwiKTogXCIgKyB2YWx1ZSk7XG5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBfc2V0TFNEYXRhKGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGQklOU1RBTlQ6IG1vY2sgZ2V0RGF0YUFzeW5jIEZBSUxFRCFcIiwgZSk7XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdFZhbHVlO1xufTtcblxudmFyIF9zZXRMU0RhdGEgPSBmdW5jdGlvbiBfc2V0TFNEYXRhKGtleSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhcIkZCSU5TVEFOVDogbW9jayBzZXREYXRhQXN5bmMgXCIgKyBrZXkgKyBcIjogXCIgKyB2YWx1ZSk7XG5cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKExTX0tFWSArICc6JyArIGtleSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRkJJTlNUQU5UOiBtb2NrIHNldERhdGFBc3luYyBGQUlMRUQhXCIsIGUpO1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZnJvbnRlbmQvZGV2a2l0LWZiaW5zdGFudC9qcy9Nb2NrRkJJbnN0YW50LmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///62\n");

/***/ }),

/***/ 63:
/*!************************************************!*\
  !*** ./frontend/devkit-fbinstant/js/player.js ***!
  \************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _bluebird = __webpack_require__(/*! bluebird */ 1);\n\nvar _bluebird2 = _interopRequireDefault(_bluebird);\n\nvar _FBInstant = __webpack_require__(/*! ./FBInstant */ 8);\n\nvar _FBInstant2 = _interopRequireDefault(_FBInstant);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @class FBInstantPlayerWrapper\n *\n * FBInstantPlayerWrapper wraps the FBInstant player API, FBInstant.player,\n * updated through FBInstant 4.1, and substitures mock behavior during\n * development in the simulator.\n *\n * Docs: https://developers.facebook.com/docs/games/instant-games/sdk/fbinstant4.1\n */\n\nvar FBInstantPlayerWrapper = function () {\n  function FBInstantPlayerWrapper() {\n    _classCallCheck(this, FBInstantPlayerWrapper);\n  }\n\n  /**\n   * @method player.getID\n   *\n   * A unique identifier for the player. This should remain the same for the\n   * same Facebook user. The same Facebook user won't have the same identifier\n   * when in different game apps. The value will always be null until\n   * FBInstant.initializeAsync() resolves.\n   *\n   * @returns {string|null}\n   */\n\n  FBInstantPlayerWrapper.prototype.getID = function getID() {\n    return _FBInstant2.default.player.getID();\n  };\n\n  /**\n   * @method player.getName\n   *\n   * The player's localized display name. The value will always be null until\n   * FBInstant.initializeAsync() resolves.\n   *\n   * @returns {string|null}\n   */\n\n  FBInstantPlayerWrapper.prototype.getName = function getName() {\n    return _FBInstant2.default.player.getName();\n  };\n\n  /**\n   * @method player.getPhoto\n   *\n   * A url to the player's public profile photo. The photo will always be a\n   * square, and with dimensions of at least 200x200. When rendering it in the\n   * game, the exact dimensions should never be assumed to be constant.\n   * It's recommended to always scale the image to a desired size before\n   * rendering. The value will always be null until FBInstant.initializeAsync()\n   * resolves.\n   *\n   * WARNING: Due to CORS, using these photos in the game canvas can cause it to\n   * be tainted, which will prevent the canvas data from being extracted.\n   * To prevent this, set the cross-origin attribute of the images you use to\n   * 'anonymous'.\n   *\n   * @returns {string|null}\n   */\n\n  FBInstantPlayerWrapper.prototype.getPhoto = function getPhoto() {\n    return _FBInstant2.default.player.getPhoto();\n  };\n\n  /**\n   * @method player.getDataAsync\n   *\n   * Retrieve data from the designated cloud storage of the current player.\n   *\n   * @arg {string[]} keys\n   * @returns {Promise<Object>} data\n   */\n\n  FBInstantPlayerWrapper.prototype.getDataAsync = function getDataAsync(keys) {\n    return _bluebird2.default.try(function () {\n      return _FBInstant2.default.player.getDataAsync(keys);\n    });\n  };\n\n  /**\n   * @method player.setDataAsync\n   *\n   * Save data to the designated cloud storage of the current player.\n   * You can save a maximum of 1MB data for each player.\n   *\n   * @arg {Object} data\n   * @returns {Promise<Object>} data\n   */\n\n  FBInstantPlayerWrapper.prototype.setDataAsync = function setDataAsync(data) {\n    return _bluebird2.default.try(function () {\n      return _FBInstant2.default.player.setDataAsync(data);\n    });\n  };\n\n  /**\n   * @method player.flushDataAsync\n   *\n   * Immediately flushes any changes to the player data to the designated cloud\n   * storage. This function is expensive, and should primarily be used for\n   * critical changes where persistence needs to be immediate and known by the\n   * game. Non-critical changes should rely on the platform to persist them\n   * in the background. NOTE: Calls to player.setDataAsync will be rejected\n   * while this function's result is pending.\n   *\n   * @returns {Promise}\n   */\n\n  FBInstantPlayerWrapper.prototype.flushDataAsync = function flushDataAsync() {\n    return _bluebird2.default.try(function () {\n      return _FBInstant2.default.player.flushDataAsync();\n    });\n  };\n\n  /**\n   * @method player.getConnectedPlayersAsync\n   *\n   * Fetches an array of ConnectedPlayer objects containing information about\n   * players that are connected to the current player, either as a\n   * Facebook friend or as a Messenger contact. Only players who also play\n   * the Instant Game are returned.\n   *\n   * @returns {Promise<Array>} players - a list of player objects\n   */\n\n  FBInstantPlayerWrapper.prototype.getConnectedPlayersAsync = function getConnectedPlayersAsync() {\n    return _bluebird2.default.try(function () {\n      return _FBInstant2.default.player.getConnectedPlayersAsync();\n    });\n  };\n\n  /**\n   * @method player.getSignedPlayerInfoAsync\n   *\n   * Fetch the player's unique identifier along with a signature that verifies\n   * that the identifier indeed comes from Facebook without being tampered with.\n   * This function should not be called until FBInstant.initializeAsync() has\n   * resolved.\n   *\n   * @arg {string} requestPayload - A developer-specified payload to include in\n   *   the signed response.\n   * @returns {Promise<SignedPlayerInfo>} result - an instance of SignedPlayerInfo\n   */\n\n  FBInstantPlayerWrapper.prototype.getSignedPlayerInfoAsync = function getSignedPlayerInfoAsync(requestPayload) {\n    return _bluebird2.default.try(function () {\n      return _FBInstant2.default.player.getSignedPlayerInfoAsync(requestPayload);\n    });\n  };\n\n  return FBInstantPlayerWrapper;\n}();\n\n;\n\n// Singleton Export\nexports.default = new FBInstantPlayerWrapper();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9mcm9udGVuZC9kZXZraXQtZmJpbnN0YW50L2pzL3BsYXllci5qcz82ZjdkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsZUFBZSxnQkFBZ0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixlQUFlLGdCQUFnQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxlQUFlLDBCQUEwQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0EiLCJmaWxlIjoiNjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfYmx1ZWJpcmQgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xuXG52YXIgX2JsdWViaXJkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JsdWViaXJkKTtcblxudmFyIF9GQkluc3RhbnQgPSByZXF1aXJlKCcuL0ZCSW5zdGFudCcpO1xuXG52YXIgX0ZCSW5zdGFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9GQkluc3RhbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEBjbGFzcyBGQkluc3RhbnRQbGF5ZXJXcmFwcGVyXG4gKlxuICogRkJJbnN0YW50UGxheWVyV3JhcHBlciB3cmFwcyB0aGUgRkJJbnN0YW50IHBsYXllciBBUEksIEZCSW5zdGFudC5wbGF5ZXIsXG4gKiB1cGRhdGVkIHRocm91Z2ggRkJJbnN0YW50IDQuMSwgYW5kIHN1YnN0aXR1cmVzIG1vY2sgYmVoYXZpb3IgZHVyaW5nXG4gKiBkZXZlbG9wbWVudCBpbiB0aGUgc2ltdWxhdG9yLlxuICpcbiAqIERvY3M6IGh0dHBzOi8vZGV2ZWxvcGVycy5mYWNlYm9vay5jb20vZG9jcy9nYW1lcy9pbnN0YW50LWdhbWVzL3Nkay9mYmluc3RhbnQ0LjFcbiAqL1xuXG52YXIgRkJJbnN0YW50UGxheWVyV3JhcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRkJJbnN0YW50UGxheWVyV3JhcHBlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRkJJbnN0YW50UGxheWVyV3JhcHBlcik7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBwbGF5ZXIuZ2V0SURcbiAgICpcbiAgICogQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHBsYXllci4gVGhpcyBzaG91bGQgcmVtYWluIHRoZSBzYW1lIGZvciB0aGVcbiAgICogc2FtZSBGYWNlYm9vayB1c2VyLiBUaGUgc2FtZSBGYWNlYm9vayB1c2VyIHdvbid0IGhhdmUgdGhlIHNhbWUgaWRlbnRpZmllclxuICAgKiB3aGVuIGluIGRpZmZlcmVudCBnYW1lIGFwcHMuIFRoZSB2YWx1ZSB3aWxsIGFsd2F5cyBiZSBudWxsIHVudGlsXG4gICAqIEZCSW5zdGFudC5pbml0aWFsaXplQXN5bmMoKSByZXNvbHZlcy5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ3xudWxsfVxuICAgKi9cblxuICBGQkluc3RhbnRQbGF5ZXJXcmFwcGVyLnByb3RvdHlwZS5nZXRJRCA9IGZ1bmN0aW9uIGdldElEKCkge1xuICAgIHJldHVybiBfRkJJbnN0YW50Mi5kZWZhdWx0LnBsYXllci5nZXRJRCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHBsYXllci5nZXROYW1lXG4gICAqXG4gICAqIFRoZSBwbGF5ZXIncyBsb2NhbGl6ZWQgZGlzcGxheSBuYW1lLiBUaGUgdmFsdWUgd2lsbCBhbHdheXMgYmUgbnVsbCB1bnRpbFxuICAgKiBGQkluc3RhbnQuaW5pdGlhbGl6ZUFzeW5jKCkgcmVzb2x2ZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH1cbiAgICovXG5cbiAgRkJJbnN0YW50UGxheWVyV3JhcHBlci5wcm90b3R5cGUuZ2V0TmFtZSA9IGZ1bmN0aW9uIGdldE5hbWUoKSB7XG4gICAgcmV0dXJuIF9GQkluc3RhbnQyLmRlZmF1bHQucGxheWVyLmdldE5hbWUoKTtcbiAgfTtcblxuICAvKipcbiAgICogQG1ldGhvZCBwbGF5ZXIuZ2V0UGhvdG9cbiAgICpcbiAgICogQSB1cmwgdG8gdGhlIHBsYXllcidzIHB1YmxpYyBwcm9maWxlIHBob3RvLiBUaGUgcGhvdG8gd2lsbCBhbHdheXMgYmUgYVxuICAgKiBzcXVhcmUsIGFuZCB3aXRoIGRpbWVuc2lvbnMgb2YgYXQgbGVhc3QgMjAweDIwMC4gV2hlbiByZW5kZXJpbmcgaXQgaW4gdGhlXG4gICAqIGdhbWUsIHRoZSBleGFjdCBkaW1lbnNpb25zIHNob3VsZCBuZXZlciBiZSBhc3N1bWVkIHRvIGJlIGNvbnN0YW50LlxuICAgKiBJdCdzIHJlY29tbWVuZGVkIHRvIGFsd2F5cyBzY2FsZSB0aGUgaW1hZ2UgdG8gYSBkZXNpcmVkIHNpemUgYmVmb3JlXG4gICAqIHJlbmRlcmluZy4gVGhlIHZhbHVlIHdpbGwgYWx3YXlzIGJlIG51bGwgdW50aWwgRkJJbnN0YW50LmluaXRpYWxpemVBc3luYygpXG4gICAqIHJlc29sdmVzLlxuICAgKlxuICAgKiBXQVJOSU5HOiBEdWUgdG8gQ09SUywgdXNpbmcgdGhlc2UgcGhvdG9zIGluIHRoZSBnYW1lIGNhbnZhcyBjYW4gY2F1c2UgaXQgdG9cbiAgICogYmUgdGFpbnRlZCwgd2hpY2ggd2lsbCBwcmV2ZW50IHRoZSBjYW52YXMgZGF0YSBmcm9tIGJlaW5nIGV4dHJhY3RlZC5cbiAgICogVG8gcHJldmVudCB0aGlzLCBzZXQgdGhlIGNyb3NzLW9yaWdpbiBhdHRyaWJ1dGUgb2YgdGhlIGltYWdlcyB5b3UgdXNlIHRvXG4gICAqICdhbm9ueW1vdXMnLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9XG4gICAqL1xuXG4gIEZCSW5zdGFudFBsYXllcldyYXBwZXIucHJvdG90eXBlLmdldFBob3RvID0gZnVuY3Rpb24gZ2V0UGhvdG8oKSB7XG4gICAgcmV0dXJuIF9GQkluc3RhbnQyLmRlZmF1bHQucGxheWVyLmdldFBob3RvKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcGxheWVyLmdldERhdGFBc3luY1xuICAgKlxuICAgKiBSZXRyaWV2ZSBkYXRhIGZyb20gdGhlIGRlc2lnbmF0ZWQgY2xvdWQgc3RvcmFnZSBvZiB0aGUgY3VycmVudCBwbGF5ZXIuXG4gICAqXG4gICAqIEBhcmcge3N0cmluZ1tdfSBrZXlzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IGRhdGFcbiAgICovXG5cbiAgRkJJbnN0YW50UGxheWVyV3JhcHBlci5wcm90b3R5cGUuZ2V0RGF0YUFzeW5jID0gZnVuY3Rpb24gZ2V0RGF0YUFzeW5jKGtleXMpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkMi5kZWZhdWx0LnRyeShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX0ZCSW5zdGFudDIuZGVmYXVsdC5wbGF5ZXIuZ2V0RGF0YUFzeW5jKGtleXMpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHBsYXllci5zZXREYXRhQXN5bmNcbiAgICpcbiAgICogU2F2ZSBkYXRhIHRvIHRoZSBkZXNpZ25hdGVkIGNsb3VkIHN0b3JhZ2Ugb2YgdGhlIGN1cnJlbnQgcGxheWVyLlxuICAgKiBZb3UgY2FuIHNhdmUgYSBtYXhpbXVtIG9mIDFNQiBkYXRhIGZvciBlYWNoIHBsYXllci5cbiAgICpcbiAgICogQGFyZyB7T2JqZWN0fSBkYXRhXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IGRhdGFcbiAgICovXG5cbiAgRkJJbnN0YW50UGxheWVyV3JhcHBlci5wcm90b3R5cGUuc2V0RGF0YUFzeW5jID0gZnVuY3Rpb24gc2V0RGF0YUFzeW5jKGRhdGEpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkMi5kZWZhdWx0LnRyeShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX0ZCSW5zdGFudDIuZGVmYXVsdC5wbGF5ZXIuc2V0RGF0YUFzeW5jKGRhdGEpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHBsYXllci5mbHVzaERhdGFBc3luY1xuICAgKlxuICAgKiBJbW1lZGlhdGVseSBmbHVzaGVzIGFueSBjaGFuZ2VzIHRvIHRoZSBwbGF5ZXIgZGF0YSB0byB0aGUgZGVzaWduYXRlZCBjbG91ZFxuICAgKiBzdG9yYWdlLiBUaGlzIGZ1bmN0aW9uIGlzIGV4cGVuc2l2ZSwgYW5kIHNob3VsZCBwcmltYXJpbHkgYmUgdXNlZCBmb3JcbiAgICogY3JpdGljYWwgY2hhbmdlcyB3aGVyZSBwZXJzaXN0ZW5jZSBuZWVkcyB0byBiZSBpbW1lZGlhdGUgYW5kIGtub3duIGJ5IHRoZVxuICAgKiBnYW1lLiBOb24tY3JpdGljYWwgY2hhbmdlcyBzaG91bGQgcmVseSBvbiB0aGUgcGxhdGZvcm0gdG8gcGVyc2lzdCB0aGVtXG4gICAqIGluIHRoZSBiYWNrZ3JvdW5kLiBOT1RFOiBDYWxscyB0byBwbGF5ZXIuc2V0RGF0YUFzeW5jIHdpbGwgYmUgcmVqZWN0ZWRcbiAgICogd2hpbGUgdGhpcyBmdW5jdGlvbidzIHJlc3VsdCBpcyBwZW5kaW5nLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG5cbiAgRkJJbnN0YW50UGxheWVyV3JhcHBlci5wcm90b3R5cGUuZmx1c2hEYXRhQXN5bmMgPSBmdW5jdGlvbiBmbHVzaERhdGFBc3luYygpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkMi5kZWZhdWx0LnRyeShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX0ZCSW5zdGFudDIuZGVmYXVsdC5wbGF5ZXIuZmx1c2hEYXRhQXN5bmMoKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQG1ldGhvZCBwbGF5ZXIuZ2V0Q29ubmVjdGVkUGxheWVyc0FzeW5jXG4gICAqXG4gICAqIEZldGNoZXMgYW4gYXJyYXkgb2YgQ29ubmVjdGVkUGxheWVyIG9iamVjdHMgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dFxuICAgKiBwbGF5ZXJzIHRoYXQgYXJlIGNvbm5lY3RlZCB0byB0aGUgY3VycmVudCBwbGF5ZXIsIGVpdGhlciBhcyBhXG4gICAqIEZhY2Vib29rIGZyaWVuZCBvciBhcyBhIE1lc3NlbmdlciBjb250YWN0LiBPbmx5IHBsYXllcnMgd2hvIGFsc28gcGxheVxuICAgKiB0aGUgSW5zdGFudCBHYW1lIGFyZSByZXR1cm5lZC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk+fSBwbGF5ZXJzIC0gYSBsaXN0IG9mIHBsYXllciBvYmplY3RzXG4gICAqL1xuXG4gIEZCSW5zdGFudFBsYXllcldyYXBwZXIucHJvdG90eXBlLmdldENvbm5lY3RlZFBsYXllcnNBc3luYyA9IGZ1bmN0aW9uIGdldENvbm5lY3RlZFBsYXllcnNBc3luYygpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkMi5kZWZhdWx0LnRyeShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX0ZCSW5zdGFudDIuZGVmYXVsdC5wbGF5ZXIuZ2V0Q29ubmVjdGVkUGxheWVyc0FzeW5jKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcGxheWVyLmdldFNpZ25lZFBsYXllckluZm9Bc3luY1xuICAgKlxuICAgKiBGZXRjaCB0aGUgcGxheWVyJ3MgdW5pcXVlIGlkZW50aWZpZXIgYWxvbmcgd2l0aCBhIHNpZ25hdHVyZSB0aGF0IHZlcmlmaWVzXG4gICAqIHRoYXQgdGhlIGlkZW50aWZpZXIgaW5kZWVkIGNvbWVzIGZyb20gRmFjZWJvb2sgd2l0aG91dCBiZWluZyB0YW1wZXJlZCB3aXRoLlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBub3QgYmUgY2FsbGVkIHVudGlsIEZCSW5zdGFudC5pbml0aWFsaXplQXN5bmMoKSBoYXNcbiAgICogcmVzb2x2ZWQuXG4gICAqXG4gICAqIEBhcmcge3N0cmluZ30gcmVxdWVzdFBheWxvYWQgLSBBIGRldmVsb3Blci1zcGVjaWZpZWQgcGF5bG9hZCB0byBpbmNsdWRlIGluXG4gICAqICAgdGhlIHNpZ25lZCByZXNwb25zZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8U2lnbmVkUGxheWVySW5mbz59IHJlc3VsdCAtIGFuIGluc3RhbmNlIG9mIFNpZ25lZFBsYXllckluZm9cbiAgICovXG5cbiAgRkJJbnN0YW50UGxheWVyV3JhcHBlci5wcm90b3R5cGUuZ2V0U2lnbmVkUGxheWVySW5mb0FzeW5jID0gZnVuY3Rpb24gZ2V0U2lnbmVkUGxheWVySW5mb0FzeW5jKHJlcXVlc3RQYXlsb2FkKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZDIuZGVmYXVsdC50cnkoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9GQkluc3RhbnQyLmRlZmF1bHQucGxheWVyLmdldFNpZ25lZFBsYXllckluZm9Bc3luYyhyZXF1ZXN0UGF5bG9hZCk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEZCSW5zdGFudFBsYXllcldyYXBwZXI7XG59KCk7XG5cbjtcblxuLy8gU2luZ2xldG9uIEV4cG9ydFxuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IEZCSW5zdGFudFBsYXllcldyYXBwZXIoKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Zyb250ZW5kL2RldmtpdC1mYmluc3RhbnQvanMvcGxheWVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///63\n");

/***/ }),

/***/ 64:
/*!*************************************************!*\
  !*** ./frontend/devkit-fbinstant/js/context.js ***!
  \*************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _bluebird = __webpack_require__(/*! bluebird */ 1);\n\nvar _bluebird2 = _interopRequireDefault(_bluebird);\n\nvar _FBInstant = __webpack_require__(/*! ./FBInstant */ 8);\n\nvar _FBInstant2 = _interopRequireDefault(_FBInstant);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @class FBInstantContextWrapper\n *\n * FBInstantContextWrapper wraps the FBInstant context API, FBInstant.context,\n * updated through FBInstant 4.0, and substitures mock behavior during\n * development in the simulator.\n *\n * Docs: https://developers.facebook.com/docs/games/instant-games/sdk/fbinstant4.1\n */\n\nvar FBInstantContextWrapper = function () {\n  function FBInstantContextWrapper() {\n    _classCallCheck(this, FBInstantContextWrapper);\n  }\n\n  /**\n   * @method context.getID\n   *\n   * A unique identifier for the current game context. This represents a specific\n   * context that the game is being played in. For example a particular messenger\n   * conversation or facebook post. This identifier will be populated only after\n   * FBInstant.startGameAsync resolves, and may be updated when\n   * FBInstant.updateAsync resolves. It will return null if the current mobile\n   * app version doesn't support context id, or when the game is being played\n   * in a solo context.\n   *\n   * @returns {string|null}\n   */\n\n  FBInstantContextWrapper.prototype.getID = function getID() {\n    return _FBInstant2.default.context.getID();\n  };\n\n  /**\n   * @method context.getType\n   *\n   * Type of the current game context. Could be\n   * 'POST', 'THREAD', 'GROUP', 'MATCH', or 'SOLO'.\n   *\n   * @returns {string|null}\n   */\n\n  FBInstantContextWrapper.prototype.getType = function getType() {\n    return _FBInstant2.default.context.getType();\n  };\n\n  /**\n   * @method context.switchAsync\n   *\n   * Attempts to switch into a specific context. If the player does not have\n   * permission to enter that context, or if the player does not provide\n   * permission for the game to enter that context, this will reject. Otherwise,\n   * the promise will resolve when the game has switched into the\n   * specified context.\n   *\n   * @returns {Promise}\n   */\n\n  FBInstantContextWrapper.prototype.switchAsync = function switchAsync(contextID) {\n    return _bluebird2.default.try(function () {\n      return _FBInstant2.default.context.switchAsync(contextID);\n    });\n  };\n\n  /**\n   * @method context.chooseAsync\n   *\n   * Opens a context selection menu for the player. If the player selects an\n   * available context, we attempt to switch into that context, and resolve if\n   * successful. Otherwise, if the player exits the menu or we fail to switch into\n   * the new context, we reject.\n   *\n   * @arg {Object} [opts]\n   * @arg {string[]} [opts.filters]\n   * @arg {number} [opts.minSize]\n   * @arg {number} [opts.maxSize]\n   *\n   * @returns {Promise}\n   */\n\n  FBInstantContextWrapper.prototype.chooseAsync = function chooseAsync(opts) {\n    return _bluebird2.default.try(function () {\n      return _FBInstant2.default.context.chooseAsync(opts);\n    });\n  };\n\n  /**\n   * @method context.createAsync\n   *\n   * Attempts to create or switch into a context between a specified player and\n   * the current player. The returned promise will reject if the player listed\n   * is not a Connected Player of the current player or if the player does not\n   * provide permission to enter the new context. Otherwise, the promise will\n   * resolve when the game has switched into the new context.\n   *\n   * @returns {Promise}\n   */\n\n  FBInstantContextWrapper.prototype.createAsync = function createAsync(playerID) {\n    return _bluebird2.default.try(function () {\n      return _FBInstant2.default.context.createAsync(playerID);\n    });\n  };\n\n  /**\n   * @method context.getPlayersAsync\n   *\n   * Gets an array of #contextplayer objects containing information about active\n   * players that are associated with the current context. This may include the\n   * current player.\n   *\n   * @returns {Promise<Array<ContextPlayer>>}\n   */\n\n  FBInstantContextWrapper.prototype.getPlayersAsync = function getPlayersAsync() {\n    return _bluebird2.default.try(function () {\n      return _FBInstant2.default.context.getPlayersAsync();\n    });\n  };\n\n  /**\n   * @method context.isSizeBetween\n   *\n   * This function determines whether the number of participants in the current\n   * game context is between a given minimum and maximum, inclusive. If one of\n   * the bounds is null only the other bound will be checked against. It will\n   * always return the original result for the first call made in a context in a\n   * given game play session. Subsequent calls, regardless of arguments, will\n   * return the answer to the original query until a context change occurs and\n   * the query result is reset.\n   *\n   * @arg {number} minSize\n   * @arg {number} maxSize\n   * @returns {boolean}\n   */\n\n  FBInstantContextWrapper.prototype.isSizeBetween = function isSizeBetween(minSize, maxSize) {\n    return _FBInstant2.default.context.isSizeBetween(minSize, maxSize);\n  };\n\n  return FBInstantContextWrapper;\n}();\n\n;\n\n// Singleton Export\nexports.default = new FBInstantContextWrapper();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9mcm9udGVuZC9kZXZraXQtZmJpbnN0YW50L2pzL2NvbnRleHQuanM/YjNkNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0YsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBIiwiZmlsZSI6IjY0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2JsdWViaXJkID0gcmVxdWlyZSgnYmx1ZWJpcmQnKTtcblxudmFyIF9ibHVlYmlyZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ibHVlYmlyZCk7XG5cbnZhciBfRkJJbnN0YW50ID0gcmVxdWlyZSgnLi9GQkluc3RhbnQnKTtcblxudmFyIF9GQkluc3RhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRkJJbnN0YW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBAY2xhc3MgRkJJbnN0YW50Q29udGV4dFdyYXBwZXJcbiAqXG4gKiBGQkluc3RhbnRDb250ZXh0V3JhcHBlciB3cmFwcyB0aGUgRkJJbnN0YW50IGNvbnRleHQgQVBJLCBGQkluc3RhbnQuY29udGV4dCxcbiAqIHVwZGF0ZWQgdGhyb3VnaCBGQkluc3RhbnQgNC4wLCBhbmQgc3Vic3RpdHVyZXMgbW9jayBiZWhhdmlvciBkdXJpbmdcbiAqIGRldmVsb3BtZW50IGluIHRoZSBzaW11bGF0b3IuXG4gKlxuICogRG9jczogaHR0cHM6Ly9kZXZlbG9wZXJzLmZhY2Vib29rLmNvbS9kb2NzL2dhbWVzL2luc3RhbnQtZ2FtZXMvc2RrL2ZiaW5zdGFudDQuMVxuICovXG5cbnZhciBGQkluc3RhbnRDb250ZXh0V3JhcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRkJJbnN0YW50Q29udGV4dFdyYXBwZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZCSW5zdGFudENvbnRleHRXcmFwcGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGNvbnRleHQuZ2V0SURcbiAgICpcbiAgICogQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGN1cnJlbnQgZ2FtZSBjb250ZXh0LiBUaGlzIHJlcHJlc2VudHMgYSBzcGVjaWZpY1xuICAgKiBjb250ZXh0IHRoYXQgdGhlIGdhbWUgaXMgYmVpbmcgcGxheWVkIGluLiBGb3IgZXhhbXBsZSBhIHBhcnRpY3VsYXIgbWVzc2VuZ2VyXG4gICAqIGNvbnZlcnNhdGlvbiBvciBmYWNlYm9vayBwb3N0LiBUaGlzIGlkZW50aWZpZXIgd2lsbCBiZSBwb3B1bGF0ZWQgb25seSBhZnRlclxuICAgKiBGQkluc3RhbnQuc3RhcnRHYW1lQXN5bmMgcmVzb2x2ZXMsIGFuZCBtYXkgYmUgdXBkYXRlZCB3aGVuXG4gICAqIEZCSW5zdGFudC51cGRhdGVBc3luYyByZXNvbHZlcy4gSXQgd2lsbCByZXR1cm4gbnVsbCBpZiB0aGUgY3VycmVudCBtb2JpbGVcbiAgICogYXBwIHZlcnNpb24gZG9lc24ndCBzdXBwb3J0IGNvbnRleHQgaWQsIG9yIHdoZW4gdGhlIGdhbWUgaXMgYmVpbmcgcGxheWVkXG4gICAqIGluIGEgc29sbyBjb250ZXh0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9XG4gICAqL1xuXG4gIEZCSW5zdGFudENvbnRleHRXcmFwcGVyLnByb3RvdHlwZS5nZXRJRCA9IGZ1bmN0aW9uIGdldElEKCkge1xuICAgIHJldHVybiBfRkJJbnN0YW50Mi5kZWZhdWx0LmNvbnRleHQuZ2V0SUQoKTtcbiAgfTtcblxuICAvKipcbiAgICogQG1ldGhvZCBjb250ZXh0LmdldFR5cGVcbiAgICpcbiAgICogVHlwZSBvZiB0aGUgY3VycmVudCBnYW1lIGNvbnRleHQuIENvdWxkIGJlXG4gICAqICdQT1NUJywgJ1RIUkVBRCcsICdHUk9VUCcsICdNQVRDSCcsIG9yICdTT0xPJy5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ3xudWxsfVxuICAgKi9cblxuICBGQkluc3RhbnRDb250ZXh0V3JhcHBlci5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIF9GQkluc3RhbnQyLmRlZmF1bHQuY29udGV4dC5nZXRUeXBlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgY29udGV4dC5zd2l0Y2hBc3luY1xuICAgKlxuICAgKiBBdHRlbXB0cyB0byBzd2l0Y2ggaW50byBhIHNwZWNpZmljIGNvbnRleHQuIElmIHRoZSBwbGF5ZXIgZG9lcyBub3QgaGF2ZVxuICAgKiBwZXJtaXNzaW9uIHRvIGVudGVyIHRoYXQgY29udGV4dCwgb3IgaWYgdGhlIHBsYXllciBkb2VzIG5vdCBwcm92aWRlXG4gICAqIHBlcm1pc3Npb24gZm9yIHRoZSBnYW1lIHRvIGVudGVyIHRoYXQgY29udGV4dCwgdGhpcyB3aWxsIHJlamVjdC4gT3RoZXJ3aXNlLFxuICAgKiB0aGUgcHJvbWlzZSB3aWxsIHJlc29sdmUgd2hlbiB0aGUgZ2FtZSBoYXMgc3dpdGNoZWQgaW50byB0aGVcbiAgICogc3BlY2lmaWVkIGNvbnRleHQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuICBGQkluc3RhbnRDb250ZXh0V3JhcHBlci5wcm90b3R5cGUuc3dpdGNoQXN5bmMgPSBmdW5jdGlvbiBzd2l0Y2hBc3luYyhjb250ZXh0SUQpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkMi5kZWZhdWx0LnRyeShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX0ZCSW5zdGFudDIuZGVmYXVsdC5jb250ZXh0LnN3aXRjaEFzeW5jKGNvbnRleHRJRCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgY29udGV4dC5jaG9vc2VBc3luY1xuICAgKlxuICAgKiBPcGVucyBhIGNvbnRleHQgc2VsZWN0aW9uIG1lbnUgZm9yIHRoZSBwbGF5ZXIuIElmIHRoZSBwbGF5ZXIgc2VsZWN0cyBhblxuICAgKiBhdmFpbGFibGUgY29udGV4dCwgd2UgYXR0ZW1wdCB0byBzd2l0Y2ggaW50byB0aGF0IGNvbnRleHQsIGFuZCByZXNvbHZlIGlmXG4gICAqIHN1Y2Nlc3NmdWwuIE90aGVyd2lzZSwgaWYgdGhlIHBsYXllciBleGl0cyB0aGUgbWVudSBvciB3ZSBmYWlsIHRvIHN3aXRjaCBpbnRvXG4gICAqIHRoZSBuZXcgY29udGV4dCwgd2UgcmVqZWN0LlxuICAgKlxuICAgKiBAYXJnIHtPYmplY3R9IFtvcHRzXVxuICAgKiBAYXJnIHtzdHJpbmdbXX0gW29wdHMuZmlsdGVyc11cbiAgICogQGFyZyB7bnVtYmVyfSBbb3B0cy5taW5TaXplXVxuICAgKiBAYXJnIHtudW1iZXJ9IFtvcHRzLm1heFNpemVdXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuICBGQkluc3RhbnRDb250ZXh0V3JhcHBlci5wcm90b3R5cGUuY2hvb3NlQXN5bmMgPSBmdW5jdGlvbiBjaG9vc2VBc3luYyhvcHRzKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZDIuZGVmYXVsdC50cnkoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9GQkluc3RhbnQyLmRlZmF1bHQuY29udGV4dC5jaG9vc2VBc3luYyhvcHRzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQG1ldGhvZCBjb250ZXh0LmNyZWF0ZUFzeW5jXG4gICAqXG4gICAqIEF0dGVtcHRzIHRvIGNyZWF0ZSBvciBzd2l0Y2ggaW50byBhIGNvbnRleHQgYmV0d2VlbiBhIHNwZWNpZmllZCBwbGF5ZXIgYW5kXG4gICAqIHRoZSBjdXJyZW50IHBsYXllci4gVGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCByZWplY3QgaWYgdGhlIHBsYXllciBsaXN0ZWRcbiAgICogaXMgbm90IGEgQ29ubmVjdGVkIFBsYXllciBvZiB0aGUgY3VycmVudCBwbGF5ZXIgb3IgaWYgdGhlIHBsYXllciBkb2VzIG5vdFxuICAgKiBwcm92aWRlIHBlcm1pc3Npb24gdG8gZW50ZXIgdGhlIG5ldyBjb250ZXh0LiBPdGhlcndpc2UsIHRoZSBwcm9taXNlIHdpbGxcbiAgICogcmVzb2x2ZSB3aGVuIHRoZSBnYW1lIGhhcyBzd2l0Y2hlZCBpbnRvIHRoZSBuZXcgY29udGV4dC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuXG4gIEZCSW5zdGFudENvbnRleHRXcmFwcGVyLnByb3RvdHlwZS5jcmVhdGVBc3luYyA9IGZ1bmN0aW9uIGNyZWF0ZUFzeW5jKHBsYXllcklEKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZDIuZGVmYXVsdC50cnkoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9GQkluc3RhbnQyLmRlZmF1bHQuY29udGV4dC5jcmVhdGVBc3luYyhwbGF5ZXJJRCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgY29udGV4dC5nZXRQbGF5ZXJzQXN5bmNcbiAgICpcbiAgICogR2V0cyBhbiBhcnJheSBvZiAjY29udGV4dHBsYXllciBvYmplY3RzIGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgYWN0aXZlXG4gICAqIHBsYXllcnMgdGhhdCBhcmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50IGNvbnRleHQuIFRoaXMgbWF5IGluY2x1ZGUgdGhlXG4gICAqIGN1cnJlbnQgcGxheWVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxDb250ZXh0UGxheWVyPj59XG4gICAqL1xuXG4gIEZCSW5zdGFudENvbnRleHRXcmFwcGVyLnByb3RvdHlwZS5nZXRQbGF5ZXJzQXN5bmMgPSBmdW5jdGlvbiBnZXRQbGF5ZXJzQXN5bmMoKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZDIuZGVmYXVsdC50cnkoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9GQkluc3RhbnQyLmRlZmF1bHQuY29udGV4dC5nZXRQbGF5ZXJzQXN5bmMoKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQG1ldGhvZCBjb250ZXh0LmlzU2l6ZUJldHdlZW5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG51bWJlciBvZiBwYXJ0aWNpcGFudHMgaW4gdGhlIGN1cnJlbnRcbiAgICogZ2FtZSBjb250ZXh0IGlzIGJldHdlZW4gYSBnaXZlbiBtaW5pbXVtIGFuZCBtYXhpbXVtLCBpbmNsdXNpdmUuIElmIG9uZSBvZlxuICAgKiB0aGUgYm91bmRzIGlzIG51bGwgb25seSB0aGUgb3RoZXIgYm91bmQgd2lsbCBiZSBjaGVja2VkIGFnYWluc3QuIEl0IHdpbGxcbiAgICogYWx3YXlzIHJldHVybiB0aGUgb3JpZ2luYWwgcmVzdWx0IGZvciB0aGUgZmlyc3QgY2FsbCBtYWRlIGluIGEgY29udGV4dCBpbiBhXG4gICAqIGdpdmVuIGdhbWUgcGxheSBzZXNzaW9uLiBTdWJzZXF1ZW50IGNhbGxzLCByZWdhcmRsZXNzIG9mIGFyZ3VtZW50cywgd2lsbFxuICAgKiByZXR1cm4gdGhlIGFuc3dlciB0byB0aGUgb3JpZ2luYWwgcXVlcnkgdW50aWwgYSBjb250ZXh0IGNoYW5nZSBvY2N1cnMgYW5kXG4gICAqIHRoZSBxdWVyeSByZXN1bHQgaXMgcmVzZXQuXG4gICAqXG4gICAqIEBhcmcge251bWJlcn0gbWluU2l6ZVxuICAgKiBAYXJnIHtudW1iZXJ9IG1heFNpemVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG4gIEZCSW5zdGFudENvbnRleHRXcmFwcGVyLnByb3RvdHlwZS5pc1NpemVCZXR3ZWVuID0gZnVuY3Rpb24gaXNTaXplQmV0d2VlbihtaW5TaXplLCBtYXhTaXplKSB7XG4gICAgcmV0dXJuIF9GQkluc3RhbnQyLmRlZmF1bHQuY29udGV4dC5pc1NpemVCZXR3ZWVuKG1pblNpemUsIG1heFNpemUpO1xuICB9O1xuXG4gIHJldHVybiBGQkluc3RhbnRDb250ZXh0V3JhcHBlcjtcbn0oKTtcblxuO1xuXG4vLyBTaW5nbGV0b24gRXhwb3J0XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgRkJJbnN0YW50Q29udGV4dFdyYXBwZXIoKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Zyb250ZW5kL2RldmtpdC1mYmluc3RhbnQvanMvY29udGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///64\n");

/***/ }),

/***/ 65:
/*!**************************************************!*\
  !*** ./frontend/devkit-fbinstant/js/payments.js ***!
  \**************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _bluebird = __webpack_require__(/*! bluebird */ 1);\n\nvar _bluebird2 = _interopRequireDefault(_bluebird);\n\nvar _FBInstant = __webpack_require__(/*! ./FBInstant */ 8);\n\nvar _FBInstant2 = _interopRequireDefault(_FBInstant);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @class FBInstantPaymentsWrapper\n *\n * FBInstantPaymentsWrapper wraps the FBInstant payments API, FBInstant.payments,\n * updated through FBInstant 4.1, and substitures mock behavior during\n * development in the simulator.\n *\n * Docs: https://developers.facebook.com/docs/games/instant-games/sdk/fbinstant4.1\n */\n\nvar FBInstantPaymentsWrapper = function () {\n  function FBInstantPaymentsWrapper() {\n    _classCallCheck(this, FBInstantPaymentsWrapper);\n  }\n\n  /**\n   * @method payments.getCatalogAsync\n   *\n   * @returns {Promise<Array<Product>>}\n   */\n\n  FBInstantPaymentsWrapper.prototype.getCatalogAsync = function getCatalogAsync() {\n    return _bluebird2.default.try(function () {\n      return _FBInstant2.default.payments.getCatalogAsync();\n    });\n  };\n\n  /**\n   * @method payments.purchaseAsync\n   * @param {PurchaseConfig} purchaseConfig\n   *\n   * @returns {Promise<Purchase>}\n   */\n\n  FBInstantPaymentsWrapper.prototype.purchaseAsync = function purchaseAsync(purchaseConfig) {\n    return _bluebird2.default.try(function () {\n      return _FBInstant2.default.payments.purchaseAsync(purchaseConfig);\n    });\n  };\n\n  /**\n   * @method payments.getPurchaseAsync\n   *\n   * @returns {Promise<Array<Purchase>>}\n   */\n\n\n  FBInstantPaymentsWrapper.prototype.getPurchasesAsync = function getPurchasesAsync() {\n    return _bluebird2.default.try(function () {\n      return _FBInstant2.default.payments.getPurchasesAsync();\n    });\n  };\n\n  /**\n   * @method payments.consumePurchaseAsync\n   * @param {String} purchaseToken\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  FBInstantPaymentsWrapper.prototype.consumePurchaseAsync = function consumePurchaseAsync(purchaseToken) {\n    return _bluebird2.default.try(function () {\n      return _FBInstant2.default.payments.consumePurchaseAsync(purchaseToken);\n    });\n  };\n\n  /**\n   * @method payments.onReady\n   * @param {Function} callback\n   *\n   * @returns {void}\n   */\n\n  FBInstantPaymentsWrapper.prototype.onReady = function onReady(callback) {\n    return _bluebird2.default.try(function () {\n      return _FBInstant2.default.payments.onReady(callback);\n    });\n  };\n\n  FBInstantPaymentsWrapper.prototype.restorePurchasesAsync = function restorePurchasesAsync() {\n    return _bluebird2.default.try(function () {\n      _FBInstant2.default.payments.restorePurchasesAsync();\n    });\n  };\n\n  return FBInstantPaymentsWrapper;\n}();\n\n;\n\n// Singleton Export\nexports.default = new FBInstantPaymentsWrapper();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9mcm9udGVuZC9kZXZraXQtZmJpbnN0YW50L2pzL3BheW1lbnRzLmpzP2E2YjciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxlQUFlO0FBQ2Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0EiLCJmaWxlIjoiNjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfYmx1ZWJpcmQgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xuXG52YXIgX2JsdWViaXJkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JsdWViaXJkKTtcblxudmFyIF9GQkluc3RhbnQgPSByZXF1aXJlKCcuL0ZCSW5zdGFudCcpO1xuXG52YXIgX0ZCSW5zdGFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9GQkluc3RhbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEBjbGFzcyBGQkluc3RhbnRQYXltZW50c1dyYXBwZXJcbiAqXG4gKiBGQkluc3RhbnRQYXltZW50c1dyYXBwZXIgd3JhcHMgdGhlIEZCSW5zdGFudCBwYXltZW50cyBBUEksIEZCSW5zdGFudC5wYXltZW50cyxcbiAqIHVwZGF0ZWQgdGhyb3VnaCBGQkluc3RhbnQgNC4xLCBhbmQgc3Vic3RpdHVyZXMgbW9jayBiZWhhdmlvciBkdXJpbmdcbiAqIGRldmVsb3BtZW50IGluIHRoZSBzaW11bGF0b3IuXG4gKlxuICogRG9jczogaHR0cHM6Ly9kZXZlbG9wZXJzLmZhY2Vib29rLmNvbS9kb2NzL2dhbWVzL2luc3RhbnQtZ2FtZXMvc2RrL2ZiaW5zdGFudDQuMVxuICovXG5cbnZhciBGQkluc3RhbnRQYXltZW50c1dyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZCSW5zdGFudFBheW1lbnRzV3JhcHBlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRkJJbnN0YW50UGF5bWVudHNXcmFwcGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHBheW1lbnRzLmdldENhdGFsb2dBc3luY1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxQcm9kdWN0Pj59XG4gICAqL1xuXG4gIEZCSW5zdGFudFBheW1lbnRzV3JhcHBlci5wcm90b3R5cGUuZ2V0Q2F0YWxvZ0FzeW5jID0gZnVuY3Rpb24gZ2V0Q2F0YWxvZ0FzeW5jKCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmQyLmRlZmF1bHQudHJ5KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfRkJJbnN0YW50Mi5kZWZhdWx0LnBheW1lbnRzLmdldENhdGFsb2dBc3luYygpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHBheW1lbnRzLnB1cmNoYXNlQXN5bmNcbiAgICogQHBhcmFtIHtQdXJjaGFzZUNvbmZpZ30gcHVyY2hhc2VDb25maWdcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8UHVyY2hhc2U+fVxuICAgKi9cblxuICBGQkluc3RhbnRQYXltZW50c1dyYXBwZXIucHJvdG90eXBlLnB1cmNoYXNlQXN5bmMgPSBmdW5jdGlvbiBwdXJjaGFzZUFzeW5jKHB1cmNoYXNlQ29uZmlnKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZDIuZGVmYXVsdC50cnkoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9GQkluc3RhbnQyLmRlZmF1bHQucGF5bWVudHMucHVyY2hhc2VBc3luYyhwdXJjaGFzZUNvbmZpZyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcGF5bWVudHMuZ2V0UHVyY2hhc2VBc3luY1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxQdXJjaGFzZT4+fVxuICAgKi9cblxuXG4gIEZCSW5zdGFudFBheW1lbnRzV3JhcHBlci5wcm90b3R5cGUuZ2V0UHVyY2hhc2VzQXN5bmMgPSBmdW5jdGlvbiBnZXRQdXJjaGFzZXNBc3luYygpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkMi5kZWZhdWx0LnRyeShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX0ZCSW5zdGFudDIuZGVmYXVsdC5wYXltZW50cy5nZXRQdXJjaGFzZXNBc3luYygpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHBheW1lbnRzLmNvbnN1bWVQdXJjaGFzZUFzeW5jXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwdXJjaGFzZVRva2VuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cblxuXG4gIEZCSW5zdGFudFBheW1lbnRzV3JhcHBlci5wcm90b3R5cGUuY29uc3VtZVB1cmNoYXNlQXN5bmMgPSBmdW5jdGlvbiBjb25zdW1lUHVyY2hhc2VBc3luYyhwdXJjaGFzZVRva2VuKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZDIuZGVmYXVsdC50cnkoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9GQkluc3RhbnQyLmRlZmF1bHQucGF5bWVudHMuY29uc3VtZVB1cmNoYXNlQXN5bmMocHVyY2hhc2VUb2tlbik7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcGF5bWVudHMub25SZWFkeVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG5cbiAgRkJJbnN0YW50UGF5bWVudHNXcmFwcGVyLnByb3RvdHlwZS5vblJlYWR5ID0gZnVuY3Rpb24gb25SZWFkeShjYWxsYmFjaykge1xuICAgIHJldHVybiBfYmx1ZWJpcmQyLmRlZmF1bHQudHJ5KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfRkJJbnN0YW50Mi5kZWZhdWx0LnBheW1lbnRzLm9uUmVhZHkoY2FsbGJhY2spO1xuICAgIH0pO1xuICB9O1xuXG4gIEZCSW5zdGFudFBheW1lbnRzV3JhcHBlci5wcm90b3R5cGUucmVzdG9yZVB1cmNoYXNlc0FzeW5jID0gZnVuY3Rpb24gcmVzdG9yZVB1cmNoYXNlc0FzeW5jKCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmQyLmRlZmF1bHQudHJ5KGZ1bmN0aW9uICgpIHtcbiAgICAgIF9GQkluc3RhbnQyLmRlZmF1bHQucGF5bWVudHMucmVzdG9yZVB1cmNoYXNlc0FzeW5jKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEZCSW5zdGFudFBheW1lbnRzV3JhcHBlcjtcbn0oKTtcblxuO1xuXG4vLyBTaW5nbGV0b24gRXhwb3J0XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgRkJJbnN0YW50UGF5bWVudHNXcmFwcGVyKCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9mcm9udGVuZC9kZXZraXQtZmJpbnN0YW50L2pzL3BheW1lbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///65\n");

/***/ }),

/***/ 7:
/*!****************************************************!*\
  !*** ./frontend/node_modules/debug/src/browser.js ***!
  \****************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ 42);\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||\n  // is firebug? http://stackoverflow.com/a/398120/376773\n  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||\n  // is firefox >= v31?\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||\n  // double check webkit in userAgent just in case we are in a worker\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function (v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit');\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function (match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === (typeof console === 'undefined' ? 'undefined' : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch (e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch (e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = Object({\"NODE_ENV\":\"development\",\"SIMULATED\":\"true\",\"FLATLINE_APP_ID\":\"tsumtsum-dev\",\"FLATLINE_HOST\":\"https://deferred-actions-a4365e9-dot-wintermute-151001.appspot.com\",\"FLATLINE_USE_V2_SESSION\":\"true\",\"FLATLINE_ADMIN_TOKEN\":\"tsumtsum_5601879890534\",\"FREESIDE_HOST\":\"https://onions.science\",\"FREESIDE_CONTEXT_STORAGE_HOST\":\"https://context-storage-dot-freeside-152323.appspot.com\",\"SOCIAL_MESSAGING_HOST\":\"https://sms-dot-wintermute-151001.appspot.com\",\"FB_INSTANT_USE_MOCK_DATA\":\"true\",\"FB_INSTANT_MOCK_SIGNATURE\":\"b67607cb5ecba55fbcc3c72771ebf9df\",\"COMMITHASH\":\"94ac762\",\"GIT_BRANCH\":\"sim_garrett\",\"BUILD_NUMBER\":\"-1\",\"IS_TEST\":undefined,\"IS_AUTOMATED\":undefined}).DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../node-libs-browser/node_modules/process/browser.js */ 6)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanM/MjQ2OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiK0NBQUE7O0FBRUEsb0dBQW9HLG1CQUFtQixFQUFFLG1CQUFtQiw4SEFBOEg7O0FBRTFRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQyIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZSAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2UgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbCA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFsnIzAwMDBDQycsICcjMDAwMEZGJywgJyMwMDMzQ0MnLCAnIzAwMzNGRicsICcjMDA2NkNDJywgJyMwMDY2RkYnLCAnIzAwOTlDQycsICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJywgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLCAnIzMzOTlGRicsICcjMzNDQzAwJywgJyMzM0NDMzMnLCAnIzMzQ0M2NicsICcjMzNDQzk5JywgJyMzM0NDQ0MnLCAnIzMzQ0NGRicsICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJywgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLCAnI0NDMDA2NicsICcjQ0MwMDk5JywgJyNDQzAwQ0MnLCAnI0NDMDBGRicsICcjQ0MzMzAwJywgJyNDQzMzMzMnLCAnI0NDMzM2NicsICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJywgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLCAnI0ZGMDBGRicsICcjRkYzMzAwJywgJyNGRjMzMzMnLCAnI0ZGMzM2NicsICcjRkYzMzk5JywgJyNGRjMzQ0MnLCAnI0ZGMzNGRicsICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMyddO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG4gIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UgfHxcbiAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCB3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpIHx8XG4gIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSB8fFxuICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gIH1cbn07XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJykgKyB0aGlzLm5hbWVzcGFjZSArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgKyBhcmdzWzBdICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSAodHlwZW9mIGNvbnNvbGUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbnNvbGUpKSAmJiBjb25zb2xlLmxvZyAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7\n");

/***/ }),

/***/ 8:
/*!***************************************************!*\
  !*** ./frontend/devkit-fbinstant/js/FBInstant.js ***!
  \***************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _MockFBInstant = __webpack_require__(/*! ./MockFBInstant */ 62);\n\nvar _MockFBInstant2 = _interopRequireDefault(_MockFBInstant);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar USE_MOCK_DATA = \"true\" === 'true' || false;\n\nvar API = _MockFBInstant2.default;\n\nif (!USE_MOCK_DATA) {\n  if (typeof FBInstant !== 'undefined') {\n    API = FBInstant;\n  } else {\n    throw new Error(\"FBINSTANT: No window.FBInstant defined!\");\n  }\n}\n\nexports.default = API;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9mcm9udGVuZC9kZXZraXQtZmJpbnN0YW50L2pzL0ZCSW5zdGFudC5qcz80ODliIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3Rjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfTW9ja0ZCSW5zdGFudCA9IHJlcXVpcmUoJy4vTW9ja0ZCSW5zdGFudCcpO1xuXG52YXIgX01vY2tGQkluc3RhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTW9ja0ZCSW5zdGFudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBVU0VfTU9DS19EQVRBID0gcHJvY2Vzcy5lbnYuRkJfSU5TVEFOVF9VU0VfTU9DS19EQVRBID09PSAndHJ1ZScgfHwgZmFsc2U7XG5cbnZhciBBUEkgPSBfTW9ja0ZCSW5zdGFudDIuZGVmYXVsdDtcblxuaWYgKCFVU0VfTU9DS19EQVRBKSB7XG4gIGlmICh0eXBlb2YgRkJJbnN0YW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIEFQSSA9IEZCSW5zdGFudDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGQklOU1RBTlQ6IE5vIHdpbmRvdy5GQkluc3RhbnQgZGVmaW5lZCFcIik7XG4gIH1cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gQVBJO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZnJvbnRlbmQvZGV2a2l0LWZiaW5zdGFudC9qcy9GQkluc3RhbnQuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n");

/***/ }),

/***/ 9:
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzYwOTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsb0dBQW9HLG1CQUFtQixFQUFFLG1CQUFtQiw4SEFBOEg7O0FBRTFROztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QyIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcztcbn0oKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSwgZXZhbCkoXCJ0aGlzXCIpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAoKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZih3aW5kb3cpKSA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n");

/***/ })

},[222]);